
BrainMCU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00005978  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000a2c  20000000  00405978  00010000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  2 .bss          000018cc  20000c00  00406600  00010c00  2**9
                  ALLOC
  3 .stack        00003004  200024cc  00407ecc  00010c00  2**0
                  ALLOC
  4 .ARM.attributes 0000002a  00000000  00000000  00010a2c  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010a56  2**0
                  CONTENTS, READONLY
  6 .debug_info   0001d7d8  00000000  00000000  00010ab1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00004cf1  00000000  00000000  0002e289  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00011b34  00000000  00000000  00032f7a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00001388  00000000  00000000  00044aae  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00002440  00000000  00000000  00045e36  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001a2c0  00000000  00000000  00048276  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001b1fc  00000000  00000000  00062536  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0005aaf2  00000000  00000000  0007d732  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00003180  00000000  00000000  000d8224  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	200054d0 	.word	0x200054d0
  400004:	00404521 	.word	0x00404521
  400008:	0040451d 	.word	0x0040451d
  40000c:	0040472d 	.word	0x0040472d
  400010:	00404731 	.word	0x00404731
  400014:	00404735 	.word	0x00404735
  400018:	00404739 	.word	0x00404739
	...
  40002c:	00403555 	.word	0x00403555
  400030:	0040451d 	.word	0x0040451d
  400034:	00000000 	.word	0x00000000
  400038:	00403575 	.word	0x00403575
  40003c:	0040473d 	.word	0x0040473d
  400040:	0040451d 	.word	0x0040451d
  400044:	0040451d 	.word	0x0040451d
  400048:	0040451d 	.word	0x0040451d
  40004c:	0040451d 	.word	0x0040451d
  400050:	004037d5 	.word	0x004037d5
  400054:	0040451d 	.word	0x0040451d
  400058:	0040451d 	.word	0x0040451d
  40005c:	00000000 	.word	0x00000000
  400060:	00403e29 	.word	0x00403e29
  400064:	00403e71 	.word	0x00403e71
  400068:	00000000 	.word	0x00000000
  40006c:	004043d1 	.word	0x004043d1
  400070:	004043e5 	.word	0x004043e5
  400074:	00000000 	.word	0x00000000
  400078:	00403ec1 	.word	0x00403ec1
  40007c:	00403f11 	.word	0x00403f11
	...
  400088:	0040451d 	.word	0x0040451d
  40008c:	0040451d 	.word	0x0040451d
  400090:	0040451d 	.word	0x0040451d
  400094:	0040451d 	.word	0x0040451d
  400098:	0040451d 	.word	0x0040451d
  40009c:	0040451d 	.word	0x0040451d
  4000a0:	0040451d 	.word	0x0040451d
  4000a4:	0040451d 	.word	0x0040451d
	...
  4000b4:	0040451d 	.word	0x0040451d
  4000b8:	0040451d 	.word	0x0040451d
  4000bc:	0040451d 	.word	0x0040451d
  4000c0:	0040451d 	.word	0x0040451d
  4000c4:	0040451d 	.word	0x0040451d
  4000c8:	0040451d 	.word	0x0040451d

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000c00 	.word	0x20000c00
  4000e8:	00000000 	.word	0x00000000
  4000ec:	00405978 	.word	0x00405978

004000f0 <frame_dummy>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4b06      	ldr	r3, [pc, #24]	; (40010c <frame_dummy+0x1c>)
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4806      	ldr	r0, [pc, #24]	; (400110 <frame_dummy+0x20>)
  4000f8:	4906      	ldr	r1, [pc, #24]	; (400114 <frame_dummy+0x24>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4806      	ldr	r0, [pc, #24]	; (400118 <frame_dummy+0x28>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b113      	cbz	r3, 40010a <frame_dummy+0x1a>
  400104:	4b05      	ldr	r3, [pc, #20]	; (40011c <frame_dummy+0x2c>)
  400106:	b103      	cbz	r3, 40010a <frame_dummy+0x1a>
  400108:	4798      	blx	r3
  40010a:	bd08      	pop	{r3, pc}
  40010c:	00000000 	.word	0x00000000
  400110:	00405978 	.word	0x00405978
  400114:	20000c04 	.word	0x20000c04
  400118:	00405978 	.word	0x00405978
  40011c:	00000000 	.word	0x00000000

00400120 <crccu_configure_descriptor>:
 * \param p_crccu Pointer to a CRCCU instance.
 * \param ul_crc_dscr_addr CRCCU descriptor address.
 */
void crccu_configure_descriptor(Crccu *p_crccu, uint32_t ul_crc_dscr_addr)
{
	p_crccu->CRCCU_DSCR = ul_crc_dscr_addr;
  400120:	6001      	str	r1, [r0, #0]
  400122:	4770      	bx	lr

00400124 <crccu_configure_mode>:
 * \param p_crccu Pointer to a CRCCU instance. 
 * \param ul_mode CRC work mode.
 */
void crccu_configure_mode(Crccu *p_crccu, uint32_t ul_mode)
{
	p_crccu->CRCCU_MR = ul_mode;
  400124:	6381      	str	r1, [r0, #56]	; 0x38
  400126:	4770      	bx	lr

00400128 <crccu_enable_dma>:
 * \param p_crccu Pointer to a CRCCU instance.
 */
void crccu_enable_dma(Crccu *p_crccu)
{
	/* Start CRC calculation */
	p_crccu->CRCCU_DMA_EN = CRCCU_DMA_EN_DMAEN;
  400128:	2301      	movs	r3, #1
  40012a:	6083      	str	r3, [r0, #8]
  40012c:	4770      	bx	lr
  40012e:	bf00      	nop

00400130 <crccu_reset>:
/**
 * \brief Reset CRCCU.
 */
void crccu_reset(Crccu *p_crccu)
{
	p_crccu->CRCCU_CR = CRCCU_CR_RESET;
  400130:	2301      	movs	r3, #1
  400132:	6343      	str	r3, [r0, #52]	; 0x34
  400134:	4770      	bx	lr
  400136:	bf00      	nop

00400138 <crccu_get_dma_status>:
 *
 * \return CRCCU DMA status.
 */
uint32_t crccu_get_dma_status(Crccu *p_crccu)
{
	return p_crccu->CRCCU_DMA_SR & CRCCU_DMA_SR_DMASR;
  400138:	6900      	ldr	r0, [r0, #16]
}
  40013a:	f000 0001 	and.w	r0, r0, #1
  40013e:	4770      	bx	lr

00400140 <crccu_read_crc_value>:
 *
 * \return CRC value.
 */
uint32_t crccu_read_crc_value(Crccu *p_crccu)
{
	return p_crccu->CRCCU_SR & CRCCU_SR_CRC_Msk;
  400140:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
  400142:	4770      	bx	lr

00400144 <efc_get_wait_state>:
 *
 * \return The number of wait states in cycle (no shift).
 */
uint32_t efc_get_wait_state(Efc *p_efc)
{
	return ((p_efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos);
  400144:	6800      	ldr	r0, [r0, #0]
}
  400146:	f3c0 2003 	ubfx	r0, r0, #8, #4
  40014a:	4770      	bx	lr

0040014c <efc_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
  40014c:	b508      	push	{r3, lr}
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws) | EEFC_FMR_CLOE);
  40014e:	0212      	lsls	r2, r2, #8
  400150:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  400154:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400158:	4311      	orrs	r1, r2
  40015a:	4b02      	ldr	r3, [pc, #8]	; (400164 <efc_init+0x18>)
  40015c:	4798      	blx	r3
#else
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
#endif	
	return EFC_RC_OK;
}
  40015e:	2000      	movs	r0, #0
  400160:	bd08      	pop	{r3, pc}
  400162:	bf00      	nop
  400164:	20000069 	.word	0x20000069

00400168 <efc_set_wait_state>:
 *
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
  400168:	b508      	push	{r3, lr}
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  40016a:	6802      	ldr	r2, [r0, #0]

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  40016c:	4b04      	ldr	r3, [pc, #16]	; (400180 <efc_set_wait_state+0x18>)
  40016e:	0209      	lsls	r1, r1, #8
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  400170:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400174:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
  400178:	4311      	orrs	r1, r2
  40017a:	4798      	blx	r3
  40017c:	bd08      	pop	{r3, pc}
  40017e:	bf00      	nop
  400180:	20000069 	.word	0x20000069

00400184 <efc_perform_command>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
  400184:	b508      	push	{r3, lr}
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
  400186:	f1a1 030e 	sub.w	r3, r1, #14
  40018a:	2b01      	cmp	r3, #1
  40018c:	d802      	bhi.n	400194 <efc_perform_command+0x10>
		return EFC_RC_NOT_SUPPORT;
  40018e:	f04f 30ff 	mov.w	r0, #4294967295

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
}
  400192:	bd08      	pop	{r3, pc}
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
  400194:	0212      	lsls	r2, r2, #8
  400196:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  40019a:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  40019e:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
  4001a2:	b2c9      	uxtb	r1, r1
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
  4001a4:	4311      	orrs	r1, r2
  4001a6:	4b01      	ldr	r3, [pc, #4]	; (4001ac <efc_perform_command+0x28>)
  4001a8:	4798      	blx	r3
  4001aa:	bd08      	pop	{r3, pc}
  4001ac:	2000006d 	.word	0x2000006d

004001b0 <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
  4001b0:	b508      	push	{r3, lr}
  4001b2:	460a      	mov	r2, r1
	efc_init(EFC, ul_mode, ul_fws);
  4001b4:	4b02      	ldr	r3, [pc, #8]	; (4001c0 <flash_init+0x10>)
  4001b6:	4601      	mov	r1, r0
  4001b8:	4802      	ldr	r0, [pc, #8]	; (4001c4 <flash_init+0x14>)
  4001ba:	4798      	blx	r3
#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
#endif

	return FLASH_RC_OK;
}
  4001bc:	2000      	movs	r0, #0
  4001be:	bd08      	pop	{r3, pc}
  4001c0:	0040014d 	.word	0x0040014d
  4001c4:	400e0a00 	.word	0x400e0a00

004001c8 <flash_write>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4001c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4001cc:	b085      	sub	sp, #20
  4001ce:	4604      	mov	r4, r0
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4001d0:	f5a0 0880 	sub.w	r8, r0, #4194304	; 0x400000
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001d4:	4d32      	ldr	r5, [pc, #200]	; (4002a0 <flash_write+0xd8>)
  4001d6:	4833      	ldr	r0, [pc, #204]	; (4002a4 <flash_write+0xdc>)
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4001d8:	9302      	str	r3, [sp, #8]
  4001da:	468b      	mov	fp, r1
  4001dc:	4691      	mov	r9, r2
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001de:	47a8      	blx	r5
	efc_set_wait_state(p_efc, 6);
  4001e0:	2106      	movs	r1, #6
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001e2:	9003      	str	r0, [sp, #12]
	efc_set_wait_state(p_efc, 6);
  4001e4:	4b30      	ldr	r3, [pc, #192]	; (4002a8 <flash_write+0xe0>)
  4001e6:	482f      	ldr	r0, [pc, #188]	; (4002a4 <flash_write+0xdc>)
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4001e8:	f3c8 284f 	ubfx	r8, r8, #9, #16
	us_offset = (ul_addr - IFLASH_ADDR) % IFLASH_PAGE_SIZE;
  4001ec:	f3c4 0a08 	ubfx	sl, r4, #0, #9

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);
  4001f0:	4798      	blx	r3

	/* Write all pages */
	while (ul_size > 0) {
  4001f2:	f1b9 0f00 	cmp.w	r9, #0
  4001f6:	d04a      	beq.n	40028e <flash_write+0xc6>
  4001f8:	4f2c      	ldr	r7, [pc, #176]	; (4002ac <flash_write+0xe4>)
  4001fa:	4654      	mov	r4, sl
  4001fc:	463d      	mov	r5, r7
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  4001fe:	f508 5a00 	add.w	sl, r8, #8192	; 0x2000
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  400202:	f5c4 7300 	rsb	r3, r4, #512	; 0x200
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  400206:	ea4f 2a4a 	mov.w	sl, sl, lsl #9
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  40020a:	454b      	cmp	r3, r9
  40020c:	bf34      	ite	cc
  40020e:	461e      	movcc	r6, r3
  400210:	464e      	movcs	r6, r9
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
  400212:	9301      	str	r3, [sp, #4]
  400214:	4651      	mov	r1, sl
  400216:	4622      	mov	r2, r4
  400218:	f8df c094 	ldr.w	ip, [pc, #148]	; 4002b0 <flash_write+0xe8>
  40021c:	4823      	ldr	r0, [pc, #140]	; (4002ac <flash_write+0xe4>)
  40021e:	47e0      	blx	ip

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);
  400220:	4632      	mov	r2, r6
  400222:	1938      	adds	r0, r7, r4
  400224:	4659      	mov	r1, fp
  400226:	f8df c088 	ldr.w	ip, [pc, #136]	; 4002b0 <flash_write+0xe8>
  40022a:	47e0      	blx	ip
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  40022c:	9b01      	ldr	r3, [sp, #4]

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  40022e:	1930      	adds	r0, r6, r4
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  400230:	1b9a      	subs	r2, r3, r6
		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
				(void *)(ul_page_addr + us_offset + writeSize),
  400232:	eb06 010a 	add.w	r1, r6, sl

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  400236:	4438      	add	r0, r7
  400238:	4421      	add	r1, r4
  40023a:	4b1d      	ldr	r3, [pc, #116]	; (4002b0 <flash_write+0xe8>)
  40023c:	b292      	uxth	r2, r2
  40023e:	4798      	blx	r3
  400240:	4b1c      	ldr	r3, [pc, #112]	; (4002b4 <flash_write+0xec>)
  400242:	1d1f      	adds	r7, r3, #4
  400244:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  400248:	f853 0f04 	ldr.w	r0, [r3, #4]!
  40024c:	1b5a      	subs	r2, r3, r5
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  40024e:	428b      	cmp	r3, r1
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  400250:	f842 000a 	str.w	r0, [r2, sl]
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  400254:	d1f8      	bne.n	400248 <flash_write+0x80>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  400256:	9b02      	ldr	r3, [sp, #8]
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  400258:	4812      	ldr	r0, [pc, #72]	; (4002a4 <flash_write+0xdc>)
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  40025a:	b17b      	cbz	r3, 40027c <flash_write+0xb4>
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  40025c:	2103      	movs	r1, #3
  40025e:	4642      	mov	r2, r8
  400260:	f8df c054 	ldr.w	ip, [pc, #84]	; 4002b8 <flash_write+0xf0>
  400264:	47e0      	blx	ip
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
					us_page);
		}

		if (ul_error) {
  400266:	b978      	cbnz	r0, 400288 <flash_write+0xc0>
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
  400268:	f108 0c01 	add.w	ip, r8, #1
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  40026c:	ebb9 0906 	subs.w	r9, r9, r6
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
  400270:	fa1f f88c 	uxth.w	r8, ip
		if (ul_error) {
			return ul_error;
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
  400274:	44b3      	add	fp, r6
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  400276:	d00a      	beq.n	40028e <flash_write+0xc6>

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
		us_offset = 0;
  400278:	4604      	mov	r4, r0
  40027a:	e7c0      	b.n	4001fe <flash_write+0x36>

		if (ul_erase_flag) {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
					us_page);
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
  40027c:	2101      	movs	r1, #1
  40027e:	4642      	mov	r2, r8
  400280:	4b0d      	ldr	r3, [pc, #52]	; (4002b8 <flash_write+0xf0>)
  400282:	4798      	blx	r3
					us_page);
		}

		if (ul_error) {
  400284:	2800      	cmp	r0, #0
  400286:	d0ef      	beq.n	400268 <flash_write+0xa0>

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);

	return FLASH_RC_OK;
}
  400288:	b005      	add	sp, #20
  40028a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		us_page++;
		us_offset = 0;
	}

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);
  40028e:	9903      	ldr	r1, [sp, #12]
  400290:	4804      	ldr	r0, [pc, #16]	; (4002a4 <flash_write+0xdc>)
  400292:	f8df c014 	ldr.w	ip, [pc, #20]	; 4002a8 <flash_write+0xe0>
  400296:	47e0      	blx	ip

	return FLASH_RC_OK;
  400298:	2000      	movs	r0, #0
}
  40029a:	b005      	add	sp, #20
  40029c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4002a0:	00400145 	.word	0x00400145
  4002a4:	400e0a00 	.word	0x400e0a00
  4002a8:	00400169 	.word	0x00400169
  4002ac:	20000c1c 	.word	0x20000c1c
  4002b0:	00404d21 	.word	0x00404d21
  4002b4:	20000c18 	.word	0x20000c18
  4002b8:	00400185 	.word	0x00400185

004002bc <flash_unlock>:
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002bc:	f421 51ff 	bic.w	r1, r1, #8160	; 0x1fe0
  4002c0:	f021 011f 	bic.w	r1, r1, #31
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_unlock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
  4002c4:	b570      	push	{r4, r5, r6, lr}
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  4002c6:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002ca:	f501 54ff 	add.w	r4, r1, #8160	; 0x1fe0
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  4002ce:	f020 001f 	bic.w	r0, r0, #31
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002d2:	341f      	adds	r4, #31
	uint16_t us_num_pages_in_region =
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual unlock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);
	if (pul_actual_start != NULL) {
  4002d4:	b102      	cbz	r2, 4002d8 <flash_unlock+0x1c>
		*pul_actual_start = ul_actual_start;
  4002d6:	6010      	str	r0, [r2, #0]
	}
	if (pul_actual_end != NULL) {
  4002d8:	b103      	cbz	r3, 4002dc <flash_unlock+0x20>
		*pul_actual_end = ul_actual_end;
  4002da:	601c      	str	r4, [r3, #0]
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4002dc:	4d0c      	ldr	r5, [pc, #48]	; (400310 <flash_unlock+0x54>)
  4002de:	f5a0 0480 	sub.w	r4, r0, #4194304	; 0x400000
  4002e2:	0a64      	lsrs	r4, r4, #9
  4002e4:	440d      	add	r5, r1
  4002e6:	b2a4      	uxth	r4, r4
  4002e8:	f3c5 254f 	ubfx	r5, r5, #9, #16
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
  4002ec:	42ac      	cmp	r4, r5
  4002ee:	d20c      	bcs.n	40030a <flash_unlock+0x4e>
  4002f0:	4e08      	ldr	r6, [pc, #32]	; (400314 <flash_unlock+0x58>)
  4002f2:	e001      	b.n	4002f8 <flash_unlock+0x3c>
  4002f4:	42ac      	cmp	r4, r5
  4002f6:	d208      	bcs.n	40030a <flash_unlock+0x4e>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
  4002f8:	4622      	mov	r2, r4
  4002fa:	4807      	ldr	r0, [pc, #28]	; (400318 <flash_unlock+0x5c>)
  4002fc:	2109      	movs	r1, #9
  4002fe:	47b0      	blx	r6
				us_start_page);
		if (ul_error) {
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
  400300:	3410      	adds	r4, #16
  400302:	b2a4      	uxth	r4, r4

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
				us_start_page);
		if (ul_error) {
  400304:	2800      	cmp	r0, #0
  400306:	d0f5      	beq.n	4002f4 <flash_unlock+0x38>
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
}
  400308:	bd70      	pop	{r4, r5, r6, pc}
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
  40030a:	2000      	movs	r0, #0
  40030c:	bd70      	pop	{r4, r5, r6, pc}
  40030e:	bf00      	nop
  400310:	ffc01fff 	.word	0xffc01fff
  400314:	00400185 	.word	0x00400185
  400318:	400e0a00 	.word	0x400e0a00

0040031c <loadNewFirmware>:
/**
 * testMemoryCopying(char* filename)
 * @brief Load configuration settings to buffers
 */
status_t loadNewFirmware(char* filename)
{	
  40031c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  400320:	f2ad 4d3c 	subw	sp, sp, #1084	; 0x43c
  400324:	4604      	mov	r4, r0
	status_t result = STATUS_PASS;
	FIL firmwareFileObj = {0};
  400326:	2100      	movs	r1, #0
  400328:	f44f 720a 	mov.w	r2, #552	; 0x228
  40032c:	a884      	add	r0, sp, #528	; 0x210
  40032e:	4d60      	ldr	r5, [pc, #384]	; (4004b0 <loadNewFirmware+0x194>)
  400330:	47a8      	blx	r5
	//initialize the suitNumber

	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  400332:	2330      	movs	r3, #48	; 0x30
  400334:	7023      	strb	r3, [r4, #0]
	FRESULT res = f_open(&firmwareFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  400336:	4621      	mov	r1, r4
  400338:	a884      	add	r0, sp, #528	; 0x210
  40033a:	2201      	movs	r2, #1
  40033c:	4b5d      	ldr	r3, [pc, #372]	; (4004b4 <loadNewFirmware+0x198>)
  40033e:	4798      	blx	r3
	if (res != FR_OK)
  400340:	4604      	mov	r4, r0
  400342:	b120      	cbz	r0, 40034e <loadNewFirmware+0x32>
	{
		return STATUS_FAIL;
  400344:	2001      	movs	r0, #1
	if (res != FR_OK)
	{
		return STATUS_FAIL;
	}
	return STATUS_PASS; 	
}
  400346:	f20d 4d3c 	addw	sp, sp, #1084	; 0x43c
  40034a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (res != FR_OK)
	{
		return STATUS_FAIL;
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
  40034e:	9002      	str	r0, [sp, #8]
	uint32_t bytes_read = 0, total_bytes_read = 0;	
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  400350:	466b      	mov	r3, sp
  400352:	220c      	movs	r2, #12
  400354:	a901      	add	r1, sp, #4
  400356:	a884      	add	r0, sp, #528	; 0x210
  400358:	4f57      	ldr	r7, [pc, #348]	; (4004b8 <loadNewFirmware+0x19c>)
	if (res != FR_OK)
	{
		return STATUS_FAIL;
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
  40035a:	9401      	str	r4, [sp, #4]
  40035c:	9403      	str	r4, [sp, #12]
	uint32_t bytes_read = 0, total_bytes_read = 0;	
  40035e:	9400      	str	r4, [sp, #0]
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  400360:	47b8      	blx	r7
	//confirm that the file has a valid header, with the CRC bytes matching. 
	if(header.fileHeaderBytes != FIRMWARE_FILE_HEADER_BYTES || header.crc1 != header.crc2)
  400362:	9b01      	ldr	r3, [sp, #4]
  400364:	4a55      	ldr	r2, [pc, #340]	; (4004bc <loadNewFirmware+0x1a0>)
  400366:	4293      	cmp	r3, r2
		return STATUS_FAIL;
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
	uint32_t bytes_read = 0, total_bytes_read = 0;	
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  400368:	4606      	mov	r6, r0
	//confirm that the file has a valid header, with the CRC bytes matching. 
	if(header.fileHeaderBytes != FIRMWARE_FILE_HEADER_BYTES || header.crc1 != header.crc2)
  40036a:	d105      	bne.n	400378 <loadNewFirmware+0x5c>
  40036c:	f8bd 2008 	ldrh.w	r2, [sp, #8]
  400370:	f8bd 300a 	ldrh.w	r3, [sp, #10]
  400374:	429a      	cmp	r2, r3
  400376:	d007      	beq.n	400388 <loadNewFirmware+0x6c>
	{
		//bad header, don't even try to load this crap!
		f_close(&firmwareFileObj); 
  400378:	a884      	add	r0, sp, #528	; 0x210
  40037a:	4b51      	ldr	r3, [pc, #324]	; (4004c0 <loadNewFirmware+0x1a4>)
  40037c:	4798      	blx	r3
		return STATUS_FAIL; 
  40037e:	2001      	movs	r0, #1
	if (res != FR_OK)
	{
		return STATUS_FAIL;
	}
	return STATUS_PASS; 	
}
  400380:	f20d 4d3c 	addw	sp, sp, #1084	; 0x43c
  400384:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return STATUS_FAIL; 
	}	
	uint32_t destAddress = FIRMWARE_TEMPORARY_LOCATION; //that where we are writing
	uint32_t retVal = 0;
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6);	
  400388:	2106      	movs	r1, #6
  40038a:	4b4e      	ldr	r3, [pc, #312]	; (4004c4 <loadNewFirmware+0x1a8>)
  40038c:	4620      	mov	r0, r4
  40038e:	4798      	blx	r3
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);		
  400390:	9987      	ldr	r1, [sp, #540]	; 0x21c
  400392:	f8df c168 	ldr.w	ip, [pc, #360]	; 4004fc <loadNewFirmware+0x1e0>
  400396:	484c      	ldr	r0, [pc, #304]	; (4004c8 <loadNewFirmware+0x1ac>)
  400398:	f501 0184 	add.w	r1, r1, #4325376	; 0x420000
  40039c:	4623      	mov	r3, r4
  40039e:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
  4003a2:	4622      	mov	r2, r4
  4003a4:	47e0      	blx	ip
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 		
  4003a6:	a804      	add	r0, sp, #16
  4003a8:	4621      	mov	r1, r4
  4003aa:	f44f 7200 	mov.w	r2, #512	; 0x200
  4003ae:	47a8      	blx	r5
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  4003b0:	9b87      	ldr	r3, [sp, #540]	; 0x21c
  4003b2:	2b0c      	cmp	r3, #12
  4003b4:	d077      	beq.n	4004a6 <loadNewFirmware+0x18a>
  4003b6:	2e00      	cmp	r6, #0
  4003b8:	d177      	bne.n	4004aa <loadNewFirmware+0x18e>
  4003ba:	f8df 8144 	ldr.w	r8, [pc, #324]	; 400500 <loadNewFirmware+0x1e4>
		{
			result = STATUS_FAIL; 
			break;
		}
		total_bytes_read += bytes_read; 
		delay_ms(100);
  4003be:	f8df 9134 	ldr.w	r9, [pc, #308]	; 4004f4 <loadNewFirmware+0x1d8>
	{
		return STATUS_FAIL;
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
	uint32_t bytes_read = 0, total_bytes_read = 0;	
  4003c2:	4635      	mov	r5, r6
  4003c4:	e008      	b.n	4003d8 <loadNewFirmware+0xbc>
		if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
		{
			result = STATUS_FAIL; 
			break;
		}
		total_bytes_read += bytes_read; 
  4003c6:	9b00      	ldr	r3, [sp, #0]
		delay_ms(100);
  4003c8:	4840      	ldr	r0, [pc, #256]	; (4004cc <loadNewFirmware+0x1b0>)
		if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
		{
			result = STATUS_FAIL; 
			break;
		}
		total_bytes_read += bytes_read; 
  4003ca:	441d      	add	r5, r3
		delay_ms(100);
  4003cc:	47c8      	blx	r9
	uint32_t retVal = 0;
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6);	
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);		
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 		
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  4003ce:	9e87      	ldr	r6, [sp, #540]	; 0x21c
  4003d0:	3e0c      	subs	r6, #12
  4003d2:	42ae      	cmp	r6, r5
  4003d4:	d913      	bls.n	4003fe <loadNewFirmware+0xe2>
  4003d6:	b994      	cbnz	r4, 4003fe <loadNewFirmware+0xe2>
	{
		res = f_read(&firmwareFileObj, buf, FIRMWARE_BUFFER_SIZE, &bytes_read);
  4003d8:	a904      	add	r1, sp, #16
  4003da:	f44f 7200 	mov.w	r2, #512	; 0x200
  4003de:	466b      	mov	r3, sp
  4003e0:	a884      	add	r0, sp, #528	; 0x210
  4003e2:	47b8      	blx	r7
  4003e4:	4604      	mov	r4, r0
		//copy the 			
		if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
  4003e6:	f505 0084 	add.w	r0, r5, #4325376	; 0x420000
  4003ea:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
  4003ee:	a904      	add	r1, sp, #16
  4003f0:	9a00      	ldr	r2, [sp, #0]
  4003f2:	2300      	movs	r3, #0
  4003f4:	47c0      	blx	r8
  4003f6:	2800      	cmp	r0, #0
  4003f8:	d0e5      	beq.n	4003c6 <loadNewFirmware+0xaa>
  4003fa:	9e87      	ldr	r6, [sp, #540]	; 0x21c
  4003fc:	3e0c      	subs	r6, #12
{
	uint32_t ul_crc;
	uint32_t ul_timeout = 0;

	/* Reset the CRCCU */
	crccu_reset(CRCCU);
  4003fe:	4834      	ldr	r0, [pc, #208]	; (4004d0 <loadNewFirmware+0x1b4>)
  400400:	4b34      	ldr	r3, [pc, #208]	; (4004d4 <loadNewFirmware+0x1b8>)

	/* Transfer width: byte, interrupt enable */
	crc_dscr.ul_tr_ctrl =	CRCCU_TR_CTRL_TRWIDTH_WORD | (ul_length/4) |
		CRCCU_TR_CTRL_IEN_ENABLE;

	crccu_configure_descriptor(CRCCU, (uint32_t) &crc_dscr);
  400402:	4f35      	ldr	r7, [pc, #212]	; (4004d8 <loadNewFirmware+0x1bc>)
  400404:	4d35      	ldr	r5, [pc, #212]	; (4004dc <loadNewFirmware+0x1c0>)
{
	uint32_t ul_crc;
	uint32_t ul_timeout = 0;

	/* Reset the CRCCU */
	crccu_reset(CRCCU);
  400406:	4798      	blx	r3

	memset((void *)&crc_dscr, 0, sizeof(crccu_dscr_type_t));
  400408:	4b35      	ldr	r3, [pc, #212]	; (4004e0 <loadNewFirmware+0x1c4>)

	crc_dscr.ul_tr_addr = (uint32_t) p_buffer;
  40040a:	4a2f      	ldr	r2, [pc, #188]	; (4004c8 <loadNewFirmware+0x1ac>)

	/* Transfer width: byte, interrupt enable */
	crc_dscr.ul_tr_ctrl =	CRCCU_TR_CTRL_TRWIDTH_WORD | (ul_length/4) |
		CRCCU_TR_CTRL_IEN_ENABLE;

	crccu_configure_descriptor(CRCCU, (uint32_t) &crc_dscr);
  40040c:	4830      	ldr	r0, [pc, #192]	; (4004d0 <loadNewFirmware+0x1b4>)
	/* Reset the CRCCU */
	crccu_reset(CRCCU);

	memset((void *)&crc_dscr, 0, sizeof(crccu_dscr_type_t));

	crc_dscr.ul_tr_addr = (uint32_t) p_buffer;
  40040e:	601a      	str	r2, [r3, #0]
	uint32_t ul_timeout = 0;

	/* Reset the CRCCU */
	crccu_reset(CRCCU);

	memset((void *)&crc_dscr, 0, sizeof(crccu_dscr_type_t));
  400410:	2400      	movs	r4, #0

	crc_dscr.ul_tr_addr = (uint32_t) p_buffer;

	/* Transfer width: byte, interrupt enable */
	crc_dscr.ul_tr_ctrl =	CRCCU_TR_CTRL_TRWIDTH_WORD | (ul_length/4) |
  400412:	08b6      	lsrs	r6, r6, #2
	uint32_t ul_timeout = 0;

	/* Reset the CRCCU */
	crccu_reset(CRCCU);

	memset((void *)&crc_dscr, 0, sizeof(crccu_dscr_type_t));
  400414:	609c      	str	r4, [r3, #8]
  400416:	60dc      	str	r4, [r3, #12]

	/* Transfer width: byte, interrupt enable */
	crc_dscr.ul_tr_ctrl =	CRCCU_TR_CTRL_TRWIDTH_WORD | (ul_length/4) |
		CRCCU_TR_CTRL_IEN_ENABLE;

	crccu_configure_descriptor(CRCCU, (uint32_t) &crc_dscr);
  400418:	4619      	mov	r1, r3
	uint32_t ul_timeout = 0;

	/* Reset the CRCCU */
	crccu_reset(CRCCU);

	memset((void *)&crc_dscr, 0, sizeof(crccu_dscr_type_t));
  40041a:	611c      	str	r4, [r3, #16]

	crc_dscr.ul_tr_addr = (uint32_t) p_buffer;

	/* Transfer width: byte, interrupt enable */
	crc_dscr.ul_tr_ctrl =	CRCCU_TR_CTRL_TRWIDTH_WORD | (ul_length/4) |
  40041c:	f046 7600 	orr.w	r6, r6, #33554432	; 0x2000000
  400420:	605e      	str	r6, [r3, #4]
		CRCCU_TR_CTRL_IEN_ENABLE;

	crccu_configure_descriptor(CRCCU, (uint32_t) &crc_dscr);
  400422:	47b8      	blx	r7

	/* Configure CRCCU mode */
	crccu_configure_mode(CRCCU, CRCCU_MR_ENABLE | ul_polynomial_type);
  400424:	482a      	ldr	r0, [pc, #168]	; (4004d0 <loadNewFirmware+0x1b4>)
  400426:	4b2f      	ldr	r3, [pc, #188]	; (4004e4 <loadNewFirmware+0x1c8>)
  400428:	2109      	movs	r1, #9
  40042a:	4798      	blx	r3

	/* Start the CRC calculation */
	crccu_enable_dma(CRCCU);
  40042c:	4828      	ldr	r0, [pc, #160]	; (4004d0 <loadNewFirmware+0x1b4>)
  40042e:	4b2e      	ldr	r3, [pc, #184]	; (4004e8 <loadNewFirmware+0x1cc>)
  400430:	4798      	blx	r3
  400432:	e001      	b.n	400438 <loadNewFirmware+0x11c>

	/* Wait for calculation ready */
	while ((crccu_get_dma_status(CRCCU) == CRCCU_DMA_SR_DMASR) &&
  400434:	3c01      	subs	r4, #1
  400436:	d003      	beq.n	400440 <loadNewFirmware+0x124>
  400438:	4825      	ldr	r0, [pc, #148]	; (4004d0 <loadNewFirmware+0x1b4>)
  40043a:	47a8      	blx	r5
  40043c:	2801      	cmp	r0, #1
  40043e:	d0f9      	beq.n	400434 <loadNewFirmware+0x118>
			(ul_timeout++ < CRCCU_TIMEOUT)) 
	{
		
	}
	/* Get CRC value */
	ul_crc = crccu_read_crc_value(CRCCU);
  400440:	4b2a      	ldr	r3, [pc, #168]	; (4004ec <loadNewFirmware+0x1d0>)
  400442:	4823      	ldr	r0, [pc, #140]	; (4004d0 <loadNewFirmware+0x1b4>)
  400444:	4798      	blx	r3
	
	//verify firmware
	uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	CRCCU_MR_PTYPE_CCITT16);
	header.crc2 = (uint16_t)ul_crc;
	if(header.crc2 == header.crc1)
  400446:	f8bd 3008 	ldrh.w	r3, [sp, #8]
	}
	
	//verify firmware
	uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	CRCCU_MR_PTYPE_CCITT16);
	header.crc2 = (uint16_t)ul_crc;
  40044a:	b280      	uxth	r0, r0
	if(header.crc2 == header.crc1)
  40044c:	4283      	cmp	r3, r0
	}
	
	//verify firmware
	uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	CRCCU_MR_PTYPE_CCITT16);
	header.crc2 = (uint16_t)ul_crc;
  40044e:	f8ad 000a 	strh.w	r0, [sp, #10]
	if(header.crc2 == header.crc1)
  400452:	d006      	beq.n	400462 <loadNewFirmware+0x146>
	else
	{
		result = STATUS_FAIL; 
	}
		
	res = f_close(&firmwareFileObj);
  400454:	a884      	add	r0, sp, #528	; 0x210
  400456:	4b1a      	ldr	r3, [pc, #104]	; (4004c0 <loadNewFirmware+0x1a4>)
  400458:	4798      	blx	r3

	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
	FRESULT res = f_open(&firmwareFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
	if (res != FR_OK)
	{
		return STATUS_FAIL;
  40045a:	3000      	adds	r0, #0
  40045c:	bf18      	it	ne
  40045e:	2001      	movne	r0, #1
  400460:	e771      	b.n	400346 <loadNewFirmware+0x2a>
	if(header.crc2 == header.crc1)
	{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = FIRMWARE_LOCATION;
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400462:	9b87      	ldr	r3, [sp, #540]	; 0x21c
  400464:	2b0c      	cmp	r3, #12
  400466:	d0f5      	beq.n	400454 <loadNewFirmware+0x138>
  400468:	f8df 8094 	ldr.w	r8, [pc, #148]	; 400500 <loadNewFirmware+0x1e4>
  40046c:	4d20      	ldr	r5, [pc, #128]	; (4004f0 <loadNewFirmware+0x1d4>)
			{
				result = STATUS_FAIL;
				break;
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
			delay_ms(10);
  40046e:	4e21      	ldr	r6, [pc, #132]	; (4004f4 <loadNewFirmware+0x1d8>)
	if(header.crc2 == header.crc1)
	{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = FIRMWARE_LOCATION;
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400470:	2400      	movs	r4, #0
  400472:	e005      	b.n	400480 <loadNewFirmware+0x164>
			{
				result = STATUS_FAIL;
				break;
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
			delay_ms(10);
  400474:	4820      	ldr	r0, [pc, #128]	; (4004f8 <loadNewFirmware+0x1dc>)
  400476:	47b0      	blx	r6
	if(header.crc2 == header.crc1)
	{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = FIRMWARE_LOCATION;
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400478:	9b87      	ldr	r3, [sp, #540]	; 0x21c
  40047a:	3b0c      	subs	r3, #12
  40047c:	42a3      	cmp	r3, r4
  40047e:	d9e9      	bls.n	400454 <loadNewFirmware+0x138>
		{			
			memcpy(buf,FIRMWARE_TEMPORARY_LOCATION+total_bytes_read,FIRMWARE_BUFFER_SIZE); 			
  400480:	f504 0184 	add.w	r1, r4, #4325376	; 0x420000
  400484:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
  400488:	f44f 7200 	mov.w	r2, #512	; 0x200
  40048c:	a804      	add	r0, sp, #16
  40048e:	47a8      	blx	r5
			if(flash_write(destAddress+total_bytes_read, (void*)buf,FIRMWARE_BUFFER_SIZE,0) != 0)
  400490:	f504 0081 	add.w	r0, r4, #4227072	; 0x408000
  400494:	f44f 7200 	mov.w	r2, #512	; 0x200
  400498:	a904      	add	r1, sp, #16
  40049a:	2300      	movs	r3, #0
			{
				result = STATUS_FAIL;
				break;
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
  40049c:	4414      	add	r4, r2
		total_bytes_read =0;
		destAddress = FIRMWARE_LOCATION;
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
		{			
			memcpy(buf,FIRMWARE_TEMPORARY_LOCATION+total_bytes_read,FIRMWARE_BUFFER_SIZE); 			
			if(flash_write(destAddress+total_bytes_read, (void*)buf,FIRMWARE_BUFFER_SIZE,0) != 0)
  40049e:	47c0      	blx	r8
  4004a0:	2800      	cmp	r0, #0
  4004a2:	d0e7      	beq.n	400474 <loadNewFirmware+0x158>
  4004a4:	e7d6      	b.n	400454 <loadNewFirmware+0x138>
	uint32_t retVal = 0;
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6);	
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);		
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 		
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  4004a6:	4626      	mov	r6, r4
  4004a8:	e7a9      	b.n	4003fe <loadNewFirmware+0xe2>
  4004aa:	f1a3 060c 	sub.w	r6, r3, #12
  4004ae:	e7a6      	b.n	4003fe <loadNewFirmware+0xe2>
  4004b0:	00404e55 	.word	0x00404e55
  4004b4:	00402f45 	.word	0x00402f45
  4004b8:	004031e9 	.word	0x004031e9
  4004bc:	aa55aa55 	.word	0xaa55aa55
  4004c0:	00403451 	.word	0x00403451
  4004c4:	004001b1 	.word	0x004001b1
  4004c8:	00424000 	.word	0x00424000
  4004cc:	000d1437 	.word	0x000d1437
  4004d0:	40044000 	.word	0x40044000
  4004d4:	00400131 	.word	0x00400131
  4004d8:	00400121 	.word	0x00400121
  4004dc:	00400139 	.word	0x00400139
  4004e0:	20001200 	.word	0x20001200
  4004e4:	00400125 	.word	0x00400125
  4004e8:	00400129 	.word	0x00400129
  4004ec:	00400141 	.word	0x00400141
  4004f0:	00404d21 	.word	0x00404d21
  4004f4:	20000085 	.word	0x20000085
  4004f8:	00014ed3 	.word	0x00014ed3
  4004fc:	004002bd 	.word	0x004002bd
  400500:	004001c9 	.word	0x004001c9

00400504 <runBootloader>:
	uint16_t crc2;
	uint32_t length; 	
}firmwareHeader_t;

void runBootloader()
{
  400504:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t status = STATUS_PASS; 
	//drv_gpio_initializeForBootloader(); 

	drv_gpio_initializeAll();
  400508:	4b63      	ldr	r3, [pc, #396]	; (400698 <runBootloader+0x194>)
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH; 	
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40050a:	4c64      	ldr	r4, [pc, #400]	; (40069c <runBootloader+0x198>)
	uint16_t crc2;
	uint32_t length; 	
}firmwareHeader_t;

void runBootloader()
{
  40050c:	b083      	sub	sp, #12
	status_t status = STATUS_PASS; 
	//drv_gpio_initializeForBootloader(); 

	drv_gpio_initializeAll();
  40050e:	4798      	blx	r3
	pmc_enable_periph_clk(ID_CRCCU);   		    
  400510:	4b63      	ldr	r3, [pc, #396]	; (4006a0 <runBootloader+0x19c>)
  400512:	2020      	movs	r0, #32
  400514:	4798      	blx	r3
	board_init();	
  400516:	4b63      	ldr	r3, [pc, #396]	; (4006a4 <runBootloader+0x1a0>)
  400518:	4798      	blx	r3
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH; 	
  40051a:	2301      	movs	r3, #1
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40051c:	4618      	mov	r0, r3
  40051e:	f10d 0105 	add.w	r1, sp, #5
	//drv_gpio_initializeForBootloader(); 

	drv_gpio_initializeAll();
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH; 	
  400522:	f88d 3005 	strb.w	r3, [sp, #5]
  400526:	f88d 3006 	strb.w	r3, [sp, #6]
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40052a:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  40052c:	f10d 0106 	add.w	r1, sp, #6
  400530:	2002      	movs	r0, #2
  400532:	47a0      	blx	r4
	int i = 0; 
	
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
  400534:	f89d 3005 	ldrb.w	r3, [sp, #5]
  400538:	2b00      	cmp	r3, #0
  40053a:	d13e      	bne.n	4005ba <runBootloader+0xb6>
  40053c:	f89d 3006 	ldrb.w	r3, [sp, #6]
  400540:	2b00      	cmp	r3, #0
  400542:	d13a      	bne.n	4005ba <runBootloader+0xb6>
  400544:	4e58      	ldr	r6, [pc, #352]	; (4006a8 <runBootloader+0x1a4>)
  400546:	250a      	movs	r5, #10
  400548:	e009      	b.n	40055e <runBootloader+0x5a>
		for(i=0;i<10;i++)
		{		
			enterBootloader = 1; //set the enter bootloader flag
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
			if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  40054a:	f89d 7006 	ldrb.w	r7, [sp, #6]
			{
				enterBootloader = 0; 
			}
			delay_ms(100); 			
  40054e:	4857      	ldr	r0, [pc, #348]	; (4006ac <runBootloader+0x1a8>)
		for(i=0;i<10;i++)
		{		
			enterBootloader = 1; //set the enter bootloader flag
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
			if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400550:	f1d7 0701 	rsbs	r7, r7, #1
  400554:	bf38      	it	cc
  400556:	2700      	movcc	r7, #0
			{
				enterBootloader = 0; 
			}
			delay_ms(100); 			
  400558:	47b0      	blx	r6
	int i = 0; 
	
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		//make sure that both IO stay low for 1 second
		for(i=0;i<10;i++)
  40055a:	3d01      	subs	r5, #1
  40055c:	d011      	beq.n	400582 <runBootloader+0x7e>
		{		
			enterBootloader = 1; //set the enter bootloader flag
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40055e:	f10d 0105 	add.w	r1, sp, #5
  400562:	2001      	movs	r0, #1
  400564:	47a0      	blx	r4
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  400566:	2002      	movs	r0, #2
  400568:	f10d 0106 	add.w	r1, sp, #6
  40056c:	47a0      	blx	r4
			if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  40056e:	f89d 3005 	ldrb.w	r3, [sp, #5]
  400572:	2b00      	cmp	r3, #0
  400574:	d0e9      	beq.n	40054a <runBootloader+0x46>
			{
				enterBootloader = 0; 
			}
			delay_ms(100); 			
  400576:	484d      	ldr	r0, [pc, #308]	; (4006ac <runBootloader+0x1a8>)
  400578:	47b0      	blx	r6
	int i = 0; 
	
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		//make sure that both IO stay low for 1 second
		for(i=0;i<10;i++)
  40057a:	3d01      	subs	r5, #1
			enterBootloader = 1; //set the enter bootloader flag
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
			drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
			if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
			{
				enterBootloader = 0; 
  40057c:	f04f 0700 	mov.w	r7, #0
	int i = 0; 
	
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		//make sure that both IO stay low for 1 second
		for(i=0;i<10;i++)
  400580:	d1ed      	bne.n	40055e <runBootloader+0x5a>
				enterBootloader = 0; 
			}
			delay_ms(100); 			
		}		
	}	
	if(enterBootloader == 1)
  400582:	b1d7      	cbz	r7, 4005ba <runBootloader+0xb6>
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400584:	a902      	add	r1, sp, #8
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400586:	2010      	movs	r0, #16
		}		
	}	
	if(enterBootloader == 1)
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400588:	f801 5d01 	strb.w	r5, [r1, #-1]!
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  40058c:	47a0      	blx	r4
		if(sdCardCD != DRV_GPIO_PIN_STATE_HIGH)
  40058e:	f89d 3007 	ldrb.w	r3, [sp, #7]
  400592:	2b01      	cmp	r3, #1
  400594:	d01e      	beq.n	4005d4 <runBootloader+0xd0>
  400596:	4d46      	ldr	r5, [pc, #280]	; (4006b0 <runBootloader+0x1ac>)
}

//blink led red 5 times if loading failed
static void errorBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400598:	2101      	movs	r1, #1
  40059a:	200e      	movs	r0, #14
  40059c:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  40059e:	2101      	movs	r1, #1
  4005a0:	200c      	movs	r0, #12
  4005a2:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  4005a4:	200d      	movs	r0, #13
  4005a6:	2101      	movs	r1, #1
  4005a8:	47a8      	blx	r5
  4005aa:	4d42      	ldr	r5, [pc, #264]	; (4006b4 <runBootloader+0x1b0>)
  4005ac:	240a      	movs	r4, #10
	
	int i = 0;
	for(i=0; i<10; i++)
	{
		delay_ms(200); 
  4005ae:	4842      	ldr	r0, [pc, #264]	; (4006b8 <runBootloader+0x1b4>)
  4005b0:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_RED_LED); 	
  4005b2:	200e      	movs	r0, #14
  4005b4:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<10; i++)
  4005b6:	3c01      	subs	r4, #1
  4005b8:	d1f9      	bne.n	4005ae <runBootloader+0xaa>

static void start_application(void)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
  4005ba:	f44f 0381 	mov.w	r3, #4227072	; 0x408000

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
  4005be:	681a      	ldr	r2, [r3, #0]
  4005c0:	f382 8808 	msr	MSP, r2
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  4005c4:	493d      	ldr	r1, [pc, #244]	; (4006bc <runBootloader+0x1b8>)
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
  4005c6:	4a3e      	ldr	r2, [pc, #248]	; (4006c0 <runBootloader+0x1bc>)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  4005c8:	608b      	str	r3, [r1, #8]
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
	/* Jump to application Reset Handler in the application */
	asm("bx %0"::"r"(app_start_address));
  4005ca:	6813      	ldr	r3, [r2, #0]
  4005cc:	4718      	bx	r3
			successBlink();
		}		
	} 	   
	start_application();
	
}
  4005ce:	b003      	add	sp, #12
  4005d0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
static status_t initializeSDCard()
{
	static FRESULT res;
	status_t status = STATUS_PASS; 
	////Initialize SD card
	sd_mmc_init();
  4005d4:	4b3b      	ldr	r3, [pc, #236]	; (4006c4 <runBootloader+0x1c0>)
  4005d6:	f8df 910c 	ldr.w	r9, [pc, #268]	; 4006e4 <runBootloader+0x1e0>
  4005da:	f8df 810c 	ldr.w	r8, [pc, #268]	; 4006e8 <runBootloader+0x1e4>
  4005de:	4f3a      	ldr	r7, [pc, #232]	; (4006c8 <runBootloader+0x1c4>)
}

static status_t initializeSDCard()
{
	static FRESULT res;
	status_t status = STATUS_PASS; 
  4005e0:	46aa      	mov	sl, r5
	////Initialize SD card
	sd_mmc_init();
  4005e2:	4798      	blx	r3
	//
	///* Wait card present and ready */
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
  4005e4:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
  4005e8:	e008      	b.n	4005fc <runBootloader+0xf8>
					break; 
				}
			}
		}
		maxAttemptCount--;
		if(maxAttemptCount == 0)
  4005ea:	3c01      	subs	r4, #1
  4005ec:	d046      	beq.n	40067c <runBootloader+0x178>
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  4005ee:	4837      	ldr	r0, [pc, #220]	; (4006cc <runBootloader+0x1c8>)
		
		
	} while (CTRL_GOOD != res);
  4005f0:	f8df b0f4 	ldr.w	fp, [pc, #244]	; 4006e8 <runBootloader+0x1e4>
		if(maxAttemptCount == 0)
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  4005f4:	47b0      	blx	r6
		
		
	} while (CTRL_GOOD != res);
  4005f6:	f898 5000 	ldrb.w	r5, [r8]
  4005fa:	b185      	cbz	r5, 40061e <runBootloader+0x11a>
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  4005fc:	2000      	movs	r0, #0
  4005fe:	47c8      	blx	r9
		if (res == CTRL_FAIL)
  400600:	2801      	cmp	r0, #1
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400602:	f888 0000 	strb.w	r0, [r8]
		if (res == CTRL_FAIL)
  400606:	d1f0      	bne.n	4005ea <runBootloader+0xe6>
		{
			while (CTRL_NO_PRESENT != sd_mmc_check(0))
  400608:	2000      	movs	r0, #0
  40060a:	47b8      	blx	r7
  40060c:	2802      	cmp	r0, #2
  40060e:	d0ec      	beq.n	4005ea <runBootloader+0xe6>
			{
				maxAttemptCount--; 
				if(maxAttemptCount == 0)
  400610:	3c01      	subs	r4, #1
  400612:	d1f9      	bne.n	400608 <runBootloader+0x104>
				{
					status = STATUS_FAIL;
  400614:	f04f 0a01 	mov.w	sl, #1
					break; 
				}
			}
		}
		maxAttemptCount--;
  400618:	f04f 34ff 	mov.w	r4, #4294967295
  40061c:	e7e7      	b.n	4005ee <runBootloader+0xea>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  40061e:	4b2c      	ldr	r3, [pc, #176]	; (4006d0 <runBootloader+0x1cc>)
  400620:	482c      	ldr	r0, [pc, #176]	; (4006d4 <runBootloader+0x1d0>)
  400622:	4629      	mov	r1, r5
  400624:	f44f 720c 	mov.w	r2, #560	; 0x230
  400628:	4798      	blx	r3
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  40062a:	4628      	mov	r0, r5
  40062c:	4929      	ldr	r1, [pc, #164]	; (4006d4 <runBootloader+0x1d0>)
  40062e:	4b2a      	ldr	r3, [pc, #168]	; (4006d8 <runBootloader+0x1d4>)
  400630:	4798      	blx	r3
	if (res == FR_INVALID_DRIVE)
  400632:	280b      	cmp	r0, #11
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400634:	f88b 0000 	strb.w	r0, [fp]
	if (res == FR_INVALID_DRIVE)
  400638:	d0ad      	beq.n	400596 <runBootloader+0x92>
		if(status == STATUS_PASS)
		{
			status = initializeSDCard(); 	
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
  40063a:	f1ba 0f00 	cmp.w	sl, #0
  40063e:	d1aa      	bne.n	400596 <runBootloader+0x92>
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400640:	4651      	mov	r1, sl
  400642:	4d1b      	ldr	r5, [pc, #108]	; (4006b0 <runBootloader+0x1ac>)
  400644:	200d      	movs	r0, #13
  400646:	47a8      	blx	r5
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
  400648:	4651      	mov	r1, sl
  40064a:	200e      	movs	r0, #14
  40064c:	47a8      	blx	r5
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  40064e:	4823      	ldr	r0, [pc, #140]	; (4006dc <runBootloader+0x1d8>)
  400650:	4b23      	ldr	r3, [pc, #140]	; (4006e0 <runBootloader+0x1dc>)
  400652:	4798      	blx	r3
		}
		if(status != STATUS_PASS)
  400654:	2800      	cmp	r0, #0
  400656:	d19f      	bne.n	400598 <runBootloader+0x94>
	}	
}
//blink led green 3 times if successful
static void successBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400658:	2101      	movs	r1, #1
  40065a:	200e      	movs	r0, #14
  40065c:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  40065e:	2101      	movs	r1, #1
  400660:	200c      	movs	r0, #12
  400662:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400664:	200d      	movs	r0, #13
  400666:	2101      	movs	r1, #1
  400668:	47a8      	blx	r5
  40066a:	4d12      	ldr	r5, [pc, #72]	; (4006b4 <runBootloader+0x1b0>)
  40066c:	2406      	movs	r4, #6
	
	int i = 0;
	for(i=0; i<6; i++)
	{
		delay_ms(200); 
  40066e:	4812      	ldr	r0, [pc, #72]	; (4006b8 <runBootloader+0x1b4>)
  400670:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 	
  400672:	200c      	movs	r0, #12
  400674:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<6; i++)
  400676:	3c01      	subs	r4, #1
  400678:	d1f9      	bne.n	40066e <runBootloader+0x16a>
  40067a:	e79e      	b.n	4005ba <runBootloader+0xb6>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  40067c:	4b14      	ldr	r3, [pc, #80]	; (4006d0 <runBootloader+0x1cc>)
  40067e:	4815      	ldr	r0, [pc, #84]	; (4006d4 <runBootloader+0x1d0>)
  400680:	4d0b      	ldr	r5, [pc, #44]	; (4006b0 <runBootloader+0x1ac>)
  400682:	4621      	mov	r1, r4
  400684:	f44f 720c 	mov.w	r2, #560	; 0x230
  400688:	4798      	blx	r3
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  40068a:	4620      	mov	r0, r4
  40068c:	4911      	ldr	r1, [pc, #68]	; (4006d4 <runBootloader+0x1d0>)
  40068e:	4b12      	ldr	r3, [pc, #72]	; (4006d8 <runBootloader+0x1d4>)
  400690:	4798      	blx	r3
  400692:	f888 0000 	strb.w	r0, [r8]
  400696:	e77f      	b.n	400598 <runBootloader+0x94>
  400698:	00403b69 	.word	0x00403b69
  40069c:	00403bd1 	.word	0x00403bd1
  4006a0:	004044d5 	.word	0x004044d5
  4006a4:	00403fc5 	.word	0x00403fc5
  4006a8:	20000085 	.word	0x20000085
  4006ac:	000d1437 	.word	0x000d1437
  4006b0:	00403ba5 	.word	0x00403ba5
  4006b4:	00403c01 	.word	0x00403c01
  4006b8:	001a286e 	.word	0x001a286e
  4006bc:	e000ed00 	.word	0xe000ed00
  4006c0:	00408004 	.word	0x00408004
  4006c4:	00400849 	.word	0x00400849
  4006c8:	00400869 	.word	0x00400869
  4006cc:	00014ed3 	.word	0x00014ed3
  4006d0:	00404e55 	.word	0x00404e55
  4006d4:	20001214 	.word	0x20001214
  4006d8:	00402f05 	.word	0x00402f05
  4006dc:	004052a4 	.word	0x004052a4
  4006e0:	0040031d 	.word	0x0040031d
  4006e4:	004011f1 	.word	0x004011f1
  4006e8:	20000e1c 	.word	0x20000e1c

004006ec <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  4006ec:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  4006ee:	4a07      	ldr	r2, [pc, #28]	; (40070c <sd_mmc_configure_slot+0x20>)
  4006f0:	4b07      	ldr	r3, [pc, #28]	; (400710 <sd_mmc_configure_slot+0x24>)
  4006f2:	6812      	ldr	r2, [r2, #0]
  4006f4:	7818      	ldrb	r0, [r3, #0]
  4006f6:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
  4006fa:	6811      	ldr	r1, [r2, #0]
  4006fc:	4c05      	ldr	r4, [pc, #20]	; (400714 <sd_mmc_configure_slot+0x28>)
  4006fe:	7c52      	ldrb	r2, [r2, #17]
  400700:	3300      	adds	r3, #0
  400702:	bf18      	it	ne
  400704:	2301      	movne	r3, #1
  400706:	47a0      	blx	r4
  400708:	bd10      	pop	{r4, pc}
  40070a:	bf00      	nop
  40070c:	20000e24 	.word	0x20000e24
  400710:	20000e2a 	.word	0x20000e2a
  400714:	00401561 	.word	0x00401561

00400718 <sd_mmc_select_slot.part.0>:
 * \retval SD_MMC_ERR_NO_CARD  No card present on slot
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
  400718:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (ioport_get_pin_level(sd_mmc_cards[slot].cd_gpio)
  40071a:	00c5      	lsls	r5, r0, #3
  40071c:	4c34      	ldr	r4, [pc, #208]	; (4007f0 <sd_mmc_select_slot.part.0+0xd8>)
  40071e:	1829      	adds	r1, r5, r0
  400720:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400724:	2601      	movs	r6, #1
  400726:	688a      	ldr	r2, [r1, #8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400728:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  40072a:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40072e:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400732:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400734:	f002 021f 	and.w	r2, r2, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  400738:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  40073a:	fa06 f202 	lsl.w	r2, r6, r2
  40073e:	4013      	ands	r3, r2
  400740:	f101 0108 	add.w	r1, r1, #8
  400744:	d110      	bne.n	400768 <sd_mmc_select_slot.part.0+0x50>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  400746:	7989      	ldrb	r1, [r1, #6]
  400748:	42b1      	cmp	r1, r6
  40074a:	d006      	beq.n	40075a <sd_mmc_select_slot.part.0+0x42>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  40074c:	4428      	add	r0, r5
  40074e:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  400752:	2304      	movs	r3, #4
  400754:	73a3      	strb	r3, [r4, #14]
		return SD_MMC_ERR_NO_CARD;
  400756:	2002      	movs	r0, #2
  400758:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
  40075a:	4a26      	ldr	r2, [pc, #152]	; (4007f4 <sd_mmc_select_slot.part.0+0xdc>)
  40075c:	7812      	ldrb	r2, [r2, #0]
  40075e:	2a00      	cmp	r2, #0
  400760:	d0f4      	beq.n	40074c <sd_mmc_select_slot.part.0+0x34>
		SysTick->CTRL = 0;
  400762:	4a25      	ldr	r2, [pc, #148]	; (4007f8 <sd_mmc_select_slot.part.0+0xe0>)
  400764:	6013      	str	r3, [r2, #0]
  400766:	e7f1      	b.n	40074c <sd_mmc_select_slot.part.0+0x34>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
  400768:	798b      	ldrb	r3, [r1, #6]
  40076a:	2b04      	cmp	r3, #4
  40076c:	d02a      	beq.n	4007c4 <sd_mmc_select_slot.part.0+0xac>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  40076e:	2b01      	cmp	r3, #1
  400770:	d003      	beq.n	40077a <sd_mmc_select_slot.part.0+0x62>
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
  400772:	2b03      	cmp	r3, #3
  400774:	d118      	bne.n	4007a8 <sd_mmc_select_slot.part.0+0x90>
		return SD_MMC_ERR_UNUSABLE;
  400776:	4618      	mov	r0, r3
  400778:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
  40077a:	4b1e      	ldr	r3, [pc, #120]	; (4007f4 <sd_mmc_select_slot.part.0+0xdc>)
  40077c:	781b      	ldrb	r3, [r3, #0]
  40077e:	b12b      	cbz	r3, 40078c <sd_mmc_select_slot.part.0+0x74>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
  400780:	4b1d      	ldr	r3, [pc, #116]	; (4007f8 <sd_mmc_select_slot.part.0+0xe0>)
  400782:	681a      	ldr	r2, [r3, #0]
  400784:	03d2      	lsls	r2, r2, #15
  400786:	d530      	bpl.n	4007ea <sd_mmc_select_slot.part.0+0xd2>
		SysTick->CTRL = 0;
  400788:	2200      	movs	r2, #0
  40078a:	601a      	str	r2, [r3, #0]
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  40078c:	1829      	adds	r1, r5, r0
  40078e:	0089      	lsls	r1, r1, #2
  400790:	1863      	adds	r3, r4, r1
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  400792:	4f1a      	ldr	r7, [pc, #104]	; (4007fc <sd_mmc_select_slot.part.0+0xe4>)
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  400794:	2602      	movs	r6, #2
  400796:	739e      	strb	r6, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  400798:	5067      	str	r7, [r4, r1]
		sd_mmc_cards[slot].bus_width = 1;
  40079a:	2701      	movs	r7, #1
		sd_mmc_cards[slot].high_speed = 0;
  40079c:	2100      	movs	r1, #0
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
  40079e:	745f      	strb	r7, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
  4007a0:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  4007a4:	7b9b      	ldrb	r3, [r3, #14]
  4007a6:	e7e4      	b.n	400772 <sd_mmc_select_slot.part.0+0x5a>
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
  4007a8:	4405      	add	r5, r0
  4007aa:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  4007ae:	4914      	ldr	r1, [pc, #80]	; (400800 <sd_mmc_select_slot.part.0+0xe8>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  4007b0:	4a14      	ldr	r2, [pc, #80]	; (400804 <sd_mmc_select_slot.part.0+0xec>)
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
  4007b2:	4b15      	ldr	r3, [pc, #84]	; (400808 <sd_mmc_select_slot.part.0+0xf0>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  4007b4:	7010      	strb	r0, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  4007b6:	600c      	str	r4, [r1, #0]
	sd_mmc_configure_slot();
  4007b8:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  4007ba:	7ba0      	ldrb	r0, [r4, #14]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  4007bc:	1e83      	subs	r3, r0, #2
  4007be:	4258      	negs	r0, r3
  4007c0:	4158      	adcs	r0, r3
  4007c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  4007c4:	4b0c      	ldr	r3, [pc, #48]	; (4007f8 <sd_mmc_select_slot.part.0+0xe0>)
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
  4007c6:	718e      	strb	r6, [r1, #6]
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  4007c8:	681a      	ldr	r2, [r3, #0]
  4007ca:	b932      	cbnz	r2, 4007da <sd_mmc_select_slot.part.0+0xc2>
		sd_mmc_sam_systick_used = true;
  4007cc:	4909      	ldr	r1, [pc, #36]	; (4007f4 <sd_mmc_select_slot.part.0+0xdc>)
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  4007ce:	4a0f      	ldr	r2, [pc, #60]	; (40080c <sd_mmc_select_slot.part.0+0xf4>)
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
  4007d0:	700e      	strb	r6, [r1, #0]
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  4007d2:	605a      	str	r2, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
  4007d4:	601e      	str	r6, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  4007d6:	2002      	movs	r0, #2
  4007d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  4007da:	4a06      	ldr	r2, [pc, #24]	; (4007f4 <sd_mmc_select_slot.part.0+0xdc>)
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  4007dc:	480c      	ldr	r0, [pc, #48]	; (400810 <sd_mmc_select_slot.part.0+0xf8>)
  4007de:	4b0d      	ldr	r3, [pc, #52]	; (400814 <sd_mmc_select_slot.part.0+0xfc>)
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  4007e0:	2100      	movs	r1, #0
  4007e2:	7011      	strb	r1, [r2, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  4007e4:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  4007e6:	2002      	movs	r0, #2
  4007e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
  4007ea:	2002      	movs	r0, #2
  4007ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4007ee:	bf00      	nop
  4007f0:	20000090 	.word	0x20000090
  4007f4:	20000e20 	.word	0x20000e20
  4007f8:	e000e010 	.word	0xe000e010
  4007fc:	00061a80 	.word	0x00061a80
  400800:	20000e24 	.word	0x20000e24
  400804:	20000e2a 	.word	0x20000e2a
  400808:	004006ed 	.word	0x004006ed
  40080c:	00e4e1c0 	.word	0x00e4e1c0
  400810:	0082ca25 	.word	0x0082ca25
  400814:	20000085 	.word	0x20000085

00400818 <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  400818:	b538      	push	{r3, r4, r5, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  40081a:	4d08      	ldr	r5, [pc, #32]	; (40083c <sd_mmc_cmd9_mci+0x24>)
  40081c:	4a08      	ldr	r2, [pc, #32]	; (400840 <sd_mmc_cmd9_mci+0x28>)
  40081e:	682b      	ldr	r3, [r5, #0]
  400820:	8999      	ldrh	r1, [r3, #12]
  400822:	f641 3009 	movw	r0, #6921	; 0x1b09
  400826:	0409      	lsls	r1, r1, #16
  400828:	4790      	blx	r2
  40082a:	4604      	mov	r4, r0
  40082c:	b118      	cbz	r0, 400836 <sd_mmc_cmd9_mci+0x1e>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  40082e:	6828      	ldr	r0, [r5, #0]
  400830:	4b04      	ldr	r3, [pc, #16]	; (400844 <sd_mmc_cmd9_mci+0x2c>)
  400832:	3012      	adds	r0, #18
  400834:	4798      	blx	r3
	return true;
}
  400836:	4620      	mov	r0, r4
  400838:	bd38      	pop	{r3, r4, r5, pc}
  40083a:	bf00      	nop
  40083c:	20000e24 	.word	0x20000e24
  400840:	00401605 	.word	0x00401605
  400844:	00401639 	.word	0x00401639

00400848 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  400848:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  40084a:	4804      	ldr	r0, [pc, #16]	; (40085c <sd_mmc_init+0x14>)
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  40084c:	4a04      	ldr	r2, [pc, #16]	; (400860 <sd_mmc_init+0x18>)
	driver_init();
  40084e:	4b05      	ldr	r3, [pc, #20]	; (400864 <sd_mmc_init+0x1c>)
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400850:	2404      	movs	r4, #4
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400852:	21ff      	movs	r1, #255	; 0xff
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400854:	7384      	strb	r4, [r0, #14]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400856:	7011      	strb	r1, [r2, #0]
	driver_init();
  400858:	4798      	blx	r3
  40085a:	bd10      	pop	{r4, pc}
  40085c:	20000090 	.word	0x20000090
  400860:	20000e2a 	.word	0x20000e2a
  400864:	00401529 	.word	0x00401529

00400868 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  400868:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40086c:	4605      	mov	r5, r0
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  40086e:	b095      	sub	sp, #84	; 0x54
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400870:	2800      	cmp	r0, #0
  400872:	f000 80ea 	beq.w	400a4a <sd_mmc_check+0x1e2>
		return SD_MMC_ERR_SLOT;
  400876:	2404      	movs	r4, #4
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400878:	4b9e      	ldr	r3, [pc, #632]	; (400af4 <sd_mmc_check+0x28c>)
  40087a:	7818      	ldrb	r0, [r3, #0]
  40087c:	2800      	cmp	r0, #0
  40087e:	f000 80de 	beq.w	400a3e <sd_mmc_check+0x1d6>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  400882:	4620      	mov	r0, r4
  400884:	b015      	add	sp, #84	; 0x54
  400886:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  40088a:	f245 5008 	movw	r0, #21768	; 0x5508
  40088e:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  400892:	47b0      	blx	r6
  400894:	2800      	cmp	r0, #0
  400896:	f040 80f7 	bne.w	400a88 <sd_mmc_check+0x220>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  40089a:	f04f 0900 	mov.w	r9, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40089e:	683b      	ldr	r3, [r7, #0]
  4008a0:	7bdb      	ldrb	r3, [r3, #15]
  4008a2:	07da      	lsls	r2, r3, #31
  4008a4:	f100 80fc 	bmi.w	400aa0 <sd_mmc_check+0x238>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  4008a8:	f245 1003 	movw	r0, #20739	; 0x5103
  4008ac:	2100      	movs	r1, #0
  4008ae:	47b0      	blx	r6
  4008b0:	2800      	cmp	r0, #0
  4008b2:	f000 80e0 	beq.w	400a76 <sd_mmc_check+0x20e>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  4008b6:	f8df 9274 	ldr.w	r9, [pc, #628]	; 400b2c <sd_mmc_check+0x2c4>
  4008ba:	683d      	ldr	r5, [r7, #0]
  4008bc:	f8df a268 	ldr.w	sl, [pc, #616]	; 400b28 <sd_mmc_check+0x2c0>
  4008c0:	47c8      	blx	r9

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4008c2:	683b      	ldr	r3, [r7, #0]
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  4008c4:	0c00      	lsrs	r0, r0, #16
  4008c6:	81a8      	strh	r0, [r5, #12]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4008c8:	7bda      	ldrb	r2, [r3, #15]
  4008ca:	07d5      	lsls	r5, r2, #31
  4008cc:	d53a      	bpl.n	400944 <sd_mmc_check+0xdc>
		if (!sd_mmc_cmd9_mci()) {
  4008ce:	4b8a      	ldr	r3, [pc, #552]	; (400af8 <sd_mmc_check+0x290>)
  4008d0:	4798      	blx	r3
  4008d2:	2800      	cmp	r0, #0
  4008d4:	f000 80cf 	beq.w	400a76 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  4008d8:	f8da 3000 	ldr.w	r3, [sl]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  4008dc:	4d87      	ldr	r5, [pc, #540]	; (400afc <sd_mmc_check+0x294>)
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4008de:	7d5a      	ldrb	r2, [r3, #21]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  4008e0:	4887      	ldr	r0, [pc, #540]	; (400b00 <sd_mmc_check+0x298>)
  4008e2:	7c99      	ldrb	r1, [r3, #18]
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  4008e4:	f002 0e07 	and.w	lr, r2, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  4008e8:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  4008ec:	f855 502e 	ldr.w	r5, [r5, lr, lsl #2]
  4008f0:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  4008f4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4008f8:	fb02 f205 	mul.w	r2, r2, r5
  4008fc:	fb00 f202 	mul.w	r2, r0, r2
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400900:	0989      	lsrs	r1, r1, #6

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400902:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400904:	f040 8179 	bne.w	400bfa <sd_mmc_check+0x392>
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400908:	7e58      	ldrb	r0, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40090a:	f893 c018 	ldrb.w	ip, [r3, #24]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40090e:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400910:	f893 e01a 	ldrb.w	lr, [r3, #26]
  400914:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400916:	7dda      	ldrb	r2, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400918:	0080      	lsls	r0, r0, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40091a:	ea40 208c 	orr.w	r0, r0, ip, lsl #10
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40091e:	0049      	lsls	r1, r1, #1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400920:	ea40 109e 	orr.w	r0, r0, lr, lsr #6
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400924:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400928:	f3c0 000b 	ubfx	r0, r0, #0, #12
  40092c:	f001 0107 	and.w	r1, r1, #7
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400930:	3001      	adds	r0, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400932:	3102      	adds	r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400934:	fa00 f101 	lsl.w	r1, r0, r1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400938:	f002 020f 	and.w	r2, r2, #15
  40093c:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  400940:	0a92      	lsrs	r2, r2, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400942:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  400944:	8999      	ldrh	r1, [r3, #12]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400946:	4d6f      	ldr	r5, [pc, #444]	; (400b04 <sd_mmc_check+0x29c>)
  400948:	0409      	lsls	r1, r1, #16
  40094a:	f243 1007 	movw	r0, #12551	; 0x3107
  40094e:	47b0      	blx	r6
  400950:	2800      	cmp	r0, #0
  400952:	f000 8090 	beq.w	400a76 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400956:	683b      	ldr	r3, [r7, #0]
  400958:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 400b28 <sd_mmc_check+0x2c0>
  40095c:	7bda      	ldrb	r2, [r3, #15]
  40095e:	07d0      	lsls	r0, r2, #31
  400960:	d530      	bpl.n	4009c4 <sd_mmc_check+0x15c>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400962:	8999      	ldrh	r1, [r3, #12]
  400964:	f241 1037 	movw	r0, #4407	; 0x1137
  400968:	0409      	lsls	r1, r1, #16
  40096a:	47a8      	blx	r5
  40096c:	2800      	cmp	r0, #0
  40096e:	f000 8082 	beq.w	400a76 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  400972:	2501      	movs	r5, #1
  400974:	9500      	str	r5, [sp, #0]
  400976:	462b      	mov	r3, r5
  400978:	4863      	ldr	r0, [pc, #396]	; (400b08 <sd_mmc_check+0x2a0>)
  40097a:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 400b34 <sd_mmc_check+0x2cc>
  40097e:	2100      	movs	r1, #0
  400980:	2208      	movs	r2, #8
  400982:	47e0      	blx	ip
  400984:	2800      	cmp	r0, #0
  400986:	d076      	beq.n	400a76 <sd_mmc_check+0x20e>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  400988:	4629      	mov	r1, r5
  40098a:	a804      	add	r0, sp, #16
  40098c:	4b5f      	ldr	r3, [pc, #380]	; (400b0c <sd_mmc_check+0x2a4>)
  40098e:	4798      	blx	r3
  400990:	2800      	cmp	r0, #0
  400992:	d070      	beq.n	400a76 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400994:	4b5e      	ldr	r3, [pc, #376]	; (400b10 <sd_mmc_check+0x2a8>)
  400996:	4798      	blx	r3
  400998:	2800      	cmp	r0, #0
  40099a:	d06c      	beq.n	400a76 <sd_mmc_check+0x20e>
  40099c:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  4009a0:	f003 030f 	and.w	r3, r3, #15
  4009a4:	2b01      	cmp	r3, #1
  4009a6:	f000 8223 	beq.w	400df0 <sd_mmc_check+0x588>
  4009aa:	f0c0 821c 	bcc.w	400de6 <sd_mmc_check+0x57e>
  4009ae:	2b02      	cmp	r3, #2
  4009b0:	f040 8219 	bne.w	400de6 <sd_mmc_check+0x57e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4009b4:	f89d 3012 	ldrb.w	r3, [sp, #18]
	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  4009b8:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  4009ba:	683b      	ldr	r3, [r7, #0]
  4009bc:	bf14      	ite	ne
  4009be:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  4009c0:	2220      	moveq	r2, #32
  4009c2:	741a      	strb	r2, [r3, #16]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  4009c4:	4d4b      	ldr	r5, [pc, #300]	; (400af4 <sd_mmc_check+0x28c>)
  4009c6:	4b53      	ldr	r3, [pc, #332]	; (400b14 <sd_mmc_check+0x2ac>)
  4009c8:	7828      	ldrb	r0, [r5, #0]
  4009ca:	4798      	blx	r3
  4009cc:	2803      	cmp	r0, #3
  4009ce:	d91a      	bls.n	400a06 <sd_mmc_check+0x19e>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  4009d0:	683b      	ldr	r3, [r7, #0]
  4009d2:	f8df a154 	ldr.w	sl, [pc, #340]	; 400b28 <sd_mmc_check+0x2c0>
  4009d6:	7bda      	ldrb	r2, [r3, #15]
  4009d8:	07d1      	lsls	r1, r2, #31
  4009da:	d512      	bpl.n	400a02 <sd_mmc_check+0x19a>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  4009dc:	8999      	ldrh	r1, [r3, #12]
  4009de:	f8df b124 	ldr.w	fp, [pc, #292]	; 400b04 <sd_mmc_check+0x29c>
  4009e2:	0409      	lsls	r1, r1, #16
  4009e4:	f241 1037 	movw	r0, #4407	; 0x1137
  4009e8:	47b0      	blx	r6
  4009ea:	2800      	cmp	r0, #0
  4009ec:	d044      	beq.n	400a78 <sd_mmc_check+0x210>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  4009ee:	f241 1006 	movw	r0, #4358	; 0x1106
  4009f2:	2102      	movs	r1, #2
  4009f4:	47d8      	blx	fp
  4009f6:	2800      	cmp	r0, #0
  4009f8:	d03e      	beq.n	400a78 <sd_mmc_check+0x210>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  4009fa:	f8da 3000 	ldr.w	r3, [sl]
  4009fe:	2204      	movs	r2, #4
  400a00:	745a      	strb	r2, [r3, #17]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  400a02:	4b45      	ldr	r3, [pc, #276]	; (400b18 <sd_mmc_check+0x2b0>)
  400a04:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  400a06:	4b45      	ldr	r3, [pc, #276]	; (400b1c <sd_mmc_check+0x2b4>)
  400a08:	4798      	blx	r3
  400a0a:	b158      	cbz	r0, 400a24 <sd_mmc_check+0x1bc>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400a0c:	683b      	ldr	r3, [r7, #0]
  400a0e:	f8df b118 	ldr.w	fp, [pc, #280]	; 400b28 <sd_mmc_check+0x2c0>
  400a12:	7bda      	ldrb	r2, [r3, #15]
  400a14:	07d2      	lsls	r2, r2, #31
  400a16:	d503      	bpl.n	400a20 <sd_mmc_check+0x1b8>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  400a18:	7c1b      	ldrb	r3, [r3, #16]
  400a1a:	2b10      	cmp	r3, #16
  400a1c:	f200 80fa 	bhi.w	400c14 <sd_mmc_check+0x3ac>
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  400a20:	4b3d      	ldr	r3, [pc, #244]	; (400b18 <sd_mmc_check+0x2b0>)
  400a22:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400a24:	683a      	ldr	r2, [r7, #0]
  400a26:	f8df 8100 	ldr.w	r8, [pc, #256]	; 400b28 <sd_mmc_check+0x2c0>
  400a2a:	7bd3      	ldrb	r3, [r2, #15]
  400a2c:	07d9      	lsls	r1, r3, #31
  400a2e:	f100 80d9 	bmi.w	400be4 <sd_mmc_check+0x37c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400a32:	7828      	ldrb	r0, [r5, #0]
	//if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			//: sd_mmc_mci_card_init())
	if(sd_mmc_mci_card_init()) 
	{
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  400a34:	2300      	movs	r3, #0
  400a36:	7393      	strb	r3, [r2, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400a38:	2800      	cmp	r0, #0
  400a3a:	f47f af22 	bne.w	400882 <sd_mmc_check+0x1a>
		driver_deselect_device(sd_mmc_slot_sel);
  400a3e:	4b38      	ldr	r3, [pc, #224]	; (400b20 <sd_mmc_check+0x2b8>)
  400a40:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  400a42:	4620      	mov	r0, r4
  400a44:	b015      	add	sp, #84	; 0x54
  400a46:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400a4a:	4b36      	ldr	r3, [pc, #216]	; (400b24 <sd_mmc_check+0x2bc>)
  400a4c:	4798      	blx	r3
sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  400a4e:	2801      	cmp	r0, #1
  400a50:	4604      	mov	r4, r0
  400a52:	f47f af11 	bne.w	400878 <sd_mmc_check+0x10>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  400a56:	4f34      	ldr	r7, [pc, #208]	; (400b28 <sd_mmc_check+0x2c0>)
	sd_mmc_card->version = CARD_VER_UNKNOWN;
	sd_mmc_card->rca = 0;
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  400a58:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 400b38 <sd_mmc_check+0x2d0>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  400a5c:	683b      	ldr	r3, [r7, #0]

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400a5e:	4e29      	ldr	r6, [pc, #164]	; (400b04 <sd_mmc_check+0x29c>)
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  400a60:	73d8      	strb	r0, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  400a62:	741d      	strb	r5, [r3, #16]
	sd_mmc_card->rca = 0;
  400a64:	819d      	strh	r5, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  400a66:	47c0      	blx	r8

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400a68:	4629      	mov	r1, r5
  400a6a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  400a6e:	47b0      	blx	r6
  400a70:	2800      	cmp	r0, #0
  400a72:	f47f af0a 	bne.w	40088a <sd_mmc_check+0x22>
  400a76:	4d1f      	ldr	r5, [pc, #124]	; (400af4 <sd_mmc_check+0x28c>)
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  400a78:	683b      	ldr	r3, [r7, #0]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400a7a:	7828      	ldrb	r0, [r5, #0]
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  400a7c:	2403      	movs	r4, #3
  400a7e:	739c      	strb	r4, [r3, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400a80:	2800      	cmp	r0, #0
  400a82:	f47f aefe 	bne.w	400882 <sd_mmc_check+0x1a>
  400a86:	e7da      	b.n	400a3e <sd_mmc_check+0x1d6>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  400a88:	4b28      	ldr	r3, [pc, #160]	; (400b2c <sd_mmc_check+0x2c4>)
  400a8a:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  400a8c:	1c45      	adds	r5, r0, #1
  400a8e:	f43f af04 	beq.w	40089a <sd_mmc_check+0x32>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  400a92:	f3c0 000b 	ubfx	r0, r0, #0, #12
  400a96:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  400a9a:	d1ec      	bne.n	400a76 <sd_mmc_check+0x20e>
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  400a9c:	46a1      	mov	r9, r4
  400a9e:	e6fe      	b.n	40089e <sd_mmc_check+0x36>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400aa0:	f640 0535 	movw	r5, #2101	; 0x835
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400aa4:	f8df a088 	ldr.w	sl, [pc, #136]	; 400b30 <sd_mmc_check+0x2c8>
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400aa8:	f8df b080 	ldr.w	fp, [pc, #128]	; 400b2c <sd_mmc_check+0x2c4>
  400aac:	e00e      	b.n	400acc <sd_mmc_check+0x264>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  400aae:	f1b9 0f00 	cmp.w	r9, #0
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  400ab2:	bf14      	ite	ne
  400ab4:	4651      	movne	r1, sl
  400ab6:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  400aba:	f244 5029 	movw	r0, #17705	; 0x4529
  400abe:	47b0      	blx	r6
  400ac0:	b150      	cbz	r0, 400ad8 <sd_mmc_check+0x270>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  400ac2:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  400ac4:	2800      	cmp	r0, #0
  400ac6:	db78      	blt.n	400bba <sd_mmc_check+0x352>
			if ((resp & OCR_CCS) != 0) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  400ac8:	3d01      	subs	r5, #1
  400aca:	d005      	beq.n	400ad8 <sd_mmc_check+0x270>
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  400acc:	f241 1037 	movw	r0, #4407	; 0x1137
  400ad0:	2100      	movs	r1, #0
  400ad2:	47b0      	blx	r6
  400ad4:	2800      	cmp	r0, #0
  400ad6:	d1ea      	bne.n	400aae <sd_mmc_check+0x246>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  400ad8:	683b      	ldr	r3, [r7, #0]
  400ada:	2202      	movs	r2, #2
  400adc:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  400ade:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  400ae2:	2100      	movs	r1, #0
  400ae4:	47b0      	blx	r6
  400ae6:	2800      	cmp	r0, #0
  400ae8:	d0c5      	beq.n	400a76 <sd_mmc_check+0x20e>
  400aea:	f241 0569 	movw	r5, #4201	; 0x1069
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  400aee:	f8df 803c 	ldr.w	r8, [pc, #60]	; 400b2c <sd_mmc_check+0x2c4>
  400af2:	e025      	b.n	400b40 <sd_mmc_check+0x2d8>
  400af4:	20000e2a 	.word	0x20000e2a
  400af8:	00400819 	.word	0x00400819
  400afc:	004052f4 	.word	0x004052f4
  400b00:	004052b4 	.word	0x004052b4
  400b04:	00401605 	.word	0x00401605
  400b08:	00081133 	.word	0x00081133
  400b0c:	004017b1 	.word	0x004017b1
  400b10:	00401819 	.word	0x00401819
  400b14:	00401551 	.word	0x00401551
  400b18:	004006ed 	.word	0x004006ed
  400b1c:	0040155d 	.word	0x0040155d
  400b20:	004015e1 	.word	0x004015e1
  400b24:	00400719 	.word	0x00400719
  400b28:	20000e24 	.word	0x20000e24
  400b2c:	00401631 	.word	0x00401631
  400b30:	401f8000 	.word	0x401f8000
  400b34:	0040165d 	.word	0x0040165d
  400b38:	004015e5 	.word	0x004015e5
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  400b3c:	3d01      	subs	r5, #1
  400b3e:	d09a      	beq.n	400a76 <sd_mmc_check+0x20e>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400b40:	49af      	ldr	r1, [pc, #700]	; (400e00 <sd_mmc_check+0x598>)
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  400b42:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 400e40 <sd_mmc_check+0x5d8>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  400b46:	f244 5001 	movw	r0, #17665	; 0x4501
  400b4a:	47b0      	blx	r6
  400b4c:	2800      	cmp	r0, #0
  400b4e:	d092      	beq.n	400a76 <sd_mmc_check+0x20e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  400b50:	47c0      	blx	r8
		if (resp & OCR_POWER_UP_BUSY) {
  400b52:	2800      	cmp	r0, #0
  400b54:	daf2      	bge.n	400b3c <sd_mmc_check+0x2d4>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  400b56:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  400b5a:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  400b5e:	d104      	bne.n	400b6a <sd_mmc_check+0x302>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  400b60:	683b      	ldr	r3, [r7, #0]
  400b62:	7bda      	ldrb	r2, [r3, #15]
  400b64:	f042 0208 	orr.w	r2, r2, #8
  400b68:	73da      	strb	r2, [r3, #15]
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  400b6a:	f645 3002 	movw	r0, #23298	; 0x5b02
  400b6e:	2100      	movs	r1, #0
  400b70:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 400e44 <sd_mmc_check+0x5dc>
  400b74:	47b0      	blx	r6
  400b76:	2800      	cmp	r0, #0
  400b78:	f43f af7d 	beq.w	400a76 <sd_mmc_check+0x20e>
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  400b7c:	683b      	ldr	r3, [r7, #0]
  400b7e:	4da1      	ldr	r5, [pc, #644]	; (400e04 <sd_mmc_check+0x59c>)
  400b80:	2201      	movs	r2, #1
  400b82:	819a      	strh	r2, [r3, #12]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  400b84:	f241 1003 	movw	r0, #4355	; 0x1103
  400b88:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  400b8c:	47c0      	blx	r8
  400b8e:	2800      	cmp	r0, #0
  400b90:	f43f af71 	beq.w	400a76 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  400b94:	4b9c      	ldr	r3, [pc, #624]	; (400e08 <sd_mmc_check+0x5a0>)
  400b96:	4798      	blx	r3
  400b98:	2800      	cmp	r0, #0
  400b9a:	f43f af6c 	beq.w	400a76 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  400b9e:	682b      	ldr	r3, [r5, #0]
  400ba0:	7c9a      	ldrb	r2, [r3, #18]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400ba2:	f3c2 0283 	ubfx	r2, r2, #2, #4
  400ba6:	3a01      	subs	r2, #1
  400ba8:	2a03      	cmp	r2, #3
  400baa:	f200 817c 	bhi.w	400ea6 <sd_mmc_check+0x63e>
  400bae:	e8df f012 	tbh	[pc, r2, lsl #1]
  400bb2:	0177      	.short	0x0177
  400bb4:	0124017d 	.word	0x0124017d
  400bb8:	0068      	.short	0x0068
			return false;
		}
		resp = driver_get_response();
		if (resp & OCR_POWER_UP_BUSY) {
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  400bba:	0041      	lsls	r1, r0, #1
  400bbc:	d50f      	bpl.n	400bde <sd_mmc_check+0x376>
				sd_mmc_card->type |= CARD_TYPE_HC;
  400bbe:	683a      	ldr	r2, [r7, #0]
  400bc0:	7bd3      	ldrb	r3, [r2, #15]
  400bc2:	f043 0308 	orr.w	r3, r3, #8
  400bc6:	73d3      	strb	r3, [r2, #15]
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400bc8:	07db      	lsls	r3, r3, #31
  400bca:	f57f ae6d 	bpl.w	4008a8 <sd_mmc_check+0x40>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  400bce:	f645 3002 	movw	r0, #23298	; 0x5b02
  400bd2:	2100      	movs	r1, #0
  400bd4:	47b0      	blx	r6
  400bd6:	2800      	cmp	r0, #0
  400bd8:	f47f ae66 	bne.w	4008a8 <sd_mmc_check+0x40>
  400bdc:	e74b      	b.n	400a76 <sd_mmc_check+0x20e>
  400bde:	683b      	ldr	r3, [r7, #0]
  400be0:	7bdb      	ldrb	r3, [r3, #15]
  400be2:	e7f1      	b.n	400bc8 <sd_mmc_check+0x360>
		// Valid new configuration
		sd_mmc_configure_slot();
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400be4:	f241 1010 	movw	r0, #4368	; 0x1110
  400be8:	f44f 7100 	mov.w	r1, #512	; 0x200
  400bec:	47b0      	blx	r6
  400bee:	2800      	cmp	r0, #0
  400bf0:	f43f af42 	beq.w	400a78 <sd_mmc_check+0x210>
  400bf4:	f8d8 2000 	ldr.w	r2, [r8]
  400bf8:	e71b      	b.n	400a32 <sd_mmc_check+0x1ca>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400bfa:	7e59      	ldrb	r1, [r3, #25]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400bfc:	7e98      	ldrb	r0, [r3, #26]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400bfe:	7eda      	ldrb	r2, [r3, #27]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400c00:	0409      	lsls	r1, r1, #16
  400c02:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400c06:	430a      	orrs	r2, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  400c08:	f3c2 0215 	ubfx	r2, r2, #0, #22
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  400c0c:	3201      	adds	r2, #1
  400c0e:	0252      	lsls	r2, r2, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  400c10:	605a      	str	r2, [r3, #4]
  400c12:	e697      	b.n	400944 <sd_mmc_check+0xdc>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  400c14:	f04f 0a01 	mov.w	sl, #1
  400c18:	f8cd a000 	str.w	sl, [sp]
  400c1c:	4653      	mov	r3, sl
  400c1e:	487b      	ldr	r0, [pc, #492]	; (400e0c <sd_mmc_check+0x5a4>)
  400c20:	497b      	ldr	r1, [pc, #492]	; (400e10 <sd_mmc_check+0x5a8>)
  400c22:	f8df c204 	ldr.w	ip, [pc, #516]	; 400e28 <sd_mmc_check+0x5c0>
  400c26:	2240      	movs	r2, #64	; 0x40
  400c28:	47e0      	blx	ip
  400c2a:	2800      	cmp	r0, #0
  400c2c:	f43f af24 	beq.w	400a78 <sd_mmc_check+0x210>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  400c30:	a804      	add	r0, sp, #16
  400c32:	4651      	mov	r1, sl
  400c34:	4b77      	ldr	r3, [pc, #476]	; (400e14 <sd_mmc_check+0x5ac>)
  400c36:	4798      	blx	r3
  400c38:	2800      	cmp	r0, #0
  400c3a:	f43f af1d 	beq.w	400a78 <sd_mmc_check+0x210>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400c3e:	4b76      	ldr	r3, [pc, #472]	; (400e18 <sd_mmc_check+0x5b0>)
  400c40:	4798      	blx	r3
  400c42:	2800      	cmp	r0, #0
  400c44:	f43f af18 	beq.w	400a78 <sd_mmc_check+0x210>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400c48:	47c8      	blx	r9
  400c4a:	0600      	lsls	r0, r0, #24
  400c4c:	f53f af14 	bmi.w	400a78 <sd_mmc_check+0x210>
  400c50:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  400c54:	f003 030f 	and.w	r3, r3, #15
  400c58:	2b0f      	cmp	r3, #15
  400c5a:	f43f aee1 	beq.w	400a20 <sd_mmc_check+0x1b8>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400c5e:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400c62:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  400c66:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  400c6a:	f47f af05 	bne.w	400a78 <sd_mmc_check+0x210>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  400c6e:	47c0      	blx	r8
	sd_mmc_card->high_speed = 1;
  400c70:	f8db 3000 	ldr.w	r3, [fp]
	sd_mmc_card->clock *= 2;
  400c74:	681a      	ldr	r2, [r3, #0]
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
	sd_mmc_card->high_speed = 1;
  400c76:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
	sd_mmc_card->clock *= 2;
  400c7a:	fa02 f20a 	lsl.w	r2, r2, sl
  400c7e:	601a      	str	r2, [r3, #0]
  400c80:	e6ce      	b.n	400a20 <sd_mmc_check+0x1b8>
	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  400c82:	2240      	movs	r2, #64	; 0x40
  400c84:	741a      	strb	r2, [r3, #16]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400c86:	7d5a      	ldrb	r2, [r3, #21]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400c88:	f893 e019 	ldrb.w	lr, [r3, #25]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400c8c:	4963      	ldr	r1, [pc, #396]	; (400e1c <sd_mmc_check+0x5b4>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  400c8e:	4864      	ldr	r0, [pc, #400]	; (400e20 <sd_mmc_check+0x5b8>)
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400c90:	f893 c018 	ldrb.w	ip, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400c94:	7e9d      	ldrb	r5, [r3, #26]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400c96:	f002 0807 	and.w	r8, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  400c9a:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400c9e:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  400ca2:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400ca6:	ea4f 028e 	mov.w	r2, lr, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400caa:	ea42 228c 	orr.w	r2, r2, ip, lsl #10
  400cae:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
  400cb2:	fb0e f101 	mul.w	r1, lr, r1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400cb6:	ea42 1295 	orr.w	r2, r2, r5, lsr #6
  400cba:	fb00 f001 	mul.w	r0, r0, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  400cbe:	f3c2 020b 	ubfx	r2, r2, #0, #12
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  400cc2:	f640 71ff 	movw	r1, #4095	; 0xfff
  400cc6:	428a      	cmp	r2, r1

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400cc8:	6018      	str	r0, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  400cca:	d011      	beq.n	400cf0 <sd_mmc_check+0x488>
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400ccc:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400cce:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400cd0:	7dd8      	ldrb	r0, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400cd2:	0049      	lsls	r1, r1, #1
  400cd4:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400cd8:	f001 0107 	and.w	r1, r1, #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  400cdc:	3201      	adds	r2, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400cde:	3102      	adds	r1, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  400ce0:	fa02 f101 	lsl.w	r1, r2, r1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400ce4:	f000 020f 	and.w	r2, r0, #15
  400ce8:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  400cec:	0a92      	lsrs	r2, r2, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400cee:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  400cf0:	8999      	ldrh	r1, [r3, #12]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400cf2:	f243 1007 	movw	r0, #12551	; 0x3107
  400cf6:	0409      	lsls	r1, r1, #16
  400cf8:	47b0      	blx	r6
  400cfa:	2800      	cmp	r0, #0
  400cfc:	f43f aebb 	beq.w	400a76 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  400d00:	683b      	ldr	r3, [r7, #0]
  400d02:	7c1b      	ldrb	r3, [r3, #16]
  400d04:	2b3f      	cmp	r3, #63	; 0x3f
  400d06:	f240 80b1 	bls.w	400e6c <sd_mmc_check+0x604>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  400d0a:	2100      	movs	r1, #0
  400d0c:	9100      	str	r1, [sp, #0]
  400d0e:	4845      	ldr	r0, [pc, #276]	; (400e24 <sd_mmc_check+0x5bc>)
  400d10:	4d45      	ldr	r5, [pc, #276]	; (400e28 <sd_mmc_check+0x5c0>)
  400d12:	f44f 7200 	mov.w	r2, #512	; 0x200
  400d16:	2301      	movs	r3, #1
  400d18:	47a8      	blx	r5
  400d1a:	2800      	cmp	r0, #0
  400d1c:	f43f aeab 	beq.w	400a76 <sd_mmc_check+0x20e>
  400d20:	f8df 8124 	ldr.w	r8, [pc, #292]	; 400e48 <sd_mmc_check+0x5e0>
  400d24:	2532      	movs	r5, #50	; 0x32
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  400d26:	a803      	add	r0, sp, #12
  400d28:	47c0      	blx	r8
  400d2a:	3d01      	subs	r5, #1
  400d2c:	b2ad      	uxth	r5, r5
  400d2e:	2800      	cmp	r0, #0
  400d30:	f43f aea1 	beq.w	400a76 <sd_mmc_check+0x20e>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  400d34:	2d00      	cmp	r5, #0
  400d36:	d1f6      	bne.n	400d26 <sd_mmc_check+0x4be>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400d38:	683b      	ldr	r3, [r7, #0]
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400d3a:	9a03      	ldr	r2, [sp, #12]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400d3c:	7e5d      	ldrb	r5, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400d3e:	7e18      	ldrb	r0, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400d40:	7e99      	ldrb	r1, [r3, #26]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400d42:	00ab      	lsls	r3, r5, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400d44:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400d48:	ea43 1191 	orr.w	r1, r3, r1, lsr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  400d4c:	f3c1 010b 	ubfx	r1, r1, #0, #12
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400d50:	f640 73ff 	movw	r3, #4095	; 0xfff
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400d54:	f002 0202 	and.w	r2, r2, #2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400d58:	4299      	cmp	r1, r3
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  400d5a:	fa5f fa82 	uxtb.w	sl, r2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  400d5e:	f04f 0532 	mov.w	r5, #50	; 0x32
  400d62:	f10d 0b10 	add.w	fp, sp, #16
  400d66:	d073      	beq.n	400e50 <sd_mmc_check+0x5e8>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  400d68:	4658      	mov	r0, fp
  400d6a:	47c0      	blx	r8
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400d6c:	3501      	adds	r5, #1
  400d6e:	b2ad      	uxth	r5, r5
		if (!driver_read_word(&sec_count)) {
  400d70:	2800      	cmp	r0, #0
  400d72:	f43f ae80 	beq.w	400a76 <sd_mmc_check+0x20e>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  400d76:	2d7f      	cmp	r5, #127	; 0x7f
  400d78:	d9f6      	bls.n	400d68 <sd_mmc_check+0x500>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  400d7a:	4d2c      	ldr	r5, [pc, #176]	; (400e2c <sd_mmc_check+0x5c4>)
  400d7c:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 400e4c <sd_mmc_check+0x5e4>
  400d80:	7828      	ldrb	r0, [r5, #0]
  400d82:	47c0      	blx	r8
  400d84:	2803      	cmp	r0, #3
  400d86:	d918      	bls.n	400dba <sd_mmc_check+0x552>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  400d88:	7828      	ldrb	r0, [r5, #0]
  400d8a:	47c0      	blx	r8
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  400d8c:	2804      	cmp	r0, #4
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  400d8e:	4680      	mov	r8, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  400d90:	d070      	beq.n	400e74 <sd_mmc_check+0x60c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400d92:	4927      	ldr	r1, [pc, #156]	; (400e30 <sd_mmc_check+0x5c8>)
  400d94:	4b27      	ldr	r3, [pc, #156]	; (400e34 <sd_mmc_check+0x5cc>)
  400d96:	2808      	cmp	r0, #8
  400d98:	bf18      	it	ne
  400d9a:	4619      	movne	r1, r3
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  400d9c:	f243 1006 	movw	r0, #12550	; 0x3106
  400da0:	47b0      	blx	r6
  400da2:	2800      	cmp	r0, #0
  400da4:	f43f ae68 	beq.w	400a78 <sd_mmc_check+0x210>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400da8:	47c8      	blx	r9
  400daa:	0602      	lsls	r2, r0, #24
  400dac:	f53f ae64 	bmi.w	400a78 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  400db0:	683b      	ldr	r3, [r7, #0]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  400db2:	4a21      	ldr	r2, [pc, #132]	; (400e38 <sd_mmc_check+0x5d0>)
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  400db4:	f883 8011 	strb.w	r8, [r3, #17]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  400db8:	4790      	blx	r2
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  400dba:	4b20      	ldr	r3, [pc, #128]	; (400e3c <sd_mmc_check+0x5d4>)
  400dbc:	4798      	blx	r3
  400dbe:	b110      	cbz	r0, 400dc6 <sd_mmc_check+0x55e>
  400dc0:	f1ba 0f00 	cmp.w	sl, #0
  400dc4:	d158      	bne.n	400e78 <sd_mmc_check+0x610>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400dc6:	f04f 080a 	mov.w	r8, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  400dca:	f241 1010 	movw	r0, #4368	; 0x1110
  400dce:	f44f 7100 	mov.w	r1, #512	; 0x200
  400dd2:	47b0      	blx	r6
  400dd4:	f108 38ff 	add.w	r8, r8, #4294967295
  400dd8:	2800      	cmp	r0, #0
  400dda:	d16a      	bne.n	400eb2 <sd_mmc_check+0x64a>
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  400ddc:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
  400de0:	f43f ae4a 	beq.w	400a78 <sd_mmc_check+0x210>
  400de4:	e7f1      	b.n	400dca <sd_mmc_check+0x562>
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  400de6:	f8da 3000 	ldr.w	r3, [sl]
  400dea:	2210      	movs	r2, #16
  400dec:	741a      	strb	r2, [r3, #16]
  400dee:	e5e9      	b.n	4009c4 <sd_mmc_check+0x15c>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  400df0:	f8da 3000 	ldr.w	r3, [sl]
  400df4:	221a      	movs	r2, #26
  400df6:	741a      	strb	r2, [r3, #16]
  400df8:	e5e4      	b.n	4009c4 <sd_mmc_check+0x15c>
	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  400dfa:	2230      	movs	r2, #48	; 0x30
  400dfc:	741a      	strb	r2, [r3, #16]
  400dfe:	e742      	b.n	400c86 <sd_mmc_check+0x41e>
  400e00:	401f8000 	.word	0x401f8000
  400e04:	20000e24 	.word	0x20000e24
  400e08:	00400819 	.word	0x00400819
  400e0c:	00081106 	.word	0x00081106
  400e10:	80ffff01 	.word	0x80ffff01
  400e14:	004017b1 	.word	0x004017b1
  400e18:	00401819 	.word	0x00401819
  400e1c:	004052f4 	.word	0x004052f4
  400e20:	00405310 	.word	0x00405310
  400e24:	00081108 	.word	0x00081108
  400e28:	0040165d 	.word	0x0040165d
  400e2c:	20000e2a 	.word	0x20000e2a
  400e30:	01b70200 	.word	0x01b70200
  400e34:	01b70000 	.word	0x01b70000
  400e38:	004006ed 	.word	0x004006ed
  400e3c:	0040155d 	.word	0x0040155d
  400e40:	00401631 	.word	0x00401631
  400e44:	00401605 	.word	0x00401605
  400e48:	0040170d 	.word	0x0040170d
  400e4c:	00401551 	.word	0x00401551

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  400e50:	4658      	mov	r0, fp
  400e52:	47c0      	blx	r8
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  400e54:	3501      	adds	r5, #1
  400e56:	b2ad      	uxth	r5, r5
			if (!driver_read_word(&sec_count)) {
  400e58:	2800      	cmp	r0, #0
  400e5a:	f43f ae0c 	beq.w	400a76 <sd_mmc_check+0x20e>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  400e5e:	2d36      	cmp	r5, #54	; 0x36
  400e60:	d1f6      	bne.n	400e50 <sd_mmc_check+0x5e8>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  400e62:	9a04      	ldr	r2, [sp, #16]
  400e64:	683b      	ldr	r3, [r7, #0]
  400e66:	0852      	lsrs	r2, r2, #1
  400e68:	605a      	str	r2, [r3, #4]
  400e6a:	e77d      	b.n	400d68 <sd_mmc_check+0x500>
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  400e6c:	4b12      	ldr	r3, [pc, #72]	; (400eb8 <sd_mmc_check+0x650>)
  400e6e:	4d13      	ldr	r5, [pc, #76]	; (400ebc <sd_mmc_check+0x654>)
  400e70:	4798      	blx	r3
  400e72:	e7a8      	b.n	400dc6 <sd_mmc_check+0x55e>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  400e74:	4912      	ldr	r1, [pc, #72]	; (400ec0 <sd_mmc_check+0x658>)
  400e76:	e791      	b.n	400d9c <sd_mmc_check+0x534>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  400e78:	f243 1006 	movw	r0, #12550	; 0x3106
  400e7c:	4911      	ldr	r1, [pc, #68]	; (400ec4 <sd_mmc_check+0x65c>)
  400e7e:	47b0      	blx	r6
  400e80:	2800      	cmp	r0, #0
  400e82:	f43f adf9 	beq.w	400a78 <sd_mmc_check+0x210>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  400e86:	47c8      	blx	r9
  400e88:	0603      	lsls	r3, r0, #24
  400e8a:	f53f adf5 	bmi.w	400a78 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400e8e:	683b      	ldr	r3, [r7, #0]
	sd_mmc_card->clock = 52000000lu;
  400e90:	4a0d      	ldr	r2, [pc, #52]	; (400ec8 <sd_mmc_check+0x660>)
  400e92:	601a      	str	r2, [r3, #0]
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  400e94:	2201      	movs	r2, #1
  400e96:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  400e9a:	4b07      	ldr	r3, [pc, #28]	; (400eb8 <sd_mmc_check+0x650>)
  400e9c:	4798      	blx	r3
  400e9e:	e792      	b.n	400dc6 <sd_mmc_check+0x55e>
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  400ea0:	2214      	movs	r2, #20
  400ea2:	741a      	strb	r2, [r3, #16]
  400ea4:	e6ef      	b.n	400c86 <sd_mmc_check+0x41e>

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  400ea6:	2212      	movs	r2, #18
  400ea8:	741a      	strb	r2, [r3, #16]
  400eaa:	e6ec      	b.n	400c86 <sd_mmc_check+0x41e>
	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  400eac:	2222      	movs	r2, #34	; 0x22
  400eae:	741a      	strb	r2, [r3, #16]
  400eb0:	e6e9      	b.n	400c86 <sd_mmc_check+0x41e>
  400eb2:	683a      	ldr	r2, [r7, #0]
  400eb4:	e5bd      	b.n	400a32 <sd_mmc_check+0x1ca>
  400eb6:	bf00      	nop
  400eb8:	004006ed 	.word	0x004006ed
  400ebc:	20000e2a 	.word	0x20000e2a
  400ec0:	01b70100 	.word	0x01b70100
  400ec4:	03b90100 	.word	0x03b90100
  400ec8:	03197500 	.word	0x03197500

00400ecc <sd_mmc_get_type>:
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
  400ecc:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400ece:	b108      	cbz	r0, 400ed4 <sd_mmc_get_type+0x8>
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  400ed0:	2000      	movs	r0, #0
  400ed2:	bd08      	pop	{r3, pc}
  400ed4:	4b08      	ldr	r3, [pc, #32]	; (400ef8 <sd_mmc_get_type+0x2c>)
  400ed6:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  400ed8:	2800      	cmp	r0, #0
  400eda:	d1f9      	bne.n	400ed0 <sd_mmc_get_type+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400edc:	4b07      	ldr	r3, [pc, #28]	; (400efc <sd_mmc_get_type+0x30>)
  400ede:	781b      	ldrb	r3, [r3, #0]
  400ee0:	b11b      	cbz	r3, 400eea <sd_mmc_get_type+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  400ee2:	4b07      	ldr	r3, [pc, #28]	; (400f00 <sd_mmc_get_type+0x34>)
  400ee4:	681b      	ldr	r3, [r3, #0]
  400ee6:	7bd8      	ldrb	r0, [r3, #15]
}
  400ee8:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  400eea:	4b06      	ldr	r3, [pc, #24]	; (400f04 <sd_mmc_get_type+0x38>)
  400eec:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  400eee:	4b04      	ldr	r3, [pc, #16]	; (400f00 <sd_mmc_get_type+0x34>)
  400ef0:	681b      	ldr	r3, [r3, #0]
  400ef2:	7bd8      	ldrb	r0, [r3, #15]
}
  400ef4:	bd08      	pop	{r3, pc}
  400ef6:	bf00      	nop
  400ef8:	00400719 	.word	0x00400719
  400efc:	20000e2a 	.word	0x20000e2a
  400f00:	20000e24 	.word	0x20000e24
  400f04:	004015e1 	.word	0x004015e1

00400f08 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  400f08:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400f0a:	b108      	cbz	r0, 400f10 <sd_mmc_get_capacity+0x8>
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  400f0c:	2000      	movs	r0, #0
  400f0e:	bd08      	pop	{r3, pc}
  400f10:	4b08      	ldr	r3, [pc, #32]	; (400f34 <sd_mmc_get_capacity+0x2c>)
  400f12:	4798      	blx	r3
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  400f14:	2800      	cmp	r0, #0
  400f16:	d1f9      	bne.n	400f0c <sd_mmc_get_capacity+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400f18:	4b07      	ldr	r3, [pc, #28]	; (400f38 <sd_mmc_get_capacity+0x30>)
  400f1a:	781b      	ldrb	r3, [r3, #0]
  400f1c:	b11b      	cbz	r3, 400f26 <sd_mmc_get_capacity+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  400f1e:	4b07      	ldr	r3, [pc, #28]	; (400f3c <sd_mmc_get_capacity+0x34>)
  400f20:	681b      	ldr	r3, [r3, #0]
  400f22:	6858      	ldr	r0, [r3, #4]
}
  400f24:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  400f26:	4b06      	ldr	r3, [pc, #24]	; (400f40 <sd_mmc_get_capacity+0x38>)
  400f28:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  400f2a:	4b04      	ldr	r3, [pc, #16]	; (400f3c <sd_mmc_get_capacity+0x34>)
  400f2c:	681b      	ldr	r3, [r3, #0]
  400f2e:	6858      	ldr	r0, [r3, #4]
}
  400f30:	bd08      	pop	{r3, pc}
  400f32:	bf00      	nop
  400f34:	00400719 	.word	0x00400719
  400f38:	20000e2a 	.word	0x20000e2a
  400f3c:	20000e24 	.word	0x20000e24
  400f40:	004015e1 	.word	0x004015e1

00400f44 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  400f44:	2000      	movs	r0, #0
  400f46:	4770      	bx	lr

00400f48 <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  400f48:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  400f4c:	468b      	mov	fp, r1
  400f4e:	b083      	sub	sp, #12
  400f50:	4692      	mov	sl, r2
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400f52:	b128      	cbz	r0, 400f60 <sd_mmc_init_read_blocks+0x18>
		return SD_MMC_ERR_SLOT;
  400f54:	f04f 0904 	mov.w	r9, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  400f58:	4648      	mov	r0, r9
  400f5a:	b003      	add	sp, #12
  400f5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400f60:	4b26      	ldr	r3, [pc, #152]	; (400ffc <sd_mmc_init_read_blocks+0xb4>)
  400f62:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  400f64:	4681      	mov	r9, r0
  400f66:	2800      	cmp	r0, #0
  400f68:	d1f6      	bne.n	400f58 <sd_mmc_init_read_blocks+0x10>
  400f6a:	4c25      	ldr	r4, [pc, #148]	; (401000 <sd_mmc_init_read_blocks+0xb8>)
  400f6c:	4d25      	ldr	r5, [pc, #148]	; (401004 <sd_mmc_init_read_blocks+0xbc>)
  400f6e:	4e26      	ldr	r6, [pc, #152]	; (401008 <sd_mmc_init_read_blocks+0xc0>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  400f70:	4f26      	ldr	r7, [pc, #152]	; (40100c <sd_mmc_init_read_blocks+0xc4>)
  400f72:	e004      	b.n	400f7e <sd_mmc_init_read_blocks+0x36>
  400f74:	47b8      	blx	r7
  400f76:	05c2      	lsls	r2, r0, #23
  400f78:	d414      	bmi.n	400fa4 <sd_mmc_init_read_blocks+0x5c>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  400f7a:	3c01      	subs	r4, #1
  400f7c:	d009      	beq.n	400f92 <sd_mmc_init_read_blocks+0x4a>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  400f7e:	682b      	ldr	r3, [r5, #0]
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  400f80:	f8df 8088 	ldr.w	r8, [pc, #136]	; 40100c <sd_mmc_init_read_blocks+0xc4>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  400f84:	8999      	ldrh	r1, [r3, #12]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  400f86:	f241 100d 	movw	r0, #4365	; 0x110d
  400f8a:	0409      	lsls	r1, r1, #16
  400f8c:	47b0      	blx	r6
  400f8e:	2800      	cmp	r0, #0
  400f90:	d1f0      	bne.n	400f74 <sd_mmc_init_read_blocks+0x2c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400f92:	4b1f      	ldr	r3, [pc, #124]	; (401010 <sd_mmc_init_read_blocks+0xc8>)
  400f94:	781b      	ldrb	r3, [r3, #0]
  400f96:	b33b      	cbz	r3, 400fe8 <sd_mmc_init_read_blocks+0xa0>
		arg = (start * SD_MMC_BLOCK_SIZE);
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  400f98:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  400f9c:	4648      	mov	r0, r9
  400f9e:	b003      	add	sp, #12
  400fa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  400fa4:	682b      	ldr	r3, [r5, #0]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  400fa6:	481b      	ldr	r0, [pc, #108]	; (401014 <sd_mmc_init_read_blocks+0xcc>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  400fa8:	7bdb      	ldrb	r3, [r3, #15]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  400faa:	4a1b      	ldr	r2, [pc, #108]	; (401018 <sd_mmc_init_read_blocks+0xd0>)
  400fac:	f1ba 0f01 	cmp.w	sl, #1
  400fb0:	bf98      	it	ls
  400fb2:	4610      	movls	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  400fb4:	071b      	lsls	r3, r3, #28
  400fb6:	d401      	bmi.n	400fbc <sd_mmc_init_read_blocks+0x74>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  400fb8:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  400fbc:	2301      	movs	r3, #1
  400fbe:	9300      	str	r3, [sp, #0]
  400fc0:	4659      	mov	r1, fp
  400fc2:	f44f 7200 	mov.w	r2, #512	; 0x200
  400fc6:	4653      	mov	r3, sl
  400fc8:	4c14      	ldr	r4, [pc, #80]	; (40101c <sd_mmc_init_read_blocks+0xd4>)
  400fca:	47a0      	blx	r4
  400fcc:	2800      	cmp	r0, #0
  400fce:	d0e0      	beq.n	400f92 <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  400fd0:	47c0      	blx	r8
		if (resp & CARD_STATUS_ERR_RD_WR) {
  400fd2:	4b13      	ldr	r3, [pc, #76]	; (401020 <sd_mmc_init_read_blocks+0xd8>)
  400fd4:	4003      	ands	r3, r0
  400fd6:	2b00      	cmp	r3, #0
  400fd8:	d1db      	bne.n	400f92 <sd_mmc_init_read_blocks+0x4a>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  400fda:	4a12      	ldr	r2, [pc, #72]	; (401024 <sd_mmc_init_read_blocks+0xdc>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  400fdc:	4b12      	ldr	r3, [pc, #72]	; (401028 <sd_mmc_init_read_blocks+0xe0>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  400fde:	f8a2 a000 	strh.w	sl, [r2]
	sd_mmc_nb_block_to_tranfer = nb_block;
  400fe2:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  400fe6:	e7b7      	b.n	400f58 <sd_mmc_init_read_blocks+0x10>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  400fe8:	2000      	movs	r0, #0
  400fea:	4b10      	ldr	r3, [pc, #64]	; (40102c <sd_mmc_init_read_blocks+0xe4>)
  400fec:	4798      	blx	r3
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  400fee:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  400ff2:	4648      	mov	r0, r9
  400ff4:	b003      	add	sp, #12
  400ff6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  400ffa:	bf00      	nop
  400ffc:	00400719 	.word	0x00400719
  401000:	00030d41 	.word	0x00030d41
  401004:	20000e24 	.word	0x20000e24
  401008:	00401605 	.word	0x00401605
  40100c:	00401631 	.word	0x00401631
  401010:	20000e2a 	.word	0x20000e2a
  401014:	00101112 	.word	0x00101112
  401018:	00081111 	.word	0x00081111
  40101c:	0040165d 	.word	0x0040165d
  401020:	e4580000 	.word	0xe4580000
  401024:	20000e28 	.word	0x20000e28
  401028:	20000e1e 	.word	0x20000e1e
  40102c:	004015e1 	.word	0x004015e1

00401030 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401030:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  401032:	4b07      	ldr	r3, [pc, #28]	; (401050 <sd_mmc_start_read_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401034:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  401036:	4798      	blx	r3
  401038:	4603      	mov	r3, r0
  40103a:	b918      	cbnz	r0, 401044 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  40103c:	4a05      	ldr	r2, [pc, #20]	; (401054 <sd_mmc_start_read_blocks+0x24>)
  40103e:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  401040:	2005      	movs	r0, #5
  401042:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401044:	4b03      	ldr	r3, [pc, #12]	; (401054 <sd_mmc_start_read_blocks+0x24>)
  401046:	881a      	ldrh	r2, [r3, #0]
  401048:	1b14      	subs	r4, r2, r4
  40104a:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  40104c:	2000      	movs	r0, #0
}
  40104e:	bd10      	pop	{r4, pc}
  401050:	004017b1 	.word	0x004017b1
  401054:	20000e28 	.word	0x20000e28

00401058 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  401058:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
  40105a:	4b12      	ldr	r3, [pc, #72]	; (4010a4 <sd_mmc_wait_end_of_read_blocks+0x4c>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  40105c:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  40105e:	4798      	blx	r3
  401060:	b908      	cbnz	r0, 401066 <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  401062:	2005      	movs	r0, #5
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  401064:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401066:	4b10      	ldr	r3, [pc, #64]	; (4010a8 <sd_mmc_wait_end_of_read_blocks+0x50>)
sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401068:	b99c      	cbnz	r4, 401092 <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  40106a:	881b      	ldrh	r3, [r3, #0]
  40106c:	b97b      	cbnz	r3, 40108e <sd_mmc_wait_end_of_read_blocks+0x36>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40106e:	4b0f      	ldr	r3, [pc, #60]	; (4010ac <sd_mmc_wait_end_of_read_blocks+0x54>)
  401070:	881b      	ldrh	r3, [r3, #0]
  401072:	2b01      	cmp	r3, #1
  401074:	d005      	beq.n	401082 <sd_mmc_wait_end_of_read_blocks+0x2a>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  401076:	f243 100c 	movw	r0, #12556	; 0x310c
  40107a:	2100      	movs	r1, #0
  40107c:	4c0c      	ldr	r4, [pc, #48]	; (4010b0 <sd_mmc_wait_end_of_read_blocks+0x58>)
  40107e:	47a0      	blx	r4
  401080:	b150      	cbz	r0, 401098 <sd_mmc_wait_end_of_read_blocks+0x40>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401082:	4b0c      	ldr	r3, [pc, #48]	; (4010b4 <sd_mmc_wait_end_of_read_blocks+0x5c>)
  401084:	781b      	ldrb	r3, [r3, #0]
  401086:	b913      	cbnz	r3, 40108e <sd_mmc_wait_end_of_read_blocks+0x36>
		driver_deselect_device(sd_mmc_slot_sel);
  401088:	2000      	movs	r0, #0
  40108a:	4b0b      	ldr	r3, [pc, #44]	; (4010b8 <sd_mmc_wait_end_of_read_blocks+0x60>)
  40108c:	4798      	blx	r3

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  40108e:	2000      	movs	r0, #0
  401090:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401092:	2200      	movs	r2, #0
  401094:	801a      	strh	r2, [r3, #0]
  401096:	e7ea      	b.n	40106e <sd_mmc_wait_end_of_read_blocks+0x16>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  401098:	4601      	mov	r1, r0
  40109a:	f243 100c 	movw	r0, #12556	; 0x310c
  40109e:	47a0      	blx	r4
  4010a0:	e7ef      	b.n	401082 <sd_mmc_wait_end_of_read_blocks+0x2a>
  4010a2:	bf00      	nop
  4010a4:	00401819 	.word	0x00401819
  4010a8:	20000e28 	.word	0x20000e28
  4010ac:	20000e1e 	.word	0x20000e1e
  4010b0:	00401605 	.word	0x00401605
  4010b4:	20000e2a 	.word	0x20000e2a
  4010b8:	004015e1 	.word	0x004015e1

004010bc <sd_mmc_init_write_blocks>:
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  4010bc:	b570      	push	{r4, r5, r6, lr}
  4010be:	4615      	mov	r5, r2
  4010c0:	b084      	sub	sp, #16
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4010c2:	b118      	cbz	r0, 4010cc <sd_mmc_init_write_blocks+0x10>
		return SD_MMC_ERR_SLOT;
  4010c4:	2404      	movs	r4, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4010c6:	4620      	mov	r0, r4
  4010c8:	b004      	add	sp, #16
  4010ca:	bd70      	pop	{r4, r5, r6, pc}
  4010cc:	9103      	str	r1, [sp, #12]
  4010ce:	4b18      	ldr	r3, [pc, #96]	; (401130 <sd_mmc_init_write_blocks+0x74>)
  4010d0:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  4010d2:	9903      	ldr	r1, [sp, #12]
  4010d4:	4604      	mov	r4, r0
  4010d6:	2800      	cmp	r0, #0
  4010d8:	d1f5      	bne.n	4010c6 <sd_mmc_init_write_blocks+0xa>
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4010da:	4b16      	ldr	r3, [pc, #88]	; (401134 <sd_mmc_init_write_blocks+0x78>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4010dc:	4a16      	ldr	r2, [pc, #88]	; (401138 <sd_mmc_init_write_blocks+0x7c>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4010de:	681b      	ldr	r3, [r3, #0]
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4010e0:	4816      	ldr	r0, [pc, #88]	; (40113c <sd_mmc_init_write_blocks+0x80>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4010e2:	7bdb      	ldrb	r3, [r3, #15]
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4010e4:	4e16      	ldr	r6, [pc, #88]	; (401140 <sd_mmc_init_write_blocks+0x84>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4010e6:	2d01      	cmp	r5, #1
  4010e8:	bf88      	it	hi
  4010ea:	4610      	movhi	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4010ec:	071b      	lsls	r3, r3, #28
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4010ee:	f04f 0301 	mov.w	r3, #1
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4010f2:	bf58      	it	pl
  4010f4:	0249      	lslpl	r1, r1, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4010f6:	9300      	str	r3, [sp, #0]
  4010f8:	f44f 7200 	mov.w	r2, #512	; 0x200
  4010fc:	462b      	mov	r3, r5
  4010fe:	47b0      	blx	r6
  401100:	b930      	cbnz	r0, 401110 <sd_mmc_init_write_blocks+0x54>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401102:	4b10      	ldr	r3, [pc, #64]	; (401144 <sd_mmc_init_write_blocks+0x88>)
  401104:	781b      	ldrb	r3, [r3, #0]
  401106:	b173      	cbz	r3, 401126 <sd_mmc_init_write_blocks+0x6a>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401108:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  40110a:	4620      	mov	r0, r4
  40110c:	b004      	add	sp, #16
  40110e:	bd70      	pop	{r4, r5, r6, pc}
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  401110:	4b0d      	ldr	r3, [pc, #52]	; (401148 <sd_mmc_init_write_blocks+0x8c>)
  401112:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  401114:	4b0d      	ldr	r3, [pc, #52]	; (40114c <sd_mmc_init_write_blocks+0x90>)
  401116:	4003      	ands	r3, r0
  401118:	2b00      	cmp	r3, #0
  40111a:	d1f2      	bne.n	401102 <sd_mmc_init_write_blocks+0x46>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40111c:	4a0c      	ldr	r2, [pc, #48]	; (401150 <sd_mmc_init_write_blocks+0x94>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  40111e:	4b0d      	ldr	r3, [pc, #52]	; (401154 <sd_mmc_init_write_blocks+0x98>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  401120:	8015      	strh	r5, [r2, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  401122:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  401124:	e7cf      	b.n	4010c6 <sd_mmc_init_write_blocks+0xa>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  401126:	2000      	movs	r0, #0
  401128:	4b0b      	ldr	r3, [pc, #44]	; (401158 <sd_mmc_init_write_blocks+0x9c>)
  40112a:	4798      	blx	r3
  40112c:	e7ec      	b.n	401108 <sd_mmc_init_write_blocks+0x4c>
  40112e:	bf00      	nop
  401130:	00400719 	.word	0x00400719
  401134:	20000e24 	.word	0x20000e24
  401138:	00109119 	.word	0x00109119
  40113c:	00089118 	.word	0x00089118
  401140:	0040165d 	.word	0x0040165d
  401144:	20000e2a 	.word	0x20000e2a
  401148:	00401631 	.word	0x00401631
  40114c:	e4580000 	.word	0xe4580000
  401150:	20000e28 	.word	0x20000e28
  401154:	20000e1e 	.word	0x20000e1e
  401158:	004015e1 	.word	0x004015e1

0040115c <sd_mmc_start_write_blocks>:
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  40115c:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  40115e:	4b07      	ldr	r3, [pc, #28]	; (40117c <sd_mmc_start_write_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  401160:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  401162:	4798      	blx	r3
  401164:	4603      	mov	r3, r0
  401166:	b918      	cbnz	r0, 401170 <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  401168:	4a05      	ldr	r2, [pc, #20]	; (401180 <sd_mmc_start_write_blocks+0x24>)
  40116a:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  40116c:	2005      	movs	r0, #5
  40116e:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401170:	4b03      	ldr	r3, [pc, #12]	; (401180 <sd_mmc_start_write_blocks+0x24>)
  401172:	881a      	ldrh	r2, [r3, #0]
  401174:	1b14      	subs	r4, r2, r4
  401176:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401178:	2000      	movs	r0, #0
}
  40117a:	bd10      	pop	{r4, pc}
  40117c:	004018bd 	.word	0x004018bd
  401180:	20000e28 	.word	0x20000e28

00401184 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401184:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
  401186:	4b14      	ldr	r3, [pc, #80]	; (4011d8 <sd_mmc_wait_end_of_write_blocks+0x54>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401188:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  40118a:	4798      	blx	r3
  40118c:	b908      	cbnz	r0, 401192 <sd_mmc_wait_end_of_write_blocks+0xe>
	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
  40118e:	2005      	movs	r0, #5
  401190:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401192:	4b12      	ldr	r3, [pc, #72]	; (4011dc <sd_mmc_wait_end_of_write_blocks+0x58>)
sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401194:	b994      	cbnz	r4, 4011bc <sd_mmc_wait_end_of_write_blocks+0x38>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  401196:	881b      	ldrh	r3, [r3, #0]
  401198:	b9e3      	cbnz	r3, 4011d4 <sd_mmc_wait_end_of_write_blocks+0x50>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40119a:	4b11      	ldr	r3, [pc, #68]	; (4011e0 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  40119c:	881b      	ldrh	r3, [r3, #0]
  40119e:	2b01      	cmp	r3, #1
  4011a0:	d012      	beq.n	4011c8 <sd_mmc_wait_end_of_write_blocks+0x44>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  4011a2:	f243 100c 	movw	r0, #12556	; 0x310c
  4011a6:	2100      	movs	r1, #0
  4011a8:	4b0e      	ldr	r3, [pc, #56]	; (4011e4 <sd_mmc_wait_end_of_write_blocks+0x60>)
  4011aa:	4798      	blx	r3
  4011ac:	b960      	cbnz	r0, 4011c8 <sd_mmc_wait_end_of_write_blocks+0x44>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4011ae:	4b0e      	ldr	r3, [pc, #56]	; (4011e8 <sd_mmc_wait_end_of_write_blocks+0x64>)
  4011b0:	781b      	ldrb	r3, [r3, #0]
  4011b2:	2b00      	cmp	r3, #0
  4011b4:	d1eb      	bne.n	40118e <sd_mmc_wait_end_of_write_blocks+0xa>
		driver_deselect_device(sd_mmc_slot_sel);
  4011b6:	4b0d      	ldr	r3, [pc, #52]	; (4011ec <sd_mmc_wait_end_of_write_blocks+0x68>)
  4011b8:	4798      	blx	r3
  4011ba:	e7e8      	b.n	40118e <sd_mmc_wait_end_of_write_blocks+0xa>
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  4011bc:	2200      	movs	r2, #0
  4011be:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4011c0:	4b07      	ldr	r3, [pc, #28]	; (4011e0 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  4011c2:	881b      	ldrh	r3, [r3, #0]
  4011c4:	2b01      	cmp	r3, #1
  4011c6:	d1ec      	bne.n	4011a2 <sd_mmc_wait_end_of_write_blocks+0x1e>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4011c8:	4b07      	ldr	r3, [pc, #28]	; (4011e8 <sd_mmc_wait_end_of_write_blocks+0x64>)
  4011ca:	781b      	ldrb	r3, [r3, #0]
  4011cc:	b913      	cbnz	r3, 4011d4 <sd_mmc_wait_end_of_write_blocks+0x50>
		driver_deselect_device(sd_mmc_slot_sel);
  4011ce:	2000      	movs	r0, #0
  4011d0:	4b06      	ldr	r3, [pc, #24]	; (4011ec <sd_mmc_wait_end_of_write_blocks+0x68>)
  4011d2:	4798      	blx	r3

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  4011d4:	2000      	movs	r0, #0
  4011d6:	bd10      	pop	{r4, pc}
  4011d8:	00401929 	.word	0x00401929
  4011dc:	20000e28 	.word	0x20000e28
  4011e0:	20000e1e 	.word	0x20000e1e
  4011e4:	00401605 	.word	0x00401605
  4011e8:	20000e2a 	.word	0x20000e2a
  4011ec:	004015e1 	.word	0x004015e1

004011f0 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  4011f0:	b510      	push	{r4, lr}
	switch (sd_mmc_check(slot))
  4011f2:	4b0f      	ldr	r3, [pc, #60]	; (401230 <sd_mmc_test_unit_ready+0x40>)
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  4011f4:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  4011f6:	4798      	blx	r3
  4011f8:	2801      	cmp	r0, #1
  4011fa:	d00d      	beq.n	401218 <sd_mmc_test_unit_ready+0x28>
  4011fc:	d307      	bcc.n	40120e <sd_mmc_test_unit_ready+0x1e>
  4011fe:	2802      	cmp	r0, #2
  401200:	d103      	bne.n	40120a <sd_mmc_test_unit_ready+0x1a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  401202:	4b0c      	ldr	r3, [pc, #48]	; (401234 <sd_mmc_test_unit_ready+0x44>)
  401204:	2200      	movs	r2, #0
  401206:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  401208:	bd10      	pop	{r4, pc}

	default:
		return CTRL_FAIL;
  40120a:	2001      	movs	r0, #1
  40120c:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  40120e:	4b09      	ldr	r3, [pc, #36]	; (401234 <sd_mmc_test_unit_ready+0x44>)
  401210:	5d1b      	ldrb	r3, [r3, r4]
  401212:	b11b      	cbz	r3, 40121c <sd_mmc_test_unit_ready+0x2c>
			return CTRL_NO_PRESENT;
  401214:	2002      	movs	r0, #2
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  401216:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  401218:	2003      	movs	r0, #3
  40121a:	bd10      	pop	{r4, pc}
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  40121c:	4620      	mov	r0, r4
  40121e:	4b06      	ldr	r3, [pc, #24]	; (401238 <sd_mmc_test_unit_ready+0x48>)
  401220:	4798      	blx	r3
  401222:	f010 0f03 	tst.w	r0, #3
			return CTRL_GOOD;
  401226:	bf0c      	ite	eq
  401228:	2002      	moveq	r0, #2
  40122a:	2000      	movne	r0, #0
  40122c:	bd10      	pop	{r4, pc}
  40122e:	bf00      	nop
  401230:	00400869 	.word	0x00400869
  401234:	20000e2c 	.word	0x20000e2c
  401238:	00400ecd 	.word	0x00400ecd

0040123c <sd_mmc_test_unit_ready_0>:
		return CTRL_FAIL;
	}
}

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  40123c:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  40123e:	2000      	movs	r0, #0
  401240:	4b01      	ldr	r3, [pc, #4]	; (401248 <sd_mmc_test_unit_ready_0+0xc>)
  401242:	4798      	blx	r3
}
  401244:	bd08      	pop	{r3, pc}
  401246:	bf00      	nop
  401248:	004011f1 	.word	0x004011f1

0040124c <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  40124c:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  40124e:	2001      	movs	r0, #1
  401250:	4b01      	ldr	r3, [pc, #4]	; (401258 <sd_mmc_test_unit_ready_1+0xc>)
  401252:	4798      	blx	r3
}
  401254:	bd08      	pop	{r3, pc}
  401256:	bf00      	nop
  401258:	004011f1 	.word	0x004011f1

0040125c <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  40125c:	b538      	push	{r3, r4, r5, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  40125e:	4b05      	ldr	r3, [pc, #20]	; (401274 <sd_mmc_read_capacity+0x18>)
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401260:	460d      	mov	r5, r1
  401262:	4604      	mov	r4, r0
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401264:	4798      	blx	r3
  401266:	0040      	lsls	r0, r0, #1
  401268:	3801      	subs	r0, #1
  40126a:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  40126c:	4b02      	ldr	r3, [pc, #8]	; (401278 <sd_mmc_read_capacity+0x1c>)
  40126e:	4620      	mov	r0, r4
  401270:	4798      	blx	r3
}
  401272:	bd38      	pop	{r3, r4, r5, pc}
  401274:	00400f09 	.word	0x00400f09
  401278:	004011f1 	.word	0x004011f1

0040127c <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  40127c:	b508      	push	{r3, lr}
  40127e:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  401280:	4b01      	ldr	r3, [pc, #4]	; (401288 <sd_mmc_read_capacity_0+0xc>)
  401282:	2000      	movs	r0, #0
  401284:	4798      	blx	r3
}
  401286:	bd08      	pop	{r3, pc}
  401288:	0040125d 	.word	0x0040125d

0040128c <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  40128c:	b508      	push	{r3, lr}
  40128e:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  401290:	4b01      	ldr	r3, [pc, #4]	; (401298 <sd_mmc_read_capacity_1+0xc>)
  401292:	2001      	movs	r0, #1
  401294:	4798      	blx	r3
}
  401296:	bd08      	pop	{r3, pc}
  401298:	0040125d 	.word	0x0040125d

0040129c <sd_mmc_unload_0>:

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  40129c:	4b01      	ldr	r3, [pc, #4]	; (4012a4 <sd_mmc_unload_0+0x8>)
  40129e:	7018      	strb	r0, [r3, #0]
}

bool sd_mmc_unload_0(bool unload)
{
	return sd_mmc_unload(0, unload);
}
  4012a0:	2001      	movs	r0, #1
  4012a2:	4770      	bx	lr
  4012a4:	20000e2c 	.word	0x20000e2c

004012a8 <sd_mmc_unload_1>:
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  4012a8:	4b01      	ldr	r3, [pc, #4]	; (4012b0 <sd_mmc_unload_1+0x8>)
  4012aa:	7058      	strb	r0, [r3, #1]
}

bool sd_mmc_unload_1(bool unload)
{
	return sd_mmc_unload(1, unload);
}
  4012ac:	2001      	movs	r0, #1
  4012ae:	4770      	bx	lr
  4012b0:	20000e2c 	.word	0x20000e2c

004012b4 <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
  4012b4:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  4012b6:	2000      	movs	r0, #0
  4012b8:	4b01      	ldr	r3, [pc, #4]	; (4012c0 <sd_mmc_wr_protect_0+0xc>)
  4012ba:	4798      	blx	r3
}

bool sd_mmc_wr_protect_0(void)
{
	return sd_mmc_wr_protect(0);
}
  4012bc:	bd08      	pop	{r3, pc}
  4012be:	bf00      	nop
  4012c0:	00400f45 	.word	0x00400f45

004012c4 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  4012c4:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  4012c6:	2001      	movs	r0, #1
  4012c8:	4b01      	ldr	r3, [pc, #4]	; (4012d0 <sd_mmc_wr_protect_1+0xc>)
  4012ca:	4798      	blx	r3
}

bool sd_mmc_wr_protect_1(void)
{
	return sd_mmc_wr_protect(1);
}
  4012cc:	bd08      	pop	{r3, pc}
  4012ce:	bf00      	nop
  4012d0:	00400f45 	.word	0x00400f45

004012d4 <sd_mmc_removal_0>:
}

bool sd_mmc_removal_0(void)
{
	return sd_mmc_removal(0);
}
  4012d4:	2001      	movs	r0, #1
  4012d6:	4770      	bx	lr

004012d8 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
	return sd_mmc_removal(1);
}
  4012d8:	2001      	movs	r0, #1
  4012da:	4770      	bx	lr

004012dc <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  4012dc:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  4012de:	4b0b      	ldr	r3, [pc, #44]	; (40130c <sd_mmc_mem_2_ram+0x30>)
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  4012e0:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  4012e2:	2201      	movs	r2, #1
  4012e4:	4798      	blx	r3
  4012e6:	b120      	cbz	r0, 4012f2 <sd_mmc_mem_2_ram+0x16>
  4012e8:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  4012ea:	bf0c      	ite	eq
  4012ec:	2002      	moveq	r0, #2
  4012ee:	2001      	movne	r0, #1
  4012f0:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  4012f2:	4620      	mov	r0, r4
  4012f4:	2101      	movs	r1, #1
  4012f6:	4b06      	ldr	r3, [pc, #24]	; (401310 <sd_mmc_mem_2_ram+0x34>)
  4012f8:	4798      	blx	r3
  4012fa:	b108      	cbz	r0, 401300 <sd_mmc_mem_2_ram+0x24>
		return CTRL_FAIL;
  4012fc:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  4012fe:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
  401300:	4b04      	ldr	r3, [pc, #16]	; (401314 <sd_mmc_mem_2_ram+0x38>)
  401302:	4798      	blx	r3
		return CTRL_FAIL;
  401304:	3000      	adds	r0, #0
  401306:	bf18      	it	ne
  401308:	2001      	movne	r0, #1
  40130a:	bd10      	pop	{r4, pc}
  40130c:	00400f49 	.word	0x00400f49
  401310:	00401031 	.word	0x00401031
  401314:	00401059 	.word	0x00401059

00401318 <sd_mmc_mem_2_ram_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  401318:	b508      	push	{r3, lr}
  40131a:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  40131c:	4b02      	ldr	r3, [pc, #8]	; (401328 <sd_mmc_mem_2_ram_0+0x10>)
  40131e:	4601      	mov	r1, r0
  401320:	2000      	movs	r0, #0
  401322:	4798      	blx	r3
}
  401324:	bd08      	pop	{r3, pc}
  401326:	bf00      	nop
  401328:	004012dd 	.word	0x004012dd

0040132c <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  40132c:	b508      	push	{r3, lr}
  40132e:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  401330:	4b02      	ldr	r3, [pc, #8]	; (40133c <sd_mmc_mem_2_ram_1+0x10>)
  401332:	4601      	mov	r1, r0
  401334:	2001      	movs	r0, #1
  401336:	4798      	blx	r3
}
  401338:	bd08      	pop	{r3, pc}
  40133a:	bf00      	nop
  40133c:	004012dd 	.word	0x004012dd

00401340 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401340:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401342:	4b0b      	ldr	r3, [pc, #44]	; (401370 <sd_mmc_ram_2_mem+0x30>)
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401344:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401346:	2201      	movs	r2, #1
  401348:	4798      	blx	r3
  40134a:	b120      	cbz	r0, 401356 <sd_mmc_ram_2_mem+0x16>
  40134c:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  40134e:	bf0c      	ite	eq
  401350:	2002      	moveq	r0, #2
  401352:	2001      	movne	r0, #1
  401354:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  401356:	4620      	mov	r0, r4
  401358:	2101      	movs	r1, #1
  40135a:	4b06      	ldr	r3, [pc, #24]	; (401374 <sd_mmc_ram_2_mem+0x34>)
  40135c:	4798      	blx	r3
  40135e:	b108      	cbz	r0, 401364 <sd_mmc_ram_2_mem+0x24>
		return CTRL_FAIL;
  401360:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  401362:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
  401364:	4b04      	ldr	r3, [pc, #16]	; (401378 <sd_mmc_ram_2_mem+0x38>)
  401366:	4798      	blx	r3
		return CTRL_FAIL;
  401368:	3000      	adds	r0, #0
  40136a:	bf18      	it	ne
  40136c:	2001      	movne	r0, #1
  40136e:	bd10      	pop	{r4, pc}
  401370:	004010bd 	.word	0x004010bd
  401374:	0040115d 	.word	0x0040115d
  401378:	00401185 	.word	0x00401185

0040137c <sd_mmc_ram_2_mem_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  40137c:	b508      	push	{r3, lr}
  40137e:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  401380:	4b02      	ldr	r3, [pc, #8]	; (40138c <sd_mmc_ram_2_mem_0+0x10>)
  401382:	4601      	mov	r1, r0
  401384:	2000      	movs	r0, #0
  401386:	4798      	blx	r3
}
  401388:	bd08      	pop	{r3, pc}
  40138a:	bf00      	nop
  40138c:	00401341 	.word	0x00401341

00401390 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  401390:	b508      	push	{r3, lr}
  401392:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  401394:	4b02      	ldr	r3, [pc, #8]	; (4013a0 <sd_mmc_ram_2_mem_1+0x10>)
  401396:	4601      	mov	r1, r0
  401398:	2001      	movs	r0, #1
  40139a:	4798      	blx	r3
}
  40139c:	bd08      	pop	{r3, pc}
  40139e:	bf00      	nop
  4013a0:	00401341 	.word	0x00401341

004013a4 <mem_test_unit_ready>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013a4:	2801      	cmp	r0, #1
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  4013a6:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013a8:	d901      	bls.n	4013ae <mem_test_unit_ready+0xa>
  4013aa:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  4013ac:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  4013ae:	0140      	lsls	r0, r0, #5
  4013b0:	4b01      	ldr	r3, [pc, #4]	; (4013b8 <mem_test_unit_ready+0x14>)
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013b2:	581b      	ldr	r3, [r3, r0]
  4013b4:	4798      	blx	r3
  4013b6:	bd08      	pop	{r3, pc}
  4013b8:	00405350 	.word	0x00405350

004013bc <mem_read_capacity>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013bc:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  4013be:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013c0:	d901      	bls.n	4013c6 <mem_read_capacity+0xa>
  4013c2:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  4013c4:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  4013c6:	4b03      	ldr	r3, [pc, #12]	; (4013d4 <mem_read_capacity+0x18>)
  4013c8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4013cc:	4608      	mov	r0, r1
  4013ce:	685b      	ldr	r3, [r3, #4]
  4013d0:	4798      	blx	r3
  4013d2:	bd08      	pop	{r3, pc}
  4013d4:	00405350 	.word	0x00405350

004013d8 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  4013d8:	2801      	cmp	r0, #1
  4013da:	bf8c      	ite	hi
  4013dc:	2000      	movhi	r0, #0
  4013de:	2001      	movls	r0, #1
  4013e0:	4770      	bx	lr
  4013e2:	bf00      	nop

004013e4 <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4013e4:	2801      	cmp	r0, #1

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
  4013e6:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4013e8:	d901      	bls.n	4013ee <mem_wr_protect+0xa>
  4013ea:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  4013ec:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4013ee:	4b03      	ldr	r3, [pc, #12]	; (4013fc <mem_wr_protect+0x18>)
  4013f0:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  4013f4:	68c3      	ldr	r3, [r0, #12]
  4013f6:	4798      	blx	r3
  4013f8:	bd08      	pop	{r3, pc}
  4013fa:	bf00      	nop
  4013fc:	00405350 	.word	0x00405350

00401400 <memory_2_ram>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401400:	2801      	cmp	r0, #1
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  401402:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401404:	d901      	bls.n	40140a <memory_2_ram+0xa>
  401406:	2001      	movs	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  401408:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  40140a:	4b04      	ldr	r3, [pc, #16]	; (40141c <memory_2_ram+0x1c>)
  40140c:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401410:	4608      	mov	r0, r1
  401412:	695b      	ldr	r3, [r3, #20]
  401414:	4611      	mov	r1, r2
  401416:	4798      	blx	r3
  401418:	bd08      	pop	{r3, pc}
  40141a:	bf00      	nop
  40141c:	00405350 	.word	0x00405350

00401420 <ram_2_memory>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401420:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
  401422:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401424:	d901      	bls.n	40142a <ram_2_memory+0xa>
  401426:	2001      	movs	r0, #1
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
  401428:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  40142a:	4b04      	ldr	r3, [pc, #16]	; (40143c <ram_2_memory+0x1c>)
  40142c:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401430:	4608      	mov	r0, r1
  401432:	699b      	ldr	r3, [r3, #24]
  401434:	4611      	mov	r1, r2
  401436:	4798      	blx	r3
  401438:	bd08      	pop	{r3, pc}
  40143a:	bf00      	nop
  40143c:	00405350 	.word	0x00405350

00401440 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  401440:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401444:	f001 033f 	and.w	r3, r1, #63	; 0x3f
	if (cmd & SDMMC_RESP_PRESENT) {
  401448:	05cf      	lsls	r7, r1, #23
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  40144a:	ea43 0000 	orr.w	r0, r3, r0
	if (cmd & SDMMC_RESP_PRESENT) {
  40144e:	d503      	bpl.n	401458 <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  401450:	050e      	lsls	r6, r1, #20
  401452:	d530      	bpl.n	4014b6 <hsmci_send_cmd_execute+0x76>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  401454:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
	if (cmd & SDMMC_CMD_OPENDRAIN) {
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401458:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  40145c:	044c      	lsls	r4, r1, #17
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  40145e:	bf48      	it	mi
  401460:	f440 6000 	orrmi.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401464:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401466:	461d      	mov	r5, r3
  401468:	f401 5480 	and.w	r4, r1, #4096	; 0x1000
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  40146c:	6158      	str	r0, [r3, #20]
  40146e:	e004      	b.n	40147a <hsmci_send_cmd_execute+0x3a>

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
		if (cmd & SDMMC_RESP_CRC) {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401470:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  401474:	d12c      	bne.n	4014d0 <hsmci_send_cmd_execute+0x90>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401476:	07da      	lsls	r2, r3, #31
  401478:	d424      	bmi.n	4014c4 <hsmci_send_cmd_execute+0x84>
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  40147a:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  40147e:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  401480:	2c00      	cmp	r4, #0
  401482:	d1f5      	bne.n	401470 <hsmci_send_cmd_execute+0x30>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401484:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401488:	d0f5      	beq.n	401476 <hsmci_send_cmd_execute+0x36>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40148a:	f8d2 c004 	ldr.w	ip, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40148e:	6897      	ldr	r7, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401490:	68d6      	ldr	r6, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401492:	69d5      	ldr	r5, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401494:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401496:	f04f 0880 	mov.w	r8, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40149a:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40149c:	f8c2 8000 	str.w	r8, [r2]
	HSMCI->HSMCI_MR = mr;
  4014a0:	f8c2 c004 	str.w	ip, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4014a4:	6097      	str	r7, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4014a6:	60d6      	str	r6, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4014a8:	61d5      	str	r5, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  4014aa:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4014ac:	6013      	str	r3, [r2, #0]
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  4014ae:	4620      	mov	r0, r4
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  4014b0:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4014b4:	4770      	bx	lr
	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  4014b6:	048d      	lsls	r5, r1, #18
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  4014b8:	bf4c      	ite	mi
  4014ba:	f440 5086 	orrmi.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  4014be:	f440 5082 	orrpl.w	r0, r0, #4160	; 0x1040
  4014c2:	e7c9      	b.n	401458 <hsmci_send_cmd_execute+0x18>
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));

	if (cmd & SDMMC_RESP_BUSY) {
  4014c4:	048b      	lsls	r3, r1, #18
  4014c6:	d415      	bmi.n	4014f4 <hsmci_send_cmd_execute+0xb4>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  4014c8:	2001      	movs	r0, #1
}
  4014ca:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4014ce:	4770      	bx	lr
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4014d0:	2080      	movs	r0, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4014d2:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4014d4:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4014d6:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4014d8:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4014da:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4014dc:	6010      	str	r0, [r2, #0]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4014de:	2305      	movs	r3, #5
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  4014e0:	2000      	movs	r0, #0
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
	HSMCI->HSMCI_MR = mr;
  4014e2:	6057      	str	r7, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4014e4:	6096      	str	r6, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4014e6:	60d5      	str	r5, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4014e8:	61d4      	str	r4, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  4014ea:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4014ec:	6013      	str	r3, [r2, #0]
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  4014ee:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  4014f2:	4770      	bx	lr
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  4014f4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4014f8:	4619      	mov	r1, r3
  4014fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  4014fc:	f04f 30ff 	mov.w	r0, #4294967295
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401500:	f003 0330 	and.w	r3, r3, #48	; 0x30
  401504:	2b20      	cmp	r3, #32
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401506:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  40150a:	d0dd      	beq.n	4014c8 <hsmci_send_cmd_execute+0x88>
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
		if (busy_wait-- == 0) {
  40150c:	3801      	subs	r0, #1
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  40150e:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  401510:	d1f6      	bne.n	401500 <hsmci_send_cmd_execute+0xc0>
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401512:	f04f 0c80 	mov.w	ip, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401516:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401518:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40151a:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40151c:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40151e:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401520:	f8c2 c000 	str.w	ip, [r2]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401524:	2305      	movs	r3, #5
  401526:	e7dc      	b.n	4014e2 <hsmci_send_cmd_execute+0xa2>

00401528 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401528:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  40152a:	4b08      	ldr	r3, [pc, #32]	; (40154c <hsmci_init+0x24>)
  40152c:	2012      	movs	r0, #18
  40152e:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401530:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401534:	2272      	movs	r2, #114	; 0x72
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401536:	2411      	movs	r4, #17
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401538:	f44f 60e0 	mov.w	r0, #1792	; 0x700

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  40153c:	2105      	movs	r1, #5
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  40153e:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  401540:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401542:	655c      	str	r4, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401544:	6058      	str	r0, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401546:	6019      	str	r1, [r3, #0]
  401548:	bd10      	pop	{r4, pc}
  40154a:	bf00      	nop
  40154c:	004044d5 	.word	0x004044d5

00401550 <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  401550:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401552:	bf0c      	ite	eq
  401554:	2004      	moveq	r0, #4
  401556:	2000      	movne	r0, #0
  401558:	4770      	bx	lr
  40155a:	bf00      	nop

0040155c <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  40155c:	2001      	movs	r0, #1
  40155e:	4770      	bx	lr

00401560 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  401560:	b33b      	cbz	r3, 4015b2 <hsmci_select_device+0x52>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401562:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401566:	0049      	lsls	r1, r1, #1
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401568:	6d58      	ldr	r0, [r3, #84]	; 0x54
  40156a:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  40156e:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401570:	4b1a      	ldr	r3, [pc, #104]	; (4015dc <hsmci_select_device+0x7c>)
  401572:	4299      	cmp	r1, r3
  401574:	d827      	bhi.n	4015c6 <hsmci_select_device+0x66>
		clkdiv = mck / (2 * speed);
  401576:	3301      	adds	r3, #1
		rest = mck % (2 * speed);
  401578:	4618      	mov	r0, r3
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
		clkdiv = mck / (2 * speed);
  40157a:	fbb3 f3f1 	udiv	r3, r3, r1
		rest = mck % (2 * speed);
  40157e:	fb01 f103 	mul.w	r1, r1, r3
  401582:	1a40      	subs	r0, r0, r1
		if (rest > 0) {
  401584:	bb08      	cbnz	r0, 4015ca <hsmci_select_device+0x6a>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
		}
		if (clkdiv > 0) {
  401586:	bb0b      	cbnz	r3, 4015cc <hsmci_select_device+0x6c>
  401588:	4619      	mov	r1, r3
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  40158a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  40158e:	2a04      	cmp	r2, #4
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401590:	6858      	ldr	r0, [r3, #4]
  401592:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  401596:	6058      	str	r0, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  401598:	6858      	ldr	r0, [r3, #4]
  40159a:	ea41 0100 	orr.w	r1, r1, r0
  40159e:	6059      	str	r1, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  4015a0:	d017      	beq.n	4015d2 <hsmci_select_device+0x72>
  4015a2:	2a08      	cmp	r2, #8
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4015a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  4015a8:	bf0c      	ite	eq
  4015aa:	22c0      	moveq	r2, #192	; 0xc0
  4015ac:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4015ae:	60da      	str	r2, [r3, #12]
  4015b0:	4770      	bx	lr
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4015b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  4015b6:	0049      	lsls	r1, r1, #1
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  4015b8:	6d58      	ldr	r0, [r3, #84]	; 0x54
  4015ba:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  4015be:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  4015c0:	4b06      	ldr	r3, [pc, #24]	; (4015dc <hsmci_select_device+0x7c>)
  4015c2:	4299      	cmp	r1, r3
  4015c4:	d9d7      	bls.n	401576 <hsmci_select_device+0x16>
  4015c6:	2100      	movs	r1, #0
  4015c8:	e7df      	b.n	40158a <hsmci_select_device+0x2a>
		clkdiv = mck / (2 * speed);
		rest = mck % (2 * speed);
		if (rest > 0) {
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  4015ca:	3301      	adds	r3, #1
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
  4015cc:	3b01      	subs	r3, #1
  4015ce:	b2d9      	uxtb	r1, r3
  4015d0:	e7db      	b.n	40158a <hsmci_select_device+0x2a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4015d2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  4015d6:	2280      	movs	r2, #128	; 0x80
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  4015d8:	60da      	str	r2, [r3, #12]
  4015da:	4770      	bx	lr
  4015dc:	07270dff 	.word	0x07270dff

004015e0 <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  4015e0:	4770      	bx	lr
  4015e2:	bf00      	nop

004015e4 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4015e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  4015e8:	2000      	movs	r0, #0
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4015ea:	685a      	ldr	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  4015ec:	f44f 6110 	mov.w	r1, #2304	; 0x900
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  4015f0:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  4015f4:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  4015f6:	6118      	str	r0, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  4015f8:	461a      	mov	r2, r3
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  4015fa:	6159      	str	r1, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  4015fc:	6c13      	ldr	r3, [r2, #64]	; 0x40
  4015fe:	07db      	lsls	r3, r3, #31
  401600:	d5fc      	bpl.n	4015fc <hsmci_send_clock+0x18>
}
  401602:	4770      	bx	lr

00401604 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401604:	b570      	push	{r4, r5, r6, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401606:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  40160a:	2400      	movs	r4, #0
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  40160c:	685a      	ldr	r2, [r3, #4]
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  40160e:	4d07      	ldr	r5, [pc, #28]	; (40162c <hsmci_send_cmd+0x28>)
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401610:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401614:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401616:	685e      	ldr	r6, [r3, #4]
  401618:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  40161c:	460a      	mov	r2, r1
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  40161e:	605e      	str	r6, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401620:	4601      	mov	r1, r0
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401622:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401624:	4620      	mov	r0, r4
  401626:	47a8      	blx	r5
}
  401628:	bd70      	pop	{r4, r5, r6, pc}
  40162a:	bf00      	nop
  40162c:	00401441 	.word	0x00401441

00401630 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401630:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401634:	6a18      	ldr	r0, [r3, #32]
}
  401636:	4770      	bx	lr

00401638 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  401638:	b430      	push	{r4, r5}
  40163a:	f100 0510 	add.w	r5, r0, #16
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  40163e:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401642:	6a23      	ldr	r3, [r4, #32]
		response++;
		*response = (response_32 >> 16) & 0xFF;
		response++;
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
  401644:	70c3      	strb	r3, [r0, #3]
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401646:	0e19      	lsrs	r1, r3, #24
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401648:	0c1a      	lsrs	r2, r3, #16
		response++;
		*response = (response_32 >>  8) & 0xFF;
  40164a:	0a1b      	lsrs	r3, r3, #8
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  40164c:	7001      	strb	r1, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  40164e:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401650:	7083      	strb	r3, [r0, #2]
  401652:	3004      	adds	r0, #4

void hsmci_get_response_128(uint8_t* response)
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  401654:	42a8      	cmp	r0, r5
  401656:	d1f4      	bne.n	401642 <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  401658:	bc30      	pop	{r4, r5}
  40165a:	4770      	bx	lr

0040165c <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  40165c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40165e:	460e      	mov	r6, r1
  401660:	f89d 5018 	ldrb.w	r5, [sp, #24]
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401664:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		response++;
	}
}

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401668:	4604      	mov	r4, r0
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  40166a:	6848      	ldr	r0, [r1, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  40166c:	b34d      	cbz	r5, 4016c2 <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  40166e:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  401672:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401674:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	// Force byte transfer if needed
	if (block_size & 0x3) {
  401678:	0797      	lsls	r7, r2, #30
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  40167a:	6841      	ldr	r1, [r0, #4]
  40167c:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  401680:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401682:	6841      	ldr	r1, [r0, #4]
  401684:	bf14      	ite	ne
  401686:	f441 5100 	orrne.w	r1, r1, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  40168a:	f421 5100 	biceq.w	r1, r1, #8192	; 0x2000
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  40168e:	f414 4f00 	tst.w	r4, #32768	; 0x8000
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401692:	6041      	str	r1, [r0, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401694:	bf0c      	ite	eq
  401696:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  40169a:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  40169e:	03e5      	lsls	r5, r4, #15
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4016a0:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  4016a4:	d421      	bmi.n	4016ea <hsmci_adtc_start+0x8e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  4016a6:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  4016aa:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  4016ac:	03a1      	lsls	r1, r4, #14
  4016ae:	d40c      	bmi.n	4016ca <hsmci_adtc_start+0x6e>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  4016b0:	0367      	lsls	r7, r4, #13
  4016b2:	d420      	bmi.n	4016f6 <hsmci_adtc_start+0x9a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  4016b4:	0325      	lsls	r5, r4, #12
  4016b6:	d40a      	bmi.n	4016ce <hsmci_adtc_start+0x72>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  4016b8:	02e1      	lsls	r1, r4, #11
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  4016ba:	bf48      	it	mi
  4016bc:	f440 2000 	orrmi.w	r0, r0, #524288	; 0x80000
  4016c0:	e005      	b.n	4016ce <hsmci_adtc_start+0x72>
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  4016c2:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  4016c6:	6048      	str	r0, [r1, #4]
  4016c8:	e7d4      	b.n	401674 <hsmci_adtc_start+0x18>
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  4016ca:	f440 1020 	orr.w	r0, r0, #2621440	; 0x280000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  4016ce:	490b      	ldr	r1, [pc, #44]	; (4016fc <hsmci_adtc_start+0xa0>)
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4016d0:	f8df e034 	ldr.w	lr, [pc, #52]	; 401708 <hsmci_adtc_start+0xac>
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  4016d4:	4f0a      	ldr	r7, [pc, #40]	; (401700 <hsmci_adtc_start+0xa4>)
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  4016d6:	800a      	strh	r2, [r1, #0]
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4016d8:	4d0a      	ldr	r5, [pc, #40]	; (401704 <hsmci_adtc_start+0xa8>)
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  4016da:	803b      	strh	r3, [r7, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4016dc:	4621      	mov	r1, r4
  4016de:	4632      	mov	r2, r6
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  4016e0:	2400      	movs	r4, #0
  4016e2:	f8ce 4000 	str.w	r4, [lr]
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  4016e6:	47a8      	blx	r5
}
  4016e8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4016ea:	f3c2 0508 	ubfx	r5, r2, #0, #9
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  4016ee:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  4016f2:	618d      	str	r5, [r1, #24]
  4016f4:	e7eb      	b.n	4016ce <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  4016f6:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  4016fa:	e7e8      	b.n	4016ce <hsmci_adtc_start+0x72>
  4016fc:	20000e30 	.word	0x20000e30
  401700:	20000e32 	.word	0x20000e32
  401704:	00401441 	.word	0x00401441
  401708:	20000e34 	.word	0x20000e34

0040170c <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  40170c:	b4f0      	push	{r4, r5, r6, r7}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40170e:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401712:	e001      	b.n	401718 <hsmci_read_word+0xc>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  401714:	0792      	lsls	r2, r2, #30
  401716:	d417      	bmi.n	401748 <hsmci_read_word+0x3c>

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401718:	6c22      	ldr	r2, [r4, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40171a:	4b21      	ldr	r3, [pc, #132]	; (4017a0 <hsmci_read_word+0x94>)
  40171c:	4013      	ands	r3, r2

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  40171e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401722:	2b00      	cmp	r3, #0
  401724:	d0f6      	beq.n	401714 <hsmci_read_word+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401726:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401728:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40172a:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40172c:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40172e:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401730:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401732:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401734:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401736:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401738:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40173a:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40173c:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  40173e:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401740:	600b      	str	r3, [r1, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401742:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401744:	bcf0      	pop	{r4, r5, r6, r7}
  401746:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401748:	4a16      	ldr	r2, [pc, #88]	; (4017a4 <hsmci_read_word+0x98>)
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40174a:	4c17      	ldr	r4, [pc, #92]	; (4017a8 <hsmci_read_word+0x9c>)
  40174c:	4d17      	ldr	r5, [pc, #92]	; (4017ac <hsmci_read_word+0xa0>)
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  40174e:	6813      	ldr	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401750:	8826      	ldrh	r6, [r4, #0]
  401752:	882d      	ldrh	r5, [r5, #0]
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
  401754:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  401756:	6004      	str	r4, [r0, #0]
	hsmci_transfert_pos += 4;
  401758:	3304      	adds	r3, #4
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40175a:	fb06 f005 	mul.w	r0, r6, r5
  40175e:	4283      	cmp	r3, r0
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401760:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401762:	d202      	bcs.n	40176a <hsmci_read_word+0x5e>
  401764:	e019      	b.n	40179a <hsmci_read_word+0x8e>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401766:	0113      	lsls	r3, r2, #4
  401768:	d417      	bmi.n	40179a <hsmci_read_word+0x8e>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  40176a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40176c:	4b0c      	ldr	r3, [pc, #48]	; (4017a0 <hsmci_read_word+0x94>)
  40176e:	4013      	ands	r3, r2
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  401770:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401774:	2b00      	cmp	r3, #0
  401776:	d0f6      	beq.n	401766 <hsmci_read_word+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401778:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40177a:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40177c:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40177e:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401780:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401782:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401784:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401786:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  401788:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40178a:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40178c:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40178e:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  401790:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401792:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401794:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401796:	bcf0      	pop	{r4, r5, r6, r7}
  401798:	4770      	bx	lr

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  40179a:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40179c:	bcf0      	pop	{r4, r5, r6, r7}
  40179e:	4770      	bx	lr
  4017a0:	c0600000 	.word	0xc0600000
  4017a4:	20000e34 	.word	0x20000e34
  4017a8:	20000e30 	.word	0x20000e30
  4017ac:	20000e32 	.word	0x20000e32

004017b0 <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  4017b0:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4017b2:	4b17      	ldr	r3, [pc, #92]	; (401810 <hsmci_start_read_blocks+0x60>)
  4017b4:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4017b6:	0784      	lsls	r4, r0, #30
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4017b8:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  4017bc:	d101      	bne.n	4017c2 <hsmci_start_read_blocks+0x12>
  4017be:	079a      	lsls	r2, r3, #30
  4017c0:	d01e      	beq.n	401800 <hsmci_start_read_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4017c2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4017c6:	685a      	ldr	r2, [r3, #4]
  4017c8:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  4017cc:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  4017ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  4017d2:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  4017d4:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4017d8:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
	hsmci_transfert_pos += nb_data;
  4017da:	4a0e      	ldr	r2, [pc, #56]	; (401814 <hsmci_start_read_blocks+0x64>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  4017dc:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4017de:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  4017e2:	bf54      	ite	pl
  4017e4:	088d      	lsrpl	r5, r1, #2
  4017e6:	460d      	movmi	r5, r1
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4017e8:	2001      	movs	r0, #1
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4017ea:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  4017ee:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4017f2:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4017f6:	6813      	ldr	r3, [r2, #0]
  4017f8:	4419      	add	r1, r3
  4017fa:	6011      	str	r1, [r2, #0]
	return true;
}
  4017fc:	bc30      	pop	{r4, r5}
  4017fe:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401800:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401804:	685a      	ldr	r2, [r3, #4]
  401806:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  40180a:	605a      	str	r2, [r3, #4]
  40180c:	e7df      	b.n	4017ce <hsmci_start_read_blocks+0x1e>
  40180e:	bf00      	nop
  401810:	20000e30 	.word	0x20000e30
  401814:	20000e34 	.word	0x20000e34

00401818 <hsmci_wait_end_of_read_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_read_blocks(void)
{
  401818:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40181a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  40181e:	e001      	b.n	401824 <hsmci_wait_end_of_read_blocks+0xc>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  401820:	0452      	lsls	r2, r2, #17
  401822:	d41b      	bmi.n	40185c <hsmci_wait_end_of_read_blocks+0x44>
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401824:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401826:	4b21      	ldr	r3, [pc, #132]	; (4018ac <hsmci_wait_end_of_read_blocks+0x94>)
  401828:	4013      	ands	r3, r2
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40182a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40182e:	2b00      	cmp	r3, #0
  401830:	d0f6      	beq.n	401820 <hsmci_wait_end_of_read_blocks+0x8>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401832:	f240 2302 	movw	r3, #514	; 0x202
  401836:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  40183a:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40183c:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40183e:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401840:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401842:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401844:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401846:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401848:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  40184a:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40184c:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40184e:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401850:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401852:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401854:	600b      	str	r3, [r1, #0]
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
  401856:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401858:	bcf0      	pop	{r4, r5, r6, r7}
  40185a:	4770      	bx	lr
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  40185c:	4a14      	ldr	r2, [pc, #80]	; (4018b0 <hsmci_wait_end_of_read_blocks+0x98>)
  40185e:	4815      	ldr	r0, [pc, #84]	; (4018b4 <hsmci_wait_end_of_read_blocks+0x9c>)
  401860:	4b15      	ldr	r3, [pc, #84]	; (4018b8 <hsmci_wait_end_of_read_blocks+0xa0>)
  401862:	8812      	ldrh	r2, [r2, #0]
  401864:	8800      	ldrh	r0, [r0, #0]
  401866:	681b      	ldr	r3, [r3, #0]
  401868:	fb00 f202 	mul.w	r2, r0, r2
  40186c:	429a      	cmp	r2, r3
  40186e:	d902      	bls.n	401876 <hsmci_wait_end_of_read_blocks+0x5e>
  401870:	e019      	b.n	4018a6 <hsmci_wait_end_of_read_blocks+0x8e>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401872:	0113      	lsls	r3, r2, #4
  401874:	d417      	bmi.n	4018a6 <hsmci_wait_end_of_read_blocks+0x8e>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401876:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401878:	4b0c      	ldr	r3, [pc, #48]	; (4018ac <hsmci_wait_end_of_read_blocks+0x94>)
  40187a:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40187c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401880:	2b00      	cmp	r3, #0
  401882:	d0f6      	beq.n	401872 <hsmci_wait_end_of_read_blocks+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401884:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401886:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401888:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40188a:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40188c:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40188e:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401890:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401892:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  401894:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401896:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401898:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40189a:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  40189c:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40189e:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  4018a0:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  4018a2:	bcf0      	pop	{r4, r5, r6, r7}
  4018a4:	4770      	bx	lr
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  4018a6:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  4018a8:	bcf0      	pop	{r4, r5, r6, r7}
  4018aa:	4770      	bx	lr
  4018ac:	c0600000 	.word	0xc0600000
  4018b0:	20000e32 	.word	0x20000e32
  4018b4:	20000e30 	.word	0x20000e30
  4018b8:	20000e34 	.word	0x20000e34

004018bc <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
  4018bc:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4018be:	4b18      	ldr	r3, [pc, #96]	; (401920 <hsmci_start_write_blocks+0x64>)
  4018c0:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  4018c2:	0784      	lsls	r4, r0, #30

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  4018c4:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  4018c8:	d101      	bne.n	4018ce <hsmci_start_write_blocks+0x12>
  4018ca:	079a      	lsls	r2, r3, #30
  4018cc:	d020      	beq.n	401910 <hsmci_start_write_blocks+0x54>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  4018ce:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4018d2:	685a      	ldr	r2, [r3, #4]
  4018d4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  4018d8:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  4018da:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  4018de:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  4018e0:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4018e4:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
	hsmci_transfert_pos += nb_data;
  4018e6:	4a0f      	ldr	r2, [pc, #60]	; (401924 <hsmci_start_write_blocks+0x68>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  4018e8:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4018ea:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  4018ee:	bf54      	ite	pl
  4018f0:	088d      	lsrpl	r5, r1, #2
  4018f2:	460d      	movmi	r5, r1
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  4018f4:	f44f 7080 	mov.w	r0, #256	; 0x100
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4018f8:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  4018fc:	f8c3 411c 	str.w	r4, [r3, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401900:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401904:	6813      	ldr	r3, [r2, #0]
  401906:	4419      	add	r1, r3
  401908:	6011      	str	r1, [r2, #0]
	return true;
}
  40190a:	2001      	movs	r0, #1
  40190c:	bc30      	pop	{r4, r5}
  40190e:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401910:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401914:	685a      	ldr	r2, [r3, #4]
  401916:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  40191a:	605a      	str	r2, [r3, #4]
  40191c:	e7dd      	b.n	4018da <hsmci_start_write_blocks+0x1e>
  40191e:	bf00      	nop
  401920:	20000e30 	.word	0x20000e30
  401924:	20000e34 	.word	0x20000e34

00401928 <hsmci_wait_end_of_write_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_write_blocks(void)
{
  401928:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40192a:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  40192e:	e001      	b.n	401934 <hsmci_wait_end_of_write_blocks+0xc>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  401930:	0412      	lsls	r2, r2, #16
  401932:	d41d      	bmi.n	401970 <hsmci_wait_end_of_write_blocks+0x48>
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401934:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr &
  401936:	4b22      	ldr	r3, [pc, #136]	; (4019c0 <hsmci_wait_end_of_write_blocks+0x98>)
  401938:	4013      	ands	r3, r2
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40193a:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  40193e:	2b00      	cmp	r3, #0
  401940:	d0f6      	beq.n	401930 <hsmci_wait_end_of_write_blocks+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401942:	f8d1 c004 	ldr.w	ip, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401946:	688f      	ldr	r7, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401948:	68ce      	ldr	r6, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40194a:	69cd      	ldr	r5, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40194c:	6d4c      	ldr	r4, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40194e:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401950:	2205      	movs	r2, #5
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401952:	f240 2302 	movw	r3, #514	; 0x202
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401956:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401958:	f8c1 c004 	str.w	ip, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  40195c:	608f      	str	r7, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40195e:	60ce      	str	r6, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401960:	61cd      	str	r5, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401962:	654c      	str	r4, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401964:	600a      	str	r2, [r1, #0]
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401966:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
			return false;
  40196a:	2000      	movs	r0, #0
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  40196c:	bcf0      	pop	{r4, r5, r6, r7}
  40196e:	4770      	bx	lr
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401970:	4a14      	ldr	r2, [pc, #80]	; (4019c4 <hsmci_wait_end_of_write_blocks+0x9c>)
  401972:	4815      	ldr	r0, [pc, #84]	; (4019c8 <hsmci_wait_end_of_write_blocks+0xa0>)
  401974:	4b15      	ldr	r3, [pc, #84]	; (4019cc <hsmci_wait_end_of_write_blocks+0xa4>)
  401976:	8812      	ldrh	r2, [r2, #0]
  401978:	8800      	ldrh	r0, [r0, #0]
  40197a:	681b      	ldr	r3, [r3, #0]
  40197c:	fb00 f202 	mul.w	r2, r0, r2
  401980:	429a      	cmp	r2, r3
  401982:	d902      	bls.n	40198a <hsmci_wait_end_of_write_blocks+0x62>
  401984:	e019      	b.n	4019ba <hsmci_wait_end_of_write_blocks+0x92>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  401986:	0693      	lsls	r3, r2, #26
  401988:	d417      	bmi.n	4019ba <hsmci_wait_end_of_write_blocks+0x92>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40198a:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40198c:	4b0c      	ldr	r3, [pc, #48]	; (4019c0 <hsmci_wait_end_of_write_blocks+0x98>)
  40198e:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401990:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401994:	2b00      	cmp	r3, #0
  401996:	d0f6      	beq.n	401986 <hsmci_wait_end_of_write_blocks+0x5e>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401998:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  40199a:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  40199c:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40199e:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4019a0:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4019a2:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4019a4:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  4019a6:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  4019a8:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  4019aa:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  4019ac:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  4019ae:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  4019b0:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  4019b2:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  4019b4:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  4019b6:	bcf0      	pop	{r4, r5, r6, r7}
  4019b8:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  4019ba:	2001      	movs	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  4019bc:	bcf0      	pop	{r4, r5, r6, r7}
  4019be:	4770      	bx	lr
  4019c0:	c0600000 	.word	0xc0600000
  4019c4:	20000e32 	.word	0x20000e32
  4019c8:	20000e30 	.word	0x20000e30
  4019cc:	20000e34 	.word	0x20000e34

004019d0 <rtc_set_hour_mode>:
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  4019d0:	6843      	ldr	r3, [r0, #4]
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  4019d2:	b919      	cbnz	r1, 4019dc <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  4019d4:	f023 0301 	bic.w	r3, r3, #1
  4019d8:	6043      	str	r3, [r0, #4]
  4019da:	4770      	bx	lr
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  4019dc:	f043 0301 	orr.w	r3, r3, #1
  4019e0:	6043      	str	r3, [r0, #4]
  4019e2:	4770      	bx	lr

004019e4 <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  4019e4:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  4019e6:	6884      	ldr	r4, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  4019e8:	6885      	ldr	r5, [r0, #8]
  4019ea:	42ac      	cmp	r4, r5
  4019ec:	d003      	beq.n	4019f6 <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  4019ee:	6884      	ldr	r4, [r0, #8]
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
	while (ul_time != p_rtc->RTC_TIMR) {
  4019f0:	6885      	ldr	r5, [r0, #8]
  4019f2:	42a5      	cmp	r5, r4
  4019f4:	d1fb      	bne.n	4019ee <rtc_get_time+0xa>
		ul_time = p_rtc->RTC_TIMR;
	}

	/* Hour */
	if (pul_hour) {
  4019f6:	b161      	cbz	r1, 401a12 <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
  4019f8:	f404 107c 	and.w	r0, r4, #4128768	; 0x3f0000
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4019fc:	0d05      	lsrs	r5, r0, #20
  4019fe:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  401a02:	f3c0 4003 	ubfx	r0, r0, #16, #4
  401a06:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  401a0a:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  401a0c:	bf48      	it	mi
  401a0e:	300c      	addmi	r0, #12
  401a10:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  401a12:	b14a      	cbz	r2, 401a28 <rtc_get_time+0x44>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
  401a14:	f404 41fe 	and.w	r1, r4, #32512	; 0x7f00
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  401a18:	0b08      	lsrs	r0, r1, #12
  401a1a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401a1e:	f3c1 2103 	ubfx	r1, r1, #8, #4
  401a22:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  401a26:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  401a28:	b143      	cbz	r3, 401a3c <rtc_get_time+0x58>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a2a:	f3c4 1202 	ubfx	r2, r4, #4, #3
  401a2e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  401a32:	f004 040f 	and.w	r4, r4, #15
  401a36:	eb04 0242 	add.w	r2, r4, r2, lsl #1
  401a3a:	601a      	str	r2, [r3, #0]
	}
}
  401a3c:	bc30      	pop	{r4, r5}
  401a3e:	4770      	bx	lr

00401a40 <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  401a40:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  401a42:	68c4      	ldr	r4, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  401a44:	68c5      	ldr	r5, [r0, #12]
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  401a46:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  401a48:	42ac      	cmp	r4, r5
  401a4a:	d003      	beq.n	401a54 <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  401a4c:	68c4      	ldr	r4, [r0, #12]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  401a4e:	68c5      	ldr	r5, [r0, #12]
  401a50:	42a5      	cmp	r5, r4
  401a52:	d1fb      	bne.n	401a4c <rtc_get_date+0xc>
		ul_date = p_rtc->RTC_CALR;
	}

	/* Retrieve year */
	if (pul_year) {
  401a54:	b1a1      	cbz	r1, 401a80 <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
  401a56:	f404 457f 	and.w	r5, r4, #65280	; 0xff00
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a5a:	0b2f      	lsrs	r7, r5, #12
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a5c:	f3c4 1002 	ubfx	r0, r4, #4, #3
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a60:	eb07 0c87 	add.w	ip, r7, r7, lsl #2
  401a64:	f3c5 2503 	ubfx	r5, r5, #8, #4
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a68:	f004 070f 	and.w	r7, r4, #15
  401a6c:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  401a70:	eb07 0040 	add.w	r0, r7, r0, lsl #1
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  401a74:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  401a78:	2764      	movs	r7, #100	; 0x64
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a7a:	fb07 5000 	mla	r0, r7, r0, r5
	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  401a7e:	6008      	str	r0, [r1, #0]
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
	}

	/* Retrieve month */
	if (pul_month) {
  401a80:	b14a      	cbz	r2, 401a96 <rtc_get_date+0x56>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
  401a82:	f404 10f8 	and.w	r0, r4, #2031616	; 0x1f0000
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a86:	0d01      	lsrs	r1, r0, #20
  401a88:	008d      	lsls	r5, r1, #2
  401a8a:	f3c0 4003 	ubfx	r0, r0, #16, #4
  401a8e:	4429      	add	r1, r5
  401a90:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  401a94:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  401a96:	b14b      	cbz	r3, 401aac <rtc_get_date+0x6c>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
  401a98:	f004 527c 	and.w	r2, r4, #1056964608	; 0x3f000000
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401a9c:	0f11      	lsrs	r1, r2, #28
  401a9e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  401aa2:	f3c2 6203 	ubfx	r2, r2, #24, #4
  401aa6:	eb02 0241 	add.w	r2, r2, r1, lsl #1
  401aaa:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  401aac:	b116      	cbz	r6, 401ab4 <rtc_get_date+0x74>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  401aae:	f3c4 5442 	ubfx	r4, r4, #21, #3
  401ab2:	6034      	str	r4, [r6, #0]
	}
}
  401ab4:	bcf0      	pop	{r4, r5, r6, r7}
  401ab6:	4770      	bx	lr

00401ab8 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  401ab8:	60c1      	str	r1, [r0, #12]
  401aba:	4770      	bx	lr

00401abc <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  401abc:	6940      	ldr	r0, [r0, #20]
}
  401abe:	4770      	bx	lr

00401ac0 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  401ac0:	6943      	ldr	r3, [r0, #20]
  401ac2:	079b      	lsls	r3, r3, #30
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  401ac4:	bf46      	itte	mi
  401ac6:	61c1      	strmi	r1, [r0, #28]
	return 0;
  401ac8:	2000      	movmi	r0, #0
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  401aca:	2001      	movpl	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  401acc:	4770      	bx	lr
  401ace:	bf00      	nop

00401ad0 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  401ad0:	6081      	str	r1, [r0, #8]
  401ad2:	4770      	bx	lr

00401ad4 <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  401ad4:	60c1      	str	r1, [r0, #12]
  401ad6:	4770      	bx	lr

00401ad8 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  401ad8:	6943      	ldr	r3, [r0, #20]
  401ada:	079b      	lsls	r3, r3, #30
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  401adc:	bf43      	ittte	mi
  401ade:	f3c1 0108 	ubfxmi	r1, r1, #0, #9
  401ae2:	61c1      	strmi	r1, [r0, #28]
	return 0;
  401ae4:	2000      	movmi	r0, #0
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  401ae6:	2001      	movpl	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  401ae8:	4770      	bx	lr
  401aea:	bf00      	nop

00401aec <usart_getchar>:
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	/* Wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  401aec:	6943      	ldr	r3, [r0, #20]
  401aee:	07db      	lsls	r3, r3, #31
  401af0:	d5fc      	bpl.n	401aec <usart_getchar>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  401af2:	6983      	ldr	r3, [r0, #24]
  401af4:	f3c3 0308 	ubfx	r3, r3, #0, #9
  401af8:	600b      	str	r3, [r1, #0]

	return 0;
}
  401afa:	2000      	movs	r0, #0
  401afc:	4770      	bx	lr
  401afe:	bf00      	nop

00401b00 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  401b00:	b538      	push	{r3, r4, r5, lr}
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  401b02:	2100      	movs	r1, #0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  401b04:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  401b06:	4b0b      	ldr	r3, [pc, #44]	; (401b34 <disk_initialize+0x34>)
  401b08:	480b      	ldr	r0, [pc, #44]	; (401b38 <disk_initialize+0x38>)
  401b0a:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  401b0c:	2c02      	cmp	r4, #2
  401b0e:	d807      	bhi.n	401b20 <disk_initialize+0x20>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  401b10:	4620      	mov	r0, r4
  401b12:	4d0a      	ldr	r5, [pc, #40]	; (401b3c <disk_initialize+0x3c>)
  401b14:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
  401b16:	2803      	cmp	r0, #3
  401b18:	d101      	bne.n	401b1e <disk_initialize+0x1e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  401b1a:	4620      	mov	r0, r4
  401b1c:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  401b1e:	b108      	cbz	r0, 401b24 <disk_initialize+0x24>
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  401b20:	2001      	movs	r0, #1
  401b22:	bd38      	pop	{r3, r4, r5, pc}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  401b24:	4620      	mov	r0, r4
  401b26:	4b06      	ldr	r3, [pc, #24]	; (401b40 <disk_initialize+0x40>)
  401b28:	4798      	blx	r3
  401b2a:	2800      	cmp	r0, #0
		return STA_PROTECT;
  401b2c:	bf0c      	ite	eq
  401b2e:	2000      	moveq	r0, #0
  401b30:	2004      	movne	r0, #4
	}

	/* The memory should already be initialized */
	return 0;
}
  401b32:	bd38      	pop	{r3, r4, r5, pc}
  401b34:	004019d1 	.word	0x004019d1
  401b38:	400e1460 	.word	0x400e1460
  401b3c:	004013a5 	.word	0x004013a5
  401b40:	004013e5 	.word	0x004013e5

00401b44 <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  401b44:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  401b46:	4b04      	ldr	r3, [pc, #16]	; (401b58 <disk_status+0x14>)
  401b48:	4798      	blx	r3
  401b4a:	b118      	cbz	r0, 401b54 <disk_status+0x10>
  401b4c:	2802      	cmp	r0, #2
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  401b4e:	bf0c      	ite	eq
  401b50:	2003      	moveq	r0, #3
  401b52:	2001      	movne	r0, #1
	}
}
  401b54:	bd08      	pop	{r3, pc}
  401b56:	bf00      	nop
  401b58:	004013a5 	.word	0x004013a5

00401b5c <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  401b5c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401b60:	4c18      	ldr	r4, [pc, #96]	; (401bc4 <disk_read+0x68>)
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  401b62:	b083      	sub	sp, #12
  401b64:	460e      	mov	r6, r1
  401b66:	4615      	mov	r5, r2
  401b68:	4698      	mov	r8, r3
  401b6a:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401b6c:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  401b6e:	4604      	mov	r4, r0
  401b70:	b918      	cbnz	r0, 401b7a <disk_read+0x1e>
		return RES_ERROR;
  401b72:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401b74:	b003      	add	sp, #12
  401b76:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  401b7a:	4b13      	ldr	r3, [pc, #76]	; (401bc8 <disk_read+0x6c>)
  401b7c:	4648      	mov	r0, r9
  401b7e:	a901      	add	r1, sp, #4
  401b80:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  401b82:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  401b84:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  401b88:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  401b8c:	442a      	add	r2, r5
  401b8e:	429a      	cmp	r2, r3
  401b90:	d903      	bls.n	401b9a <disk_read+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  401b92:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401b94:	b003      	add	sp, #12
  401b96:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  401b9a:	f1b8 0f00 	cmp.w	r8, #0
  401b9e:	d00f      	beq.n	401bc0 <disk_read+0x64>
  401ba0:	f8df b028 	ldr.w	fp, [pc, #40]	; 401bcc <disk_read+0x70>
  401ba4:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  401ba8:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  401baa:	4629      	mov	r1, r5
  401bac:	4632      	mov	r2, r6
  401bae:	4648      	mov	r0, r9
  401bb0:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  401bb2:	3701      	adds	r7, #1
  401bb4:	4425      	add	r5, r4
  401bb6:	4456      	add	r6, sl
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  401bb8:	2800      	cmp	r0, #0
  401bba:	d1da      	bne.n	401b72 <disk_read+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  401bbc:	4547      	cmp	r7, r8
  401bbe:	d3f4      	bcc.n	401baa <disk_read+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  401bc0:	2000      	movs	r0, #0
  401bc2:	e7d7      	b.n	401b74 <disk_read+0x18>
  401bc4:	004013d9 	.word	0x004013d9
  401bc8:	004013bd 	.word	0x004013bd
  401bcc:	00401401 	.word	0x00401401

00401bd0 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  401bd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401bd4:	4c18      	ldr	r4, [pc, #96]	; (401c38 <disk_write+0x68>)
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  401bd6:	b083      	sub	sp, #12
  401bd8:	460e      	mov	r6, r1
  401bda:	4615      	mov	r5, r2
  401bdc:	4698      	mov	r8, r3
  401bde:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  401be0:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  401be2:	4604      	mov	r4, r0
  401be4:	b918      	cbnz	r0, 401bee <disk_write+0x1e>
		return RES_ERROR;
  401be6:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401be8:	b003      	add	sp, #12
  401bea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  401bee:	4b13      	ldr	r3, [pc, #76]	; (401c3c <disk_write+0x6c>)
  401bf0:	4648      	mov	r0, r9
  401bf2:	a901      	add	r1, sp, #4
  401bf4:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  401bf6:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  401bf8:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  401bfc:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  401c00:	442a      	add	r2, r5
  401c02:	429a      	cmp	r2, r3
  401c04:	d903      	bls.n	401c0e <disk_write+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  401c06:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  401c08:	b003      	add	sp, #12
  401c0a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  401c0e:	f1b8 0f00 	cmp.w	r8, #0
  401c12:	d00f      	beq.n	401c34 <disk_write+0x64>
  401c14:	f8df b028 	ldr.w	fp, [pc, #40]	; 401c40 <disk_write+0x70>
  401c18:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  401c1c:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  401c1e:	4629      	mov	r1, r5
  401c20:	4632      	mov	r2, r6
  401c22:	4648      	mov	r0, r9
  401c24:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  401c26:	3701      	adds	r7, #1
  401c28:	4425      	add	r5, r4
  401c2a:	4456      	add	r6, sl
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  401c2c:	2800      	cmp	r0, #0
  401c2e:	d1da      	bne.n	401be6 <disk_write+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  401c30:	4547      	cmp	r7, r8
  401c32:	d3f4      	bcc.n	401c1e <disk_write+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  401c34:	2000      	movs	r0, #0
  401c36:	e7d7      	b.n	401be8 <disk_write+0x18>
  401c38:	004013d9 	.word	0x004013d9
  401c3c:	004013bd 	.word	0x004013bd
  401c40:	00401421 	.word	0x00401421

00401c44 <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  401c44:	b510      	push	{r4, lr}
  401c46:	4614      	mov	r4, r2
  401c48:	b082      	sub	sp, #8
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  401c4a:	2903      	cmp	r1, #3
  401c4c:	d829      	bhi.n	401ca2 <disk_ioctl+0x5e>
  401c4e:	e8df f001 	tbb	[pc, r1]
  401c52:	131c      	.short	0x131c
  401c54:	0207      	.short	0x0207
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  401c56:	2301      	movs	r3, #1
  401c58:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  401c5a:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  401c5c:	b002      	add	sp, #8
  401c5e:	bd10      	pop	{r4, pc}
	break;

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
  401c60:	4b11      	ldr	r3, [pc, #68]	; (401ca8 <disk_ioctl+0x64>)
  401c62:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
  401c64:	1e43      	subs	r3, r0, #1
  401c66:	b2db      	uxtb	r3, r3
  401c68:	2b01      	cmp	r3, #1
  401c6a:	d916      	bls.n	401c9a <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_1024) &&
  401c6c:	2804      	cmp	r0, #4
  401c6e:	d014      	beq.n	401c9a <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_2048) &&
  401c70:	2808      	cmp	r0, #8
  401c72:	d012      	beq.n	401c9a <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
  401c74:	2001      	movs	r0, #1
  401c76:	e7f1      	b.n	401c5c <disk_ioctl+0x18>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
  401c78:	a901      	add	r1, sp, #4
  401c7a:	4b0c      	ldr	r3, [pc, #48]	; (401cac <disk_ioctl+0x68>)
  401c7c:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
  401c7e:	9b01      	ldr	r3, [sp, #4]

		res = RES_OK;
  401c80:	2000      	movs	r0, #0
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);

		*(DWORD *)buff = ul_last_sector_num + 1;
  401c82:	3301      	adds	r3, #1
  401c84:	6023      	str	r3, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  401c86:	b002      	add	sp, #8
  401c88:	bd10      	pop	{r4, pc}
	}
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  401c8a:	4b09      	ldr	r3, [pc, #36]	; (401cb0 <disk_ioctl+0x6c>)
  401c8c:	4798      	blx	r3
			res = RES_OK;
  401c8e:	2800      	cmp	r0, #0
  401c90:	bf14      	ite	ne
  401c92:	2003      	movne	r0, #3
  401c94:	2000      	moveq	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  401c96:	b002      	add	sp, #8
  401c98:	bd10      	pop	{r4, pc}
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  401c9a:	2000      	movs	r0, #0
  401c9c:	7020      	strb	r0, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  401c9e:	b002      	add	sp, #8
  401ca0:	bd10      	pop	{r4, pc}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
  401ca2:	2004      	movs	r0, #4
  401ca4:	e7da      	b.n	401c5c <disk_ioctl+0x18>
  401ca6:	bf00      	nop
  401ca8:	004013d9 	.word	0x004013d9
  401cac:	004013bd 	.word	0x004013bd
  401cb0:	004013a5 	.word	0x004013a5

00401cb4 <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  401cb4:	b530      	push	{r4, r5, lr}
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  401cb6:	4c12      	ldr	r4, [pc, #72]	; (401d00 <get_fattime+0x4c>)
  401cb8:	4d12      	ldr	r5, [pc, #72]	; (401d04 <get_fattime+0x50>)
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  401cba:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  401cbc:	4620      	mov	r0, r4
  401cbe:	a903      	add	r1, sp, #12
  401cc0:	aa04      	add	r2, sp, #16
  401cc2:	ab05      	add	r3, sp, #20
  401cc4:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  401cc6:	ab09      	add	r3, sp, #36	; 0x24
  401cc8:	4620      	mov	r0, r4
  401cca:	9300      	str	r3, [sp, #0]
  401ccc:	a906      	add	r1, sp, #24
  401cce:	aa07      	add	r2, sp, #28
  401cd0:	ab08      	add	r3, sp, #32
  401cd2:	4c0d      	ldr	r4, [pc, #52]	; (401d08 <get_fattime+0x54>)
  401cd4:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  401cd6:	9d08      	ldr	r5, [sp, #32]
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  401cd8:	9c07      	ldr	r4, [sp, #28]
			| (ul_day << 16)
  401cda:	9805      	ldr	r0, [sp, #20]
			| (ul_hour << 11)
  401cdc:	9903      	ldr	r1, [sp, #12]
			| (ul_minute << 5)
  401cde:	9a04      	ldr	r2, [sp, #16]

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  401ce0:	9b06      	ldr	r3, [sp, #24]
			| (ul_month << 21)
			| (ul_day << 16)
  401ce2:	042d      	lsls	r5, r5, #16
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  401ce4:	ea45 5444 	orr.w	r4, r5, r4, lsl #21
			| (ul_day << 16)
  401ce8:	4320      	orrs	r0, r4
			| (ul_hour << 11)
  401cea:	ea40 21c1 	orr.w	r1, r0, r1, lsl #11
			| (ul_minute << 5)
  401cee:	ea41 1042 	orr.w	r0, r1, r2, lsl #5

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  401cf2:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| (ul_second << 0);

	return ul_time;
}
  401cf6:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
  401cfa:	b00b      	add	sp, #44	; 0x2c
  401cfc:	bd30      	pop	{r4, r5, pc}
  401cfe:	bf00      	nop
  401d00:	400e1460 	.word	0x400e1460
  401d04:	004019e5 	.word	0x004019e5
  401d08:	00401a41 	.word	0x00401a41

00401d0c <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dj,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  401d0c:	b470      	push	{r4, r5, r6}
  401d0e:	4a19      	ldr	r2, [pc, #100]	; (401d74 <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  401d10:	2600      	movs	r6, #0
  401d12:	4633      	mov	r3, r6
		if (Files[i].fs) {	/* Existing entry */
  401d14:	f852 4c08 	ldr.w	r4, [r2, #-8]
  401d18:	b174      	cbz	r4, 401d38 <chk_lock+0x2c>
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  401d1a:	6805      	ldr	r5, [r0, #0]
  401d1c:	42ac      	cmp	r4, r5
  401d1e:	d010      	beq.n	401d42 <chk_lock+0x36>
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  401d20:	3301      	adds	r3, #1
  401d22:	2b03      	cmp	r3, #3
  401d24:	f102 020c 	add.w	r2, r2, #12
  401d28:	d1f4      	bne.n	401d14 <chk_lock+0x8>
		} else {			/* Blank entry */
			be++;
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  401d2a:	b93e      	cbnz	r6, 401d3c <chk_lock+0x30>
  401d2c:	2902      	cmp	r1, #2
  401d2e:	bf14      	ite	ne
  401d30:	2012      	movne	r0, #18
  401d32:	2000      	moveq	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  401d34:	bc70      	pop	{r4, r5, r6}
  401d36:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
				Files[i].clu == dj->sclust &&
				Files[i].idx == dj->index) break;
		} else {			/* Blank entry */
			be++;
  401d38:	3601      	adds	r6, #1
  401d3a:	e7f1      	b.n	401d20 <chk_lock+0x14>
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  401d3c:	2000      	movs	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  401d3e:	bc70      	pop	{r4, r5, r6}
  401d40:	4770      	bx	lr
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  401d42:	f852 5c04 	ldr.w	r5, [r2, #-4]
  401d46:	6884      	ldr	r4, [r0, #8]
  401d48:	42a5      	cmp	r5, r4
  401d4a:	d1e9      	bne.n	401d20 <chk_lock+0x14>
				Files[i].clu == dj->sclust &&
  401d4c:	8815      	ldrh	r5, [r2, #0]
  401d4e:	88c4      	ldrh	r4, [r0, #6]
  401d50:	42a5      	cmp	r5, r4
  401d52:	d1e5      	bne.n	401d20 <chk_lock+0x14>
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  401d54:	b109      	cbz	r1, 401d5a <chk_lock+0x4e>
  401d56:	2010      	movs	r0, #16
  401d58:	e7ec      	b.n	401d34 <chk_lock+0x28>
  401d5a:	4a07      	ldr	r2, [pc, #28]	; (401d78 <chk_lock+0x6c>)
  401d5c:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  401d60:	eb02 0383 	add.w	r3, r2, r3, lsl #2
}
  401d64:	bc70      	pop	{r4, r5, r6}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  401d66:	895b      	ldrh	r3, [r3, #10]
  401d68:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  401d6c:	bf14      	ite	ne
  401d6e:	2000      	movne	r0, #0
  401d70:	2010      	moveq	r0, #16
}
  401d72:	4770      	bx	lr
  401d74:	20000e44 	.word	0x20000e44
  401d78:	20000e3c 	.word	0x20000e3c

00401d7c <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  401d7c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD wsect;


	wsect = fs->winsect;
  401d80:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  401d82:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  401d84:	4604      	mov	r4, r0
  401d86:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  401d88:	d002      	beq.n	401d90 <move_window+0x14>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  401d8a:	7903      	ldrb	r3, [r0, #4]
  401d8c:	b973      	cbnz	r3, 401dac <move_window+0x30>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  401d8e:	b916      	cbnz	r6, 401d96 <move_window+0x1a>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
  401d90:	2000      	movs	r0, #0
  401d92:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  401d96:	7860      	ldrb	r0, [r4, #1]
  401d98:	4d17      	ldr	r5, [pc, #92]	; (401df8 <move_window+0x7c>)
  401d9a:	f104 0130 	add.w	r1, r4, #48	; 0x30
  401d9e:	4632      	mov	r2, r6
  401da0:	2301      	movs	r3, #1
  401da2:	47a8      	blx	r5
  401da4:	bb20      	cbnz	r0, 401df0 <move_window+0x74>
				return FR_DISK_ERR;
			fs->winsect = sector;
  401da6:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
  401da8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  401dac:	f100 0830 	add.w	r8, r0, #48	; 0x30
  401db0:	4641      	mov	r1, r8
  401db2:	7840      	ldrb	r0, [r0, #1]
  401db4:	f8df 9044 	ldr.w	r9, [pc, #68]	; 401dfc <move_window+0x80>
  401db8:	462a      	mov	r2, r5
  401dba:	2301      	movs	r3, #1
  401dbc:	47c8      	blx	r9
  401dbe:	b9b8      	cbnz	r0, 401df0 <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  401dc0:	69e3      	ldr	r3, [r4, #28]
  401dc2:	6a22      	ldr	r2, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  401dc4:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  401dc6:	441a      	add	r2, r3
  401dc8:	4295      	cmp	r5, r2
  401dca:	d2e0      	bcs.n	401d8e <move_window+0x12>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  401dcc:	78e7      	ldrb	r7, [r4, #3]
  401dce:	2f01      	cmp	r7, #1
  401dd0:	d801      	bhi.n	401dd6 <move_window+0x5a>
  401dd2:	e7dc      	b.n	401d8e <move_window+0x12>
  401dd4:	69e3      	ldr	r3, [r4, #28]
					wsect += fs->fsize;
  401dd6:	441d      	add	r5, r3
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  401dd8:	3f01      	subs	r7, #1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  401dda:	462a      	mov	r2, r5
  401ddc:	7860      	ldrb	r0, [r4, #1]
  401dde:	4641      	mov	r1, r8
  401de0:	2301      	movs	r3, #1
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  401de2:	b2ff      	uxtb	r7, r7
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  401de4:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  401de6:	2f01      	cmp	r7, #1
  401de8:	d1f4      	bne.n	401dd4 <move_window+0x58>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  401dea:	2e00      	cmp	r6, #0
  401dec:	d0d0      	beq.n	401d90 <move_window+0x14>
  401dee:	e7d2      	b.n	401d96 <move_window+0x1a>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
  401df0:	2001      	movs	r0, #1
  401df2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  401df6:	bf00      	nop
  401df8:	00401b5d 	.word	0x00401b5d
  401dfc:	00401bd1 	.word	0x00401bd1

00401e00 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  401e00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;


	res = move_window(fs, 0);
  401e04:	2100      	movs	r1, #0
  401e06:	4b31      	ldr	r3, [pc, #196]	; (401ecc <sync+0xcc>)
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  401e08:	4605      	mov	r5, r0
	FRESULT res;


	res = move_window(fs, 0);
  401e0a:	4798      	blx	r3
  401e0c:	4603      	mov	r3, r0
	if (res == FR_OK) {
  401e0e:	b950      	cbnz	r0, 401e26 <sync+0x26>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  401e10:	782b      	ldrb	r3, [r5, #0]
  401e12:	2b03      	cmp	r3, #3
  401e14:	d00a      	beq.n	401e2c <sync+0x2c>
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  401e16:	2100      	movs	r1, #0
  401e18:	4b2d      	ldr	r3, [pc, #180]	; (401ed0 <sync+0xd0>)
  401e1a:	7868      	ldrb	r0, [r5, #1]
  401e1c:	460a      	mov	r2, r1
  401e1e:	4798      	blx	r3
  401e20:	1c03      	adds	r3, r0, #0
  401e22:	bf18      	it	ne
  401e24:	2301      	movne	r3, #1
			res = FR_DISK_ERR;
	}

	return res;
}
  401e26:	4618      	mov	r0, r3
  401e28:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  401e2c:	796b      	ldrb	r3, [r5, #5]
  401e2e:	2b00      	cmp	r3, #0
  401e30:	d0f1      	beq.n	401e16 <sync+0x16>
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  401e32:	f105 0130 	add.w	r1, r5, #48	; 0x30

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
  401e36:	62e8      	str	r0, [r5, #44]	; 0x2c
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  401e38:	460b      	mov	r3, r1
  401e3a:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  401e3e:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  401e42:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
  401e44:	f04f 0400 	mov.w	r4, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  401e48:	d1f9      	bne.n	401e3e <sync+0x3e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  401e4a:	692a      	ldr	r2, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  401e4c:	68eb      	ldr	r3, [r5, #12]
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  401e4e:	f885 2218 	strb.w	r2, [r5, #536]	; 0x218
  401e52:	f3c2 2b07 	ubfx	fp, r2, #8, #8
  401e56:	ea4f 4a12 	mov.w	sl, r2, lsr #16
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  401e5a:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  401e5e:	ea4f 6e13 	mov.w	lr, r3, lsr #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  401e62:	2052      	movs	r0, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  401e64:	ea4f 6912 	mov.w	r9, r2, lsr #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  401e68:	f3c3 2807 	ubfx	r8, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  401e6c:	2261      	movs	r2, #97	; 0x61
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  401e6e:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  401e70:	f885 b219 	strb.w	fp, [r5, #537]	; 0x219
  401e74:	f885 a21a 	strb.w	sl, [r5, #538]	; 0x21a
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  401e78:	f04f 0b41 	mov.w	fp, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  401e7c:	f04f 0a72 	mov.w	sl, #114	; 0x72
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  401e80:	2755      	movs	r7, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  401e82:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  401e86:	f885 622f 	strb.w	r6, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  401e8a:	f885 0030 	strb.w	r0, [r5, #48]	; 0x30
  401e8e:	f885 0031 	strb.w	r0, [r5, #49]	; 0x31
  401e92:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  401e96:	f885 2217 	strb.w	r2, [r5, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  401e9a:	f885 921b 	strb.w	r9, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  401e9e:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
  401ea2:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
  401ea6:	f885 e21f 	strb.w	lr, [r5, #543]	; 0x21f
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  401eaa:	f885 722e 	strb.w	r7, [r5, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  401eae:	f885 b033 	strb.w	fp, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  401eb2:	f885 b216 	strb.w	fp, [r5, #534]	; 0x216
  401eb6:	f885 a214 	strb.w	sl, [r5, #532]	; 0x214
  401eba:	f885 a215 	strb.w	sl, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  401ebe:	7868      	ldrb	r0, [r5, #1]
  401ec0:	696a      	ldr	r2, [r5, #20]
  401ec2:	4e04      	ldr	r6, [pc, #16]	; (401ed4 <sync+0xd4>)
  401ec4:	2301      	movs	r3, #1
  401ec6:	47b0      	blx	r6
			fs->fsi_flag = 0;
  401ec8:	716c      	strb	r4, [r5, #5]
  401eca:	e7a4      	b.n	401e16 <sync+0x16>
  401ecc:	00401d7d 	.word	0x00401d7d
  401ed0:	00401c45 	.word	0x00401c45
  401ed4:	00401bd1 	.word	0x00401bd1

00401ed8 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  401ed8:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  401eda:	b108      	cbz	r0, 401ee0 <validate+0x8>
  401edc:	7803      	ldrb	r3, [r0, #0]
  401ede:	b90b      	cbnz	r3, 401ee4 <validate+0xc>
		return FR_INVALID_OBJECT;
  401ee0:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  401ee2:	bd08      	pop	{r3, pc}
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  401ee4:	88c3      	ldrh	r3, [r0, #6]
  401ee6:	428b      	cmp	r3, r1
  401ee8:	d1fa      	bne.n	401ee0 <validate+0x8>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  401eea:	4b04      	ldr	r3, [pc, #16]	; (401efc <validate+0x24>)
  401eec:	7840      	ldrb	r0, [r0, #1]
  401eee:	4798      	blx	r3
  401ef0:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
  401ef4:	bf0c      	ite	eq
  401ef6:	2000      	moveq	r0, #0
  401ef8:	2003      	movne	r0, #3
  401efa:	bd08      	pop	{r3, pc}
  401efc:	00401b45 	.word	0x00401b45

00401f00 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  401f00:	b570      	push	{r4, r5, r6, lr}
  401f02:	4604      	mov	r4, r0
  401f04:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  401f06:	7840      	ldrb	r0, [r0, #1]
  401f08:	4d1d      	ldr	r5, [pc, #116]	; (401f80 <check_fs+0x80>)
  401f0a:	f104 0130 	add.w	r1, r4, #48	; 0x30
  401f0e:	2301      	movs	r3, #1
  401f10:	47a8      	blx	r5
  401f12:	b108      	cbz	r0, 401f18 <check_fs+0x18>
		return 3;
  401f14:	2003      	movs	r0, #3
  401f16:	bd70      	pop	{r4, r5, r6, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  401f18:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  401f1c:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
  401f20:	4b18      	ldr	r3, [pc, #96]	; (401f84 <check_fs+0x84>)
  401f22:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  401f26:	b212      	sxth	r2, r2
  401f28:	429a      	cmp	r2, r3
  401f2a:	d001      	beq.n	401f30 <check_fs+0x30>
		return 2;
  401f2c:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  401f2e:	bd70      	pop	{r4, r5, r6, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  401f30:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  401f34:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
  401f38:	f894 5066 	ldrb.w	r5, [r4, #102]	; 0x66
  401f3c:	f894 1067 	ldrb.w	r1, [r4, #103]	; 0x67
  401f40:	4b11      	ldr	r3, [pc, #68]	; (401f88 <check_fs+0x88>)
  401f42:	0412      	lsls	r2, r2, #16
  401f44:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
  401f48:	432a      	orrs	r2, r5
  401f4a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  401f4e:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  401f52:	429a      	cmp	r2, r3
  401f54:	d0eb      	beq.n	401f2e <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  401f56:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
  401f5a:	f894 5085 	ldrb.w	r5, [r4, #133]	; 0x85
  401f5e:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  401f62:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
  401f66:	0412      	lsls	r2, r2, #16
  401f68:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  401f6c:	430a      	orrs	r2, r1
  401f6e:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  401f72:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
  401f76:	1ac0      	subs	r0, r0, r3
  401f78:	bf18      	it	ne
  401f7a:	2001      	movne	r0, #1
  401f7c:	bd70      	pop	{r4, r5, r6, pc}
  401f7e:	bf00      	nop
  401f80:	00401b5d 	.word	0x00401b5d
  401f84:	ffffaa55 	.word	0xffffaa55
  401f88:	00544146 	.word	0x00544146

00401f8c <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  401f8c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  401f90:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  401f92:	781c      	ldrb	r4, [r3, #0]
  401f94:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  401f96:	2c09      	cmp	r4, #9
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  401f98:	4615      	mov	r5, r2
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  401f9a:	d802      	bhi.n	401fa2 <chk_mounted+0x16>
  401f9c:	785a      	ldrb	r2, [r3, #1]
  401f9e:	2a3a      	cmp	r2, #58	; 0x3a
  401fa0:	d015      	beq.n	401fce <chk_mounted+0x42>
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  401fa2:	4bbd      	ldr	r3, [pc, #756]	; (402298 <chk_mounted+0x30c>)
  401fa4:	681c      	ldr	r4, [r3, #0]
  401fa6:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  401fa8:	b174      	cbz	r4, 401fc8 <chk_mounted+0x3c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  401faa:	7823      	ldrb	r3, [r4, #0]
  401fac:	b1b3      	cbz	r3, 401fdc <chk_mounted+0x50>
		stat = disk_status(fs->drv);
  401fae:	4bbb      	ldr	r3, [pc, #748]	; (40229c <chk_mounted+0x310>)
  401fb0:	7860      	ldrb	r0, [r4, #1]
  401fb2:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  401fb4:	07c3      	lsls	r3, r0, #31
  401fb6:	d411      	bmi.n	401fdc <chk_mounted+0x50>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  401fb8:	b305      	cbz	r5, 401ffc <chk_mounted+0x70>
				return FR_WRITE_PROTECTED;
  401fba:	f010 0f04 	tst.w	r0, #4
  401fbe:	bf0c      	ite	eq
  401fc0:	2000      	moveq	r0, #0
  401fc2:	200a      	movne	r0, #10
  401fc4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  401fc8:	200c      	movs	r0, #12
  401fca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
  401fce:	3302      	adds	r3, #2
  401fd0:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  401fd2:	2c00      	cmp	r4, #0
  401fd4:	d0e5      	beq.n	401fa2 <chk_mounted+0x16>
		return FR_INVALID_DRIVE;
  401fd6:	200b      	movs	r0, #11
  401fd8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  401fdc:	2000      	movs	r0, #0
  401fde:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  401fe0:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  401fe2:	4baf      	ldr	r3, [pc, #700]	; (4022a0 <chk_mounted+0x314>)
  401fe4:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  401fe6:	07c7      	lsls	r7, r0, #31
  401fe8:	d502      	bpl.n	401ff0 <chk_mounted+0x64>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  401fea:	2003      	movs	r0, #3
  401fec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  401ff0:	b13d      	cbz	r5, 402002 <chk_mounted+0x76>
  401ff2:	0746      	lsls	r6, r0, #29
  401ff4:	d505      	bpl.n	402002 <chk_mounted+0x76>
		return FR_WRITE_PROTECTED;
  401ff6:	200a      	movs	r0, #10
  401ff8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  401ffc:	4628      	mov	r0, r5
  401ffe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  402002:	4620      	mov	r0, r4
  402004:	2100      	movs	r1, #0
  402006:	4da7      	ldr	r5, [pc, #668]	; (4022a4 <chk_mounted+0x318>)
  402008:	47a8      	blx	r5
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  40200a:	2801      	cmp	r0, #1
  40200c:	d007      	beq.n	40201e <chk_mounted+0x92>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  40200e:	2600      	movs	r6, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  402010:	2803      	cmp	r0, #3
  402012:	f000 80bf 	beq.w	402194 <chk_mounted+0x208>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  402016:	b1c0      	cbz	r0, 40204a <chk_mounted+0xbe>
  402018:	200d      	movs	r0, #13
  40201a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  40201e:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
  402022:	2b00      	cmp	r3, #0
  402024:	d0f8      	beq.n	402018 <chk_mounted+0x8c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  402026:	f894 21f8 	ldrb.w	r2, [r4, #504]	; 0x1f8
  40202a:	f894 11f9 	ldrb.w	r1, [r4, #505]	; 0x1f9
  40202e:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
  402032:	f894 61f7 	ldrb.w	r6, [r4, #503]	; 0x1f7
  402036:	0412      	lsls	r2, r2, #16
  402038:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  40203c:	4313      	orrs	r3, r2
  40203e:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  402042:	4631      	mov	r1, r6
  402044:	4620      	mov	r0, r4
  402046:	47a8      	blx	r5
  402048:	e7e2      	b.n	402010 <chk_mounted+0x84>
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  40204a:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  40204e:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  402052:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  402056:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40205a:	d1dd      	bne.n	402018 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  40205c:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  402060:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  402064:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
  402068:	d10d      	bne.n	402086 <chk_mounted+0xfa>
  40206a:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
  40206e:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
  402072:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  402076:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
  40207a:	0412      	lsls	r2, r2, #16
  40207c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  402080:	4313      	orrs	r3, r2
  402082:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  402086:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  40208a:	61e1      	str	r1, [r4, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  40208c:	1e43      	subs	r3, r0, #1
  40208e:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  402090:	70e0      	strb	r0, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402092:	d8c1      	bhi.n	402018 <chk_mounted+0x8c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  402094:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
  402098:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  40209a:	2b00      	cmp	r3, #0
  40209c:	d0bc      	beq.n	402018 <chk_mounted+0x8c>
  40209e:	1e5a      	subs	r2, r3, #1
  4020a0:	421a      	tst	r2, r3
  4020a2:	d1b9      	bne.n	402018 <chk_mounted+0x8c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  4020a4:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
  4020a8:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  4020ac:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  4020b0:	0715      	lsls	r5, r2, #28
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  4020b2:	8122      	strh	r2, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  4020b4:	d1b0      	bne.n	402018 <chk_mounted+0x8c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  4020b6:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
  4020ba:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  4020be:	ea55 2507 	orrs.w	r5, r5, r7, lsl #8
  4020c2:	d10f      	bne.n	4020e4 <chk_mounted+0x158>
  4020c4:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
  4020c8:	f894 8053 	ldrb.w	r8, [r4, #83]	; 0x53
  4020cc:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
  4020d0:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  4020d4:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  4020d8:	ea4c 6c08 	orr.w	ip, ip, r8, lsl #24
  4020dc:	ea4c 0505 	orr.w	r5, ip, r5
  4020e0:	ea45 2507 	orr.w	r5, r5, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  4020e4:	f894 c03f 	ldrb.w	ip, [r4, #63]	; 0x3f
  4020e8:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  4020ec:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  4020f0:	d092      	beq.n	402018 <chk_mounted+0x8c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  4020f2:	fb00 fc01 	mul.w	ip, r0, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  4020f6:	eb07 1012 	add.w	r0, r7, r2, lsr #4
  4020fa:	4460      	add	r0, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  4020fc:	4285      	cmp	r5, r0
  4020fe:	d38b      	bcc.n	402018 <chk_mounted+0x8c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  402100:	1a2d      	subs	r5, r5, r0
  402102:	fbb5 f3f3 	udiv	r3, r5, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  402106:	2b00      	cmp	r3, #0
  402108:	d086      	beq.n	402018 <chk_mounted+0x8c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  40210a:	f640 75f5 	movw	r5, #4085	; 0xff5
  40210e:	42ab      	cmp	r3, r5
  402110:	f240 80c0 	bls.w	402294 <chk_mounted+0x308>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402114:	f64f 75f5 	movw	r5, #65525	; 0xfff5
  402118:	42ab      	cmp	r3, r5
  40211a:	f200 80a0 	bhi.w	40225e <chk_mounted+0x2d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  40211e:	2502      	movs	r5, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402120:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  402122:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402124:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402126:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402128:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  40212a:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  40212c:	2a00      	cmp	r2, #0
  40212e:	f43f af73 	beq.w	402018 <chk_mounted+0x8c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  402132:	4467      	add	r7, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402134:	2d02      	cmp	r5, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  402136:	6267      	str	r7, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402138:	f000 808f 	beq.w	40225a <chk_mounted+0x2ce>
  40213c:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  402140:	f003 0301 	and.w	r3, r3, #1
  402144:	eb03 0352 	add.w	r3, r3, r2, lsr #1
  402148:	2501      	movs	r5, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  40214a:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  40214e:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
  402152:	f4ff af61 	bcc.w	402018 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  402156:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
  40215a:	2300      	movs	r3, #0

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  40215c:	2d03      	cmp	r5, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  40215e:	6122      	str	r2, [r4, #16]
	fs->last_clust = 0;
  402160:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  402162:	d01a      	beq.n	40219a <chk_mounted+0x20e>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402164:	4e50      	ldr	r6, [pc, #320]	; (4022a8 <chk_mounted+0x31c>)
  402166:	4951      	ldr	r1, [pc, #324]	; (4022ac <chk_mounted+0x320>)
  402168:	8830      	ldrh	r0, [r6, #0]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  40216a:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  40216c:	3001      	adds	r0, #1
	fs->winsect = 0;		/* Invalidate sector cache */
  40216e:	2200      	movs	r2, #0
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402170:	b280      	uxth	r0, r0
  402172:	8030      	strh	r0, [r6, #0]
  402174:	80e0      	strh	r0, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
  402176:	4613      	mov	r3, r2
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
	fs->winsect = 0;		/* Invalidate sector cache */
  402178:	62e2      	str	r2, [r4, #44]	; 0x2c
	fs->wflag = 0;
  40217a:	7122      	strb	r2, [r4, #4]
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  40217c:	4615      	mov	r5, r2
  40217e:	4608      	mov	r0, r1
  402180:	58ca      	ldr	r2, [r1, r3]
  402182:	4294      	cmp	r4, r2
  402184:	bf08      	it	eq
  402186:	501d      	streq	r5, [r3, r0]
  402188:	330c      	adds	r3, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  40218a:	2b24      	cmp	r3, #36	; 0x24
  40218c:	d1f8      	bne.n	402180 <chk_mounted+0x1f4>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  40218e:	2000      	movs	r0, #0
  402190:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  402194:	2001      	movs	r0, #1
  402196:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  40219a:	f894 1061 	ldrb.w	r1, [r4, #97]	; 0x61
  40219e:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
  4021a2:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  4021a4:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4021a8:	4432      	add	r2, r6
  4021aa:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4021ac:	7860      	ldrb	r0, [r4, #1]
  4021ae:	4e40      	ldr	r6, [pc, #256]	; (4022b0 <chk_mounted+0x324>)
  4021b0:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4021b4:	2301      	movs	r3, #1
  4021b6:	47b0      	blx	r6
  4021b8:	2800      	cmp	r0, #0
  4021ba:	d1d3      	bne.n	402164 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4021bc:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  4021c0:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4021c4:	4b3b      	ldr	r3, [pc, #236]	; (4022b4 <chk_mounted+0x328>)
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4021c6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4021ca:	b212      	sxth	r2, r2
  4021cc:	429a      	cmp	r2, r3
  4021ce:	d1c9      	bne.n	402164 <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4021d0:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
  4021d4:	f894 6033 	ldrb.w	r6, [r4, #51]	; 0x33
  4021d8:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  4021dc:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4021e0:	4b35      	ldr	r3, [pc, #212]	; (4022b8 <chk_mounted+0x32c>)
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4021e2:	0400      	lsls	r0, r0, #16
  4021e4:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
  4021e8:	4302      	orrs	r2, r0
  4021ea:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4021ee:	429a      	cmp	r2, r3
  4021f0:	d1b8      	bne.n	402164 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4021f2:	f894 0216 	ldrb.w	r0, [r4, #534]	; 0x216
  4021f6:	f894 6217 	ldrb.w	r6, [r4, #535]	; 0x217
  4021fa:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
  4021fe:	f894 1215 	ldrb.w	r1, [r4, #533]	; 0x215
  402202:	0400      	lsls	r0, r0, #16
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402204:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402208:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  40220c:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402210:	4302      	orrs	r2, r0
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402212:	3320      	adds	r3, #32
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402214:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402218:	429a      	cmp	r2, r3
  40221a:	d1a3      	bne.n	402164 <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40221c:	f894 721e 	ldrb.w	r7, [r4, #542]	; 0x21e
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402220:	f894 621a 	ldrb.w	r6, [r4, #538]	; 0x21a
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402224:	f894 821f 	ldrb.w	r8, [r4, #543]	; 0x21f
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402228:	f894 c21b 	ldrb.w	ip, [r4, #539]	; 0x21b
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40222c:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402230:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402234:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402238:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40223c:	043f      	lsls	r7, r7, #16
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40223e:	0436      	lsls	r6, r6, #16
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402240:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402244:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402248:	433a      	orrs	r2, r7
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40224a:	4333      	orrs	r3, r6
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40224c:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402250:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402254:	60e2      	str	r2, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402256:	6123      	str	r3, [r4, #16]
  402258:	e784      	b.n	402164 <chk_mounted+0x1d8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  40225a:	005b      	lsls	r3, r3, #1
  40225c:	e775      	b.n	40214a <chk_mounted+0x1be>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  40225e:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  402260:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402262:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402264:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402266:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402268:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  40226a:	2a00      	cmp	r2, #0
  40226c:	f47f aed4 	bne.w	402018 <chk_mounted+0x8c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402270:	f894 505e 	ldrb.w	r5, [r4, #94]	; 0x5e
  402274:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
  402278:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  40227c:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  402280:	042d      	lsls	r5, r5, #16
  402282:	ea45 6507 	orr.w	r5, r5, r7, lsl #24
  402286:	432a      	orrs	r2, r5
  402288:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  40228c:	009b      	lsls	r3, r3, #2
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  40228e:	6262      	str	r2, [r4, #36]	; 0x24
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402290:	2503      	movs	r5, #3
  402292:	e75a      	b.n	40214a <chk_mounted+0x1be>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
  402294:	2501      	movs	r5, #1
  402296:	e743      	b.n	402120 <chk_mounted+0x194>
  402298:	20000e60 	.word	0x20000e60
  40229c:	00401b45 	.word	0x00401b45
  4022a0:	00401b01 	.word	0x00401b01
  4022a4:	00401f01 	.word	0x00401f01
  4022a8:	20000e38 	.word	0x20000e38
  4022ac:	20000e3c 	.word	0x20000e3c
  4022b0:	00401b5d 	.word	0x00401b5d
  4022b4:	ffffaa55 	.word	0xffffaa55
  4022b8:	41615252 	.word	0x41615252

004022bc <get_fat.part.3>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  4022bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  4022c0:	7803      	ldrb	r3, [r0, #0]
  4022c2:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  4022c4:	4604      	mov	r4, r0
  4022c6:	460d      	mov	r5, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  4022c8:	d048      	beq.n	40235c <get_fat.part.3+0xa0>
  4022ca:	2b03      	cmp	r3, #3
  4022cc:	d029      	beq.n	402322 <get_fat.part.3+0x66>
  4022ce:	2b01      	cmp	r3, #1
  4022d0:	d003      	beq.n	4022da <get_fat.part.3+0x1e>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  4022d2:	f04f 30ff 	mov.w	r0, #4294967295
}
  4022d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4022da:	6a01      	ldr	r1, [r0, #32]
  4022dc:	4f29      	ldr	r7, [pc, #164]	; (402384 <get_fat.part.3+0xc8>)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  4022de:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4022e2:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4022e6:	47b8      	blx	r7
  4022e8:	2800      	cmp	r0, #0
  4022ea:	d1f2      	bne.n	4022d2 <get_fat.part.3+0x16>
		wc = fs->win[bc % SS(fs)]; bc++;
  4022ec:	f3c6 0308 	ubfx	r3, r6, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4022f0:	6a21      	ldr	r1, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4022f2:	4423      	add	r3, r4
  4022f4:	3601      	adds	r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4022f6:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4022fa:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4022fc:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402300:	47b8      	blx	r7
  402302:	2800      	cmp	r0, #0
  402304:	d1e5      	bne.n	4022d2 <get_fat.part.3+0x16>
		wc |= fs->win[bc % SS(fs)] << 8;
  402306:	f3c6 0608 	ubfx	r6, r6, #0, #9
  40230a:	4434      	add	r4, r6
  40230c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402310:	ea48 2003 	orr.w	r0, r8, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402314:	07eb      	lsls	r3, r5, #31
  402316:	bf4c      	ite	mi
  402318:	0900      	lsrmi	r0, r0, #4
  40231a:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  40231e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  402322:	6a01      	ldr	r1, [r0, #32]
  402324:	4b17      	ldr	r3, [pc, #92]	; (402384 <get_fat.part.3+0xc8>)
  402326:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  40232a:	4798      	blx	r3
  40232c:	2800      	cmp	r0, #0
  40232e:	d1d0      	bne.n	4022d2 <get_fat.part.3+0x16>
		p = &fs->win[clst * 4 % SS(fs)];
  402330:	00ad      	lsls	r5, r5, #2
  402332:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402336:	f105 0330 	add.w	r3, r5, #48	; 0x30
  40233a:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
  40233c:	442c      	add	r4, r5
  40233e:	78d8      	ldrb	r0, [r3, #3]
  402340:	7899      	ldrb	r1, [r3, #2]
  402342:	785a      	ldrb	r2, [r3, #1]
  402344:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402348:	0600      	lsls	r0, r0, #24
  40234a:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  40234e:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
  402352:	4318      	orrs	r0, r3
  402354:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402358:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  40235c:	6a01      	ldr	r1, [r0, #32]
  40235e:	4b09      	ldr	r3, [pc, #36]	; (402384 <get_fat.part.3+0xc8>)
  402360:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402364:	4798      	blx	r3
  402366:	2800      	cmp	r0, #0
  402368:	d1b3      	bne.n	4022d2 <get_fat.part.3+0x16>
		p = &fs->win[clst * 2 % SS(fs)];
  40236a:	006d      	lsls	r5, r5, #1
  40236c:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
  402370:	1963      	adds	r3, r4, r5
  402372:	461c      	mov	r4, r3
  402374:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  402378:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
  40237c:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402380:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402384:	00401d7d 	.word	0x00401d7d

00402388 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  40238a:	6883      	ldr	r3, [r0, #8]
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  40238c:	4604      	mov	r4, r0
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  40238e:	2b01      	cmp	r3, #1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402390:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  402392:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402394:	d003      	beq.n	40239e <dir_sdi+0x16>
  402396:	6800      	ldr	r0, [r0, #0]
  402398:	6982      	ldr	r2, [r0, #24]
  40239a:	4293      	cmp	r3, r2
  40239c:	d301      	bcc.n	4023a2 <dir_sdi+0x1a>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  40239e:	2002      	movs	r0, #2
  4023a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  4023a2:	b9b3      	cbnz	r3, 4023d2 <dir_sdi+0x4a>
  4023a4:	7803      	ldrb	r3, [r0, #0]
  4023a6:	2b03      	cmp	r3, #3
  4023a8:	d010      	beq.n	4023cc <dir_sdi+0x44>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  4023aa:	2300      	movs	r3, #0
  4023ac:	60e3      	str	r3, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  4023ae:	8903      	ldrh	r3, [r0, #8]
  4023b0:	42ab      	cmp	r3, r5
  4023b2:	d9f4      	bls.n	40239e <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  4023b4:	6a43      	ldr	r3, [r0, #36]	; 0x24
  4023b6:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  4023ba:	6123      	str	r3, [r4, #16]
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  4023bc:	f005 050f 	and.w	r5, r5, #15
  4023c0:	eb00 1045 	add.w	r0, r0, r5, lsl #5
  4023c4:	3030      	adds	r0, #48	; 0x30
  4023c6:	6160      	str	r0, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  4023c8:	2000      	movs	r0, #0
  4023ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;
  4023cc:	6a43      	ldr	r3, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  4023ce:	2b00      	cmp	r3, #0
  4023d0:	d0eb      	beq.n	4023aa <dir_sdi+0x22>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  4023d2:	7886      	ldrb	r6, [r0, #2]
  4023d4:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  4023d6:	42b5      	cmp	r5, r6
  4023d8:	d319      	bcc.n	40240e <dir_sdi+0x86>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4023da:	2b01      	cmp	r3, #1
  4023dc:	d9df      	bls.n	40239e <dir_sdi+0x16>
  4023de:	1bad      	subs	r5, r5, r6
  4023e0:	429a      	cmp	r2, r3
  4023e2:	b2ad      	uxth	r5, r5
  4023e4:	d9db      	bls.n	40239e <dir_sdi+0x16>
  4023e6:	4f11      	ldr	r7, [pc, #68]	; (40242c <dir_sdi+0xa4>)
  4023e8:	e008      	b.n	4023fc <dir_sdi+0x74>
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  4023ea:	2801      	cmp	r0, #1
  4023ec:	d9d7      	bls.n	40239e <dir_sdi+0x16>
  4023ee:	6820      	ldr	r0, [r4, #0]
  4023f0:	6982      	ldr	r2, [r0, #24]
  4023f2:	429a      	cmp	r2, r3
  4023f4:	d9d3      	bls.n	40239e <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  4023f6:	42ae      	cmp	r6, r5
  4023f8:	d809      	bhi.n	40240e <dir_sdi+0x86>
  4023fa:	460d      	mov	r5, r1
  4023fc:	4619      	mov	r1, r3
  4023fe:	47b8      	blx	r7
  402400:	1ba9      	subs	r1, r5, r6
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402402:	1c42      	adds	r2, r0, #1
  402404:	4603      	mov	r3, r0
  402406:	b289      	uxth	r1, r1
  402408:	d1ef      	bne.n	4023ea <dir_sdi+0x62>
  40240a:	2001      	movs	r0, #1
  40240c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  40240e:	60e3      	str	r3, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402410:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402412:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402414:	3a02      	subs	r2, #2
  402416:	4293      	cmp	r3, r2
	return clst * fs->csize + fs->database;
  402418:	bf3b      	ittet	cc
  40241a:	7881      	ldrbcc	r1, [r0, #2]
  40241c:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  40241e:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
  402420:	fb01 2303 	mlacc	r3, r1, r3, r2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402424:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402428:	6123      	str	r3, [r4, #16]
  40242a:	e7c7      	b.n	4023bc <dir_sdi+0x34>
  40242c:	004022bd 	.word	0x004022bd

00402430 <put_fat.part.4>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402430:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402434:	7803      	ldrb	r3, [r0, #0]
  402436:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402438:	4604      	mov	r4, r0
  40243a:	460d      	mov	r5, r1
  40243c:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  40243e:	d05b      	beq.n	4024f8 <put_fat.part.4+0xc8>
  402440:	2b03      	cmp	r3, #3
  402442:	d039      	beq.n	4024b8 <put_fat.part.4+0x88>
  402444:	2b01      	cmp	r3, #1
  402446:	d004      	beq.n	402452 <put_fat.part.4+0x22>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
  402448:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
  40244a:	2301      	movs	r3, #1
  40244c:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  40244e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402452:	6a01      	ldr	r1, [r0, #32]
  402454:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 40252c <put_fat.part.4+0xfc>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  402458:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  40245c:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  402460:	47c0      	blx	r8
			if (res != FR_OK) break;
  402462:	2800      	cmp	r0, #0
  402464:	d1f1      	bne.n	40244a <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402466:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  40246a:	f015 0501 	ands.w	r5, r5, #1
  40246e:	4423      	add	r3, r4
  402470:	b2f2      	uxtb	r2, r6
  402472:	d006      	beq.n	402482 <put_fat.part.4+0x52>
  402474:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
  402478:	f001 010f 	and.w	r1, r1, #15
  40247c:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
  402480:	b2d2      	uxtb	r2, r2
  402482:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402486:	6a21      	ldr	r1, [r4, #32]
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
  402488:	3701      	adds	r7, #1
			fs->wflag = 1;
  40248a:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  40248c:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  402490:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402492:	4620      	mov	r0, r4
  402494:	47c0      	blx	r8
			if (res != FR_OK) break;
  402496:	2800      	cmp	r0, #0
  402498:	d1d7      	bne.n	40244a <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  40249a:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  40249e:	2d00      	cmp	r5, #0
  4024a0:	d13f      	bne.n	402522 <put_fat.part.4+0xf2>
  4024a2:	4427      	add	r7, r4
  4024a4:	f3c6 2603 	ubfx	r6, r6, #8, #4
  4024a8:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  4024ac:	f023 030f 	bic.w	r3, r3, #15
  4024b0:	431e      	orrs	r6, r3
  4024b2:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
  4024b6:	e7c8      	b.n	40244a <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  4024b8:	6a01      	ldr	r1, [r0, #32]
  4024ba:	4b1c      	ldr	r3, [pc, #112]	; (40252c <put_fat.part.4+0xfc>)
  4024bc:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  4024c0:	4798      	blx	r3
			if (res != FR_OK) break;
  4024c2:	2800      	cmp	r0, #0
  4024c4:	d1c1      	bne.n	40244a <put_fat.part.4+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
  4024c6:	00ad      	lsls	r5, r5, #2
  4024c8:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  4024cc:	f105 0330 	add.w	r3, r5, #48	; 0x30
  4024d0:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
  4024d2:	4425      	add	r5, r4
  4024d4:	78da      	ldrb	r2, [r3, #3]
  4024d6:	0612      	lsls	r2, r2, #24
  4024d8:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  4024dc:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
  4024de:	f3c6 2707 	ubfx	r7, r6, #8, #8
  4024e2:	0c31      	lsrs	r1, r6, #16
  4024e4:	0e32      	lsrs	r2, r6, #24
  4024e6:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
  4024ea:	705f      	strb	r7, [r3, #1]
  4024ec:	7099      	strb	r1, [r3, #2]
  4024ee:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  4024f0:	2301      	movs	r3, #1
  4024f2:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  4024f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  4024f8:	6a01      	ldr	r1, [r0, #32]
  4024fa:	4b0c      	ldr	r3, [pc, #48]	; (40252c <put_fat.part.4+0xfc>)
  4024fc:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402500:	4798      	blx	r3
			if (res != FR_OK) break;
  402502:	2800      	cmp	r0, #0
  402504:	d1a1      	bne.n	40244a <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
  402506:	006d      	lsls	r5, r5, #1
  402508:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  40250c:	1962      	adds	r2, r4, r5
  40250e:	f3c6 2307 	ubfx	r3, r6, #8, #8
  402512:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402516:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
  402518:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  40251c:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  40251e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402522:	f3c6 1607 	ubfx	r6, r6, #4, #8
  402526:	4427      	add	r7, r4
  402528:	e7c3      	b.n	4024b2 <put_fat.part.4+0x82>
  40252a:	bf00      	nop
  40252c:	00401d7d 	.word	0x00401d7d

00402530 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  402530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402534:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  402536:	4688      	mov	r8, r1
  402538:	bb01      	cbnz	r1, 40257c <create_chain+0x4c>
		scl = fs->last_clust;			/* Get suggested start point */
  40253a:	68c6      	ldr	r6, [r0, #12]
  40253c:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  40253e:	b35e      	cbz	r6, 402598 <create_chain+0x68>
  402540:	429e      	cmp	r6, r3
  402542:	bf28      	it	cs
  402544:	2601      	movcs	r6, #1
  402546:	4f2e      	ldr	r7, [pc, #184]	; (402600 <create_chain+0xd0>)
  402548:	4634      	mov	r4, r6
  40254a:	e00f      	b.n	40256c <create_chain+0x3c>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  40254c:	2e01      	cmp	r6, #1
  40254e:	d925      	bls.n	40259c <create_chain+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402550:	2b02      	cmp	r3, #2
  402552:	d910      	bls.n	402576 <create_chain+0x46>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
  402554:	2402      	movs	r4, #2
  402556:	4628      	mov	r0, r5
  402558:	4621      	mov	r1, r4
  40255a:	47b8      	blx	r7
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
  40255c:	b338      	cbz	r0, 4025ae <create_chain+0x7e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  40255e:	1c41      	adds	r1, r0, #1
  402560:	d021      	beq.n	4025a6 <create_chain+0x76>
  402562:	2801      	cmp	r0, #1
  402564:	d007      	beq.n	402576 <create_chain+0x46>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  402566:	42a6      	cmp	r6, r4
  402568:	d018      	beq.n	40259c <create_chain+0x6c>
  40256a:	69ab      	ldr	r3, [r5, #24]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  40256c:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  40256e:	429c      	cmp	r4, r3
  402570:	d2ec      	bcs.n	40254c <create_chain+0x1c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402572:	2c01      	cmp	r4, #1
  402574:	d8ef      	bhi.n	402556 <create_chain+0x26>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402576:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
  402578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  40257c:	2901      	cmp	r1, #1
  40257e:	d9fa      	bls.n	402576 <create_chain+0x46>
  402580:	6983      	ldr	r3, [r0, #24]
  402582:	4299      	cmp	r1, r3
  402584:	d2f7      	bcs.n	402576 <create_chain+0x46>
  402586:	4b1e      	ldr	r3, [pc, #120]	; (402600 <create_chain+0xd0>)
  402588:	4798      	blx	r3
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
  40258a:	2801      	cmp	r0, #1
  40258c:	d9f3      	bls.n	402576 <create_chain+0x46>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  40258e:	69ab      	ldr	r3, [r5, #24]
  402590:	4283      	cmp	r3, r0
  402592:	d8f1      	bhi.n	402578 <create_chain+0x48>
  402594:	4646      	mov	r6, r8
  402596:	e7d6      	b.n	402546 <create_chain+0x16>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402598:	2601      	movs	r6, #1
  40259a:	e7d4      	b.n	402546 <create_chain+0x16>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  40259c:	2000      	movs	r0, #0
  40259e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  4025a2:	2801      	cmp	r0, #1
  4025a4:	d1e7      	bne.n	402576 <create_chain+0x46>
  4025a6:	f04f 30ff 	mov.w	r0, #4294967295
  4025aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4025ae:	69ab      	ldr	r3, [r5, #24]
  4025b0:	42a3      	cmp	r3, r4
  4025b2:	d9e0      	bls.n	402576 <create_chain+0x46>
  4025b4:	4628      	mov	r0, r5
  4025b6:	4621      	mov	r1, r4
  4025b8:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  4025bc:	4e11      	ldr	r6, [pc, #68]	; (402604 <create_chain+0xd4>)
  4025be:	47b0      	blx	r6
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
  4025c0:	2800      	cmp	r0, #0
  4025c2:	d1ee      	bne.n	4025a2 <create_chain+0x72>
  4025c4:	f1b8 0f00 	cmp.w	r8, #0
  4025c8:	d00b      	beq.n	4025e2 <create_chain+0xb2>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4025ca:	f1b8 0f01 	cmp.w	r8, #1
  4025ce:	d9d2      	bls.n	402576 <create_chain+0x46>
  4025d0:	69ab      	ldr	r3, [r5, #24]
  4025d2:	4598      	cmp	r8, r3
  4025d4:	d2cf      	bcs.n	402576 <create_chain+0x46>
  4025d6:	4641      	mov	r1, r8
  4025d8:	4628      	mov	r0, r5
  4025da:	4622      	mov	r2, r4
  4025dc:	47b0      	blx	r6

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
  4025de:	2800      	cmp	r0, #0
  4025e0:	d1df      	bne.n	4025a2 <create_chain+0x72>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  4025e2:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  4025e4:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  4025e6:	1c5a      	adds	r2, r3, #1
  4025e8:	d006      	beq.n	4025f8 <create_chain+0xc8>
			fs->free_clust--;
  4025ea:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
  4025ec:	2201      	movs	r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  4025ee:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  4025f0:	716a      	strb	r2, [r5, #5]
  4025f2:	4620      	mov	r0, r4
  4025f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4025f8:	4620      	mov	r0, r4
  4025fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4025fe:	bf00      	nop
  402600:	004022bd 	.word	0x004022bd
  402604:	00402431 	.word	0x00402431

00402608 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402608:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  40260c:	88c5      	ldrh	r5, [r0, #6]
  40260e:	3501      	adds	r5, #1
  402610:	b2ad      	uxth	r5, r5
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402612:	4604      	mov	r4, r0
  402614:	460e      	mov	r6, r1
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402616:	b915      	cbnz	r5, 40261e <dir_next+0x16>
		return FR_NO_FILE;
  402618:	2004      	movs	r0, #4
  40261a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  40261e:	6903      	ldr	r3, [r0, #16]
  402620:	2b00      	cmp	r3, #0
  402622:	d0f9      	beq.n	402618 <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402624:	f015 070f 	ands.w	r7, r5, #15
  402628:	d008      	beq.n	40263c <dir_next+0x34>
  40262a:	6800      	ldr	r0, [r0, #0]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  40262c:	eb00 1347 	add.w	r3, r0, r7, lsl #5
  402630:	3330      	adds	r3, #48	; 0x30
  402632:	6163      	str	r3, [r4, #20]
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  402634:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  402636:	2000      	movs	r0, #0
  402638:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  40263c:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  40263e:	3301      	adds	r3, #1
  402640:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402642:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402644:	b161      	cbz	r1, 402660 <dir_next+0x58>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402646:	7882      	ldrb	r2, [r0, #2]
  402648:	3a01      	subs	r2, #1
  40264a:	ea12 1215 	ands.w	r2, r2, r5, lsr #4
  40264e:	d1ed      	bne.n	40262c <dir_next+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402650:	2901      	cmp	r1, #1
  402652:	d902      	bls.n	40265a <dir_next+0x52>
  402654:	6982      	ldr	r2, [r0, #24]
  402656:	4291      	cmp	r1, r2
  402658:	d306      	bcc.n	402668 <dir_next+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  40265a:	2002      	movs	r0, #2
  40265c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402660:	8902      	ldrh	r2, [r0, #8]
  402662:	42aa      	cmp	r2, r5
  402664:	d9d8      	bls.n	402618 <dir_next+0x10>
  402666:	e7e1      	b.n	40262c <dir_next+0x24>
  402668:	4b34      	ldr	r3, [pc, #208]	; (40273c <dir_next+0x134>)
  40266a:	4798      	blx	r3
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  40266c:	2801      	cmp	r0, #1
  40266e:	4680      	mov	r8, r0
  402670:	d9f3      	bls.n	40265a <dir_next+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402672:	f1b0 3fff 	cmp.w	r0, #4294967295
  402676:	d01c      	beq.n	4026b2 <dir_next+0xaa>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402678:	6820      	ldr	r0, [r4, #0]
  40267a:	6982      	ldr	r2, [r0, #24]
  40267c:	4542      	cmp	r2, r8
  40267e:	d90e      	bls.n	40269e <dir_next+0x96>
  402680:	f1a8 0602 	sub.w	r6, r8, #2
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402684:	f8c4 800c 	str.w	r8, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402688:	6982      	ldr	r2, [r0, #24]
  40268a:	3a02      	subs	r2, #2
  40268c:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  40268e:	bf3b      	ittet	cc
  402690:	7881      	ldrbcc	r1, [r0, #2]
  402692:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402694:	2600      	movcs	r6, #0
	return clst * fs->csize + fs->database;
  402696:	fb01 2606 	mlacc	r6, r1, r6, r2
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  40269a:	6126      	str	r6, [r4, #16]
  40269c:	e7c6      	b.n	40262c <dir_next+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  40269e:	2e00      	cmp	r6, #0
  4026a0:	d0ba      	beq.n	402618 <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  4026a2:	68e1      	ldr	r1, [r4, #12]
  4026a4:	4b26      	ldr	r3, [pc, #152]	; (402740 <dir_next+0x138>)
  4026a6:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  4026a8:	4680      	mov	r8, r0
  4026aa:	b928      	cbnz	r0, 4026b8 <dir_next+0xb0>
  4026ac:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  4026ae:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  4026b2:	2001      	movs	r0, #1
  4026b4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
  4026b8:	2801      	cmp	r0, #1
  4026ba:	d0ce      	beq.n	40265a <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  4026bc:	f1b0 3fff 	cmp.w	r0, #4294967295
  4026c0:	d0f7      	beq.n	4026b2 <dir_next+0xaa>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  4026c2:	6820      	ldr	r0, [r4, #0]
  4026c4:	f8df 907c 	ldr.w	r9, [pc, #124]	; 402744 <dir_next+0x13c>
  4026c8:	2100      	movs	r1, #0
  4026ca:	47c8      	blx	r9
  4026cc:	2800      	cmp	r0, #0
  4026ce:	d1f0      	bne.n	4026b2 <dir_next+0xaa>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  4026d0:	6822      	ldr	r2, [r4, #0]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4026d2:	4601      	mov	r1, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  4026d4:	f102 0330 	add.w	r3, r2, #48	; 0x30
  4026d8:	f502 720c 	add.w	r2, r2, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4026dc:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4026e0:	4293      	cmp	r3, r2
  4026e2:	d1fb      	bne.n	4026dc <dir_next+0xd4>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  4026e4:	6823      	ldr	r3, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4026e6:	699a      	ldr	r2, [r3, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  4026e8:	f1a8 0602 	sub.w	r6, r8, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4026ec:	3a02      	subs	r2, #2
  4026ee:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  4026f0:	bf3b      	ittet	cc
  4026f2:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
  4026f4:	7899      	ldrbcc	r1, [r3, #2]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  4026f6:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
  4026f8:	fb01 2206 	mlacc	r2, r1, r6, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  4026fc:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  4026fe:	f04f 0a00 	mov.w	sl, #0
						dj->fs->wflag = 1;
  402702:	f04f 0b01 	mov.w	fp, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402706:	e00b      	b.n	402720 <dir_next+0x118>
						dj->fs->wflag = 1;
  402708:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  40270c:	6820      	ldr	r0, [r4, #0]
  40270e:	47c8      	blx	r9
  402710:	f10a 0a01 	add.w	sl, sl, #1
  402714:	2800      	cmp	r0, #0
  402716:	d1cc      	bne.n	4026b2 <dir_next+0xaa>
						dj->fs->winsect++;
  402718:	6823      	ldr	r3, [r4, #0]
  40271a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  40271c:	3201      	adds	r2, #1
  40271e:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402720:	6823      	ldr	r3, [r4, #0]
  402722:	7898      	ldrb	r0, [r3, #2]
  402724:	fa5f f28a 	uxtb.w	r2, sl
  402728:	4290      	cmp	r0, r2
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  40272a:	f04f 0100 	mov.w	r1, #0
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  40272e:	d8eb      	bhi.n	402708 <dir_next+0x100>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  402730:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  402732:	1a8a      	subs	r2, r1, r2
  402734:	62da      	str	r2, [r3, #44]	; 0x2c
  402736:	6820      	ldr	r0, [r4, #0]
  402738:	e7a4      	b.n	402684 <dir_next+0x7c>
  40273a:	bf00      	nop
  40273c:	004022bd 	.word	0x004022bd
  402740:	00402531 	.word	0x00402531
  402744:	00401d7d 	.word	0x00401d7d

00402748 <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  402748:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  40274c:	f04f 08ff 	mov.w	r8, #255	; 0xff
  402750:	b085      	sub	sp, #20
  402752:	4f52      	ldr	r7, [pc, #328]	; (40289c <dir_find.part.5+0x154>)
  402754:	f8df 914c 	ldr.w	r9, [pc, #332]	; 4028a4 <dir_find.part.5+0x15c>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402758:	f8df a14c 	ldr.w	sl, [pc, #332]	; 4028a8 <dir_find.part.5+0x160>
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  40275c:	4605      	mov	r5, r0
  40275e:	4646      	mov	r6, r8
  402760:	e008      	b.n	402774 <dir_find.part.5+0x2c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402762:	290f      	cmp	r1, #15
  402764:	d03e      	beq.n	4027e4 <dir_find.part.5+0x9c>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402766:	26ff      	movs	r6, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  402768:	4628      	mov	r0, r5
  40276a:	2100      	movs	r1, #0
  40276c:	4b4c      	ldr	r3, [pc, #304]	; (4028a0 <dir_find.part.5+0x158>)
  40276e:	4798      	blx	r3
	} while (res == FR_OK);
  402770:	2800      	cmp	r0, #0
  402772:	d134      	bne.n	4027de <dir_find.part.5+0x96>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  402774:	6828      	ldr	r0, [r5, #0]
  402776:	6929      	ldr	r1, [r5, #16]
  402778:	47b8      	blx	r7
		if (res != FR_OK) break;
  40277a:	bb80      	cbnz	r0, 4027de <dir_find.part.5+0x96>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  40277c:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  40277e:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402780:	2a00      	cmp	r2, #0
  402782:	d078      	beq.n	402876 <dir_find.part.5+0x12e>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  402784:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402786:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  402788:	f003 013f 	and.w	r1, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40278c:	d0eb      	beq.n	402766 <dir_find.part.5+0x1e>
  40278e:	071b      	lsls	r3, r3, #28
  402790:	d4e7      	bmi.n	402762 <dir_find.part.5+0x1a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  402792:	290f      	cmp	r1, #15
  402794:	d026      	beq.n	4027e4 <dir_find.part.5+0x9c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  402796:	b98e      	cbnz	r6, 4027bc <dir_find.part.5+0x74>
  402798:	4694      	mov	ip, r2
  40279a:	f104 060a 	add.w	r6, r4, #10
  40279e:	4622      	mov	r2, r4
  4027a0:	4603      	mov	r3, r0
  4027a2:	e001      	b.n	4027a8 <dir_find.part.5+0x60>
  4027a4:	f812 cf01 	ldrb.w	ip, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  4027a8:	01d9      	lsls	r1, r3, #7
  4027aa:	ea41 0353 	orr.w	r3, r1, r3, lsr #1
  4027ae:	fa5c f383 	uxtab	r3, ip, r3
  4027b2:	42b2      	cmp	r2, r6
  4027b4:	b2db      	uxtb	r3, r3
  4027b6:	d1f5      	bne.n	4027a4 <dir_find.part.5+0x5c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  4027b8:	4543      	cmp	r3, r8
  4027ba:	d010      	beq.n	4027de <dir_find.part.5+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  4027bc:	f64f 72ff 	movw	r2, #65535	; 0xffff
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  4027c0:	69ab      	ldr	r3, [r5, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  4027c2:	842a      	strh	r2, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  4027c4:	7ada      	ldrb	r2, [r3, #11]
  4027c6:	07d2      	lsls	r2, r2, #31
  4027c8:	d4cd      	bmi.n	402766 <dir_find.part.5+0x1e>
  4027ca:	f104 060b 	add.w	r6, r4, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  4027ce:	f814 1b01 	ldrb.w	r1, [r4], #1
  4027d2:	f813 2b01 	ldrb.w	r2, [r3], #1
  4027d6:	4291      	cmp	r1, r2
  4027d8:	d1c5      	bne.n	402766 <dir_find.part.5+0x1e>
  4027da:	42b4      	cmp	r4, r6
  4027dc:	d1f7      	bne.n	4027ce <dir_find.part.5+0x86>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  4027de:	b005      	add	sp, #20
  4027e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
  4027e4:	69eb      	ldr	r3, [r5, #28]
  4027e6:	2b00      	cmp	r3, #0
  4027e8:	d0be      	beq.n	402768 <dir_find.part.5+0x20>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  4027ea:	0651      	lsls	r1, r2, #25
  4027ec:	d53f      	bpl.n	40286e <dir_find.part.5+0x126>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  4027ee:	88e9      	ldrh	r1, [r5, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
  4027f0:	f894 800d 	ldrb.w	r8, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  4027f4:	8429      	strh	r1, [r5, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
  4027f6:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  4027fa:	7b61      	ldrb	r1, [r4, #13]
  4027fc:	4541      	cmp	r1, r8
  4027fe:	d1b2      	bne.n	402766 <dir_find.part.5+0x1e>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  402800:	7822      	ldrb	r2, [r4, #0]
  402802:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 4028ac <dir_find.part.5+0x164>
  402806:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  40280a:	3a01      	subs	r2, #1
  40280c:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
  402810:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  402814:	f64f 78ff 	movw	r8, #65535	; 0xffff
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  402818:	2201      	movs	r2, #1
  40281a:	e003      	b.n	402824 <dir_find.part.5+0xdc>
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  40281c:	4540      	cmp	r0, r8
  40281e:	d135      	bne.n	40288c <dir_find.part.5+0x144>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  402820:	45cb      	cmp	fp, r9
  402822:	d02c      	beq.n	40287e <dir_find.part.5+0x136>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  402824:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
  402828:	eb04 0e00 	add.w	lr, r4, r0
  40282c:	5c20      	ldrb	r0, [r4, r0]
  40282e:	f89e e001 	ldrb.w	lr, [lr, #1]
  402832:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		if (wc) {	/* Last char has not been processed */
  402836:	2a00      	cmp	r2, #0
  402838:	d0f0      	beq.n	40281c <dir_find.part.5+0xd4>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  40283a:	f10c 0201 	add.w	r2, ip, #1
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  40283e:	e88d 100a 	stmia.w	sp, {r1, r3, ip}
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402842:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402844:	47d0      	blx	sl
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402846:	f8dd c008 	ldr.w	ip, [sp, #8]
  40284a:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  40284e:	4602      	mov	r2, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402850:	e89d 000a 	ldmia.w	sp, {r1, r3}
  402854:	d81a      	bhi.n	40288c <dir_find.part.5+0x144>
  402856:	f833 001c 	ldrh.w	r0, [r3, ip, lsl #1]
  40285a:	9202      	str	r2, [sp, #8]
  40285c:	47d0      	blx	sl
  40285e:	9a02      	ldr	r2, [sp, #8]
  402860:	4282      	cmp	r2, r0
  402862:	e89d 000a 	ldmia.w	sp, {r1, r3}
  402866:	d111      	bne.n	40288c <dir_find.part.5+0x144>
  402868:	f8dd c00c 	ldr.w	ip, [sp, #12]
  40286c:	e7d8      	b.n	402820 <dir_find.part.5+0xd8>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40286e:	42b2      	cmp	r2, r6
  402870:	f47f af79 	bne.w	402766 <dir_find.part.5+0x1e>
  402874:	e7c1      	b.n	4027fa <dir_find.part.5+0xb2>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402876:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  402878:	b005      	add	sp, #20
  40287a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  40287e:	7820      	ldrb	r0, [r4, #0]
  402880:	0640      	lsls	r0, r0, #25
  402882:	d506      	bpl.n	402892 <dir_find.part.5+0x14a>
  402884:	b12a      	cbz	r2, 402892 <dir_find.part.5+0x14a>
  402886:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
  40288a:	b113      	cbz	r3, 402892 <dir_find.part.5+0x14a>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  40288c:	4688      	mov	r8, r1
  40288e:	26ff      	movs	r6, #255	; 0xff
  402890:	e76a      	b.n	402768 <dir_find.part.5+0x20>
  402892:	3e01      	subs	r6, #1
  402894:	b2f6      	uxtb	r6, r6
  402896:	4688      	mov	r8, r1
  402898:	e766      	b.n	402768 <dir_find.part.5+0x20>
  40289a:	bf00      	nop
  40289c:	00401d7d 	.word	0x00401d7d
  4028a0:	00402609 	.word	0x00402609
  4028a4:	00405460 	.word	0x00405460
  4028a8:	004034e9 	.word	0x004034e9
  4028ac:	00405453 	.word	0x00405453

004028b0 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  4028b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  4028b4:	f8d0 a018 	ldr.w	sl, [r0, #24]
  4028b8:	69c5      	ldr	r5, [r0, #28]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  4028ba:	b089      	sub	sp, #36	; 0x24
  4028bc:	f10a 36ff 	add.w	r6, sl, #4294967295
  4028c0:	4604      	mov	r4, r0
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  4028c2:	4632      	mov	r2, r6
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  4028c4:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4028c6:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  4028ca:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4028ce:	a908      	add	r1, sp, #32
  4028d0:	428b      	cmp	r3, r1
  4028d2:	d1f8      	bne.n	4028c6 <dir_register+0x16>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  4028d4:	f89d 301f 	ldrb.w	r3, [sp, #31]
  4028d8:	9301      	str	r3, [sp, #4]
  4028da:	07da      	lsls	r2, r3, #31
  4028dc:	d456      	bmi.n	40298c <dir_register+0xdc>
  4028de:	4fb1      	ldr	r7, [pc, #708]	; (402ba4 <dir_register+0x2f4>)
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  4028e0:	9b01      	ldr	r3, [sp, #4]
  4028e2:	079b      	lsls	r3, r3, #30
  4028e4:	f100 80c2 	bmi.w	402a6c <dir_register+0x1bc>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
  4028e8:	f04f 0901 	mov.w	r9, #1
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
  4028ec:	4620      	mov	r0, r4
  4028ee:	2100      	movs	r1, #0
  4028f0:	47b8      	blx	r7
	if (res != FR_OK) return res;
  4028f2:	2800      	cmp	r0, #0
  4028f4:	d147      	bne.n	402986 <dir_register+0xd6>
  4028f6:	4682      	mov	sl, r0
  4028f8:	4eab      	ldr	r6, [pc, #684]	; (402ba8 <dir_register+0x2f8>)
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4028fa:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 402bb0 <dir_register+0x300>
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
  4028fe:	4605      	mov	r5, r0
  402900:	e005      	b.n	40290e <dir_register+0x5e>
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
  402902:	461d      	mov	r5, r3
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402904:	47c0      	blx	r8
	} while (res == FR_OK);
  402906:	4603      	mov	r3, r0
  402908:	2800      	cmp	r0, #0
  40290a:	f040 80ce 	bne.w	402aaa <dir_register+0x1fa>
	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
  40290e:	6921      	ldr	r1, [r4, #16]
  402910:	6820      	ldr	r0, [r4, #0]
  402912:	47b0      	blx	r6
		if (res != FR_OK) break;
  402914:	4603      	mov	r3, r0
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  402916:	f105 0c01 	add.w	ip, r5, #1
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  40291a:	4620      	mov	r0, r4
  40291c:	2101      	movs	r1, #1
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  40291e:	2b00      	cmp	r3, #0
  402920:	f040 80c3 	bne.w	402aaa <dir_register+0x1fa>
		c = *dj->dir;				/* Check the entry status */
  402924:	6962      	ldr	r2, [r4, #20]
  402926:	7812      	ldrb	r2, [r2, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  402928:	2ae5      	cmp	r2, #229	; 0xe5
  40292a:	d001      	beq.n	402930 <dir_register+0x80>
  40292c:	2a00      	cmp	r2, #0
  40292e:	d1e8      	bne.n	402902 <dir_register+0x52>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  402930:	b90d      	cbnz	r5, 402936 <dir_register+0x86>
  402932:	f8b4 a006 	ldrh.w	sl, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  402936:	fa1f f58c 	uxth.w	r5, ip
  40293a:	454d      	cmp	r5, r9
  40293c:	d1e2      	bne.n	402904 <dir_register+0x54>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  40293e:	f1b9 0f01 	cmp.w	r9, #1
  402942:	f040 80b6 	bne.w	402ab2 <dir_register+0x202>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  402946:	6820      	ldr	r0, [r4, #0]
  402948:	6921      	ldr	r1, [r4, #16]
  40294a:	47b0      	blx	r6
		if (res == FR_OK) {
  40294c:	b9d8      	cbnz	r0, 402986 <dir_register+0xd6>
			dir = dj->dir;
  40294e:	6965      	ldr	r5, [r4, #20]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402950:	4601      	mov	r1, r0
  402952:	f105 0220 	add.w	r2, r5, #32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402956:	462b      	mov	r3, r5

	while (cnt--)
		*d++ = (BYTE)val;
  402958:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  40295c:	4293      	cmp	r3, r2
  40295e:	d1fb      	bne.n	402958 <dir_register+0xa8>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  402960:	69a2      	ldr	r2, [r4, #24]
  402962:	f105 000b 	add.w	r0, r5, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402966:	462b      	mov	r3, r5
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  402968:	f812 1b01 	ldrb.w	r1, [r2], #1
  40296c:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  402970:	4283      	cmp	r3, r0
  402972:	d1f9      	bne.n	402968 <dir_register+0xb8>
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  402974:	69a3      	ldr	r3, [r4, #24]
  402976:	7adb      	ldrb	r3, [r3, #11]
  402978:	f003 0318 	and.w	r3, r3, #24
  40297c:	732b      	strb	r3, [r5, #12]
#endif
			dj->fs->wflag = 1;
  40297e:	6823      	ldr	r3, [r4, #0]
  402980:	2201      	movs	r2, #1
  402982:	711a      	strb	r2, [r3, #4]
  402984:	2000      	movs	r0, #0
		}
	}

	return res;
}
  402986:	b009      	add	sp, #36	; 0x24
  402988:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  40298c:	2300      	movs	r3, #0
  40298e:	4f85      	ldr	r7, [pc, #532]	; (402ba4 <dir_register+0x2f4>)
  402990:	f8df 8220 	ldr.w	r8, [pc, #544]	; 402bb4 <dir_register+0x304>
  402994:	f88a 300b 	strb.w	r3, [sl, #11]
		for (n = 1; n < 100; n++) {
  402998:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  40299c:	61e3      	str	r3, [r4, #28]
  40299e:	f10d 0b1f 	add.w	fp, sp, #31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  4029a2:	4632      	mov	r2, r6
  4029a4:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  4029a6:	f813 1b01 	ldrb.w	r1, [r3], #1
  4029aa:	f802 1f01 	strb.w	r1, [r2, #1]!
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4029ae:	455b      	cmp	r3, fp
  4029b0:	d1f9      	bne.n	4029a6 <dir_register+0xf6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  4029b2:	f1b9 0f05 	cmp.w	r9, #5
  4029b6:	d957      	bls.n	402a68 <dir_register+0x1b8>
  4029b8:	8828      	ldrh	r0, [r5, #0]
  4029ba:	4629      	mov	r1, r5
  4029bc:	464a      	mov	r2, r9
  4029be:	e000      	b.n	4029c2 <dir_register+0x112>
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  4029c0:	4618      	mov	r0, r3
  4029c2:	03d3      	lsls	r3, r2, #15
  4029c4:	ea43 0252 	orr.w	r2, r3, r2, lsr #1
  4029c8:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  4029cc:	fa10 f282 	uxtah	r2, r0, r2
  4029d0:	b292      	uxth	r2, r2
  4029d2:	2b00      	cmp	r3, #0
  4029d4:	d1f4      	bne.n	4029c0 <dir_register+0x110>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  4029d6:	2307      	movs	r3, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
  4029d8:	f002 000f 	and.w	r0, r2, #15
  4029dc:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  4029e0:	2939      	cmp	r1, #57	; 0x39
  4029e2:	bf88      	it	hi
  4029e4:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  4029e8:	3b01      	subs	r3, #1
  4029ea:	a803      	add	r0, sp, #12
  4029ec:	4418      	add	r0, r3
		seq /= 16;
  4029ee:	f3c2 120f 	ubfx	r2, r2, #4, #16
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
  4029f2:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
  4029f4:	2a00      	cmp	r2, #0
  4029f6:	d1ef      	bne.n	4029d8 <dir_register+0x128>
	ns[i] = '~';
  4029f8:	a908      	add	r1, sp, #32
  4029fa:	4419      	add	r1, r3
  4029fc:	207e      	movs	r0, #126	; 0x7e
  4029fe:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  402a02:	2b00      	cmp	r3, #0
  402a04:	d04f      	beq.n	402aa6 <dir_register+0x1f6>
  402a06:	f89a 1000 	ldrb.w	r1, [sl]
  402a0a:	2920      	cmp	r1, #32
  402a0c:	d014      	beq.n	402a38 <dir_register+0x188>
  402a0e:	4651      	mov	r1, sl
  402a10:	e003      	b.n	402a1a <dir_register+0x16a>
  402a12:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  402a16:	2820      	cmp	r0, #32
  402a18:	d00e      	beq.n	402a38 <dir_register+0x188>
  402a1a:	3201      	adds	r2, #1
  402a1c:	429a      	cmp	r2, r3
  402a1e:	d1f8      	bne.n	402a12 <dir_register+0x162>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  402a20:	2b07      	cmp	r3, #7
  402a22:	d80b      	bhi.n	402a3c <dir_register+0x18c>
  402a24:	a908      	add	r1, sp, #32
  402a26:	4419      	add	r1, r3
  402a28:	3301      	adds	r3, #1
  402a2a:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  402a2e:	f80a 1002 	strb.w	r1, [sl, r2]
  402a32:	3201      	adds	r2, #1
	} while (j < 8);
  402a34:	2a07      	cmp	r2, #7
  402a36:	d807      	bhi.n	402a48 <dir_register+0x198>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  402a38:	2b07      	cmp	r3, #7
  402a3a:	d9f3      	bls.n	402a24 <dir_register+0x174>
  402a3c:	2120      	movs	r1, #32
  402a3e:	f80a 1002 	strb.w	r1, [sl, r2]
  402a42:	3201      	adds	r2, #1
	} while (j < 8);
  402a44:	2a07      	cmp	r2, #7
  402a46:	d9f7      	bls.n	402a38 <dir_register+0x188>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  402a48:	4620      	mov	r0, r4
  402a4a:	2100      	movs	r1, #0
  402a4c:	47b8      	blx	r7
	if (res != FR_OK) return res;
  402a4e:	bb10      	cbnz	r0, 402a96 <dir_register+0x1e6>
  402a50:	4620      	mov	r0, r4
  402a52:	47c0      	blx	r8
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
  402a54:	b9f8      	cbnz	r0, 402a96 <dir_register+0x1e6>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
  402a56:	f109 0901 	add.w	r9, r9, #1
  402a5a:	fa1f f989 	uxth.w	r9, r9
  402a5e:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
  402a62:	d19e      	bne.n	4029a2 <dir_register+0xf2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  402a64:	2007      	movs	r0, #7
  402a66:	e78e      	b.n	402986 <dir_register+0xd6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  402a68:	464a      	mov	r2, r9
  402a6a:	e7b4      	b.n	4029d6 <dir_register+0x126>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
  402a6c:	882b      	ldrh	r3, [r5, #0]
  402a6e:	2b00      	cmp	r3, #0
  402a70:	f43f af3a 	beq.w	4028e8 <dir_register+0x38>
  402a74:	2300      	movs	r3, #0
  402a76:	3301      	adds	r3, #1
  402a78:	b29b      	uxth	r3, r3
  402a7a:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
  402a7e:	2a00      	cmp	r2, #0
  402a80:	d1f9      	bne.n	402a76 <dir_register+0x1c6>
  402a82:	4a4a      	ldr	r2, [pc, #296]	; (402bac <dir_register+0x2fc>)
  402a84:	3319      	adds	r3, #25
  402a86:	fb82 1903 	smull	r1, r9, r2, r3
  402a8a:	17db      	asrs	r3, r3, #31
  402a8c:	ebc3 09a9 	rsb	r9, r3, r9, asr #2
  402a90:	fa1f f989 	uxth.w	r9, r9
  402a94:	e72a      	b.n	4028ec <dir_register+0x3c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  402a96:	2804      	cmp	r0, #4
  402a98:	f47f af75 	bne.w	402986 <dir_register+0xd6>
		fn[NS] = sn[NS]; dj->lfn = lfn;
  402a9c:	9b01      	ldr	r3, [sp, #4]
  402a9e:	f88a 300b 	strb.w	r3, [sl, #11]
  402aa2:	61e5      	str	r5, [r4, #28]
  402aa4:	e71c      	b.n	4028e0 <dir_register+0x30>
		seq /= 16;
	} while (seq);
	ns[i] = '~';

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  402aa6:	461a      	mov	r2, r3
  402aa8:	e7c6      	b.n	402a38 <dir_register+0x188>
  402aaa:	4618      	mov	r0, r3
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  402aac:	b009      	add	sp, #36	; 0x24
  402aae:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
  402ab2:	4651      	mov	r1, sl
  402ab4:	4620      	mov	r0, r4
  402ab6:	47b8      	blx	r7
		if (res == FR_OK) {
  402ab8:	4603      	mov	r3, r0
  402aba:	2800      	cmp	r0, #0
  402abc:	d1f5      	bne.n	402aaa <dir_register+0x1fa>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  402abe:	69a2      	ldr	r2, [r4, #24]
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  402ac0:	4683      	mov	fp, r0
  402ac2:	f102 000b 	add.w	r0, r2, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  402ac6:	f812 3b01 	ldrb.w	r3, [r2], #1
  402aca:	ea4f 11cb 	mov.w	r1, fp, lsl #7
  402ace:	ea41 0b5b 	orr.w	fp, r1, fp, lsr #1
  402ad2:	fa53 fb8b 	uxtab	fp, r3, fp
  402ad6:	4282      	cmp	r2, r0
  402ad8:	fa5f fb8b 	uxtb.w	fp, fp
  402adc:	d1f3      	bne.n	402ac6 <dir_register+0x216>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
  402ade:	f109 39ff 	add.w	r9, r9, #4294967295
  402ae2:	fa1f f989 	uxth.w	r9, r9
  402ae6:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 402bb8 <dir_register+0x308>
  402aea:	f8cd b000 	str.w	fp, [sp]
  402aee:	46cb      	mov	fp, r9
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
  402af0:	6820      	ldr	r0, [r4, #0]
  402af2:	6921      	ldr	r1, [r4, #16]
  402af4:	47b0      	blx	r6
  402af6:	4603      	mov	r3, r0
				if (res != FR_OK) break;
  402af8:	2800      	cmp	r0, #0
  402afa:	d1d6      	bne.n	402aaa <dir_register+0x1fa>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  402afc:	fa5f fa8b 	uxtb.w	sl, fp
  402b00:	6965      	ldr	r5, [r4, #20]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  402b02:	9b00      	ldr	r3, [sp, #0]
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  402b04:	f8d4 901c 	ldr.w	r9, [r4, #28]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  402b08:	736b      	strb	r3, [r5, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  402b0a:	f10a 32ff 	add.w	r2, sl, #4294967295
  402b0e:	eb02 0142 	add.w	r1, r2, r2, lsl #1
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  402b12:	270f      	movs	r7, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  402b14:	4603      	mov	r3, r0
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  402b16:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  402b1a:	72ef      	strb	r7, [r5, #11]
	dir[LDIR_Type] = 0;
  402b1c:	7328      	strb	r0, [r5, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  402b1e:	76a8      	strb	r0, [r5, #26]
  402b20:	76e8      	strb	r0, [r5, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  402b22:	4602      	mov	r2, r0
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402b24:	f64f 77ff 	movw	r7, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b28:	20ff      	movs	r0, #255	; 0xff
  402b2a:	e010      	b.n	402b4e <dir_register+0x29e>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402b2c:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b30:	f805 300e 	strb.w	r3, [r5, lr]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  402b34:	3201      	adds	r2, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b36:	44ae      	add	lr, r5
  402b38:	ea4f 2c13 	mov.w	ip, r3, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  402b3c:	2b00      	cmp	r3, #0
  402b3e:	bf08      	it	eq
  402b40:	463b      	moveq	r3, r7
	} while (++s < 13);
  402b42:	2a0d      	cmp	r2, #13
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402b44:	f101 0101 	add.w	r1, r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b48:	f88e c001 	strb.w	ip, [lr, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  402b4c:	d00c      	beq.n	402b68 <dir_register+0x2b8>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402b4e:	42bb      	cmp	r3, r7
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b50:	f818 e002 	ldrb.w	lr, [r8, r2]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  402b54:	d1ea      	bne.n	402b2c <dir_register+0x27c>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b56:	eb05 0c0e 	add.w	ip, r5, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  402b5a:	3201      	adds	r2, #1
  402b5c:	2a0d      	cmp	r2, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  402b5e:	f805 000e 	strb.w	r0, [r5, lr]
  402b62:	f88c 0001 	strb.w	r0, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  402b66:	d1f2      	bne.n	402b4e <dir_register+0x29e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  402b68:	f64f 72ff 	movw	r2, #65535	; 0xffff
  402b6c:	4293      	cmp	r3, r2
  402b6e:	d002      	beq.n	402b76 <dir_register+0x2c6>
  402b70:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  402b74:	b90b      	cbnz	r3, 402b7a <dir_register+0x2ca>
  402b76:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  402b7a:	f885 a000 	strb.w	sl, [r5]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  402b7e:	6823      	ldr	r3, [r4, #0]
				res = dir_next(dj, 0);	/* Next entry */
  402b80:	4a0b      	ldr	r2, [pc, #44]	; (402bb0 <dir_register+0x300>)
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  402b82:	2101      	movs	r1, #1
  402b84:	7119      	strb	r1, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  402b86:	4620      	mov	r0, r4
  402b88:	2100      	movs	r1, #0
  402b8a:	4790      	blx	r2
			} while (res == FR_OK && --ne);
  402b8c:	4603      	mov	r3, r0
  402b8e:	2800      	cmp	r0, #0
  402b90:	d18b      	bne.n	402aaa <dir_register+0x1fa>
  402b92:	f10b 3bff 	add.w	fp, fp, #4294967295
  402b96:	fa1f fb8b 	uxth.w	fp, fp
  402b9a:	f1bb 0f00 	cmp.w	fp, #0
  402b9e:	d1a7      	bne.n	402af0 <dir_register+0x240>
  402ba0:	e6d1      	b.n	402946 <dir_register+0x96>
  402ba2:	bf00      	nop
  402ba4:	00402389 	.word	0x00402389
  402ba8:	00401d7d 	.word	0x00401d7d
  402bac:	4ec4ec4f 	.word	0x4ec4ec4f
  402bb0:	00402609 	.word	0x00402609
  402bb4:	00402749 	.word	0x00402749
  402bb8:	00405454 	.word	0x00405454

00402bbc <remove_chain.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  402bbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402bc0:	4604      	mov	r4, r0
  402bc2:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  402bc4:	69a3      	ldr	r3, [r4, #24]
  402bc6:	4f16      	ldr	r7, [pc, #88]	; (402c20 <remove_chain.part.6+0x64>)
  402bc8:	f8df 8058 	ldr.w	r8, [pc, #88]	; 402c24 <remove_chain.part.6+0x68>
  402bcc:	429d      	cmp	r5, r3
  402bce:	d220      	bcs.n	402c12 <remove_chain.part.6+0x56>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402bd0:	2d01      	cmp	r5, #1
  402bd2:	d90b      	bls.n	402bec <remove_chain.part.6+0x30>
  402bd4:	4620      	mov	r0, r4
  402bd6:	4629      	mov	r1, r5
  402bd8:	47b8      	blx	r7

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  402bda:	4606      	mov	r6, r0
  402bdc:	b1c8      	cbz	r0, 402c12 <remove_chain.part.6+0x56>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  402bde:	2801      	cmp	r0, #1
  402be0:	d004      	beq.n	402bec <remove_chain.part.6+0x30>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  402be2:	3001      	adds	r0, #1
  402be4:	d018      	beq.n	402c18 <remove_chain.part.6+0x5c>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402be6:	69a3      	ldr	r3, [r4, #24]
  402be8:	429d      	cmp	r5, r3
  402bea:	d302      	bcc.n	402bf2 <remove_chain.part.6+0x36>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  402bec:	2002      	movs	r0, #2
  402bee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402bf2:	2200      	movs	r2, #0
  402bf4:	4629      	mov	r1, r5
  402bf6:	4620      	mov	r0, r4
  402bf8:	47c0      	blx	r8
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
  402bfa:	2201      	movs	r2, #1
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
  402bfc:	b968      	cbnz	r0, 402c1a <remove_chain.part.6+0x5e>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  402bfe:	6923      	ldr	r3, [r4, #16]
  402c00:	1c59      	adds	r1, r3, #1
  402c02:	d002      	beq.n	402c0a <remove_chain.part.6+0x4e>
				fs->free_clust++;
  402c04:	4413      	add	r3, r2
  402c06:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  402c08:	7162      	strb	r2, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  402c0a:	69a3      	ldr	r3, [r4, #24]
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  402c0c:	4635      	mov	r5, r6
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  402c0e:	429d      	cmp	r5, r3
  402c10:	d3de      	bcc.n	402bd0 <remove_chain.part.6+0x14>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  402c12:	2000      	movs	r0, #0
  402c14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  402c18:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  402c1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402c1e:	bf00      	nop
  402c20:	004022bd 	.word	0x004022bd
  402c24:	00402431 	.word	0x00402431

00402c28 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  402c28:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  402c2c:	780b      	ldrb	r3, [r1, #0]
  402c2e:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  402c30:	b083      	sub	sp, #12
  402c32:	4689      	mov	r9, r1
  402c34:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  402c36:	f000 8133 	beq.w	402ea0 <follow_path+0x278>
  402c3a:	2b5c      	cmp	r3, #92	; 0x5c
  402c3c:	f000 8130 	beq.w	402ea0 <follow_path+0x278>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
  402c40:	2400      	movs	r4, #0
  402c42:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  402c44:	f899 0000 	ldrb.w	r0, [r9]
  402c48:	281f      	cmp	r0, #31
  402c4a:	f240 8132 	bls.w	402eb2 <follow_path+0x28a>
  402c4e:	4da7      	ldr	r5, [pc, #668]	; (402eec <follow_path+0x2c4>)
  402c50:	e001      	b.n	402c56 <follow_path+0x2e>
  402c52:	f819 0f01 	ldrb.w	r0, [r9, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  402c56:	282f      	cmp	r0, #47	; 0x2f
  402c58:	d0fb      	beq.n	402c52 <follow_path+0x2a>
  402c5a:	285c      	cmp	r0, #92	; 0x5c
  402c5c:	d0f9      	beq.n	402c52 <follow_path+0x2a>
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402c5e:	281f      	cmp	r0, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
  402c60:	69f7      	ldr	r7, [r6, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402c62:	f240 80ec 	bls.w	402e3e <follow_path+0x216>
  402c66:	282f      	cmp	r0, #47	; 0x2f
  402c68:	d02d      	beq.n	402cc6 <follow_path+0x9e>
  402c6a:	285c      	cmp	r0, #92	; 0x5c
  402c6c:	d02b      	beq.n	402cc6 <follow_path+0x9e>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402c6e:	2101      	movs	r1, #1
  402c70:	f1a7 0b02 	sub.w	fp, r7, #2
  402c74:	46ca      	mov	sl, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402c76:	2401      	movs	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402c78:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  402c7a:	b300      	cbz	r0, 402cbe <follow_path+0x96>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  402c7c:	287f      	cmp	r0, #127	; 0x7f
  402c7e:	d809      	bhi.n	402c94 <follow_path+0x6c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  402c80:	2822      	cmp	r0, #34	; 0x22
  402c82:	d01c      	beq.n	402cbe <follow_path+0x96>
  402c84:	4a9a      	ldr	r2, [pc, #616]	; (402ef0 <follow_path+0x2c8>)
  402c86:	e001      	b.n	402c8c <follow_path+0x64>
  402c88:	4298      	cmp	r0, r3
  402c8a:	d018      	beq.n	402cbe <follow_path+0x96>
  402c8c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  402c90:	2b00      	cmp	r3, #0
  402c92:	d1f9      	bne.n	402c88 <follow_path+0x60>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  402c94:	f82b 0f02 	strh.w	r0, [fp, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402c98:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402c9c:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402c9e:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  402ca2:	f240 80ce 	bls.w	402e42 <follow_path+0x21a>
  402ca6:	282f      	cmp	r0, #47	; 0x2f
  402ca8:	d00f      	beq.n	402cca <follow_path+0xa2>
  402caa:	285c      	cmp	r0, #92	; 0x5c
  402cac:	d00d      	beq.n	402cca <follow_path+0xa2>
		if (di >= _MAX_LFN)				/* Reject too long name */
  402cae:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  402cb2:	d004      	beq.n	402cbe <follow_path+0x96>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402cb4:	2101      	movs	r1, #1
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  402cb6:	461c      	mov	r4, r3
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  402cb8:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  402cba:	2800      	cmp	r0, #0
  402cbc:	d1de      	bne.n	402c7c <follow_path+0x54>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  402cbe:	2006      	movs	r0, #6
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  402cc0:	b003      	add	sp, #12
  402cc2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  402cc6:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  402cc8:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  402cca:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402ccc:	f04f 0b00 	mov.w	fp, #0
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402cd0:	2c00      	cmp	r4, #0
  402cd2:	d0f4      	beq.n	402cbe <follow_path+0x96>
  402cd4:	eb07 0044 	add.w	r0, r7, r4, lsl #1
		w = lfn[di-1];
  402cd8:	f830 2d02 	ldrh.w	r2, [r0, #-2]!
		if (w != ' ' && w != '.') break;
  402cdc:	2a20      	cmp	r2, #32
  402cde:	d001      	beq.n	402ce4 <follow_path+0xbc>
  402ce0:	2a2e      	cmp	r2, #46	; 0x2e
  402ce2:	d102      	bne.n	402cea <follow_path+0xc2>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  402ce4:	3c01      	subs	r4, #1
  402ce6:	d1f7      	bne.n	402cd8 <follow_path+0xb0>
  402ce8:	e7e9      	b.n	402cbe <follow_path+0x96>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  402cea:	2300      	movs	r3, #0
  402cec:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  402cf0:	69b3      	ldr	r3, [r6, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  402cf2:	eb07 0044 	add.w	r0, r7, r4, lsl #1
  402cf6:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402cfa:	2220      	movs	r2, #32
  402cfc:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402d00:	428b      	cmp	r3, r1
  402d02:	d1fb      	bne.n	402cfc <follow_path+0xd4>
  402d04:	1ebb      	subs	r3, r7, #2
  402d06:	f04f 0a00 	mov.w	sl, #0
  402d0a:	e001      	b.n	402d10 <follow_path+0xe8>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  402d0c:	f10a 0a01 	add.w	sl, sl, #1
  402d10:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  402d14:	2a20      	cmp	r2, #32
  402d16:	d0f9      	beq.n	402d0c <follow_path+0xe4>
  402d18:	2a2e      	cmp	r2, #46	; 0x2e
  402d1a:	d0f7      	beq.n	402d0c <follow_path+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
  402d1c:	f1ba 0f00 	cmp.w	sl, #0
  402d20:	d001      	beq.n	402d26 <follow_path+0xfe>
  402d22:	f04b 0b03 	orr.w	fp, fp, #3
  402d26:	4603      	mov	r3, r0
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  402d28:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
  402d2c:	292e      	cmp	r1, #46	; 0x2e
  402d2e:	d001      	beq.n	402d34 <follow_path+0x10c>
  402d30:	3c01      	subs	r4, #1
  402d32:	d1f9      	bne.n	402d28 <follow_path+0x100>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  402d34:	f04f 0c00 	mov.w	ip, #0
  402d38:	4610      	mov	r0, r2
  402d3a:	46e0      	mov	r8, ip
  402d3c:	2308      	movs	r3, #8
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  402d3e:	f10a 0a01 	add.w	sl, sl, #1
		if (!w) break;					/* Break on end of the LFN */
  402d42:	b378      	cbz	r0, 402da4 <follow_path+0x17c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402d44:	2820      	cmp	r0, #32
  402d46:	d01f      	beq.n	402d88 <follow_path+0x160>
  402d48:	282e      	cmp	r0, #46	; 0x2e
  402d4a:	d01b      	beq.n	402d84 <follow_path+0x15c>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  402d4c:	459c      	cmp	ip, r3
  402d4e:	d220      	bcs.n	402d92 <follow_path+0x16a>
  402d50:	4554      	cmp	r4, sl
  402d52:	d07a      	beq.n	402e4a <follow_path+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  402d54:	287f      	cmp	r0, #127	; 0x7f
  402d56:	f200 8083 	bhi.w	402e60 <follow_path+0x238>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  402d5a:	282b      	cmp	r0, #43	; 0x2b
  402d5c:	f000 8090 	beq.w	402e80 <follow_path+0x258>
  402d60:	4a64      	ldr	r2, [pc, #400]	; (402ef4 <follow_path+0x2cc>)
  402d62:	e002      	b.n	402d6a <follow_path+0x142>
  402d64:	4288      	cmp	r0, r1
  402d66:	f000 808b 	beq.w	402e80 <follow_path+0x258>
  402d6a:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  402d6e:	2900      	cmp	r1, #0
  402d70:	d1f8      	bne.n	402d64 <follow_path+0x13c>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  402d72:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
  402d76:	2919      	cmp	r1, #25
  402d78:	f200 80a6 	bhi.w	402ec8 <follow_path+0x2a0>
					b |= 2;
  402d7c:	f048 0802 	orr.w	r8, r8, #2
  402d80:	b2c0      	uxtb	r0, r0
  402d82:	e080      	b.n	402e86 <follow_path+0x25e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  402d84:	4554      	cmp	r4, sl
  402d86:	d060      	beq.n	402e4a <follow_path+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
  402d88:	f04b 0b03 	orr.w	fp, fp, #3
  402d8c:	f837 001a 	ldrh.w	r0, [r7, sl, lsl #1]
  402d90:	e7d5      	b.n	402d3e <follow_path+0x116>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  402d92:	2b0b      	cmp	r3, #11
  402d94:	f000 80a6 	beq.w	402ee4 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  402d98:	4554      	cmp	r4, sl
  402d9a:	d058      	beq.n	402e4e <follow_path+0x226>
			if (si > di) break;			/* No extension */
  402d9c:	45a2      	cmp	sl, r4

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  402d9e:	f04b 0b03 	orr.w	fp, fp, #3
			if (si > di) break;			/* No extension */
  402da2:	d954      	bls.n	402e4e <follow_path+0x226>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  402da4:	69b1      	ldr	r1, [r6, #24]
  402da6:	7808      	ldrb	r0, [r1, #0]
  402da8:	28e5      	cmp	r0, #229	; 0xe5
  402daa:	d075      	beq.n	402e98 <follow_path+0x270>

	if (ni == 8) b <<= 2;
  402dac:	2b08      	cmp	r3, #8
  402dae:	bf04      	itt	eq
  402db0:	ea4f 0288 	moveq.w	r2, r8, lsl #2
  402db4:	fa5f f882 	uxtbeq.w	r8, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  402db8:	f008 030c 	and.w	r3, r8, #12
  402dbc:	2b0c      	cmp	r3, #12
  402dbe:	d068      	beq.n	402e92 <follow_path+0x26a>
  402dc0:	f008 0003 	and.w	r0, r8, #3
  402dc4:	2803      	cmp	r0, #3
  402dc6:	d064      	beq.n	402e92 <follow_path+0x26a>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  402dc8:	f01b 0f02 	tst.w	fp, #2
  402dcc:	d109      	bne.n	402de2 <follow_path+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  402dce:	f008 0203 	and.w	r2, r8, #3
  402dd2:	2a01      	cmp	r2, #1
  402dd4:	bf08      	it	eq
  402dd6:	f04b 0b10 	orreq.w	fp, fp, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  402dda:	2b04      	cmp	r3, #4
  402ddc:	bf08      	it	eq
  402dde:	f04b 0b08 	orreq.w	fp, fp, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  402de2:	f881 b00b 	strb.w	fp, [r1, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  402de6:	4630      	mov	r0, r6
  402de8:	2100      	movs	r1, #0
  402dea:	4b43      	ldr	r3, [pc, #268]	; (402ef8 <follow_path+0x2d0>)
  402dec:	4798      	blx	r3
	if (res != FR_OK) return res;
  402dee:	b9d0      	cbnz	r0, 402e26 <follow_path+0x1fe>
  402df0:	4b42      	ldr	r3, [pc, #264]	; (402efc <follow_path+0x2d4>)
  402df2:	4630      	mov	r0, r6
  402df4:	4798      	blx	r3
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  402df6:	69b3      	ldr	r3, [r6, #24]
  402df8:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  402dfa:	b9b0      	cbnz	r0, 402e2a <follow_path+0x202>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  402dfc:	0759      	lsls	r1, r3, #29
  402dfe:	f53f af5f 	bmi.w	402cc0 <follow_path+0x98>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  402e02:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  402e04:	7ada      	ldrb	r2, [r3, #11]
  402e06:	06d2      	lsls	r2, r2, #27
  402e08:	d568      	bpl.n	402edc <follow_path+0x2b4>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  402e0a:	7d5c      	ldrb	r4, [r3, #21]
  402e0c:	7d1a      	ldrb	r2, [r3, #20]
  402e0e:	7ed8      	ldrb	r0, [r3, #27]
  402e10:	7e99      	ldrb	r1, [r3, #26]
  402e12:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  402e16:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  402e1a:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  402e1e:	60b3      	str	r3, [r6, #8]
  402e20:	f899 0000 	ldrb.w	r0, [r9]
		}
  402e24:	e717      	b.n	402c56 <follow_path+0x2e>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  402e26:	69b3      	ldr	r3, [r6, #24]
  402e28:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  402e2a:	2804      	cmp	r0, #4
  402e2c:	f47f af48 	bne.w	402cc0 <follow_path+0x98>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  402e30:	f013 0f04 	tst.w	r3, #4
  402e34:	bf08      	it	eq
  402e36:	2005      	moveq	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  402e38:	b003      	add	sp, #12
  402e3a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  402e3e:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  402e40:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  402e42:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  402e44:	f04f 0b04 	mov.w	fp, #4
  402e48:	e742      	b.n	402cd0 <follow_path+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  402e4a:	2b0b      	cmp	r3, #11
  402e4c:	d04a      	beq.n	402ee4 <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  402e4e:	ea4f 0288 	mov.w	r2, r8, lsl #2
  402e52:	fa5f f882 	uxtb.w	r8, r2
  402e56:	46a2      	mov	sl, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  402e58:	230b      	movs	r3, #11
  402e5a:	f04f 0c08 	mov.w	ip, #8
  402e5e:	e795      	b.n	402d8c <follow_path+0x164>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  402e60:	2100      	movs	r1, #0
  402e62:	e88d 1008 	stmia.w	sp, {r3, ip}
  402e66:	47a8      	blx	r5
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  402e68:	e89d 1008 	ldmia.w	sp, {r3, ip}
  402e6c:	b348      	cbz	r0, 402ec2 <follow_path+0x29a>
  402e6e:	4a24      	ldr	r2, [pc, #144]	; (402f00 <follow_path+0x2d8>)
  402e70:	4410      	add	r0, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  402e72:	f04b 0b02 	orr.w	fp, fp, #2
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  402e76:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  402e7a:	2800      	cmp	r0, #0
  402e7c:	f47f af6d 	bne.w	402d5a <follow_path+0x132>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  402e80:	f04b 0b03 	orr.w	fp, fp, #3
  402e84:	205f      	movs	r0, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  402e86:	69b1      	ldr	r1, [r6, #24]
  402e88:	f801 000c 	strb.w	r0, [r1, ip]
  402e8c:	f10c 0c01 	add.w	ip, ip, #1
  402e90:	e77c      	b.n	402d8c <follow_path+0x164>

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
  402e92:	f04b 0b02 	orr.w	fp, fp, #2
  402e96:	e797      	b.n	402dc8 <follow_path+0x1a0>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  402e98:	2005      	movs	r0, #5
  402e9a:	7008      	strb	r0, [r1, #0]
  402e9c:	69b1      	ldr	r1, [r6, #24]
  402e9e:	e785      	b.n	402dac <follow_path+0x184>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
  402ea0:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
  402ea4:	2400      	movs	r4, #0
  402ea6:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  402ea8:	f899 0000 	ldrb.w	r0, [r9]
  402eac:	281f      	cmp	r0, #31
  402eae:	f63f aece 	bhi.w	402c4e <follow_path+0x26>
		res = dir_sdi(dj, 0);
  402eb2:	4630      	mov	r0, r6
  402eb4:	4621      	mov	r1, r4
  402eb6:	4b10      	ldr	r3, [pc, #64]	; (402ef8 <follow_path+0x2d0>)
  402eb8:	4798      	blx	r3
		dj->dir = 0;
  402eba:	6174      	str	r4, [r6, #20]
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  402ebc:	b003      	add	sp, #12
  402ebe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  402ec2:	f04b 0b02 	orr.w	fp, fp, #2
  402ec6:	e7db      	b.n	402e80 <follow_path+0x258>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  402ec8:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
  402ecc:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
  402ece:	bf97      	itett	ls
  402ed0:	3820      	subls	r0, #32
  402ed2:	b2c0      	uxtbhi	r0, r0
  402ed4:	b2c0      	uxtbls	r0, r0
  402ed6:	f048 0801 	orrls.w	r8, r8, #1
  402eda:	e7d4      	b.n	402e86 <follow_path+0x25e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  402edc:	2005      	movs	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  402ede:	b003      	add	sp, #12
  402ee0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
  402ee4:	f04b 0b03 	orr.w	fp, fp, #3
  402ee8:	230b      	movs	r3, #11
  402eea:	e75b      	b.n	402da4 <follow_path+0x17c>
  402eec:	0040349d 	.word	0x0040349d
  402ef0:	00405440 	.word	0x00405440
  402ef4:	0040544c 	.word	0x0040544c
  402ef8:	00402389 	.word	0x00402389
  402efc:	00402749 	.word	0x00402749
  402f00:	004053c0 	.word	0x004053c0

00402f04 <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
  402f04:	b4f0      	push	{r4, r5, r6, r7}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  402f06:	b110      	cbz	r0, 402f0e <f_mount+0xa>
		return FR_INVALID_DRIVE;
  402f08:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  402f0a:	bcf0      	pop	{r4, r5, r6, r7}
  402f0c:	4770      	bx	lr
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  402f0e:	4d0b      	ldr	r5, [pc, #44]	; (402f3c <f_mount+0x38>)
  402f10:	682b      	ldr	r3, [r5, #0]

	if (rfs) {
  402f12:	b15b      	cbz	r3, 402f2c <f_mount+0x28>
  402f14:	4c0a      	ldr	r4, [pc, #40]	; (402f40 <f_mount+0x3c>)
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  402f16:	4607      	mov	r7, r0
  402f18:	4626      	mov	r6, r4
  402f1a:	5822      	ldr	r2, [r4, r0]
  402f1c:	4293      	cmp	r3, r2
  402f1e:	bf08      	it	eq
  402f20:	5187      	streq	r7, [r0, r6]
  402f22:	300c      	adds	r0, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  402f24:	2824      	cmp	r0, #36	; 0x24
  402f26:	d1f8      	bne.n	402f1a <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  402f28:	2200      	movs	r2, #0
  402f2a:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  402f2c:	b109      	cbz	r1, 402f32 <f_mount+0x2e>
		fs->fs_type = 0;		/* Clear new fs object */
  402f2e:	2300      	movs	r3, #0
  402f30:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  402f32:	6029      	str	r1, [r5, #0]

	return FR_OK;
  402f34:	2000      	movs	r0, #0
}
  402f36:	bcf0      	pop	{r4, r5, r6, r7}
  402f38:	4770      	bx	lr
  402f3a:	bf00      	nop
  402f3c:	20000e60 	.word	0x20000e60
  402f40:	20000e3c 	.word	0x20000e3c

00402f44 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  402f44:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402f48:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  402f4c:	2300      	movs	r3, #0
  402f4e:	6003      	str	r3, [r0, #0]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  402f50:	4616      	mov	r6, r2
  402f52:	9101      	str	r1, [sp, #4]

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  402f54:	f002 021e 	and.w	r2, r2, #30
  402f58:	4b9a      	ldr	r3, [pc, #616]	; (4031c4 <f_open+0x280>)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  402f5a:	4604      	mov	r4, r0

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  402f5c:	a905      	add	r1, sp, #20
  402f5e:	a801      	add	r0, sp, #4
  402f60:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  402f62:	ab02      	add	r3, sp, #8
  402f64:	aa0e      	add	r2, sp, #56	; 0x38
  402f66:	930b      	str	r3, [sp, #44]	; 0x2c
  402f68:	920c      	str	r2, [sp, #48]	; 0x30


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  402f6a:	f006 071f 	and.w	r7, r6, #31
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
  402f6e:	b130      	cbz	r0, 402f7e <f_open+0x3a>
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  402f70:	f016 0f1c 	tst.w	r6, #28
  402f74:	d11a      	bne.n	402fac <f_open+0x68>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  402f76:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  402f7a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
  402f7e:	9901      	ldr	r1, [sp, #4]
  402f80:	4b91      	ldr	r3, [pc, #580]	; (4031c8 <f_open+0x284>)
  402f82:	a805      	add	r0, sp, #20
  402f84:	4798      	blx	r3
	dir = dj.dir;
  402f86:	9d0a      	ldr	r5, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  402f88:	2800      	cmp	r0, #0
  402f8a:	d1f1      	bne.n	402f70 <f_open+0x2c>
		if (!dir)	/* Current dir itself */
  402f8c:	2d00      	cmp	r5, #0
  402f8e:	f000 80ab 	beq.w	4030e8 <f_open+0x1a4>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  402f92:	f037 0801 	bics.w	r8, r7, #1
  402f96:	bf0c      	ite	eq
  402f98:	2100      	moveq	r1, #0
  402f9a:	2101      	movne	r1, #1
  402f9c:	a805      	add	r0, sp, #20
  402f9e:	4b8b      	ldr	r3, [pc, #556]	; (4031cc <f_open+0x288>)
  402fa0:	4798      	blx	r3
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  402fa2:	f016 0f1c 	tst.w	r6, #28
  402fa6:	d01b      	beq.n	402fe0 <f_open+0x9c>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  402fa8:	2800      	cmp	r0, #0
  402faa:	d050      	beq.n	40304e <f_open+0x10a>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  402fac:	2804      	cmp	r0, #4
  402fae:	d1e2      	bne.n	402f76 <f_open+0x32>
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  402fb0:	4b87      	ldr	r3, [pc, #540]	; (4031d0 <f_open+0x28c>)
  402fb2:	681a      	ldr	r2, [r3, #0]
  402fb4:	b12a      	cbz	r2, 402fc2 <f_open+0x7e>
  402fb6:	68da      	ldr	r2, [r3, #12]
  402fb8:	b11a      	cbz	r2, 402fc2 <f_open+0x7e>
  402fba:	699b      	ldr	r3, [r3, #24]
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  402fbc:	2012      	movs	r0, #18
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  402fbe:	2b00      	cmp	r3, #0
  402fc0:	d1d9      	bne.n	402f76 <f_open+0x32>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  402fc2:	a805      	add	r0, sp, #20
  402fc4:	4b83      	ldr	r3, [pc, #524]	; (4031d4 <f_open+0x290>)
  402fc6:	4798      	blx	r3
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  402fc8:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  402fcc:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  402fce:	2800      	cmp	r0, #0
  402fd0:	d1d1      	bne.n	402f76 <f_open+0x32>
  402fd2:	0738      	lsls	r0, r7, #28
  402fd4:	f100 808a 	bmi.w	4030ec <f_open+0x1a8>
  402fd8:	9e05      	ldr	r6, [sp, #20]
  402fda:	f027 0801 	bic.w	r8, r7, #1
  402fde:	e011      	b.n	403004 <f_open+0xc0>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  402fe0:	2800      	cmp	r0, #0
  402fe2:	d1c8      	bne.n	402f76 <f_open+0x32>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  402fe4:	7aeb      	ldrb	r3, [r5, #11]
  402fe6:	06d9      	lsls	r1, r3, #27
  402fe8:	d43e      	bmi.n	403068 <f_open+0x124>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  402fea:	07b2      	lsls	r2, r6, #30
  402fec:	d501      	bpl.n	402ff2 <f_open+0xae>
  402fee:	07db      	lsls	r3, r3, #31
  402ff0:	d435      	bmi.n	40305e <f_open+0x11a>
  402ff2:	f006 0308 	and.w	r3, r6, #8
  402ff6:	b2db      	uxtb	r3, r3
  402ff8:	9e05      	ldr	r6, [sp, #20]
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  402ffa:	b11b      	cbz	r3, 403004 <f_open+0xc0>
			mode |= FA__WRITTEN;
  402ffc:	f047 0720 	orr.w	r7, r7, #32
  403000:	f027 0801 	bic.w	r8, r7, #1
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  403004:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
			Files[i].clu == dj->sclust &&
  403006:	9807      	ldr	r0, [sp, #28]
			Files[i].idx == dj->index) break;
  403008:	f8bd c01a 	ldrh.w	ip, [sp, #26]
  40300c:	4a72      	ldr	r2, [pc, #456]	; (4031d8 <f_open+0x294>)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  40300e:	61e3      	str	r3, [r4, #28]
		fp->dir_ptr = dir;
  403010:	6225      	str	r5, [r4, #32]
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  403012:	2300      	movs	r3, #0
		if (Files[i].fs == dj->fs &&
  403014:	f852 1c08 	ldr.w	r1, [r2, #-8]
  403018:	42b1      	cmp	r1, r6
  40301a:	d02a      	beq.n	403072 <f_open+0x12e>
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  40301c:	3301      	adds	r3, #1
  40301e:	2b03      	cmp	r3, #3
  403020:	f102 020c 	add.w	r2, r2, #12
  403024:	d1f6      	bne.n	403014 <f_open+0xd0>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403026:	4a6a      	ldr	r2, [pc, #424]	; (4031d0 <f_open+0x28c>)
  403028:	6813      	ldr	r3, [r2, #0]
  40302a:	2b00      	cmp	r3, #0
  40302c:	f000 809a 	beq.w	403164 <f_open+0x220>
  403030:	68d3      	ldr	r3, [r2, #12]
  403032:	2b00      	cmp	r3, #0
  403034:	f000 8095 	beq.w	403162 <f_open+0x21e>
  403038:	6993      	ldr	r3, [r2, #24]
  40303a:	2b00      	cmp	r3, #0
  40303c:	f000 80ac 	beq.w	403198 <f_open+0x254>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403040:	2300      	movs	r3, #0
		if (!fp->lockid) res = FR_INT_ERR;
  403042:	2002      	movs	r0, #2
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403044:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403046:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40304a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  40304e:	7aeb      	ldrb	r3, [r5, #11]
  403050:	f013 0f11 	tst.w	r3, #17
  403054:	d103      	bne.n	40305e <f_open+0x11a>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  403056:	0776      	lsls	r6, r6, #29
  403058:	d5bb      	bpl.n	402fd2 <f_open+0x8e>
					res = FR_EXIST;
  40305a:	2008      	movs	r0, #8
  40305c:	e78b      	b.n	402f76 <f_open+0x32>
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
  40305e:	2007      	movs	r0, #7
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403060:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403064:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
  403068:	2004      	movs	r0, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40306a:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40306e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
  403072:	f852 1c04 	ldr.w	r1, [r2, #-4]
  403076:	4281      	cmp	r1, r0
  403078:	d1d0      	bne.n	40301c <f_open+0xd8>
			Files[i].clu == dj->sclust &&
  40307a:	8811      	ldrh	r1, [r2, #0]
  40307c:	4561      	cmp	r1, ip
  40307e:	d1cd      	bne.n	40301c <f_open+0xd8>
  403080:	0059      	lsls	r1, r3, #1
  403082:	4a53      	ldr	r2, [pc, #332]	; (4031d0 <f_open+0x28c>)
  403084:	18c8      	adds	r0, r1, r3
  403086:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  40308a:	8940      	ldrh	r0, [r0, #10]
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  40308c:	f1b8 0f00 	cmp.w	r8, #0
  403090:	d161      	bne.n	403156 <f_open+0x212>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  403092:	3001      	adds	r0, #1
  403094:	b280      	uxth	r0, r0
  403096:	4419      	add	r1, r3
  403098:	eb02 0281 	add.w	r2, r2, r1, lsl #2

	return i + 1;
  40309c:	3301      	adds	r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40309e:	8150      	strh	r0, [r2, #10]
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  4030a0:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fp->lockid) res = FR_INT_ERR;
  4030a2:	2b00      	cmp	r3, #0
  4030a4:	d052      	beq.n	40314c <f_open+0x208>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  4030a6:	71a7      	strb	r7, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  4030a8:	7d68      	ldrb	r0, [r5, #21]
  4030aa:	7ea9      	ldrb	r1, [r5, #26]
  4030ac:	7d2a      	ldrb	r2, [r5, #20]
  4030ae:	7eeb      	ldrb	r3, [r5, #27]
  4030b0:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  4030b4:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  4030b8:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  4030bc:	6123      	str	r3, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4030be:	7fab      	ldrb	r3, [r5, #30]
  4030c0:	7fe8      	ldrb	r0, [r5, #31]
  4030c2:	7f29      	ldrb	r1, [r5, #28]
  4030c4:	7f6a      	ldrb	r2, [r5, #29]
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4030c6:	6026      	str	r6, [r4, #0]
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4030c8:	041b      	lsls	r3, r3, #16
  4030ca:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  4030ce:	430b      	orrs	r3, r1
		fp->fptr = 0;						/* File pointer */
  4030d0:	2000      	movs	r0, #0
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4030d2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4030d6:	60e3      	str	r3, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  4030d8:	60a0      	str	r0, [r4, #8]
		fp->dsect = 0;
  4030da:	61a0      	str	r0, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4030dc:	88f3      	ldrh	r3, [r6, #6]
  4030de:	80a3      	strh	r3, [r4, #4]
	}

	LEAVE_FF(dj.fs, res);
}
  4030e0:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4030e4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dir = dj.dir;

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
		if (!dir)	/* Current dir itself */
			res = FR_INVALID_NAME;
  4030e8:	2006      	movs	r0, #6
  4030ea:	e741      	b.n	402f70 <f_open+0x2c>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
  4030ec:	4b3b      	ldr	r3, [pc, #236]	; (4031dc <f_open+0x298>)
  4030ee:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  4030f0:	f895 c015 	ldrb.w	ip, [r5, #21]
  4030f4:	7eab      	ldrb	r3, [r5, #26]
  4030f6:	7d29      	ldrb	r1, [r5, #20]
  4030f8:	7eea      	ldrb	r2, [r5, #27]
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  4030fa:	9e05      	ldr	r6, [sp, #20]
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4030fc:	73a8      	strb	r0, [r5, #14]
  4030fe:	ea4f 4810 	mov.w	r8, r0, lsr #16
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  403102:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
  403106:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  40310a:	f3c0 2907 	ubfx	r9, r0, #8, #8
			dir[DIR_Attr] = 0;					/* Reset attribute */
  40310e:	2300      	movs	r3, #0
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  403110:	f885 8010 	strb.w	r8, [r5, #16]
  403114:	0e00      	lsrs	r0, r0, #24
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  403116:	f04f 0c01 	mov.w	ip, #1
			if (cl) {							/* Remove the cluster chain if exist */
  40311a:	ea52 4801 	orrs.w	r8, r2, r1, lsl #16
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  40311e:	f885 900f 	strb.w	r9, [r5, #15]
  403122:	7468      	strb	r0, [r5, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  403124:	72eb      	strb	r3, [r5, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  403126:	772b      	strb	r3, [r5, #28]
  403128:	776b      	strb	r3, [r5, #29]
  40312a:	77ab      	strb	r3, [r5, #30]
  40312c:	77eb      	strb	r3, [r5, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  40312e:	76ab      	strb	r3, [r5, #26]
  403130:	76eb      	strb	r3, [r5, #27]
  403132:	752b      	strb	r3, [r5, #20]
  403134:	756b      	strb	r3, [r5, #21]
			dj.fs->wflag = 1;
  403136:	f886 c004 	strb.w	ip, [r6, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  40313a:	f43f af5f 	beq.w	402ffc <f_open+0xb8>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40313e:	45e0      	cmp	r8, ip
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  403140:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  403144:	d002      	beq.n	40314c <f_open+0x208>
  403146:	69b3      	ldr	r3, [r6, #24]
  403148:	4598      	cmp	r8, r3
  40314a:	d327      	bcc.n	40319c <f_open+0x258>
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
		if (!fp->lockid) res = FR_INT_ERR;
  40314c:	2002      	movs	r0, #2
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40314e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403152:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403156:	2800      	cmp	r0, #0
  403158:	f47f af72 	bne.w	403040 <f_open+0xfc>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40315c:	f44f 7080 	mov.w	r0, #256	; 0x100
  403160:	e799      	b.n	403096 <f_open+0x152>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403162:	2301      	movs	r3, #1
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
  403164:	0059      	lsls	r1, r3, #1
  403166:	eb01 0c03 	add.w	ip, r1, r3
  40316a:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  40316e:	eb02 000c 	add.w	r0, r2, ip
  403172:	f842 600c 	str.w	r6, [r2, ip]
		Files[i].clu = dj->sclust;
  403176:	f8dd b01c 	ldr.w	fp, [sp, #28]
		Files[i].idx = dj->index;
  40317a:	f8bd a01a 	ldrh.w	sl, [sp, #26]

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
  40317e:	f8c0 b004 	str.w	fp, [r0, #4]
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
  403182:	f04f 0c00 	mov.w	ip, #0
	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
  403186:	f8a0 a008 	strh.w	sl, [r0, #8]
		Files[i].ctr = 0;
  40318a:	f8a0 c00a 	strh.w	ip, [r0, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  40318e:	f1b8 0f00 	cmp.w	r8, #0
  403192:	d1e3      	bne.n	40315c <f_open+0x218>
  403194:	4640      	mov	r0, r8
  403196:	e77c      	b.n	403092 <f_open+0x14e>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403198:	2302      	movs	r3, #2
  40319a:	e7e3      	b.n	403164 <f_open+0x220>
  40319c:	4630      	mov	r0, r6
  40319e:	4641      	mov	r1, r8
  4031a0:	4b0f      	ldr	r3, [pc, #60]	; (4031e0 <f_open+0x29c>)
  4031a2:	4798      	blx	r3
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
  4031a4:	2800      	cmp	r0, #0
  4031a6:	f47f aee6 	bne.w	402f76 <f_open+0x32>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4031aa:	9805      	ldr	r0, [sp, #20]
					res = move_window(dj.fs, dw);
  4031ac:	4b0d      	ldr	r3, [pc, #52]	; (4031e4 <f_open+0x2a0>)
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4031ae:	f108 32ff 	add.w	r2, r8, #4294967295
					res = move_window(dj.fs, dw);
  4031b2:	4649      	mov	r1, r9
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4031b4:	60c2      	str	r2, [r0, #12]
					res = move_window(dj.fs, dw);
  4031b6:	4798      	blx	r3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  4031b8:	2800      	cmp	r0, #0
  4031ba:	f47f aedc 	bne.w	402f76 <f_open+0x32>
  4031be:	9e05      	ldr	r6, [sp, #20]
  4031c0:	e71c      	b.n	402ffc <f_open+0xb8>
  4031c2:	bf00      	nop
  4031c4:	00401f8d 	.word	0x00401f8d
  4031c8:	00402c29 	.word	0x00402c29
  4031cc:	00401d0d 	.word	0x00401d0d
  4031d0:	20000e3c 	.word	0x20000e3c
  4031d4:	004028b1 	.word	0x004028b1
  4031d8:	20000e44 	.word	0x20000e44
  4031dc:	00401cb5 	.word	0x00401cb5
  4031e0:	00402bbd 	.word	0x00402bbd
  4031e4:	00401d7d 	.word	0x00401d7d

004031e8 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4031e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4031ec:	469b      	mov	fp, r3
  4031ee:	4606      	mov	r6, r0
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  4031f0:	2300      	movs	r3, #0
  4031f2:	f8cb 3000 	str.w	r3, [fp]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4031f6:	b083      	sub	sp, #12
  4031f8:	460d      	mov	r5, r1
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  4031fa:	6800      	ldr	r0, [r0, #0]
  4031fc:	88b1      	ldrh	r1, [r6, #4]
  4031fe:	4b62      	ldr	r3, [pc, #392]	; (403388 <f_read+0x1a0>)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403200:	4614      	mov	r4, r2
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  403202:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  403204:	b928      	cbnz	r0, 403212 <f_read+0x2a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403206:	79b3      	ldrb	r3, [r6, #6]
  403208:	061f      	lsls	r7, r3, #24
  40320a:	d405      	bmi.n	403218 <f_read+0x30>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  40320c:	07d8      	lsls	r0, r3, #31
  40320e:	d407      	bmi.n	403220 <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
  403210:	2007      	movs	r0, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403212:	b003      	add	sp, #12
  403214:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  403218:	2002      	movs	r0, #2
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  40321a:	b003      	add	sp, #12
  40321c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403220:	68b1      	ldr	r1, [r6, #8]
  403222:	68f7      	ldr	r7, [r6, #12]
  403224:	1a7f      	subs	r7, r7, r1
  403226:	42bc      	cmp	r4, r7
  403228:	bf38      	it	cc
  40322a:	4627      	movcc	r7, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  40322c:	2f00      	cmp	r7, #0
  40322e:	f000 80a8 	beq.w	403382 <f_read+0x19a>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403232:	f3c1 0308 	ubfx	r3, r1, #0, #9
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403236:	f8df 8158 	ldr.w	r8, [pc, #344]	; 403390 <f_read+0x1a8>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40323a:	f8df 9158 	ldr.w	r9, [pc, #344]	; 403394 <f_read+0x1ac>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  40323e:	2b00      	cmp	r3, #0
  403240:	d13e      	bne.n	4032c0 <f_read+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  403242:	6830      	ldr	r0, [r6, #0]
  403244:	7883      	ldrb	r3, [r0, #2]
  403246:	3b01      	subs	r3, #1
  403248:	ea03 2351 	and.w	r3, r3, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  40324c:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  403250:	d04b      	beq.n	4032ea <f_read+0x102>
  403252:	6972      	ldr	r2, [r6, #20]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403254:	6981      	ldr	r1, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  403256:	f1a2 0c02 	sub.w	ip, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  40325a:	3902      	subs	r1, #2
  40325c:	458c      	cmp	ip, r1
  40325e:	d271      	bcs.n	403344 <f_read+0x15c>
	return clst * fs->csize + fs->database;
  403260:	7882      	ldrb	r2, [r0, #2]
  403262:	6a81      	ldr	r1, [r0, #40]	; 0x28
  403264:	fb02 110c 	mla	r1, r2, ip, r1
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403268:	2900      	cmp	r1, #0
  40326a:	d06b      	beq.n	403344 <f_read+0x15c>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  40326c:	0a7c      	lsrs	r4, r7, #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  40326e:	eb01 0a03 	add.w	sl, r1, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403272:	d043      	beq.n	4032fc <f_read+0x114>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  403274:	1919      	adds	r1, r3, r4
  403276:	4291      	cmp	r1, r2
					cc = fp->fs->csize - csect;
  403278:	bf88      	it	hi
  40327a:	ebc3 0402 	rsbhi	r4, r3, r2
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  40327e:	b2e3      	uxtb	r3, r4
  403280:	7840      	ldrb	r0, [r0, #1]
  403282:	4629      	mov	r1, r5
  403284:	4652      	mov	r2, sl
  403286:	47c0      	blx	r8
					ABORT(fp->fs, FR_DISK_ERR);
  403288:	79b3      	ldrb	r3, [r6, #6]
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  40328a:	2800      	cmp	r0, #0
  40328c:	d161      	bne.n	403352 <f_read+0x16a>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  40328e:	065a      	lsls	r2, r3, #25
  403290:	d504      	bpl.n	40329c <f_read+0xb4>
  403292:	69b3      	ldr	r3, [r6, #24]
  403294:	ebca 0303 	rsb	r3, sl, r3
  403298:	429c      	cmp	r4, r3
  40329a:	d85f      	bhi.n	40335c <f_read+0x174>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  40329c:	0262      	lsls	r2, r4, #9
  40329e:	68b1      	ldr	r1, [r6, #8]
  4032a0:	18ab      	adds	r3, r5, r2
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4032a2:	4411      	add	r1, r2
  4032a4:	60b1      	str	r1, [r6, #8]
  4032a6:	f8db 1000 	ldr.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4032aa:	1abf      	subs	r7, r7, r2
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4032ac:	4411      	add	r1, r2
  4032ae:	461d      	mov	r5, r3
  4032b0:	f8cb 1000 	str.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4032b4:	d065      	beq.n	403382 <f_read+0x19a>
  4032b6:	68b1      	ldr	r1, [r6, #8]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  4032b8:	f3c1 0308 	ubfx	r3, r1, #0, #9
  4032bc:	2b00      	cmp	r3, #0
  4032be:	d0c0      	beq.n	403242 <f_read+0x5a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  4032c0:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  4032c4:	f103 0428 	add.w	r4, r3, #40	; 0x28
  4032c8:	42ba      	cmp	r2, r7
  4032ca:	bf28      	it	cs
  4032cc:	463a      	movcs	r2, r7
  4032ce:	4434      	add	r4, r6
  4032d0:	462b      	mov	r3, r5
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4032d2:	2a00      	cmp	r2, #0
  4032d4:	d0e5      	beq.n	4032a2 <f_read+0xba>
  4032d6:	18ab      	adds	r3, r5, r2
  4032d8:	4629      	mov	r1, r5
		*d++ = *s++;
  4032da:	f814 5b01 	ldrb.w	r5, [r4], #1
  4032de:	f801 5b01 	strb.w	r5, [r1], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4032e2:	4299      	cmp	r1, r3
  4032e4:	d1f9      	bne.n	4032da <f_read+0xf2>
  4032e6:	68b1      	ldr	r1, [r6, #8]
  4032e8:	e7db      	b.n	4032a2 <f_read+0xba>
	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {						/* On the cluster boundary? */
				if (fp->fptr == 0) {			/* On the top of the file? */
  4032ea:	bb29      	cbnz	r1, 403338 <f_read+0x150>
					clst = fp->sclust;			/* Follow from the origin */
  4032ec:	6932      	ldr	r2, [r6, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  4032ee:	2a01      	cmp	r2, #1
  4032f0:	d928      	bls.n	403344 <f_read+0x15c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4032f2:	1c51      	adds	r1, r2, #1
  4032f4:	d02c      	beq.n	403350 <f_read+0x168>
  4032f6:	6830      	ldr	r0, [r6, #0]
				fp->clust = clst;				/* Update current cluster */
  4032f8:	6172      	str	r2, [r6, #20]
  4032fa:	e7ab      	b.n	403254 <f_read+0x6c>
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  4032fc:	69b2      	ldr	r2, [r6, #24]
  4032fe:	4552      	cmp	r2, sl
  403300:	d014      	beq.n	40332c <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403302:	79b3      	ldrb	r3, [r6, #6]
  403304:	065b      	lsls	r3, r3, #25
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403306:	f106 0428 	add.w	r4, r6, #40	; 0x28
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  40330a:	d509      	bpl.n	403320 <f_read+0x138>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40330c:	2301      	movs	r3, #1
  40330e:	7840      	ldrb	r0, [r0, #1]
  403310:	4621      	mov	r1, r4
  403312:	47c8      	blx	r9
						ABORT(fp->fs, FR_DISK_ERR);
  403314:	79b3      	ldrb	r3, [r6, #6]
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403316:	b9e0      	cbnz	r0, 403352 <f_read+0x16a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
  403318:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  40331c:	6830      	ldr	r0, [r6, #0]
  40331e:	71b3      	strb	r3, [r6, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403320:	7840      	ldrb	r0, [r0, #1]
  403322:	4621      	mov	r1, r4
  403324:	4652      	mov	r2, sl
  403326:	2301      	movs	r3, #1
  403328:	47c0      	blx	r8
  40332a:	b988      	cbnz	r0, 403350 <f_read+0x168>
  40332c:	68b1      	ldr	r1, [r6, #8]
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  40332e:	f8c6 a018 	str.w	sl, [r6, #24]
  403332:	f3c1 0308 	ubfx	r3, r1, #0, #9
  403336:	e7c3      	b.n	4032c0 <f_read+0xd8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  403338:	6971      	ldr	r1, [r6, #20]
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  40333a:	2901      	cmp	r1, #1
  40333c:	d902      	bls.n	403344 <f_read+0x15c>
  40333e:	6982      	ldr	r2, [r0, #24]
  403340:	4291      	cmp	r1, r2
  403342:	d318      	bcc.n	403376 <f_read+0x18e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403344:	79b3      	ldrb	r3, [r6, #6]
  403346:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40334a:	71b3      	strb	r3, [r6, #6]
  40334c:	2002      	movs	r0, #2
  40334e:	e760      	b.n	403212 <f_read+0x2a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
  403350:	79b3      	ldrb	r3, [r6, #6]
  403352:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403356:	71b3      	strb	r3, [r6, #6]
  403358:	2001      	movs	r0, #1
  40335a:	e75a      	b.n	403212 <f_read+0x2a>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  40335c:	eb05 2343 	add.w	r3, r5, r3, lsl #9
  403360:	f503 7000 	add.w	r0, r3, #512	; 0x200
  403364:	f106 0228 	add.w	r2, r6, #40	; 0x28
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403368:	f812 1b01 	ldrb.w	r1, [r2], #1
  40336c:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403370:	4283      	cmp	r3, r0
  403372:	d1f9      	bne.n	403368 <f_read+0x180>
  403374:	e792      	b.n	40329c <f_read+0xb4>
  403376:	9301      	str	r3, [sp, #4]
  403378:	4a04      	ldr	r2, [pc, #16]	; (40338c <f_read+0x1a4>)
  40337a:	4790      	blx	r2
  40337c:	9b01      	ldr	r3, [sp, #4]
  40337e:	4602      	mov	r2, r0
  403380:	e7b5      	b.n	4032ee <f_read+0x106>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
  403382:	2000      	movs	r0, #0
  403384:	e745      	b.n	403212 <f_read+0x2a>
  403386:	bf00      	nop
  403388:	00401ed9 	.word	0x00401ed9
  40338c:	004022bd 	.word	0x004022bd
  403390:	00401b5d 	.word	0x00401b5d
  403394:	00401bd1 	.word	0x00401bd1

00403398 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  403398:	b538      	push	{r3, r4, r5, lr}
  40339a:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  40339c:	4b27      	ldr	r3, [pc, #156]	; (40343c <f_sync+0xa4>)
  40339e:	6800      	ldr	r0, [r0, #0]
  4033a0:	88a1      	ldrh	r1, [r4, #4]
  4033a2:	4798      	blx	r3
	if (res == FR_OK) {
  4033a4:	b9d0      	cbnz	r0, 4033dc <f_sync+0x44>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  4033a6:	79a2      	ldrb	r2, [r4, #6]
  4033a8:	f002 0320 	and.w	r3, r2, #32
  4033ac:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  4033b0:	b1a3      	cbz	r3, 4033dc <f_sync+0x44>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
  4033b2:	0653      	lsls	r3, r2, #25
  4033b4:	d50d      	bpl.n	4033d2 <f_sync+0x3a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  4033b6:	4621      	mov	r1, r4
  4033b8:	69a2      	ldr	r2, [r4, #24]
  4033ba:	f851 3b28 	ldr.w	r3, [r1], #40
  4033be:	4d20      	ldr	r5, [pc, #128]	; (403440 <f_sync+0xa8>)
  4033c0:	7858      	ldrb	r0, [r3, #1]
  4033c2:	2301      	movs	r3, #1
  4033c4:	47a8      	blx	r5
  4033c6:	2800      	cmp	r0, #0
  4033c8:	d136      	bne.n	403438 <f_sync+0xa0>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  4033ca:	79a3      	ldrb	r3, [r4, #6]
  4033cc:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  4033d0:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  4033d2:	6820      	ldr	r0, [r4, #0]
  4033d4:	69e1      	ldr	r1, [r4, #28]
  4033d6:	4b1b      	ldr	r3, [pc, #108]	; (403444 <f_sync+0xac>)
  4033d8:	4798      	blx	r3
			if (res == FR_OK) {
  4033da:	b100      	cbz	r0, 4033de <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  4033dc:	bd38      	pop	{r3, r4, r5, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
  4033de:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
  4033e0:	4a19      	ldr	r2, [pc, #100]	; (403448 <f_sync+0xb0>)
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  4033e2:	7aeb      	ldrb	r3, [r5, #11]
  4033e4:	f043 0320 	orr.w	r3, r3, #32
  4033e8:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  4033ea:	68e3      	ldr	r3, [r4, #12]
  4033ec:	772b      	strb	r3, [r5, #28]
  4033ee:	89a3      	ldrh	r3, [r4, #12]
  4033f0:	0a1b      	lsrs	r3, r3, #8
  4033f2:	776b      	strb	r3, [r5, #29]
  4033f4:	89e3      	ldrh	r3, [r4, #14]
  4033f6:	77ab      	strb	r3, [r5, #30]
  4033f8:	7be3      	ldrb	r3, [r4, #15]
  4033fa:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  4033fc:	6923      	ldr	r3, [r4, #16]
  4033fe:	76ab      	strb	r3, [r5, #26]
  403400:	8a23      	ldrh	r3, [r4, #16]
  403402:	0a1b      	lsrs	r3, r3, #8
  403404:	76eb      	strb	r3, [r5, #27]
  403406:	8a63      	ldrh	r3, [r4, #18]
  403408:	752b      	strb	r3, [r5, #20]
  40340a:	8a63      	ldrh	r3, [r4, #18]
  40340c:	0a1b      	lsrs	r3, r3, #8
  40340e:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  403410:	4790      	blx	r2
				ST_DWORD(dir+DIR_WrtTime, tim);
  403412:	f3c0 2107 	ubfx	r1, r0, #8, #8
  403416:	0c02      	lsrs	r2, r0, #16
  403418:	0e03      	lsrs	r3, r0, #24
  40341a:	75e9      	strb	r1, [r5, #23]
  40341c:	762a      	strb	r2, [r5, #24]
  40341e:	75a8      	strb	r0, [r5, #22]
  403420:	766b      	strb	r3, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  403422:	79a0      	ldrb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403424:	6823      	ldr	r3, [r4, #0]
				res = sync(fp->fs);
  403426:	4a09      	ldr	r2, [pc, #36]	; (40344c <f_sync+0xb4>)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403428:	f020 0020 	bic.w	r0, r0, #32
				fp->fs->wflag = 1;
  40342c:	2101      	movs	r1, #1
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  40342e:	71a0      	strb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403430:	7119      	strb	r1, [r3, #4]
				res = sync(fp->fs);
  403432:	6820      	ldr	r0, [r4, #0]
  403434:	4790      	blx	r2
  403436:	bd38      	pop	{r3, r4, r5, pc}
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
  403438:	2001      	movs	r0, #1
  40343a:	e7cf      	b.n	4033dc <f_sync+0x44>
  40343c:	00401ed9 	.word	0x00401ed9
  403440:	00401bd1 	.word	0x00401bd1
  403444:	00401d7d 	.word	0x00401d7d
  403448:	00401cb5 	.word	0x00401cb5
  40344c:	00401e01 	.word	0x00401e01

00403450 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403450:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403452:	4b10      	ldr	r3, [pc, #64]	; (403494 <f_close+0x44>)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403454:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403456:	4798      	blx	r3
#if _FS_SHARE
	if (res == FR_OK) {		/* Decrement open counter */
  403458:	b998      	cbnz	r0, 403482 <f_close+0x32>
{
	WORD n;
	FRESULT res;


	if (--i < _FS_SHARE) {
  40345a:	6a63      	ldr	r3, [r4, #36]	; 0x24
  40345c:	3b01      	subs	r3, #1
  40345e:	2b02      	cmp	r3, #2
  403460:	d810      	bhi.n	403484 <f_close+0x34>
		n = Files[i].ctr;
  403462:	005d      	lsls	r5, r3, #1
  403464:	490c      	ldr	r1, [pc, #48]	; (403498 <f_close+0x48>)
  403466:	18ea      	adds	r2, r5, r3
  403468:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  40346c:	3208      	adds	r2, #8
  40346e:	8856      	ldrh	r6, [r2, #2]
		if (n == 0x100) n = 0;
		if (n) n--;
  403470:	f426 7780 	bic.w	r7, r6, #256	; 0x100
  403474:	b147      	cbz	r7, 403488 <f_close+0x38>
  403476:	3e01      	subs	r6, #1
  403478:	b2b6      	uxth	r6, r6
		Files[i].ctr = n;
  40347a:	8056      	strh	r6, [r2, #2]
		if (!n) Files[i].fs = 0;
  40347c:	b12e      	cbz	r6, 40348a <f_close+0x3a>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  40347e:	2300      	movs	r3, #0
  403480:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
  403482:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (n) n--;
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;
		res = FR_OK;
	} else {
		res = FR_INT_ERR;
  403484:	2002      	movs	r0, #2
  403486:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (--i < _FS_SHARE) {
		n = Files[i].ctr;
		if (n == 0x100) n = 0;
		if (n) n--;
		Files[i].ctr = n;
  403488:	8050      	strh	r0, [r2, #2]
		if (!n) Files[i].fs = 0;
  40348a:	442b      	add	r3, r5
  40348c:	009b      	lsls	r3, r3, #2
  40348e:	2200      	movs	r2, #0
  403490:	50ca      	str	r2, [r1, r3]
  403492:	e7f4      	b.n	40347e <f_close+0x2e>
  403494:	00403399 	.word	0x00403399
  403498:	20000e3c 	.word	0x20000e3c

0040349c <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  40349c:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
  40349e:	b410      	push	{r4}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  4034a0:	d90e      	bls.n	4034c0 <ff_convert+0x24>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  4034a2:	b981      	cbnz	r1, 4034c6 <ff_convert+0x2a>
  4034a4:	4b0e      	ldr	r3, [pc, #56]	; (4034e0 <ff_convert+0x44>)
  4034a6:	e001      	b.n	4034ac <ff_convert+0x10>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  4034a8:	2980      	cmp	r1, #128	; 0x80
  4034aa:	d015      	beq.n	4034d8 <ff_convert+0x3c>
				if (src == Tbl[c]) break;
  4034ac:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  4034b0:	4282      	cmp	r2, r0
  4034b2:	b28c      	uxth	r4, r1
  4034b4:	f101 0101 	add.w	r1, r1, #1
  4034b8:	d1f6      	bne.n	4034a8 <ff_convert+0xc>
  4034ba:	f104 0080 	add.w	r0, r4, #128	; 0x80
  4034be:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  4034c0:	f85d 4b04 	ldr.w	r4, [sp], #4
  4034c4:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4034c6:	28ff      	cmp	r0, #255	; 0xff
  4034c8:	d806      	bhi.n	4034d8 <ff_convert+0x3c>
  4034ca:	3880      	subs	r0, #128	; 0x80
  4034cc:	4b05      	ldr	r3, [pc, #20]	; (4034e4 <ff_convert+0x48>)
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  4034ce:	f85d 4b04 	ldr.w	r4, [sp], #4
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4034d2:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  4034d6:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  4034d8:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  4034da:	f85d 4b04 	ldr.w	r4, [sp], #4
  4034de:	4770      	bx	lr
  4034e0:	00405642 	.word	0x00405642
  4034e4:	00405644 	.word	0x00405644

004034e8 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  4034e8:	2861      	cmp	r0, #97	; 0x61
  4034ea:	d00a      	beq.n	403502 <ff_wtoupper+0x1a>
  4034ec:	4907      	ldr	r1, [pc, #28]	; (40350c <ff_wtoupper+0x24>)
  4034ee:	2200      	movs	r2, #0
  4034f0:	e001      	b.n	4034f6 <ff_wtoupper+0xe>
  4034f2:	4283      	cmp	r3, r0
  4034f4:	d006      	beq.n	403504 <ff_wtoupper+0x1c>
  4034f6:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  4034fa:	3201      	adds	r2, #1
  4034fc:	2b00      	cmp	r3, #0
  4034fe:	d1f8      	bne.n	4034f2 <ff_wtoupper+0xa>

	return tbl_lower[i] ? tbl_upper[i] : chr;
}
  403500:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403502:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403504:	4b02      	ldr	r3, [pc, #8]	; (403510 <ff_wtoupper+0x28>)
  403506:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  40350a:	4770      	bx	lr
  40350c:	00405464 	.word	0x00405464
  403510:	00405744 	.word	0x00405744

00403514 <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  403514:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  403516:	685a      	ldr	r2, [r3, #4]
  403518:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  40351a:	6842      	ldr	r2, [r0, #4]
  40351c:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  40351e:	685a      	ldr	r2, [r3, #4]
  403520:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  403522:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  403524:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403526:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403528:	6803      	ldr	r3, [r0, #0]
  40352a:	3301      	adds	r3, #1
  40352c:	6003      	str	r3, [r0, #0]
  40352e:	4770      	bx	lr

00403530 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  403530:	6843      	ldr	r3, [r0, #4]
  403532:	6882      	ldr	r2, [r0, #8]
  403534:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  403536:	6883      	ldr	r3, [r0, #8]
  403538:	6842      	ldr	r2, [r0, #4]
  40353a:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  40353c:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  40353e:	685a      	ldr	r2, [r3, #4]
  403540:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  403542:	bf04      	itt	eq
  403544:	6882      	ldreq	r2, [r0, #8]
  403546:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  403548:	2200      	movs	r2, #0
  40354a:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  40354c:	681a      	ldr	r2, [r3, #0]
  40354e:	3a01      	subs	r2, #1
  403550:	601a      	str	r2, [r3, #0]
  403552:	4770      	bx	lr

00403554 <SVC_Handler>:
/**
 * \brief Handler for Sytem supervisor call.
 */
void vPortSVCHandler(void)
{
	__asm volatile (" ldr r3, pxCurrentTCBConst2  \n"  /* Restore the context. */
  403554:	4b06      	ldr	r3, [pc, #24]	; (403570 <pxCurrentTCBConst2>)
  403556:	6819      	ldr	r1, [r3, #0]
  403558:	6808      	ldr	r0, [r1, #0]
  40355a:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40355e:	f380 8809 	msr	PSP, r0
  403562:	f04f 0000 	mov.w	r0, #0
  403566:	f380 8811 	msr	BASEPRI, r0
  40356a:	f04e 0e0d 	orr.w	lr, lr, #13
  40356e:	4770      	bx	lr

00403570 <pxCurrentTCBConst2>:
  403570:	20000f20 	.word	0x20000f20

00403574 <PendSV_Handler>:
 * \brief Handler for Sytem interrupt-driven request.
 */
void xPortPendSVHandler(void)
{
	/* This is a naked function. */
	__asm volatile (" mrs r0, psp      \n"
  403574:	f3ef 8009 	mrs	r0, PSP
  403578:	4b0c      	ldr	r3, [pc, #48]	; (4035ac <pxCurrentTCBConst>)
  40357a:	681a      	ldr	r2, [r3, #0]
  40357c:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403580:	6010      	str	r0, [r2, #0]
  403582:	e92d 4008 	stmdb	sp!, {r3, lr}
  403586:	f04f 0000 	mov.w	r0, #0
  40358a:	f380 8811 	msr	BASEPRI, r0
  40358e:	f000 f8b9 	bl	403704 <vTaskSwitchContext>
  403592:	f04f 0000 	mov.w	r0, #0
  403596:	f380 8811 	msr	BASEPRI, r0
  40359a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  40359e:	6819      	ldr	r1, [r3, #0]
  4035a0:	6808      	ldr	r0, [r1, #0]
  4035a2:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4035a6:	f380 8809 	msr	PSP, r0
  4035aa:	4770      	bx	lr

004035ac <pxCurrentTCBConst>:
  4035ac:	20000f20 	.word	0x20000f20

004035b0 <xPortSysTickHandler>:

/**
 * \brief Handler for Sytem Tick interrupt.
 */
void xPortSysTickHandler(void)
{
  4035b0:	b508      	push	{r3, lr}
	unsigned portLONG ulDummy;

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  4035b2:	4b07      	ldr	r3, [pc, #28]	; (4035d0 <xPortSysTickHandler+0x20>)
  4035b4:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  4035b8:	601a      	str	r2, [r3, #0]
#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
  4035ba:	f04f 0000 	mov.w	r0, #0
  4035be:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
  4035c2:	4b04      	ldr	r3, [pc, #16]	; (4035d4 <xPortSysTickHandler+0x24>)
  4035c4:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulDummy);
  4035c6:	f04f 0000 	mov.w	r0, #0
  4035ca:	f380 8811 	msr	BASEPRI, r0
  4035ce:	bd08      	pop	{r3, pc}
  4035d0:	e000ed04 	.word	0xe000ed04
  4035d4:	004035d9 	.word	0x004035d9

004035d8 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  4035d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4035dc:	4b3e      	ldr	r3, [pc, #248]	; (4036d8 <vTaskIncrementTick+0x100>)
  4035de:	681b      	ldr	r3, [r3, #0]
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  4035e0:	b083      	sub	sp, #12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4035e2:	2b00      	cmp	r3, #0
  4035e4:	d150      	bne.n	403688 <vTaskIncrementTick+0xb0>
	{
		++xTickCount;
  4035e6:	4c3d      	ldr	r4, [pc, #244]	; (4036dc <vTaskIncrementTick+0x104>)
  4035e8:	6823      	ldr	r3, [r4, #0]
  4035ea:	3301      	adds	r3, #1
  4035ec:	6023      	str	r3, [r4, #0]
		if( xTickCount == ( portTickType ) 0 )
  4035ee:	6823      	ldr	r3, [r4, #0]
  4035f0:	2b00      	cmp	r3, #0
  4035f2:	d050      	beq.n	403696 <vTaskIncrementTick+0xbe>
  4035f4:	4a3a      	ldr	r2, [pc, #232]	; (4036e0 <vTaskIncrementTick+0x108>)
  4035f6:	9201      	str	r2, [sp, #4]
  4035f8:	6813      	ldr	r3, [r2, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  4035fa:	6822      	ldr	r2, [r4, #0]
  4035fc:	4937      	ldr	r1, [pc, #220]	; (4036dc <vTaskIncrementTick+0x104>)
  4035fe:	429a      	cmp	r2, r3
  403600:	d346      	bcc.n	403690 <vTaskIncrementTick+0xb8>
  403602:	4d38      	ldr	r5, [pc, #224]	; (4036e4 <vTaskIncrementTick+0x10c>)
  403604:	682b      	ldr	r3, [r5, #0]
  403606:	681b      	ldr	r3, [r3, #0]
  403608:	2b00      	cmp	r3, #0
  40360a:	d036      	beq.n	40367a <vTaskIncrementTick+0xa2>
  40360c:	682b      	ldr	r3, [r5, #0]
  40360e:	68db      	ldr	r3, [r3, #12]
  403610:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  403614:	6809      	ldr	r1, [r1, #0]
  403616:	f8db 2004 	ldr.w	r2, [fp, #4]
  40361a:	428a      	cmp	r2, r1
  40361c:	d857      	bhi.n	4036ce <vTaskIncrementTick+0xf6>
  40361e:	4f32      	ldr	r7, [pc, #200]	; (4036e8 <vTaskIncrementTick+0x110>)
  403620:	4e32      	ldr	r6, [pc, #200]	; (4036ec <vTaskIncrementTick+0x114>)
  403622:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 4036fc <vTaskIncrementTick+0x124>
  403626:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 403700 <vTaskIncrementTick+0x128>
  40362a:	e009      	b.n	403640 <vTaskIncrementTick+0x68>
  40362c:	4a2d      	ldr	r2, [pc, #180]	; (4036e4 <vTaskIncrementTick+0x10c>)
  40362e:	6813      	ldr	r3, [r2, #0]
  403630:	68db      	ldr	r3, [r3, #12]
  403632:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  403636:	6821      	ldr	r1, [r4, #0]
  403638:	f8db 2004 	ldr.w	r2, [fp, #4]
  40363c:	428a      	cmp	r2, r1
  40363e:	d846      	bhi.n	4036ce <vTaskIncrementTick+0xf6>
  403640:	f10b 0a04 	add.w	sl, fp, #4
  403644:	4650      	mov	r0, sl
  403646:	47b8      	blx	r7
  403648:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  40364c:	f10b 0018 	add.w	r0, fp, #24
  403650:	b10a      	cbz	r2, 403656 <vTaskIncrementTick+0x7e>
  403652:	4a25      	ldr	r2, [pc, #148]	; (4036e8 <vTaskIncrementTick+0x110>)
  403654:	4790      	blx	r2
  403656:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
  40365a:	6832      	ldr	r2, [r6, #0]
  40365c:	4293      	cmp	r3, r2
  40365e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  403662:	bf88      	it	hi
  403664:	4a21      	ldrhi	r2, [pc, #132]	; (4036ec <vTaskIncrementTick+0x114>)
  403666:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  40366a:	4651      	mov	r1, sl
  40366c:	bf88      	it	hi
  40366e:	6013      	strhi	r3, [r2, #0]
  403670:	47c0      	blx	r8
  403672:	682b      	ldr	r3, [r5, #0]
  403674:	681b      	ldr	r3, [r3, #0]
  403676:	2b00      	cmp	r3, #0
  403678:	d1d8      	bne.n	40362c <vTaskIncrementTick+0x54>
  40367a:	9a01      	ldr	r2, [sp, #4]
  40367c:	f04f 33ff 	mov.w	r3, #4294967295
  403680:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  403682:	b003      	add	sp, #12
  403684:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
  403688:	4b19      	ldr	r3, [pc, #100]	; (4036f0 <vTaskIncrementTick+0x118>)
  40368a:	681a      	ldr	r2, [r3, #0]
  40368c:	3201      	adds	r2, #1
  40368e:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  403690:	b003      	add	sp, #12
  403692:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  403696:	4b13      	ldr	r3, [pc, #76]	; (4036e4 <vTaskIncrementTick+0x10c>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  403698:	4916      	ldr	r1, [pc, #88]	; (4036f4 <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40369a:	6818      	ldr	r0, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = pxTemp;
			xNumOfOverflows++;
  40369c:	4a16      	ldr	r2, [pc, #88]	; (4036f8 <vTaskIncrementTick+0x120>)
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  40369e:	680d      	ldr	r5, [r1, #0]
  4036a0:	601d      	str	r5, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  4036a2:	6008      	str	r0, [r1, #0]
			xNumOfOverflows++;
  4036a4:	6811      	ldr	r1, [r2, #0]
  4036a6:	3101      	adds	r1, #1
  4036a8:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  4036aa:	681a      	ldr	r2, [r3, #0]
  4036ac:	6812      	ldr	r2, [r2, #0]
  4036ae:	b932      	cbnz	r2, 4036be <vTaskIncrementTick+0xe6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  4036b0:	4b0b      	ldr	r3, [pc, #44]	; (4036e0 <vTaskIncrementTick+0x108>)
  4036b2:	4a0b      	ldr	r2, [pc, #44]	; (4036e0 <vTaskIncrementTick+0x108>)
  4036b4:	9301      	str	r3, [sp, #4]
  4036b6:	f04f 33ff 	mov.w	r3, #4294967295
  4036ba:	6013      	str	r3, [r2, #0]
  4036bc:	e79d      	b.n	4035fa <vTaskIncrementTick+0x22>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4036be:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4036c0:	4a07      	ldr	r2, [pc, #28]	; (4036e0 <vTaskIncrementTick+0x108>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4036c2:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4036c4:	9201      	str	r2, [sp, #4]
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  4036c6:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  4036c8:	685b      	ldr	r3, [r3, #4]
  4036ca:	6013      	str	r3, [r2, #0]
  4036cc:	e795      	b.n	4035fa <vTaskIncrementTick+0x22>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  4036ce:	9b01      	ldr	r3, [sp, #4]
  4036d0:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  4036d2:	b003      	add	sp, #12
  4036d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4036d8:	20000f24 	.word	0x20000f24
  4036dc:	20000e68 	.word	0x20000e68
  4036e0:	200000b8 	.word	0x200000b8
  4036e4:	20000f14 	.word	0x20000f14
  4036e8:	00403531 	.word	0x00403531
  4036ec:	20000e64 	.word	0x20000e64
  4036f0:	20000f28 	.word	0x20000f28
  4036f4:	20000f0c 	.word	0x20000f0c
  4036f8:	20000f30 	.word	0x20000f30
  4036fc:	20000e6c 	.word	0x20000e6c
  403700:	00403515 	.word	0x00403515

00403704 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  403704:	b430      	push	{r4, r5}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  403706:	4b29      	ldr	r3, [pc, #164]	; (4037ac <vTaskSwitchContext+0xa8>)
  403708:	681b      	ldr	r3, [r3, #0]
  40370a:	2b00      	cmp	r3, #0
  40370c:	d134      	bne.n	403778 <vTaskSwitchContext+0x74>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  40370e:	4b28      	ldr	r3, [pc, #160]	; (4037b0 <vTaskSwitchContext+0xac>)
  403710:	4928      	ldr	r1, [pc, #160]	; (4037b4 <vTaskSwitchContext+0xb0>)
  403712:	681a      	ldr	r2, [r3, #0]
  403714:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  403718:	0092      	lsls	r2, r2, #2
  40371a:	588a      	ldr	r2, [r1, r2]
  40371c:	b94a      	cbnz	r2, 403732 <vTaskSwitchContext+0x2e>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
  40371e:	681a      	ldr	r2, [r3, #0]
  403720:	3a01      	subs	r2, #1
  403722:	601a      	str	r2, [r3, #0]

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  403724:	681a      	ldr	r2, [r3, #0]
  403726:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  40372a:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  40372e:	2a00      	cmp	r2, #0
  403730:	d0f5      	beq.n	40371e <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  403732:	681b      	ldr	r3, [r3, #0]
  403734:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  403738:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  40373c:	f101 0208 	add.w	r2, r1, #8
  403740:	684b      	ldr	r3, [r1, #4]
  403742:	685b      	ldr	r3, [r3, #4]
  403744:	604b      	str	r3, [r1, #4]
  403746:	4293      	cmp	r3, r2
  403748:	d02c      	beq.n	4037a4 <vTaskSwitchContext+0xa0>

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  40374a:	491b      	ldr	r1, [pc, #108]	; (4037b8 <vTaskSwitchContext+0xb4>)
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  40374c:	4a1b      	ldr	r2, [pc, #108]	; (4037bc <vTaskSwitchContext+0xb8>)

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  40374e:	6808      	ldr	r0, [r1, #0]
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  403750:	68db      	ldr	r3, [r3, #12]
  403752:	6013      	str	r3, [r2, #0]

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  403754:	b170      	cbz	r0, 403774 <vTaskSwitchContext+0x70>
  403756:	6813      	ldr	r3, [r2, #0]
  403758:	4819      	ldr	r0, [pc, #100]	; (4037c0 <vTaskSwitchContext+0xbc>)
  40375a:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  40375c:	6803      	ldr	r3, [r0, #0]
  40375e:	429c      	cmp	r4, r3
  403760:	d008      	beq.n	403774 <vTaskSwitchContext+0x70>
  403762:	4b18      	ldr	r3, [pc, #96]	; (4037c4 <vTaskSwitchContext+0xc0>)
  403764:	4d18      	ldr	r5, [pc, #96]	; (4037c8 <vTaskSwitchContext+0xc4>)
  403766:	681c      	ldr	r4, [r3, #0]
  403768:	682d      	ldr	r5, [r5, #0]
  40376a:	3408      	adds	r4, #8
  40376c:	42a5      	cmp	r5, r4
  40376e:	d808      	bhi.n	403782 <vTaskSwitchContext+0x7e>
  403770:	2300      	movs	r3, #0
  403772:	600b      	str	r3, [r1, #0]
	}
}
  403774:	bc30      	pop	{r4, r5}
  403776:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  403778:	4b14      	ldr	r3, [pc, #80]	; (4037cc <vTaskSwitchContext+0xc8>)
  40377a:	2201      	movs	r2, #1
  40377c:	601a      	str	r2, [r3, #0]
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
  40377e:	bc30      	pop	{r4, r5}
  403780:	4770      	bx	lr
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  403782:	4913      	ldr	r1, [pc, #76]	; (4037d0 <vTaskSwitchContext+0xcc>)
  403784:	6812      	ldr	r2, [r2, #0]
  403786:	681c      	ldr	r4, [r3, #0]
  403788:	680d      	ldr	r5, [r1, #0]
  40378a:	6819      	ldr	r1, [r3, #0]
  40378c:	6c52      	ldr	r2, [r2, #68]	; 0x44
  40378e:	6002      	str	r2, [r0, #0]
  403790:	3104      	adds	r1, #4
  403792:	6019      	str	r1, [r3, #0]
  403794:	6818      	ldr	r0, [r3, #0]
  403796:	6819      	ldr	r1, [r3, #0]
  403798:	6025      	str	r5, [r4, #0]
  40379a:	3104      	adds	r1, #4
  40379c:	6002      	str	r2, [r0, #0]
  40379e:	6019      	str	r1, [r3, #0]
	}
}
  4037a0:	bc30      	pop	{r4, r5}
  4037a2:	4770      	bx	lr
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4037a4:	685b      	ldr	r3, [r3, #4]
  4037a6:	604b      	str	r3, [r1, #4]
  4037a8:	e7cf      	b.n	40374a <vTaskSwitchContext+0x46>
  4037aa:	bf00      	nop
  4037ac:	20000f24 	.word	0x20000f24
  4037b0:	20000e64 	.word	0x20000e64
  4037b4:	20000e6c 	.word	0x20000e6c
  4037b8:	20000f10 	.word	0x20000f10
  4037bc:	20000f20 	.word	0x20000f20
  4037c0:	200000b4 	.word	0x200000b4
  4037c4:	20000f1c 	.word	0x20000f1c
  4037c8:	20000f2c 	.word	0x20000f2c
  4037cc:	20000f18 	.word	0x20000f18
  4037d0:	20000e68 	.word	0x20000e68

004037d4 <WDT_Handler>:
}
/**
 *  \brief Handler for watchdog interrupt.
 */
void WDT_Handler(void)
{
  4037d4:	b508      	push	{r3, lr}

	/* Clear status bit to acknowledge interrupt by dummy read. */
	wdt_get_status(WDT);
  4037d6:	4804      	ldr	r0, [pc, #16]	; (4037e8 <WDT_Handler+0x14>)
  4037d8:	4b04      	ldr	r3, [pc, #16]	; (4037ec <WDT_Handler+0x18>)
  4037da:	4798      	blx	r3

	drv_uart_putString(&uart0Config, "Restarting system!!!\r");
  4037dc:	4804      	ldr	r0, [pc, #16]	; (4037f0 <WDT_Handler+0x1c>)
  4037de:	4905      	ldr	r1, [pc, #20]	; (4037f4 <WDT_Handler+0x20>)
  4037e0:	4b05      	ldr	r3, [pc, #20]	; (4037f8 <WDT_Handler+0x24>)
  4037e2:	4798      	blx	r3
  4037e4:	bd08      	pop	{r3, pc}
  4037e6:	bf00      	nop
  4037e8:	400e1450 	.word	0x400e1450
  4037ec:	00404519 	.word	0x00404519
  4037f0:	200000bc 	.word	0x200000bc
  4037f4:	00405924 	.word	0x00405924
  4037f8:	00403df5 	.word	0x00403df5

004037fc <drv_gpio_int_cd>:
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4037fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4037fe:	4e0b      	ldr	r6, [pc, #44]	; (40382c <drv_gpio_int_cd+0x30>)
  403800:	4b0b      	ldr	r3, [pc, #44]	; (403830 <drv_gpio_int_cd+0x34>)
  403802:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
	pio_disable_interrupt(PIOB, PinMask);
  403806:	4d0b      	ldr	r5, [pc, #44]	; (403834 <drv_gpio_int_cd+0x38>)
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  403808:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  40380a:	4798      	blx	r3
	pio_disable_interrupt(PIOB, PinMask);
  40380c:	4b0a      	ldr	r3, [pc, #40]	; (403838 <drv_gpio_int_cd+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  40380e:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOB, PinMask);
  403810:	4601      	mov	r1, r0
  403812:	4628      	mov	r0, r5
  403814:	4798      	blx	r3
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
  403816:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
  403818:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOB, PinMask);
  40381a:	4806      	ldr	r0, [pc, #24]	; (403834 <drv_gpio_int_cd+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
  40381c:	bf04      	itt	eq
  40381e:	2301      	moveq	r3, #1
  403820:	f886 310e 	strbeq.w	r3, [r6, #270]	; 0x10e
	}
	pio_enable_interrupt(PIOB, PinMask);
  403824:	4621      	mov	r1, r4
  403826:	4b05      	ldr	r3, [pc, #20]	; (40383c <drv_gpio_int_cd+0x40>)
  403828:	4798      	blx	r3
  40382a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40382c:	200000d4 	.word	0x200000d4
  403830:	004042fd 	.word	0x004042fd
  403834:	400e1000 	.word	0x400e1000
  403838:	00404139 	.word	0x00404139
  40383c:	00404131 	.word	0x00404131

00403840 <drv_gpio_int_lbo>:
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  403840:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  403842:	4e0b      	ldr	r6, [pc, #44]	; (403870 <drv_gpio_int_lbo+0x30>)
  403844:	4b0b      	ldr	r3, [pc, #44]	; (403874 <drv_gpio_int_lbo+0x34>)
  403846:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
	pio_disable_interrupt(PIOA, PinMask);
  40384a:	4d0b      	ldr	r5, [pc, #44]	; (403878 <drv_gpio_int_lbo+0x38>)
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  40384c:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40384e:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  403850:	4b0a      	ldr	r3, [pc, #40]	; (40387c <drv_gpio_int_lbo+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  403852:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  403854:	4601      	mov	r1, r0
  403856:	4628      	mov	r0, r5
  403858:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40385a:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40385c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40385e:	4806      	ldr	r0, [pc, #24]	; (403878 <drv_gpio_int_lbo+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
  403860:	bf04      	itt	eq
  403862:	2301      	moveq	r3, #1
  403864:	f886 30fe 	strbeq.w	r3, [r6, #254]	; 0xfe
	}
	pio_enable_interrupt(PIOA, PinMask);
  403868:	4621      	mov	r1, r4
  40386a:	4b05      	ldr	r3, [pc, #20]	; (403880 <drv_gpio_int_lbo+0x40>)
  40386c:	4798      	blx	r3
  40386e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403870:	200000d4 	.word	0x200000d4
  403874:	004042fd 	.word	0x004042fd
  403878:	400e0e00 	.word	0x400e0e00
  40387c:	00404139 	.word	0x00404139
  403880:	00404131 	.word	0x00404131

00403884 <drv_gpio_int_dc2>:
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  403884:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  403886:	4e0b      	ldr	r6, [pc, #44]	; (4038b4 <drv_gpio_int_dc2+0x30>)
  403888:	4b0b      	ldr	r3, [pc, #44]	; (4038b8 <drv_gpio_int_dc2+0x34>)
  40388a:	6e30      	ldr	r0, [r6, #96]	; 0x60
	pio_disable_interrupt(PIOA, PinMask);
  40388c:	4d0b      	ldr	r5, [pc, #44]	; (4038bc <drv_gpio_int_dc2+0x38>)
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  40388e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  403890:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  403892:	4b0b      	ldr	r3, [pc, #44]	; (4038c0 <drv_gpio_int_dc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  403894:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  403896:	4601      	mov	r1, r0
  403898:	4628      	mov	r0, r5
  40389a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40389c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40389e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4038a0:	4806      	ldr	r0, [pc, #24]	; (4038bc <drv_gpio_int_dc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
  4038a2:	bf04      	itt	eq
  4038a4:	2301      	moveq	r3, #1
  4038a6:	f886 306e 	strbeq.w	r3, [r6, #110]	; 0x6e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4038aa:	4621      	mov	r1, r4
  4038ac:	4b05      	ldr	r3, [pc, #20]	; (4038c4 <drv_gpio_int_dc2+0x40>)
  4038ae:	4798      	blx	r3
  4038b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4038b2:	bf00      	nop
  4038b4:	200000d4 	.word	0x200000d4
  4038b8:	004042fd 	.word	0x004042fd
  4038bc:	400e0e00 	.word	0x400e0e00
  4038c0:	00404139 	.word	0x00404139
  4038c4:	00404131 	.word	0x00404131

004038c8 <drv_gpio_int_dc1>:
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4038c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4038ca:	4e0b      	ldr	r6, [pc, #44]	; (4038f8 <drv_gpio_int_dc1+0x30>)
  4038cc:	4b0b      	ldr	r3, [pc, #44]	; (4038fc <drv_gpio_int_dc1+0x34>)
  4038ce:	6d30      	ldr	r0, [r6, #80]	; 0x50
	pio_disable_interrupt(PIOA, PinMask);
  4038d0:	4d0b      	ldr	r5, [pc, #44]	; (403900 <drv_gpio_int_dc1+0x38>)
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4038d2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4038d4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4038d6:	4b0b      	ldr	r3, [pc, #44]	; (403904 <drv_gpio_int_dc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4038d8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4038da:	4601      	mov	r1, r0
  4038dc:	4628      	mov	r0, r5
  4038de:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4038e0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4038e2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4038e4:	4806      	ldr	r0, [pc, #24]	; (403900 <drv_gpio_int_dc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
  4038e6:	bf04      	itt	eq
  4038e8:	2301      	moveq	r3, #1
  4038ea:	f886 305e 	strbeq.w	r3, [r6, #94]	; 0x5e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4038ee:	4621      	mov	r1, r4
  4038f0:	4b05      	ldr	r3, [pc, #20]	; (403908 <drv_gpio_int_dc1+0x40>)
  4038f2:	4798      	blx	r3
  4038f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4038f6:	bf00      	nop
  4038f8:	200000d4 	.word	0x200000d4
  4038fc:	004042fd 	.word	0x004042fd
  403900:	400e0e00 	.word	0x400e0e00
  403904:	00404139 	.word	0x00404139
  403908:	00404131 	.word	0x00404131

0040390c <drv_gpio_int_oc2>:
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  40390c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  40390e:	4e0b      	ldr	r6, [pc, #44]	; (40393c <drv_gpio_int_oc2+0x30>)
  403910:	4b0b      	ldr	r3, [pc, #44]	; (403940 <drv_gpio_int_oc2+0x34>)
  403912:	6c30      	ldr	r0, [r6, #64]	; 0x40
	pio_disable_interrupt(PIOA, PinMask);
  403914:	4d0b      	ldr	r5, [pc, #44]	; (403944 <drv_gpio_int_oc2+0x38>)
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  403916:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  403918:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  40391a:	4b0b      	ldr	r3, [pc, #44]	; (403948 <drv_gpio_int_oc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  40391c:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  40391e:	4601      	mov	r1, r0
  403920:	4628      	mov	r0, r5
  403922:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  403924:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  403926:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  403928:	4806      	ldr	r0, [pc, #24]	; (403944 <drv_gpio_int_oc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
  40392a:	bf04      	itt	eq
  40392c:	2301      	moveq	r3, #1
  40392e:	f886 304e 	strbeq.w	r3, [r6, #78]	; 0x4e
	}
	pio_enable_interrupt(PIOA, PinMask);
  403932:	4621      	mov	r1, r4
  403934:	4b05      	ldr	r3, [pc, #20]	; (40394c <drv_gpio_int_oc2+0x40>)
  403936:	4798      	blx	r3
  403938:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40393a:	bf00      	nop
  40393c:	200000d4 	.word	0x200000d4
  403940:	004042fd 	.word	0x004042fd
  403944:	400e0e00 	.word	0x400e0e00
  403948:	00404139 	.word	0x00404139
  40394c:	00404131 	.word	0x00404131

00403950 <drv_gpio_int_oc1>:
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  403950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  403952:	4e0b      	ldr	r6, [pc, #44]	; (403980 <drv_gpio_int_oc1+0x30>)
  403954:	4b0b      	ldr	r3, [pc, #44]	; (403984 <drv_gpio_int_oc1+0x34>)
  403956:	6b30      	ldr	r0, [r6, #48]	; 0x30
	pio_disable_interrupt(PIOA, PinMask);
  403958:	4d0b      	ldr	r5, [pc, #44]	; (403988 <drv_gpio_int_oc1+0x38>)
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  40395a:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  40395c:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  40395e:	4b0b      	ldr	r3, [pc, #44]	; (40398c <drv_gpio_int_oc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  403960:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  403962:	4601      	mov	r1, r0
  403964:	4628      	mov	r0, r5
  403966:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  403968:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40396a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40396c:	4806      	ldr	r0, [pc, #24]	; (403988 <drv_gpio_int_oc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
  40396e:	bf04      	itt	eq
  403970:	2301      	moveq	r3, #1
  403972:	f886 303e 	strbeq.w	r3, [r6, #62]	; 0x3e
	}
	pio_enable_interrupt(PIOA, PinMask);
  403976:	4621      	mov	r1, r4
  403978:	4b05      	ldr	r3, [pc, #20]	; (403990 <drv_gpio_int_oc1+0x40>)
  40397a:	4798      	blx	r3
  40397c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40397e:	bf00      	nop
  403980:	200000d4 	.word	0x200000d4
  403984:	004042fd 	.word	0x004042fd
  403988:	400e0e00 	.word	0x400e0e00
  40398c:	00404139 	.word	0x00404139
  403990:	00404131 	.word	0x00404131

00403994 <drv_gpio_int_sw2>:
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  403994:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  403996:	4e0b      	ldr	r6, [pc, #44]	; (4039c4 <drv_gpio_int_sw2+0x30>)
  403998:	4b0b      	ldr	r3, [pc, #44]	; (4039c8 <drv_gpio_int_sw2+0x34>)
  40399a:	6a30      	ldr	r0, [r6, #32]
	pio_disable_interrupt(PIOA, PinMask);
  40399c:	4d0b      	ldr	r5, [pc, #44]	; (4039cc <drv_gpio_int_sw2+0x38>)
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  40399e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  4039a0:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4039a2:	4b0b      	ldr	r3, [pc, #44]	; (4039d0 <drv_gpio_int_sw2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  4039a4:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4039a6:	4601      	mov	r1, r0
  4039a8:	4628      	mov	r0, r5
  4039aa:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4039ac:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4039ae:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4039b0:	4806      	ldr	r0, [pc, #24]	; (4039cc <drv_gpio_int_sw2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
  4039b2:	bf04      	itt	eq
  4039b4:	2301      	moveq	r3, #1
  4039b6:	f886 302e 	strbeq.w	r3, [r6, #46]	; 0x2e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4039ba:	4621      	mov	r1, r4
  4039bc:	4b05      	ldr	r3, [pc, #20]	; (4039d4 <drv_gpio_int_sw2+0x40>)
  4039be:	4798      	blx	r3
  4039c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4039c2:	bf00      	nop
  4039c4:	200000d4 	.word	0x200000d4
  4039c8:	004042fd 	.word	0x004042fd
  4039cc:	400e0e00 	.word	0x400e0e00
  4039d0:	00404139 	.word	0x00404139
  4039d4:	00404131 	.word	0x00404131

004039d8 <drv_gpio_int_sw1>:
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4039d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4039da:	4e0a      	ldr	r6, [pc, #40]	; (403a04 <drv_gpio_int_sw1+0x2c>)
  4039dc:	4b0a      	ldr	r3, [pc, #40]	; (403a08 <drv_gpio_int_sw1+0x30>)
  4039de:	6930      	ldr	r0, [r6, #16]
	pio_disable_interrupt(PIOA, PinMask);
  4039e0:	4d0a      	ldr	r5, [pc, #40]	; (403a0c <drv_gpio_int_sw1+0x34>)
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4039e2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4039e4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4039e6:	4b0a      	ldr	r3, [pc, #40]	; (403a10 <drv_gpio_int_sw1+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4039e8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4039ea:	4601      	mov	r1, r0
  4039ec:	4628      	mov	r0, r5
  4039ee:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4039f0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4039f2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4039f4:	4805      	ldr	r0, [pc, #20]	; (403a0c <drv_gpio_int_sw1+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
  4039f6:	bf04      	itt	eq
  4039f8:	2301      	moveq	r3, #1
  4039fa:	77b3      	strbeq	r3, [r6, #30]
	}
	pio_enable_interrupt(PIOA, PinMask);
  4039fc:	4621      	mov	r1, r4
  4039fe:	4b05      	ldr	r3, [pc, #20]	; (403a14 <drv_gpio_int_sw1+0x3c>)
  403a00:	4798      	blx	r3
  403a02:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403a04:	200000d4 	.word	0x200000d4
  403a08:	004042fd 	.word	0x004042fd
  403a0c:	400e0e00 	.word	0x400e0e00
  403a10:	00404139 	.word	0x00404139
  403a14:	00404131 	.word	0x00404131

00403a18 <drv_gpio_int_pw>:
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  403a18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  403a1a:	4e0a      	ldr	r6, [pc, #40]	; (403a44 <drv_gpio_int_pw+0x2c>)
  403a1c:	4b0a      	ldr	r3, [pc, #40]	; (403a48 <drv_gpio_int_pw+0x30>)
  403a1e:	6830      	ldr	r0, [r6, #0]
	pio_disable_interrupt(PIOA, PinMask);
  403a20:	4d0a      	ldr	r5, [pc, #40]	; (403a4c <drv_gpio_int_pw+0x34>)
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  403a22:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  403a24:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  403a26:	4b0a      	ldr	r3, [pc, #40]	; (403a50 <drv_gpio_int_pw+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  403a28:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  403a2a:	4601      	mov	r1, r0
  403a2c:	4628      	mov	r0, r5
  403a2e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  403a30:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  403a32:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  403a34:	4805      	ldr	r0, [pc, #20]	; (403a4c <drv_gpio_int_pw+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
  403a36:	bf04      	itt	eq
  403a38:	2301      	moveq	r3, #1
  403a3a:	73b3      	strbeq	r3, [r6, #14]
	}
	pio_enable_interrupt(PIOA, PinMask);
  403a3c:	4621      	mov	r1, r4
  403a3e:	4b05      	ldr	r3, [pc, #20]	; (403a54 <drv_gpio_int_pw+0x3c>)
  403a40:	4798      	blx	r3
  403a42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403a44:	200000d4 	.word	0x200000d4
  403a48:	004042fd 	.word	0x004042fd
  403a4c:	400e0e00 	.word	0x400e0e00
  403a50:	00404139 	.word	0x00404139
  403a54:	00404131 	.word	0x00404131

00403a58 <drv_gpio_config>:
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  403a58:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  403a5c:	7903      	ldrb	r3, [r0, #4]
  403a5e:	2b01      	cmp	r3, #1
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  403a60:	b082      	sub	sp, #8
  403a62:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  403a64:	d011      	beq.n	403a8a <drv_gpio_config+0x32>
		p_pio->PIO_PPDDR |= PinMask; 
		
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
  403a66:	7942      	ldrb	r2, [r0, #5]
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  403a68:	4b34      	ldr	r3, [pc, #208]	; (403b3c <drv_gpio_config+0xe4>)
  403a6a:	6800      	ldr	r0, [r0, #0]
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_1;	//set default pin state
  403a6c:	2a01      	cmp	r2, #1
  403a6e:	bf14      	ite	ne
  403a70:	f04f 5540 	movne.w	r5, #805306368	; 0x30000000
  403a74:	f04f 5560 	moveq.w	r5, #939524096	; 0x38000000
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  403a78:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  403a7a:	4629      	mov	r1, r5
  403a7c:	6820      	ldr	r0, [r4, #0]
  403a7e:	4b30      	ldr	r3, [pc, #192]	; (403b40 <drv_gpio_config+0xe8>)
  403a80:	4798      	blx	r3
	}
	
	return status;
}
  403a82:	2000      	movs	r0, #0
  403a84:	b002      	add	sp, #8
  403a86:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
		if (gpioConfig->pullUpEnabled == TRUE)
  403a8a:	7b02      	ldrb	r2, [r0, #12]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  403a8c:	4f2d      	ldr	r7, [pc, #180]	; (403b44 <drv_gpio_config+0xec>)
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  403a8e:	7b43      	ldrb	r3, [r0, #13]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  403a90:	2a01      	cmp	r2, #1
  403a92:	bf18      	it	ne
  403a94:	f04f 5720 	movne.w	r7, #671088640	; 0x28000000
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  403a98:	2b01      	cmp	r3, #1
  403a9a:	d041      	beq.n	403b20 <drv_gpio_config+0xc8>
  403a9c:	4d2a      	ldr	r5, [pc, #168]	; (403b48 <drv_gpio_config+0xf0>)
  403a9e:	4e2b      	ldr	r6, [pc, #172]	; (403b4c <drv_gpio_config+0xf4>)
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);	
  403aa0:	4b26      	ldr	r3, [pc, #152]	; (403b3c <drv_gpio_config+0xe4>)
  403aa2:	6820      	ldr	r0, [r4, #0]
  403aa4:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  403aa6:	4b26      	ldr	r3, [pc, #152]	; (403b40 <drv_gpio_config+0xe8>)
  403aa8:	6820      	ldr	r0, [r4, #0]
  403aaa:	4639      	mov	r1, r7
  403aac:	4798      	blx	r3
		 
		PinFlag = 0;	//Reset the PinFlag to use it to configure interrupt
		switch(gpioConfig->interruptType)	//set interrupt configuration flag
  403aae:	79a3      	ldrb	r3, [r4, #6]
  403ab0:	2b03      	cmp	r3, #3
  403ab2:	d82e      	bhi.n	403b12 <drv_gpio_config+0xba>
  403ab4:	4a26      	ldr	r2, [pc, #152]	; (403b50 <drv_gpio_config+0xf8>)
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  403ab6:	6820      	ldr	r0, [r4, #0]
  403ab8:	f852 8023 	ldr.w	r8, [r2, r3, lsl #2]
  403abc:	47a8      	blx	r5
  403abe:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403ac0:	6820      	ldr	r0, [r4, #0]
  403ac2:	47b0      	blx	r6
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  403ac4:	f018 0f70 	tst.w	r8, #112	; 0x70
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403ac8:	4606      	mov	r6, r0
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  403aca:	d019      	beq.n	403b00 <drv_gpio_config+0xa8>
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  403acc:	6820      	ldr	r0, [r4, #0]
  403ace:	4b21      	ldr	r3, [pc, #132]	; (403b54 <drv_gpio_config+0xfc>)
  403ad0:	4798      	blx	r3
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  403ad2:	68a3      	ldr	r3, [r4, #8]
  403ad4:	9300      	str	r3, [sp, #0]
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  403ad6:	4607      	mov	r7, r0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  403ad8:	4601      	mov	r1, r0
  403ada:	4632      	mov	r2, r6
  403adc:	4643      	mov	r3, r8
  403ade:	4628      	mov	r0, r5
  403ae0:	4c1d      	ldr	r4, [pc, #116]	; (403b58 <drv_gpio_config+0x100>)
  403ae2:	47a0      	blx	r4
			pio_enable_interrupt(p_pio, PinMask);
  403ae4:	4631      	mov	r1, r6
  403ae6:	4b1d      	ldr	r3, [pc, #116]	; (403b5c <drv_gpio_config+0x104>)
  403ae8:	4628      	mov	r0, r5
  403aea:	4798      	blx	r3
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  403aec:	b27a      	sxtb	r2, r7
  403aee:	0952      	lsrs	r2, r2, #5
  403af0:	f007 071f 	and.w	r7, r7, #31
  403af4:	2101      	movs	r1, #1
  403af6:	4b1a      	ldr	r3, [pc, #104]	; (403b60 <drv_gpio_config+0x108>)
  403af8:	fa01 f707 	lsl.w	r7, r1, r7
  403afc:	f843 7022 	str.w	r7, [r3, r2, lsl #2]
			NVIC_EnableIRQ(PinPio);
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  403b00:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  403b04:	2000      	movs	r0, #0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
			pio_enable_interrupt(p_pio, PinMask);
			NVIC_EnableIRQ(PinPio);
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  403b06:	431e      	orrs	r6, r3
  403b08:	f8c5 6090 	str.w	r6, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  403b0c:	b002      	add	sp, #8
  403b0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  403b12:	6820      	ldr	r0, [r4, #0]
  403b14:	47a8      	blx	r5
  403b16:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403b18:	6820      	ldr	r0, [r4, #0]
  403b1a:	47b0      	blx	r6
  403b1c:	4606      	mov	r6, r0
  403b1e:	e7ef      	b.n	403b00 <drv_gpio_config+0xa8>
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  403b20:	4d09      	ldr	r5, [pc, #36]	; (403b48 <drv_gpio_config+0xf0>)
  403b22:	6800      	ldr	r0, [r0, #0]
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403b24:	4e09      	ldr	r6, [pc, #36]	; (403b4c <drv_gpio_config+0xf4>)
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  403b26:	47a8      	blx	r5
  403b28:	4680      	mov	r8, r0
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403b2a:	6820      	ldr	r0, [r4, #0]
  403b2c:	47b0      	blx	r6
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  403b2e:	2205      	movs	r2, #5
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  403b30:	4601      	mov	r1, r0
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  403b32:	4b0c      	ldr	r3, [pc, #48]	; (403b64 <drv_gpio_config+0x10c>)
  403b34:	4640      	mov	r0, r8
  403b36:	4798      	blx	r3
  403b38:	e7b2      	b.n	403aa0 <drv_gpio_config+0x48>
  403b3a:	bf00      	nop
  403b3c:	004044d5 	.word	0x004044d5
  403b40:	004041a1 	.word	0x004041a1
  403b44:	28000001 	.word	0x28000001
  403b48:	004042e5 	.word	0x004042e5
  403b4c:	004042fd 	.word	0x004042fd
  403b50:	0040593c 	.word	0x0040593c
  403b54:	004042f5 	.word	0x004042f5
  403b58:	00404381 	.word	0x00404381
  403b5c:	00404131 	.word	0x00404131
  403b60:	e000e100 	.word	0xe000e100
  403b64:	0040402d 	.word	0x0040402d

00403b68 <drv_gpio_initializeAll>:
 * @brief initialize all GPIO
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
  403b68:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;
  403b6a:	4b0b      	ldr	r3, [pc, #44]	; (403b98 <drv_gpio_initializeAll+0x30>)
  403b6c:	4c0b      	ldr	r4, [pc, #44]	; (403b9c <drv_gpio_initializeAll+0x34>)
  403b6e:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  403b72:	4f0b      	ldr	r7, [pc, #44]	; (403ba0 <drv_gpio_initializeAll+0x38>)
  403b74:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
  403b78:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  403b7c:	f504 7688 	add.w	r6, r4, #272	; 0x110
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
	status_t status = STATUS_PASS; 
  403b80:	2500      	movs	r5, #0
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;
	
	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&gpioConfig[i]) != STATUS_PASS)
  403b82:	4620      	mov	r0, r4
  403b84:	47b8      	blx	r7
  403b86:	3410      	adds	r4, #16
		{
			//printf("failed to initialize GPIO at index %d", i);
			status |= STATUS_FAIL;
  403b88:	2800      	cmp	r0, #0
  403b8a:	bf18      	it	ne
  403b8c:	2501      	movne	r5, #1
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;
	
	for(i = 0; i < numGpio ; i++)
  403b8e:	42b4      	cmp	r4, r6
  403b90:	d1f7      	bne.n	403b82 <drv_gpio_initializeAll+0x1a>
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST2]);
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST3]);
	
	
	return status; 
}
  403b92:	4628      	mov	r0, r5
  403b94:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  403b96:	bf00      	nop
  403b98:	400e0200 	.word	0x400e0200
  403b9c:	200000d4 	.word	0x200000d4
  403ba0:	00403a59 	.word	0x00403a59

00403ba4 <drv_gpio_setPinState>:
 * @brief Set a GPIO to HIGH or LOW
 * @param drv_gpio_pins_t pin, drv_gpio_pin_state_t state
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
  403ba4:	b510      	push	{r4, lr}
	status_t status = STATUS_PASS;
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
  403ba6:	4b07      	ldr	r3, [pc, #28]	; (403bc4 <drv_gpio_setPinState+0x20>)
  403ba8:	0100      	lsls	r0, r0, #4
  403baa:	181a      	adds	r2, r3, r0
  403bac:	7914      	ldrb	r4, [r2, #4]
  403bae:	b93c      	cbnz	r4, 403bc0 <drv_gpio_setPinState+0x1c>
	{
		return STATUS_FAIL; 
	}
	if (state == DRV_GPIO_PIN_STATE_HIGH)
  403bb0:	2901      	cmp	r1, #1
	{
		pio_set_pin_high(gpioConfig[pin].pinId);
  403bb2:	5818      	ldr	r0, [r3, r0]
  403bb4:	bf0c      	ite	eq
  403bb6:	4b04      	ldreq	r3, [pc, #16]	; (403bc8 <drv_gpio_setPinState+0x24>)
	}
	else
	{
		pio_set_pin_low(gpioConfig[pin].pinId);
  403bb8:	4b04      	ldrne	r3, [pc, #16]	; (403bcc <drv_gpio_setPinState+0x28>)
  403bba:	4798      	blx	r3
	}
	return status;
  403bbc:	4620      	mov	r0, r4
  403bbe:	bd10      	pop	{r4, pc}
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
	status_t status = STATUS_PASS;
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
	{
		return STATUS_FAIL; 
  403bc0:	2001      	movs	r0, #1
	else
	{
		pio_set_pin_low(gpioConfig[pin].pinId);
	}
	return status;
}
  403bc2:	bd10      	pop	{r4, pc}
  403bc4:	200000d4 	.word	0x200000d4
  403bc8:	00404145 	.word	0x00404145
  403bcc:	00404161 	.word	0x00404161

00403bd0 <drv_gpio_getPinState>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_getPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t* state)
{
	status_t status = STATUS_PASS;
	bool value = ioport_get_pin_level(gpioConfig[pin].pinId);
  403bd0:	4b0a      	ldr	r3, [pc, #40]	; (403bfc <drv_gpio_getPinState+0x2c>)
  403bd2:	0100      	lsls	r0, r0, #4
  403bd4:	5818      	ldr	r0, [r3, r0]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  403bd6:	0943      	lsrs	r3, r0, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  403bd8:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  403bdc:	f203 7307 	addw	r3, r3, #1799	; 0x707
  403be0:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  403be2:	f000 001f 	and.w	r0, r0, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  403be6:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  403be8:	2301      	movs	r3, #1
  403bea:	fa03 f000 	lsl.w	r0, r3, r0
	if (value == false)
  403bee:	4002      	ands	r2, r0
	{
		*state = DRV_GPIO_PIN_STATE_LOW;
  403bf0:	bf08      	it	eq
  403bf2:	4613      	moveq	r3, r2
  403bf4:	700b      	strb	r3, [r1, #0]
	else
	{
		*state = DRV_GPIO_PIN_STATE_HIGH;
	}
	return status;
}
  403bf6:	2000      	movs	r0, #0
  403bf8:	4770      	bx	lr
  403bfa:	bf00      	nop
  403bfc:	200000d4 	.word	0x200000d4

00403c00 <drv_gpio_togglePin>:
 * @brief Toggle a GPIO level
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_togglePin(drv_gpio_pins_t pin)
{
  403c00:	b508      	push	{r3, lr}
	status_t status = STATUS_PASS;
	pio_toggle_pin(gpioConfig[pin].pinId);
  403c02:	4a03      	ldr	r2, [pc, #12]	; (403c10 <drv_gpio_togglePin+0x10>)
  403c04:	4b03      	ldr	r3, [pc, #12]	; (403c14 <drv_gpio_togglePin+0x14>)
  403c06:	0100      	lsls	r0, r0, #4
  403c08:	5810      	ldr	r0, [r2, r0]
  403c0a:	4798      	blx	r3
	return status;
}
  403c0c:	2000      	movs	r0, #0
  403c0e:	bd08      	pop	{r3, pc}
  403c10:	200000d4 	.word	0x200000d4
  403c14:	0040417d 	.word	0x0040417d

00403c18 <uart_process_byte>:
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  403c18:	b510      	push	{r4, lr}
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  403c1a:	f8b1 3204 	ldrh.w	r3, [r1, #516]	; 0x204
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  403c1e:	b082      	sub	sp, #8
	uint32_t val = 0;
  403c20:	2200      	movs	r2, #0
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  403c22:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  403c26:	460c      	mov	r4, r1
	uint32_t val = 0;
  403c28:	9201      	str	r2, [sp, #4]
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  403c2a:	d028      	beq.n	403c7e <uart_process_byte+0x66>
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  403c2c:	d30c      	bcc.n	403c48 <uart_process_byte+0x30>
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
	}
	if(memBuf->rx_fifo.i_last == FIFO_BUFFER_SIZE)
  403c2e:	f8b4 3202 	ldrh.w	r3, [r4, #514]	; 0x202
  403c32:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_last = 0;                            // roll over the index counter
  403c36:	bf04      	itt	eq
  403c38:	2300      	moveq	r3, #0
  403c3a:	f8a4 3202 	strheq.w	r3, [r4, #514]	; 0x202
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
  403c3e:	2301      	movs	r3, #1
  403c40:	f884 3207 	strb.w	r3, [r4, #519]	; 0x207
}
  403c44:	b002      	add	sp, #8
  403c46:	bd10      	pop	{r4, pc}
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
  403c48:	a901      	add	r1, sp, #4
  403c4a:	4b14      	ldr	r3, [pc, #80]	; (403c9c <uart_process_byte+0x84>)
  403c4c:	4798      	blx	r3
  403c4e:	b140      	cbz	r0, 403c62 <uart_process_byte+0x4a>
  403c50:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
		//if(p_usart == UART1)
		//{
			//usart_putchar(UART0, val);
		//}
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  403c54:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
  403c58:	bf04      	itt	eq
  403c5a:	2301      	moveq	r3, #1
  403c5c:	f884 3208 	strbeq.w	r3, [r4, #520]	; 0x208
  403c60:	e7e5      	b.n	403c2e <uart_process_byte+0x16>
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
  403c62:	f8b4 2202 	ldrh.w	r2, [r4, #514]	; 0x202
  403c66:	9b01      	ldr	r3, [sp, #4]
  403c68:	54a3      	strb	r3, [r4, r2]
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  403c6a:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  403c6e:	3301      	adds	r3, #1
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  403c70:	3201      	adds	r2, #1
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  403c72:	b29b      	uxth	r3, r3
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  403c74:	f8a4 2202 	strh.w	r2, [r4, #514]	; 0x202
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  403c78:	f8a4 3204 	strh.w	r3, [r4, #516]	; 0x204
  403c7c:	e7ea      	b.n	403c54 <uart_process_byte+0x3c>
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  403c7e:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
		usart_getchar(p_usart,&val);		
  403c82:	4a06      	ldr	r2, [pc, #24]	; (403c9c <uart_process_byte+0x84>)
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  403c84:	3301      	adds	r3, #1
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  403c86:	2101      	movs	r1, #1
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  403c88:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  403c8c:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
  403c90:	a901      	add	r1, sp, #4
  403c92:	4790      	blx	r2
  403c94:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  403c98:	e7dc      	b.n	403c54 <uart_process_byte+0x3c>
  403c9a:	bf00      	nop
  403c9c:	00401aed 	.word	0x00401aed

00403ca0 <uart_process_tx_byte>:
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  403ca0:	b570      	push	{r4, r5, r6, lr}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  403ca2:	f8b1 3414 	ldrh.w	r3, [r1, #1044]	; 0x414
  403ca6:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  403caa:	460c      	mov	r4, r1
  403cac:	4602      	mov	r2, r0
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  403cae:	d00f      	beq.n	403cd0 <uart_process_tx_byte+0x30>
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->tx_fifo.num_bytes > 0)
  403cb0:	b98b      	cbnz	r3, 403cd6 <uart_process_tx_byte+0x36>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{   // tx sw buffer is empty
		memBuf->uart_tx_fifo_not_empty_flag = 0;          // clear the tx flag
  403cb2:	f881 3416 	strb.w	r3, [r1, #1046]	; 0x416
		uart_disable_interrupt(p_usart,UART_IER_TXEMPTY); //the buffer is empty, stop the interrupt. 
  403cb6:	f44f 7100 	mov.w	r1, #512	; 0x200
  403cba:	4b23      	ldr	r3, [pc, #140]	; (403d48 <uart_process_tx_byte+0xa8>)
  403cbc:	4798      	blx	r3
  403cbe:	f8b4 2410 	ldrh.w	r2, [r4, #1040]	; 0x410
	}
	if(memBuf->tx_fifo.i_first == FIFO_BUFFER_SIZE)
  403cc2:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_first = 0;                      // roll over the index counter
  403cc6:	bf04      	itt	eq
  403cc8:	2300      	moveq	r3, #0
  403cca:	f8a4 3410 	strheq.w	r3, [r4, #1040]	; 0x410
  403cce:	bd70      	pop	{r4, r5, r6, pc}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  403cd0:	2100      	movs	r1, #0
  403cd2:	f884 1417 	strb.w	r1, [r4, #1047]	; 0x417
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
  403cd6:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  403cda:	481c      	ldr	r0, [pc, #112]	; (403d4c <uart_process_tx_byte+0xac>)
  403cdc:	1865      	adds	r5, r4, r1
  403cde:	4282      	cmp	r2, r0
  403ce0:	f895 5210 	ldrb.w	r5, [r5, #528]	; 0x210
  403ce4:	d010      	beq.n	403d08 <uart_process_tx_byte+0x68>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  403ce6:	481a      	ldr	r0, [pc, #104]	; (403d50 <uart_process_tx_byte+0xb0>)
  403ce8:	4282      	cmp	r2, r0
  403cea:	d01f      	beq.n	403d2c <uart_process_tx_byte+0x8c>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  403cec:	4819      	ldr	r0, [pc, #100]	; (403d54 <uart_process_tx_byte+0xb4>)
  403cee:	4282      	cmp	r2, r0
  403cf0:	d023      	beq.n	403d3a <uart_process_tx_byte+0x9a>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  403cf2:	4819      	ldr	r0, [pc, #100]	; (403d58 <uart_process_tx_byte+0xb8>)
  403cf4:	4282      	cmp	r2, r0
  403cf6:	d012      	beq.n	403d1e <uart_process_tx_byte+0x7e>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  403cf8:	1c4a      	adds	r2, r1, #1
  403cfa:	b292      	uxth	r2, r2
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  403cfc:	3b01      	subs	r3, #1
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  403cfe:	f8a4 2410 	strh.w	r2, [r4, #1040]	; 0x410
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  403d02:	f8a4 3414 	strh.w	r3, [r4, #1044]	; 0x414
  403d06:	e7dc      	b.n	403cc2 <uart_process_tx_byte+0x22>
  403d08:	4e14      	ldr	r6, [pc, #80]	; (403d5c <uart_process_tx_byte+0xbc>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  403d0a:	4810      	ldr	r0, [pc, #64]	; (403d4c <uart_process_tx_byte+0xac>)
  403d0c:	4629      	mov	r1, r5
  403d0e:	47b0      	blx	r6
  403d10:	2800      	cmp	r0, #0
  403d12:	d1fa      	bne.n	403d0a <uart_process_tx_byte+0x6a>
  403d14:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
  403d18:	f8b4 3414 	ldrh.w	r3, [r4, #1044]	; 0x414
  403d1c:	e7ec      	b.n	403cf8 <uart_process_tx_byte+0x58>
  403d1e:	4e10      	ldr	r6, [pc, #64]	; (403d60 <uart_process_tx_byte+0xc0>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  403d20:	480d      	ldr	r0, [pc, #52]	; (403d58 <uart_process_tx_byte+0xb8>)
  403d22:	4629      	mov	r1, r5
  403d24:	47b0      	blx	r6
  403d26:	2800      	cmp	r0, #0
  403d28:	d1fa      	bne.n	403d20 <uart_process_tx_byte+0x80>
  403d2a:	e7f3      	b.n	403d14 <uart_process_tx_byte+0x74>
  403d2c:	4e0b      	ldr	r6, [pc, #44]	; (403d5c <uart_process_tx_byte+0xbc>)
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  403d2e:	4808      	ldr	r0, [pc, #32]	; (403d50 <uart_process_tx_byte+0xb0>)
  403d30:	4629      	mov	r1, r5
  403d32:	47b0      	blx	r6
  403d34:	2800      	cmp	r0, #0
  403d36:	d1fa      	bne.n	403d2e <uart_process_tx_byte+0x8e>
  403d38:	e7ec      	b.n	403d14 <uart_process_tx_byte+0x74>
  403d3a:	4e09      	ldr	r6, [pc, #36]	; (403d60 <uart_process_tx_byte+0xc0>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  403d3c:	4805      	ldr	r0, [pc, #20]	; (403d54 <uart_process_tx_byte+0xb4>)
  403d3e:	4629      	mov	r1, r5
  403d40:	47b0      	blx	r6
  403d42:	2800      	cmp	r0, #0
  403d44:	d1fa      	bne.n	403d3c <uart_process_tx_byte+0x9c>
  403d46:	e7e5      	b.n	403d14 <uart_process_tx_byte+0x74>
  403d48:	00401ab9 	.word	0x00401ab9
  403d4c:	400e0600 	.word	0x400e0600
  403d50:	400e0800 	.word	0x400e0800
  403d54:	40024000 	.word	0x40024000
  403d58:	40028000 	.word	0x40028000
  403d5c:	00401ac1 	.word	0x00401ac1
  403d60:	00401ad9 	.word	0x00401ad9

00403d64 <drv_uart_putChar>:
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  403d64:	b538      	push	{r3, r4, r5, lr}
  403d66:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  403d68:	4b1f      	ldr	r3, [pc, #124]	; (403de8 <drv_uart_putChar+0x84>)
  403d6a:	6800      	ldr	r0, [r0, #0]
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  403d6c:	460d      	mov	r5, r1
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  403d6e:	f44f 7100 	mov.w	r1, #512	; 0x200
  403d72:	4798      	blx	r3
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
  403d74:	6962      	ldr	r2, [r4, #20]
  403d76:	481d      	ldr	r0, [pc, #116]	; (403dec <drv_uart_putChar+0x88>)
  403d78:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  403d7c:	eb00 1342 	add.w	r3, r0, r2, lsl #5
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  403d80:	f8b3 2414 	ldrh.w	r2, [r3, #1044]	; 0x414
  403d84:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  403d88:	d021      	beq.n	403dce <drv_uart_putChar+0x6a>
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  403d8a:	d20e      	bcs.n	403daa <drv_uart_putChar+0x46>
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  403d8c:	f8b3 1412 	ldrh.w	r1, [r3, #1042]	; 0x412
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  403d90:	3201      	adds	r2, #1
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  403d92:	1858      	adds	r0, r3, r1
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  403d94:	b292      	uxth	r2, r2
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  403d96:	3101      	adds	r1, #1
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  403d98:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  403d9c:	f880 5210 	strb.w	r5, [r0, #528]	; 0x210
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  403da0:	f8a3 2414 	strh.w	r2, [r3, #1044]	; 0x414
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  403da4:	f8a3 1412 	strh.w	r1, [r3, #1042]	; 0x412
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  403da8:	d019      	beq.n	403dde <drv_uart_putChar+0x7a>
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
	}
	if(memBuf->tx_fifo.i_last == FIFO_BUFFER_SIZE)
  403daa:	f8b3 2412 	ldrh.w	r2, [r3, #1042]	; 0x412
  403dae:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_last = 0;                            // roll over the index counter
  403db2:	bf04      	itt	eq
  403db4:	2200      	moveq	r2, #0
  403db6:	f8a3 2412 	strheq.w	r2, [r3, #1042]	; 0x412
	}
	memBuf->uart_tx_fifo_not_empty_flag = 1;                 // set tx-data ready flag	
  403dba:	2201      	movs	r2, #1
  403dbc:	f883 2416 	strb.w	r2, [r3, #1046]	; 0x416
	//re-enable the interrupts
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);		
  403dc0:	6820      	ldr	r0, [r4, #0]
  403dc2:	4b0b      	ldr	r3, [pc, #44]	; (403df0 <drv_uart_putChar+0x8c>)
  403dc4:	f44f 7100 	mov.w	r1, #512	; 0x200
  403dc8:	4798      	blx	r3
	return status;	
}
  403dca:	2000      	movs	r0, #0
  403dcc:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  403dce:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  403dd2:	2101      	movs	r1, #1
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  403dd4:	440a      	add	r2, r1
  403dd6:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  403dda:	f883 1418 	strb.w	r1, [r3, #1048]	; 0x418
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
  403dde:	2201      	movs	r2, #1
  403de0:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
  403de4:	e7e1      	b.n	403daa <drv_uart_putChar+0x46>
  403de6:	bf00      	nop
  403de8:	00401ad5 	.word	0x00401ad5
  403dec:	20001444 	.word	0x20001444
  403df0:	00401ad1 	.word	0x00401ad1

00403df4 <drv_uart_putString>:
	return result; 
}


void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  403df4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	int size = strlen(str);
  403df8:	4b09      	ldr	r3, [pc, #36]	; (403e20 <drv_uart_putString+0x2c>)
	return result; 
}


void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  403dfa:	4606      	mov	r6, r0
	int i=0;
	int size = strlen(str);
  403dfc:	4608      	mov	r0, r1
	return result; 
}


void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
  403dfe:	460d      	mov	r5, r1
	int i=0;
	int size = strlen(str);
  403e00:	4798      	blx	r3

	for (i=0;i<size;)
  403e02:	1e07      	subs	r7, r0, #0
  403e04:	dd09      	ble.n	403e1a <drv_uart_putString+0x26>
  403e06:	f8df 801c 	ldr.w	r8, [pc, #28]	; 403e24 <drv_uart_putString+0x30>
  403e0a:	2400      	movs	r4, #0
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  403e0c:	4630      	mov	r0, r6
  403e0e:	5d29      	ldrb	r1, [r5, r4]
  403e10:	47c0      	blx	r8
  403e12:	b900      	cbnz	r0, 403e16 <drv_uart_putString+0x22>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  403e14:	3401      	adds	r4, #1
void drv_uart_putString(drv_uart_config_t* uartConfig, char* str)
{
	int i=0;
	int size = strlen(str);

	for (i=0;i<size;)
  403e16:	42a7      	cmp	r7, r4
  403e18:	dcf8      	bgt.n	403e0c <drv_uart_putString+0x18>
  403e1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403e1e:	bf00      	nop
  403e20:	00404f15 	.word	0x00404f15
  403e24:	00403d65 	.word	0x00403d65

00403e28 <UART0_Handler>:
	}
}

// interrupt handlers
void UART0_Handler()
{	
  403e28:	b510      	push	{r4, lr}
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  403e2a:	480c      	ldr	r0, [pc, #48]	; (403e5c <UART0_Handler+0x34>)
  403e2c:	4b0c      	ldr	r3, [pc, #48]	; (403e60 <UART0_Handler+0x38>)
  403e2e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  403e30:	07c2      	lsls	r2, r0, #31
{	
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  403e32:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  403e34:	d503      	bpl.n	403e3e <UART0_Handler+0x16>
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  403e36:	490b      	ldr	r1, [pc, #44]	; (403e64 <UART0_Handler+0x3c>)
  403e38:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  403e3c:	b953      	cbnz	r3, 403e54 <UART0_Handler+0x2c>
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  403e3e:	05a3      	lsls	r3, r4, #22
  403e40:	d503      	bpl.n	403e4a <UART0_Handler+0x22>
	{
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  403e42:	4908      	ldr	r1, [pc, #32]	; (403e64 <UART0_Handler+0x3c>)
  403e44:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  403e48:	b903      	cbnz	r3, 403e4c <UART0_Handler+0x24>
  403e4a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART0, &(uartMemBuf[0])); 	
  403e4c:	4803      	ldr	r0, [pc, #12]	; (403e5c <UART0_Handler+0x34>)
  403e4e:	4b06      	ldr	r3, [pc, #24]	; (403e68 <UART0_Handler+0x40>)
  403e50:	4798      	blx	r3
  403e52:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
  403e54:	4801      	ldr	r0, [pc, #4]	; (403e5c <UART0_Handler+0x34>)
  403e56:	4b05      	ldr	r3, [pc, #20]	; (403e6c <UART0_Handler+0x44>)
  403e58:	4798      	blx	r3
  403e5a:	e7f0      	b.n	403e3e <UART0_Handler+0x16>
  403e5c:	400e0600 	.word	0x400e0600
  403e60:	00401abd 	.word	0x00401abd
  403e64:	20001444 	.word	0x20001444
  403e68:	00403ca1 	.word	0x00403ca1
  403e6c:	00403c19 	.word	0x00403c19

00403e70 <UART1_Handler>:
		}
	}	
}

void UART1_Handler()
{
  403e70:	b510      	push	{r4, lr}
	uint32_t status = uart_get_status(UART1); 
  403e72:	480e      	ldr	r0, [pc, #56]	; (403eac <UART1_Handler+0x3c>)
  403e74:	4b0e      	ldr	r3, [pc, #56]	; (403eb0 <UART1_Handler+0x40>)
  403e76:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  403e78:	07c2      	lsls	r2, r0, #31
	}	
}

void UART1_Handler()
{
	uint32_t status = uart_get_status(UART1); 
  403e7a:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  403e7c:	d503      	bpl.n	403e86 <UART1_Handler+0x16>
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  403e7e:	490d      	ldr	r1, [pc, #52]	; (403eb4 <UART1_Handler+0x44>)
  403e80:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  403e84:	b963      	cbnz	r3, 403ea0 <UART1_Handler+0x30>
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  403e86:	05a3      	lsls	r3, r4, #22
  403e88:	d503      	bpl.n	403e92 <UART1_Handler+0x22>
	{
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  403e8a:	490a      	ldr	r1, [pc, #40]	; (403eb4 <UART1_Handler+0x44>)
  403e8c:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  403e90:	b903      	cbnz	r3, 403e94 <UART1_Handler+0x24>
  403e92:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART1, &(uartMemBuf[1])); 	
  403e94:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  403e98:	4804      	ldr	r0, [pc, #16]	; (403eac <UART1_Handler+0x3c>)
  403e9a:	4b07      	ldr	r3, [pc, #28]	; (403eb8 <UART1_Handler+0x48>)
  403e9c:	4798      	blx	r3
  403e9e:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
  403ea0:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  403ea4:	4801      	ldr	r0, [pc, #4]	; (403eac <UART1_Handler+0x3c>)
  403ea6:	4b05      	ldr	r3, [pc, #20]	; (403ebc <UART1_Handler+0x4c>)
  403ea8:	4798      	blx	r3
  403eaa:	e7ec      	b.n	403e86 <UART1_Handler+0x16>
  403eac:	400e0800 	.word	0x400e0800
  403eb0:	00401abd 	.word	0x00401abd
  403eb4:	20001444 	.word	0x20001444
  403eb8:	00403ca1 	.word	0x00403ca1
  403ebc:	00403c19 	.word	0x00403c19

00403ec0 <USART0_Handler>:
		}
	}
}

void USART0_Handler()
{
  403ec0:	b510      	push	{r4, lr}
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  403ec2:	480e      	ldr	r0, [pc, #56]	; (403efc <USART0_Handler+0x3c>)
  403ec4:	4b0e      	ldr	r3, [pc, #56]	; (403f00 <USART0_Handler+0x40>)
  403ec6:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  403ec8:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  403eca:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  403ecc:	d503      	bpl.n	403ed6 <USART0_Handler+0x16>
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  403ece:	490d      	ldr	r1, [pc, #52]	; (403f04 <USART0_Handler+0x44>)
  403ed0:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  403ed4:	b963      	cbnz	r3, 403ef0 <USART0_Handler+0x30>
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  403ed6:	05a3      	lsls	r3, r4, #22
  403ed8:	d503      	bpl.n	403ee2 <USART0_Handler+0x22>
	{
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  403eda:	490a      	ldr	r1, [pc, #40]	; (403f04 <USART0_Handler+0x44>)
  403edc:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  403ee0:	b903      	cbnz	r3, 403ee4 <USART0_Handler+0x24>
  403ee2:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART0, &(uartMemBuf[2])); 	
  403ee4:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  403ee8:	4804      	ldr	r0, [pc, #16]	; (403efc <USART0_Handler+0x3c>)
  403eea:	4b07      	ldr	r3, [pc, #28]	; (403f08 <USART0_Handler+0x48>)
  403eec:	4798      	blx	r3
  403eee:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
  403ef0:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  403ef4:	4801      	ldr	r0, [pc, #4]	; (403efc <USART0_Handler+0x3c>)
  403ef6:	4b05      	ldr	r3, [pc, #20]	; (403f0c <USART0_Handler+0x4c>)
  403ef8:	4798      	blx	r3
  403efa:	e7ec      	b.n	403ed6 <USART0_Handler+0x16>
  403efc:	40024000 	.word	0x40024000
  403f00:	00401abd 	.word	0x00401abd
  403f04:	20001444 	.word	0x20001444
  403f08:	00403ca1 	.word	0x00403ca1
  403f0c:	00403c19 	.word	0x00403c19

00403f10 <USART1_Handler>:
		}
	}	
}

void USART1_Handler()
{
  403f10:	b510      	push	{r4, lr}
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  403f12:	480e      	ldr	r0, [pc, #56]	; (403f4c <USART1_Handler+0x3c>)
  403f14:	4b0e      	ldr	r3, [pc, #56]	; (403f50 <USART1_Handler+0x40>)
  403f16:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  403f18:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  403f1a:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  403f1c:	d503      	bpl.n	403f26 <USART1_Handler+0x16>
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  403f1e:	490d      	ldr	r1, [pc, #52]	; (403f54 <USART1_Handler+0x44>)
  403f20:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  403f24:	b963      	cbnz	r3, 403f40 <USART1_Handler+0x30>
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  403f26:	05a3      	lsls	r3, r4, #22
  403f28:	d503      	bpl.n	403f32 <USART1_Handler+0x22>
	{
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  403f2a:	490a      	ldr	r1, [pc, #40]	; (403f54 <USART1_Handler+0x44>)
  403f2c:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  403f30:	b903      	cbnz	r3, 403f34 <USART1_Handler+0x24>
  403f32:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART1, &(uartMemBuf[3])); 	
  403f34:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  403f38:	4804      	ldr	r0, [pc, #16]	; (403f4c <USART1_Handler+0x3c>)
  403f3a:	4b07      	ldr	r3, [pc, #28]	; (403f58 <USART1_Handler+0x48>)
  403f3c:	4798      	blx	r3
  403f3e:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
  403f40:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  403f44:	4801      	ldr	r0, [pc, #4]	; (403f4c <USART1_Handler+0x3c>)
  403f46:	4b05      	ldr	r3, [pc, #20]	; (403f5c <USART1_Handler+0x4c>)
  403f48:	4798      	blx	r3
  403f4a:	e7ec      	b.n	403f26 <USART1_Handler+0x16>
  403f4c:	40028000 	.word	0x40028000
  403f50:	00401abd 	.word	0x00401abd
  403f54:	20001444 	.word	0x20001444
  403f58:	00403ca1 	.word	0x00403ca1
  403f5c:	00403c19 	.word	0x00403c19

00403f60 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  403f60:	b538      	push	{r3, r4, r5, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  403f62:	480e      	ldr	r0, [pc, #56]	; (403f9c <sysclk_init+0x3c>)
  403f64:	4d0e      	ldr	r5, [pc, #56]	; (403fa0 <sysclk_init+0x40>)
  403f66:	4c0f      	ldr	r4, [pc, #60]	; (403fa4 <sysclk_init+0x44>)
  403f68:	47a8      	blx	r5
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  403f6a:	2000      	movs	r0, #0
  403f6c:	213e      	movs	r1, #62	; 0x3e
  403f6e:	4b0e      	ldr	r3, [pc, #56]	; (403fa8 <sysclk_init+0x48>)
  403f70:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  403f72:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  403f74:	2800      	cmp	r0, #0
  403f76:	d0fc      	beq.n	403f72 <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  403f78:	4b0c      	ldr	r3, [pc, #48]	; (403fac <sysclk_init+0x4c>)
  403f7a:	4c0d      	ldr	r4, [pc, #52]	; (403fb0 <sysclk_init+0x50>)
  403f7c:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  403f7e:	4b0d      	ldr	r3, [pc, #52]	; (403fb4 <sysclk_init+0x54>)
  403f80:	4a0d      	ldr	r2, [pc, #52]	; (403fb8 <sysclk_init+0x58>)
  403f82:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  403f84:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  403f86:	2800      	cmp	r0, #0
  403f88:	d0fc      	beq.n	403f84 <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  403f8a:	4b0c      	ldr	r3, [pc, #48]	; (403fbc <sysclk_init+0x5c>)
  403f8c:	2010      	movs	r0, #16
  403f8e:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  403f90:	4b0b      	ldr	r3, [pc, #44]	; (403fc0 <sysclk_init+0x60>)
  403f92:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  403f94:	4801      	ldr	r0, [pc, #4]	; (403f9c <sysclk_init+0x3c>)
  403f96:	47a8      	blx	r5
  403f98:	bd38      	pop	{r3, r4, r5, pc}
  403f9a:	bf00      	nop
  403f9c:	07270e00 	.word	0x07270e00
  403fa0:	004046a1 	.word	0x004046a1
  403fa4:	004044a5 	.word	0x004044a5
  403fa8:	00404451 	.word	0x00404451
  403fac:	004044b5 	.word	0x004044b5
  403fb0:	004044c5 	.word	0x004044c5
  403fb4:	400e0400 	.word	0x400e0400
  403fb8:	200e3f01 	.word	0x200e3f01
  403fbc:	004043f9 	.word	0x004043f9
  403fc0:	004045b9 	.word	0x004045b9

00403fc4 <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  403fc4:	b538      	push	{r3, r4, r5, lr}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  403fc6:	200b      	movs	r0, #11
  403fc8:	4d13      	ldr	r5, [pc, #76]	; (404018 <board_init+0x54>)
	//ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
	//ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
	//
	
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  403fca:	4c14      	ldr	r4, [pc, #80]	; (40401c <board_init+0x58>)
  403fcc:	47a8      	blx	r5
  403fce:	200c      	movs	r0, #12
  403fd0:	47a8      	blx	r5
  403fd2:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403fd6:	201c      	movs	r0, #28
  403fd8:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  403fda:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403fde:	201d      	movs	r0, #29
  403fe0:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  403fe2:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403fe6:	201e      	movs	r0, #30
  403fe8:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  403fea:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403fee:	201f      	movs	r0, #31
  403ff0:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  403ff2:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403ff6:	201a      	movs	r0, #26
  403ff8:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  403ffa:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  403ffe:	201b      	movs	r0, #27
  404000:	47a0      	blx	r4

	/* Configure SD/MMC card detect pin */
	gpio_configure_pin(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  404002:	4907      	ldr	r1, [pc, #28]	; (404020 <board_init+0x5c>)
  404004:	202b      	movs	r0, #43	; 0x2b
  404006:	47a0      	blx	r4

//#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART1_PIO, PINS_UART1, PINS_UART1_FLAGS);
  404008:	4b06      	ldr	r3, [pc, #24]	; (404024 <board_init+0x60>)
  40400a:	4807      	ldr	r0, [pc, #28]	; (404028 <board_init+0x64>)
  40400c:	210c      	movs	r1, #12
  40400e:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  404012:	4798      	blx	r3
  404014:	bd38      	pop	{r3, r4, r5, pc}
  404016:	bf00      	nop
  404018:	004044d5 	.word	0x004044d5
  40401c:	004041a1 	.word	0x004041a1
  404020:	28000001 	.word	0x28000001
  404024:	00404259 	.word	0x00404259
  404028:	400e1000 	.word	0x400e1000

0040402c <pio_set_debounce_filter>:
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  40402c:	0052      	lsls	r2, r2, #1
  40402e:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  404032:	fbb3 f2f2 	udiv	r2, r3, r2
  404036:	3a01      	subs	r2, #1
  404038:	f3c2 020d 	ubfx	r2, r2, #0, #14
void pio_set_debounce_filter(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_cut_off)
{
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Set Debouncing, 0 bit field no effect */
	p_pio->PIO_IFSCER = ul_mask;
  40403c:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  404040:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
  404044:	4770      	bx	lr
  404046:	bf00      	nop

00404048 <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404048:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  40404c:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  40404e:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404050:	d030      	beq.n	4040b4 <pio_set_peripheral+0x6c>
  404052:	d812      	bhi.n	40407a <pio_set_peripheral+0x32>
  404054:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  404058:	d020      	beq.n	40409c <pio_set_peripheral+0x54>
  40405a:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40405e:	d11a      	bne.n	404096 <pio_set_peripheral+0x4e>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404060:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  404062:	4313      	orrs	r3, r2
  404064:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  404066:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  404068:	6f41      	ldr	r1, [r0, #116]	; 0x74
  40406a:	400b      	ands	r3, r1
  40406c:	ea23 0302 	bic.w	r3, r3, r2
  404070:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  404072:	6042      	str	r2, [r0, #4]
}
  404074:	f85d 4b04 	ldr.w	r4, [sp], #4
  404078:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40407a:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40407e:	d0f9      	beq.n	404074 <pio_set_peripheral+0x2c>
  404080:	d822      	bhi.n	4040c8 <pio_set_peripheral+0x80>
  404082:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  404086:	d1f4      	bne.n	404072 <pio_set_peripheral+0x2a>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
		break;
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404088:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  40408a:	4313      	orrs	r3, r2
  40408c:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40408e:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  404090:	4313      	orrs	r3, r2
  404092:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  404094:	e7ed      	b.n	404072 <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404096:	2900      	cmp	r1, #0
  404098:	d1eb      	bne.n	404072 <pio_set_peripheral+0x2a>
  40409a:	e7eb      	b.n	404074 <pio_set_peripheral+0x2c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  40409c:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40409e:	6f04      	ldr	r4, [r0, #112]	; 0x70
  4040a0:	43d3      	mvns	r3, r2
  4040a2:	4021      	ands	r1, r4
  4040a4:	4019      	ands	r1, r3
  4040a6:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4040a8:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4040aa:	6f44      	ldr	r4, [r0, #116]	; 0x74
  4040ac:	4021      	ands	r1, r4
  4040ae:	400b      	ands	r3, r1
  4040b0:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4040b2:	e7de      	b.n	404072 <pio_set_peripheral+0x2a>
		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4040b4:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  4040b6:	6f01      	ldr	r1, [r0, #112]	; 0x70
  4040b8:	400b      	ands	r3, r1
  4040ba:	ea23 0302 	bic.w	r3, r3, r2
  4040be:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4040c0:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  4040c2:	4313      	orrs	r3, r2
  4040c4:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  4040c6:	e7d4      	b.n	404072 <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4040c8:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  4040cc:	d0d2      	beq.n	404074 <pio_set_peripheral+0x2c>
  4040ce:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  4040d2:	d0cf      	beq.n	404074 <pio_set_peripheral+0x2c>
  4040d4:	e7cd      	b.n	404072 <pio_set_peripheral+0x2a>
  4040d6:	bf00      	nop

004040d8 <pio_set_input>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4040d8:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4040da:	6441      	str	r1, [r0, #68]	; 0x44
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  4040dc:	bf4c      	ite	mi
  4040de:	6641      	strmi	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4040e0:	6601      	strpl	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  4040e2:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  4040e6:	bf14      	ite	ne
  4040e8:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  4040ea:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  4040ec:	0793      	lsls	r3, r2, #30
  4040ee:	d406      	bmi.n	4040fe <pio_set_input+0x26>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  4040f0:	0713      	lsls	r3, r2, #28
			p_pio->PIO_IFSCER = ul_mask;
  4040f2:	bf48      	it	mi
  4040f4:	f8c0 1084 	strmi.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  4040f8:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  4040fa:	6001      	str	r1, [r0, #0]
  4040fc:	4770      	bx	lr
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
		p_pio->PIO_IFSCDR = ul_mask;
  4040fe:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  404102:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  404104:	6001      	str	r1, [r0, #0]
  404106:	4770      	bx	lr

00404108 <pio_configure_interrupt>:
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  404108:	06d3      	lsls	r3, r2, #27
  40410a:	d50e      	bpl.n	40412a <pio_configure_interrupt+0x22>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  40410c:	0693      	lsls	r3, r2, #26
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  40410e:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  404112:	bf4c      	ite	mi
  404114:	f8c0 10d4 	strmi.w	r1, [r0, #212]	; 0xd4
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  404118:	f8c0 10d0 	strpl.w	r1, [r0, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  40411c:	0653      	lsls	r3, r2, #25
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  40411e:	bf4c      	ite	mi
  404120:	f8c0 10c0 	strmi.w	r1, [r0, #192]	; 0xc0
		} else {
			/* Level select */
			p_pio->PIO_LSR = ul_mask;
  404124:	f8c0 10c4 	strpl.w	r1, [r0, #196]	; 0xc4
  404128:	4770      	bx	lr
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
  40412a:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  40412e:	4770      	bx	lr

00404130 <pio_enable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_ISR;
  404130:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  404132:	6401      	str	r1, [r0, #64]	; 0x40
  404134:	4770      	bx	lr
  404136:	bf00      	nop

00404138 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  404138:	6441      	str	r1, [r0, #68]	; 0x44
  40413a:	4770      	bx	lr

0040413c <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  40413c:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  40413e:	4770      	bx	lr

00404140 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  404140:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  404142:	4770      	bx	lr

00404144 <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404144:	0943      	lsrs	r3, r0, #5
  404146:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  40414a:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40414e:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  404150:	f000 001f 	and.w	r0, r0, #31
  404154:	2201      	movs	r2, #1
  404156:	fa02 f000 	lsl.w	r0, r2, r0
  40415a:	6318      	str	r0, [r3, #48]	; 0x30
  40415c:	4770      	bx	lr
  40415e:	bf00      	nop

00404160 <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404160:	0943      	lsrs	r3, r0, #5
  404162:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404166:	f203 7307 	addw	r3, r3, #1799	; 0x707
  40416a:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  40416c:	f000 001f 	and.w	r0, r0, #31
  404170:	2201      	movs	r2, #1
  404172:	fa02 f000 	lsl.w	r0, r2, r0
  404176:	6358      	str	r0, [r3, #52]	; 0x34
  404178:	4770      	bx	lr
  40417a:	bf00      	nop

0040417c <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40417c:	0943      	lsrs	r3, r0, #5
  40417e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404182:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404186:	025b      	lsls	r3, r3, #9
 */
void pio_toggle_pin(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  404188:	f000 001f 	and.w	r0, r0, #31
  40418c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  40418e:	2101      	movs	r1, #1
  404190:	fa01 f000 	lsl.w	r0, r1, r0
  404194:	4210      	tst	r0, r2
		/* Value to be driven on the I/O line: 0. */
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  404196:	bf14      	ite	ne
  404198:	6358      	strne	r0, [r3, #52]	; 0x34
	} else {
		/* Value to be driven on the I/O line: 1. */
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  40419a:	6318      	streq	r0, [r3, #48]	; 0x30
  40419c:	4770      	bx	lr
  40419e:	bf00      	nop

004041a0 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  4041a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4041a2:	0944      	lsrs	r4, r0, #5
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  4041a4:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4041a6:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4041aa:	f001 41f0 	and.w	r1, r1, #2013265920	; 0x78000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4041ae:	f204 7407 	addw	r4, r4, #1799	; 0x707
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4041b2:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4041b6:	ea4f 2444 	mov.w	r4, r4, lsl #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4041ba:	d00b      	beq.n	4041d4 <pio_configure_pin+0x34>
  4041bc:	d819      	bhi.n	4041f2 <pio_configure_pin+0x52>
  4041be:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  4041c2:	d007      	beq.n	4041d4 <pio_configure_pin+0x34>
  4041c4:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  4041c8:	d004      	beq.n	4041d4 <pio_configure_pin+0x34>
  4041ca:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  4041ce:	d001      	beq.n	4041d4 <pio_configure_pin+0x34>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  4041d0:	2000      	movs	r0, #0
	}

	return 1;
}
  4041d2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  4041d4:	2601      	movs	r6, #1
  4041d6:	f000 001f 	and.w	r0, r0, #31
  4041da:	fa06 f700 	lsl.w	r7, r6, r0
  4041de:	463a      	mov	r2, r7
  4041e0:	4620      	mov	r0, r4
  4041e2:	4b1b      	ldr	r3, [pc, #108]	; (404250 <pio_configure_pin+0xb0>)
  4041e4:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4041e6:	07ed      	lsls	r5, r5, #31
		p_pio->PIO_PUER = ul_mask;
  4041e8:	bf4c      	ite	mi
  4041ea:	6667      	strmi	r7, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4041ec:	6627      	strpl	r7, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  4041ee:	4630      	mov	r0, r6
  4041f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4041f2:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  4041f6:	d010      	beq.n	40421a <pio_configure_pin+0x7a>
  4041f8:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  4041fc:	d00d      	beq.n	40421a <pio_configure_pin+0x7a>
  4041fe:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  404202:	d1e5      	bne.n	4041d0 <pio_configure_pin+0x30>
				(ul_flags & PIO_PULLUP));
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  404204:	2601      	movs	r6, #1
  404206:	f000 011f 	and.w	r1, r0, #31
  40420a:	462a      	mov	r2, r5
  40420c:	4620      	mov	r0, r4
  40420e:	fa06 f101 	lsl.w	r1, r6, r1
  404212:	4b10      	ldr	r3, [pc, #64]	; (404254 <pio_configure_pin+0xb4>)
  404214:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  404216:	4630      	mov	r0, r6
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  404218:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40421a:	f000 001f 	and.w	r0, r0, #31
  40421e:	2301      	movs	r3, #1
  404220:	4083      	lsls	r3, r0
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  404222:	f005 0104 	and.w	r1, r5, #4
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  404226:	07e8      	lsls	r0, r5, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  404228:	6463      	str	r3, [r4, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40422a:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  40422e:	bf4c      	ite	mi
  404230:	6663      	strmi	r3, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  404232:	6623      	strpl	r3, [r4, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  404234:	b149      	cbz	r1, 40424a <pio_configure_pin+0xaa>
		p_pio->PIO_MDER = ul_mask;
  404236:	6523      	str	r3, [r4, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  404238:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  40423c:	bf0c      	ite	eq
  40423e:	6323      	streq	r3, [r4, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  404240:	6363      	strne	r3, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  404242:	6123      	str	r3, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  404244:	6023      	str	r3, [r4, #0]

	default:
		return 0;
	}

	return 1;
  404246:	2001      	movs	r0, #1
  404248:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40424a:	6563      	str	r3, [r4, #84]	; 0x54
  40424c:	e7f4      	b.n	404238 <pio_configure_pin+0x98>
  40424e:	bf00      	nop
  404250:	00404049 	.word	0x00404049
  404254:	004040d9 	.word	0x004040d9

00404258 <pio_configure_pin_group>:
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  404258:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
  40425c:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  404260:	b570      	push	{r4, r5, r6, lr}
  404262:	4614      	mov	r4, r2
  404264:	4606      	mov	r6, r0
  404266:	460d      	mov	r5, r1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  404268:	d00b      	beq.n	404282 <pio_configure_pin_group+0x2a>
  40426a:	d814      	bhi.n	404296 <pio_configure_pin_group+0x3e>
  40426c:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  404270:	d007      	beq.n	404282 <pio_configure_pin_group+0x2a>
  404272:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  404276:	d004      	beq.n	404282 <pio_configure_pin_group+0x2a>
  404278:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  40427c:	d001      	beq.n	404282 <pio_configure_pin_group+0x2a>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  40427e:	2000      	movs	r0, #0
	}

	return 1;
}
  404280:	bd70      	pop	{r4, r5, r6, pc}
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  404282:	4619      	mov	r1, r3
  404284:	462a      	mov	r2, r5
  404286:	4b15      	ldr	r3, [pc, #84]	; (4042dc <pio_configure_pin_group+0x84>)
  404288:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40428a:	07e0      	lsls	r0, r4, #31
		p_pio->PIO_PUER = ul_mask;
  40428c:	bf4c      	ite	mi
  40428e:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  404290:	6635      	strpl	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  404292:	2001      	movs	r0, #1
  404294:	bd70      	pop	{r4, r5, r6, pc}
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  404296:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40429a:	d009      	beq.n	4042b0 <pio_configure_pin_group+0x58>
  40429c:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4042a0:	d006      	beq.n	4042b0 <pio_configure_pin_group+0x58>
  4042a2:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4042a6:	d1ea      	bne.n	40427e <pio_configure_pin_group+0x26>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  4042a8:	4b0d      	ldr	r3, [pc, #52]	; (4042e0 <pio_configure_pin_group+0x88>)
  4042aa:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4042ac:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  4042ae:	bd70      	pop	{r4, r5, r6, pc}
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4042b0:	07e1      	lsls	r1, r4, #31
	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  4042b2:	f004 0204 	and.w	r2, r4, #4
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4042b6:	6475      	str	r5, [r6, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  4042b8:	f004 5360 	and.w	r3, r4, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  4042bc:	bf4c      	ite	mi
  4042be:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4042c0:	6635      	strpl	r5, [r6, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  4042c2:	b14a      	cbz	r2, 4042d8 <pio_configure_pin_group+0x80>
		p_pio->PIO_MDER = ul_mask;
  4042c4:	6535      	str	r5, [r6, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  4042c6:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  4042ca:	bf0c      	ite	eq
  4042cc:	6335      	streq	r5, [r6, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  4042ce:	6375      	strne	r5, [r6, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  4042d0:	6135      	str	r5, [r6, #16]
	p_pio->PIO_PER = ul_mask;
  4042d2:	6035      	str	r5, [r6, #0]

	default:
		return 0;
	}

	return 1;
  4042d4:	2001      	movs	r0, #1
  4042d6:	bd70      	pop	{r4, r5, r6, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  4042d8:	6575      	str	r5, [r6, #84]	; 0x54
  4042da:	e7f4      	b.n	4042c6 <pio_configure_pin_group+0x6e>
  4042dc:	00404049 	.word	0x00404049
  4042e0:	004040d9 	.word	0x004040d9

004042e4 <pio_get_pin_group>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4042e4:	0940      	lsrs	r0, r0, #5
  4042e6:	f500 1000 	add.w	r0, r0, #2097152	; 0x200000
  4042ea:	f200 7007 	addw	r0, r0, #1799	; 0x707
#endif
	return p_pio;
}
  4042ee:	0240      	lsls	r0, r0, #9
  4042f0:	4770      	bx	lr
  4042f2:	bf00      	nop

004042f4 <pio_get_pin_group_id>:
		ul_id = ID_PIOC;
	} else {
		ul_id = ID_PIOA + (ul_pin >> 5);
	}
#else
	ul_id = ID_PIOA + (ul_pin >> 5);
  4042f4:	0940      	lsrs	r0, r0, #5
#endif
	return ul_id;
}
  4042f6:	300b      	adds	r0, #11
  4042f8:	4770      	bx	lr
  4042fa:	bf00      	nop

004042fc <pio_get_pin_group_mask>:
 *
 * \return GPIO port pin mask.
 */
uint32_t pio_get_pin_group_mask(uint32_t ul_pin)
{
	uint32_t ul_mask = 1 << (ul_pin & 0x1F);
  4042fc:	2301      	movs	r3, #1
  4042fe:	f000 001f 	and.w	r0, r0, #31
	return ul_mask;
}
  404302:	fa03 f000 	lsl.w	r0, r3, r0
  404306:	4770      	bx	lr

00404308 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  404308:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40430c:	4b17      	ldr	r3, [pc, #92]	; (40436c <pio_handler_process+0x64>)
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  40430e:	4680      	mov	r8, r0
  404310:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  404312:	4798      	blx	r3
	status &= pio_get_interrupt_mask(p_pio);
  404314:	4b16      	ldr	r3, [pc, #88]	; (404370 <pio_handler_process+0x68>)
{
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  404316:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  404318:	4640      	mov	r0, r8
  40431a:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  40431c:	4005      	ands	r5, r0
  40431e:	d018      	beq.n	404352 <pio_handler_process+0x4a>
  404320:	4c14      	ldr	r4, [pc, #80]	; (404374 <pio_handler_process+0x6c>)
  404322:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
  404326:	e003      	b.n	404330 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  404328:	42bc      	cmp	r4, r7
  40432a:	d012      	beq.n	404352 <pio_handler_process+0x4a>
  40432c:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  40432e:	b185      	cbz	r5, 404352 <pio_handler_process+0x4a>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  404330:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  404334:	42b3      	cmp	r3, r6
  404336:	d1f7      	bne.n	404328 <pio_handler_process+0x20>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  404338:	f854 1c08 	ldr.w	r1, [r4, #-8]
  40433c:	4229      	tst	r1, r5
  40433e:	d0f3      	beq.n	404328 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  404340:	6823      	ldr	r3, [r4, #0]
  404342:	4630      	mov	r0, r6
  404344:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  404346:	f854 3c08 	ldr.w	r3, [r4, #-8]
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40434a:	42bc      	cmp	r4, r7
			if (gs_interrupt_sources[i].id == ul_id) {
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40434c:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  404350:	d1ec      	bne.n	40432c <pio_handler_process+0x24>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  404352:	4b09      	ldr	r3, [pc, #36]	; (404378 <pio_handler_process+0x70>)
  404354:	681b      	ldr	r3, [r3, #0]
  404356:	b133      	cbz	r3, 404366 <pio_handler_process+0x5e>
		if (pio_capture_handler) {
  404358:	4b08      	ldr	r3, [pc, #32]	; (40437c <pio_handler_process+0x74>)
  40435a:	681b      	ldr	r3, [r3, #0]
  40435c:	b10b      	cbz	r3, 404362 <pio_handler_process+0x5a>
			pio_capture_handler(p_pio);
  40435e:	4640      	mov	r0, r8
  404360:	4798      	blx	r3
  404362:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404366:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40436a:	bf00      	nop
  40436c:	0040413d 	.word	0x0040413d
  404370:	00404141 	.word	0x00404141
  404374:	20000f48 	.word	0x20000f48
  404378:	200024c4 	.word	0x200024c4
  40437c:	20000f38 	.word	0x20000f38

00404380 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  404380:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  404384:	4d0f      	ldr	r5, [pc, #60]	; (4043c4 <pio_handler_set+0x44>)
  404386:	682c      	ldr	r4, [r5, #0]
  404388:	2c0b      	cmp	r4, #11
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  40438a:	468c      	mov	ip, r1
  40438c:	4616      	mov	r6, r2
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  40438e:	d902      	bls.n	404396 <pio_handler_set+0x16>
		return 1;
  404390:	2001      	movs	r0, #1

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);

	return 0;
}
  404392:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  404396:	f8df 8030 	ldr.w	r8, [pc, #48]	; 4043c8 <pio_handler_set+0x48>
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40439a:	f8df 9030 	ldr.w	r9, [pc, #48]	; 4043cc <pio_handler_set+0x4c>

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  40439e:	ea4f 1e04 	mov.w	lr, r4, lsl #4
  4043a2:	eb08 070e 	add.w	r7, r8, lr
	pSource->id = ul_id;
  4043a6:	f848 c00e 	str.w	ip, [r8, lr]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4043aa:	4611      	mov	r1, r2

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
  4043ac:	60bb      	str	r3, [r7, #8]
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4043ae:	461a      	mov	r2, r3
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4043b0:	9b08      	ldr	r3, [sp, #32]
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
  4043b2:	607e      	str	r6, [r7, #4]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;
  4043b4:	3401      	adds	r4, #1
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4043b6:	60fb      	str	r3, [r7, #12]
	gs_ul_nb_sources++;
  4043b8:	602c      	str	r4, [r5, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4043ba:	47c8      	blx	r9

	return 0;
  4043bc:	2000      	movs	r0, #0
  4043be:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4043c2:	bf00      	nop
  4043c4:	20000f34 	.word	0x20000f34
  4043c8:	20000f3c 	.word	0x20000f3c
  4043cc:	00404109 	.word	0x00404109

004043d0 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  4043d0:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  4043d2:	4802      	ldr	r0, [pc, #8]	; (4043dc <PIOA_Handler+0xc>)
  4043d4:	4b02      	ldr	r3, [pc, #8]	; (4043e0 <PIOA_Handler+0x10>)
  4043d6:	210b      	movs	r1, #11
  4043d8:	4798      	blx	r3
  4043da:	bd08      	pop	{r3, pc}
  4043dc:	400e0e00 	.word	0x400e0e00
  4043e0:	00404309 	.word	0x00404309

004043e4 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  4043e4:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  4043e6:	4802      	ldr	r0, [pc, #8]	; (4043f0 <PIOB_Handler+0xc>)
  4043e8:	4b02      	ldr	r3, [pc, #8]	; (4043f4 <PIOB_Handler+0x10>)
  4043ea:	210c      	movs	r1, #12
  4043ec:	4798      	blx	r3
  4043ee:	bd08      	pop	{r3, pc}
  4043f0:	400e1000 	.word	0x400e1000
  4043f4:	00404309 	.word	0x00404309

004043f8 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  4043f8:	4914      	ldr	r1, [pc, #80]	; (40444c <pmc_switch_mck_to_pllack+0x54>)
  4043fa:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  4043fc:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  404400:	4318      	orrs	r0, r3
  404402:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404404:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  404406:	071b      	lsls	r3, r3, #28
  404408:	d407      	bmi.n	40441a <pmc_switch_mck_to_pllack+0x22>
  40440a:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40440e:	e001      	b.n	404414 <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404410:	3b01      	subs	r3, #1
  404412:	d016      	beq.n	404442 <pmc_switch_mck_to_pllack+0x4a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404414:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  404416:	0710      	lsls	r0, r2, #28
  404418:	d5fa      	bpl.n	404410 <pmc_switch_mck_to_pllack+0x18>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40441a:	490c      	ldr	r1, [pc, #48]	; (40444c <pmc_switch_mck_to_pllack+0x54>)
  40441c:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  40441e:	f023 0303 	bic.w	r3, r3, #3
  404422:	f043 0302 	orr.w	r3, r3, #2
  404426:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  404428:	6e88      	ldr	r0, [r1, #104]	; 0x68
  40442a:	f010 0008 	ands.w	r0, r0, #8
  40442e:	d10a      	bne.n	404446 <pmc_switch_mck_to_pllack+0x4e>
  404430:	f44f 6300 	mov.w	r3, #2048	; 0x800
  404434:	e001      	b.n	40443a <pmc_switch_mck_to_pllack+0x42>
			--ul_timeout) {
		if (ul_timeout == 0) {
  404436:	3b01      	subs	r3, #1
  404438:	d003      	beq.n	404442 <pmc_switch_mck_to_pllack+0x4a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40443a:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40443c:	0712      	lsls	r2, r2, #28
  40443e:	d5fa      	bpl.n	404436 <pmc_switch_mck_to_pllack+0x3e>
  404440:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  404442:	2001      	movs	r0, #1
  404444:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  404446:	2000      	movs	r0, #0
}
  404448:	4770      	bx	lr
  40444a:	bf00      	nop
  40444c:	400e0400 	.word	0x400e0400

00404450 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  404450:	b9c8      	cbnz	r0, 404486 <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  404452:	4b11      	ldr	r3, [pc, #68]	; (404498 <pmc_switch_mainck_to_xtal+0x48>)
  404454:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404456:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  40445a:	f022 0203 	bic.w	r2, r2, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  40445e:	0209      	lsls	r1, r1, #8
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404460:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  404464:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  404466:	f042 0201 	orr.w	r2, r2, #1
  40446a:	430a      	orrs	r2, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40446c:	621a      	str	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  40446e:	4619      	mov	r1, r3
  404470:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  404472:	4a09      	ldr	r2, [pc, #36]	; (404498 <pmc_switch_mainck_to_xtal+0x48>)
  404474:	07db      	lsls	r3, r3, #31
  404476:	d5fb      	bpl.n	404470 <pmc_switch_mainck_to_xtal+0x20>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  404478:	6a13      	ldr	r3, [r2, #32]
  40447a:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  40447e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  404482:	6213      	str	r3, [r2, #32]
  404484:	4770      	bx	lr
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  404486:	4904      	ldr	r1, [pc, #16]	; (404498 <pmc_switch_mainck_to_xtal+0x48>)
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  404488:	4a04      	ldr	r2, [pc, #16]	; (40449c <pmc_switch_mainck_to_xtal+0x4c>)
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  40448a:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  40448c:	4b04      	ldr	r3, [pc, #16]	; (4044a0 <pmc_switch_mainck_to_xtal+0x50>)
  40448e:	4002      	ands	r2, r0
  404490:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  404492:	620b      	str	r3, [r1, #32]
  404494:	4770      	bx	lr
  404496:	bf00      	nop
  404498:	400e0400 	.word	0x400e0400
  40449c:	fec8fffc 	.word	0xfec8fffc
  4044a0:	01370002 	.word	0x01370002

004044a4 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4044a4:	4b02      	ldr	r3, [pc, #8]	; (4044b0 <pmc_osc_is_ready_mainck+0xc>)
  4044a6:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4044a8:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  4044ac:	4770      	bx	lr
  4044ae:	bf00      	nop
  4044b0:	400e0400 	.word	0x400e0400

004044b4 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4044b4:	4b02      	ldr	r3, [pc, #8]	; (4044c0 <pmc_disable_pllack+0xc>)
  4044b6:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  4044ba:	629a      	str	r2, [r3, #40]	; 0x28
  4044bc:	4770      	bx	lr
  4044be:	bf00      	nop
  4044c0:	400e0400 	.word	0x400e0400

004044c4 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  4044c4:	4b02      	ldr	r3, [pc, #8]	; (4044d0 <pmc_is_locked_pllack+0xc>)
  4044c6:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4044c8:	f000 0002 	and.w	r0, r0, #2
  4044cc:	4770      	bx	lr
  4044ce:	bf00      	nop
  4044d0:	400e0400 	.word	0x400e0400

004044d4 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  4044d4:	2822      	cmp	r0, #34	; 0x22
  4044d6:	d819      	bhi.n	40450c <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
  4044d8:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  4044da:	4b0e      	ldr	r3, [pc, #56]	; (404514 <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
  4044dc:	d809      	bhi.n	4044f2 <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  4044de:	2101      	movs	r1, #1
  4044e0:	699a      	ldr	r2, [r3, #24]
  4044e2:	fa01 f000 	lsl.w	r0, r1, r0
  4044e6:	4002      	ands	r2, r0
  4044e8:	4290      	cmp	r0, r2
  4044ea:	d011      	beq.n	404510 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
  4044ec:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  4044ee:	2000      	movs	r0, #0
  4044f0:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  4044f2:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  4044f4:	2101      	movs	r1, #1
  4044f6:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  4044fa:	fa01 f000 	lsl.w	r0, r1, r0
  4044fe:	4002      	ands	r2, r0
  404500:	4290      	cmp	r0, r2
  404502:	d005      	beq.n	404510 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
  404504:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  404508:	2000      	movs	r0, #0
  40450a:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  40450c:	2001      	movs	r0, #1
  40450e:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  404510:	2000      	movs	r0, #0
}
  404512:	4770      	bx	lr
  404514:	400e0400 	.word	0x400e0400

00404518 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  404518:	6880      	ldr	r0, [r0, #8]
}
  40451a:	4770      	bx	lr

0040451c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40451c:	e7fe      	b.n	40451c <Dummy_Handler>
  40451e:	bf00      	nop

00404520 <Reset_Handler>:

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  404520:	481c      	ldr	r0, [pc, #112]	; (404594 <Reset_Handler+0x74>)
  404522:	4b1d      	ldr	r3, [pc, #116]	; (404598 <Reset_Handler+0x78>)
  404524:	4298      	cmp	r0, r3
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  404526:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  404528:	d925      	bls.n	404576 <Reset_Handler+0x56>
		for (; pDest < &_erelocate;) {
  40452a:	4a1c      	ldr	r2, [pc, #112]	; (40459c <Reset_Handler+0x7c>)
  40452c:	4293      	cmp	r3, r2
  40452e:	d20a      	bcs.n	404546 <Reset_Handler+0x26>
  404530:	43d9      	mvns	r1, r3
  404532:	440a      	add	r2, r1
  404534:	f022 0403 	bic.w	r4, r2, #3
  404538:	3404      	adds	r4, #4
  40453a:	2200      	movs	r2, #0
			*pDest++ = *pSrc++;
  40453c:	5881      	ldr	r1, [r0, r2]
  40453e:	5099      	str	r1, [r3, r2]
  404540:	3204      	adds	r2, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  404542:	42a2      	cmp	r2, r4
  404544:	d1fa      	bne.n	40453c <Reset_Handler+0x1c>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  404546:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  404548:	4b15      	ldr	r3, [pc, #84]	; (4045a0 <Reset_Handler+0x80>)
  40454a:	4a16      	ldr	r2, [pc, #88]	; (4045a4 <Reset_Handler+0x84>)
  40454c:	4293      	cmp	r3, r2
  40454e:	d20a      	bcs.n	404566 <Reset_Handler+0x46>
  404550:	43d9      	mvns	r1, r3
  404552:	440a      	add	r2, r1
  404554:	f022 0103 	bic.w	r1, r2, #3
  404558:	4419      	add	r1, r3
		*pDest++ = 0;
  40455a:	2200      	movs	r2, #0
  40455c:	3b04      	subs	r3, #4
  40455e:	f843 2f04 	str.w	r2, [r3, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  404562:	428b      	cmp	r3, r1
  404564:	d1fb      	bne.n	40455e <Reset_Handler+0x3e>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  404566:	4b10      	ldr	r3, [pc, #64]	; (4045a8 <Reset_Handler+0x88>)
  404568:	4a10      	ldr	r2, [pc, #64]	; (4045ac <Reset_Handler+0x8c>)
  40456a:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  40456c:	4b10      	ldr	r3, [pc, #64]	; (4045b0 <Reset_Handler+0x90>)
  40456e:	4798      	blx	r3

	/* Branch to main function */
	main();
  404570:	4b10      	ldr	r3, [pc, #64]	; (4045b4 <Reset_Handler+0x94>)
  404572:	4798      	blx	r3
  404574:	e7fe      	b.n	404574 <Reset_Handler+0x54>

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  404576:	d2e6      	bcs.n	404546 <Reset_Handler+0x26>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  404578:	4908      	ldr	r1, [pc, #32]	; (40459c <Reset_Handler+0x7c>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  40457a:	3804      	subs	r0, #4
	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  40457c:	1aca      	subs	r2, r1, r3
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  40457e:	4410      	add	r0, r2
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  404580:	2a00      	cmp	r2, #0
  404582:	d0e0      	beq.n	404546 <Reset_Handler+0x26>
  404584:	460a      	mov	r2, r1
  404586:	1a54      	subs	r4, r2, r1
			*pDest-- = *pSrc--;
  404588:	5824      	ldr	r4, [r4, r0]
  40458a:	f842 4d04 	str.w	r4, [r2, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  40458e:	4293      	cmp	r3, r2
  404590:	d1f9      	bne.n	404586 <Reset_Handler+0x66>
  404592:	e7d8      	b.n	404546 <Reset_Handler+0x26>
  404594:	00405978 	.word	0x00405978
  404598:	20000000 	.word	0x20000000
  40459c:	20000a2c 	.word	0x20000a2c
  4045a0:	20000c00 	.word	0x20000c00
  4045a4:	200024cc 	.word	0x200024cc
  4045a8:	e000ed00 	.word	0xe000ed00
  4045ac:	00400000 	.word	0x00400000
  4045b0:	00404789 	.word	0x00404789
  4045b4:	00404755 	.word	0x00404755

004045b8 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  4045b8:	4b32      	ldr	r3, [pc, #200]	; (404684 <SystemCoreClockUpdate+0xcc>)
  4045ba:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  4045bc:	f002 0203 	and.w	r2, r2, #3
  4045c0:	2a01      	cmp	r2, #1
  4045c2:	d03a      	beq.n	40463a <SystemCoreClockUpdate+0x82>
  4045c4:	d323      	bcc.n	40460e <SystemCoreClockUpdate+0x56>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4045c6:	6a1a      	ldr	r2, [r3, #32]
  4045c8:	01d2      	lsls	r2, r2, #7
  4045ca:	d547      	bpl.n	40465c <SystemCoreClockUpdate+0xa4>
				SystemCoreClock = CHIP_FREQ_XTAL;
  4045cc:	4a2e      	ldr	r2, [pc, #184]	; (404688 <SystemCoreClockUpdate+0xd0>)
  4045ce:	482f      	ldr	r0, [pc, #188]	; (40468c <SystemCoreClockUpdate+0xd4>)
  4045d0:	6010      	str	r0, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  4045d2:	4b2c      	ldr	r3, [pc, #176]	; (404684 <SystemCoreClockUpdate+0xcc>)
  4045d4:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4045d6:	f001 0103 	and.w	r1, r1, #3
  4045da:	2902      	cmp	r1, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  4045dc:	bf0b      	itete	eq
  4045de:	6a99      	ldreq	r1, [r3, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  4045e0:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  4045e2:	6a9b      	ldreq	r3, [r3, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  4045e4:	6adb      	ldrne	r3, [r3, #44]	; 0x2c
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  4045e6:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  4045ea:	fb01 0000 	mla	r0, r1, r0, r0
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  4045ee:	b2db      	uxtb	r3, r3
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  4045f0:	fbb0 f0f3 	udiv	r0, r0, r3
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  4045f4:	4b23      	ldr	r3, [pc, #140]	; (404684 <SystemCoreClockUpdate+0xcc>)
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  4045f6:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  4045f8:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4045fa:	f001 0170 	and.w	r1, r1, #112	; 0x70
  4045fe:	2970      	cmp	r1, #112	; 0x70
  404600:	d115      	bne.n	40462e <SystemCoreClockUpdate+0x76>
		SystemCoreClock /= 3U;
  404602:	4b23      	ldr	r3, [pc, #140]	; (404690 <SystemCoreClockUpdate+0xd8>)
  404604:	fba3 1000 	umull	r1, r0, r3, r0
  404608:	0840      	lsrs	r0, r0, #1
  40460a:	6010      	str	r0, [r2, #0]
  40460c:	4770      	bx	lr
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40460e:	4b21      	ldr	r3, [pc, #132]	; (404694 <SystemCoreClockUpdate+0xdc>)
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  404610:	4a1d      	ldr	r2, [pc, #116]	; (404688 <SystemCoreClockUpdate+0xd0>)
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  404612:	695b      	ldr	r3, [r3, #20]
  404614:	061b      	lsls	r3, r3, #24
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  404616:	bf4c      	ite	mi
  404618:	f44f 4000 	movmi.w	r0, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40461c:	f44f 40fa 	movpl.w	r0, #32000	; 0x7d00
  404620:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  404622:	4b18      	ldr	r3, [pc, #96]	; (404684 <SystemCoreClockUpdate+0xcc>)
  404624:	6b19      	ldr	r1, [r3, #48]	; 0x30
  404626:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40462a:	2970      	cmp	r1, #112	; 0x70
  40462c:	d0e9      	beq.n	404602 <SystemCoreClockUpdate+0x4a>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40462e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  404630:	f3c3 1302 	ubfx	r3, r3, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  404634:	40d8      	lsrs	r0, r3
  404636:	6010      	str	r0, [r2, #0]
  404638:	4770      	bx	lr
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40463a:	6a1a      	ldr	r2, [r3, #32]
  40463c:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
			SystemCoreClock = CHIP_FREQ_XTAL;
  404640:	4a11      	ldr	r2, [pc, #68]	; (404688 <SystemCoreClockUpdate+0xd0>)
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  404642:	d108      	bne.n	404656 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  404644:	4814      	ldr	r0, [pc, #80]	; (404698 <SystemCoreClockUpdate+0xe0>)
  404646:	6010      	str	r0, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  404648:	6a1b      	ldr	r3, [r3, #32]
  40464a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40464e:	2b10      	cmp	r3, #16
  404650:	d014      	beq.n	40467c <SystemCoreClockUpdate+0xc4>
  404652:	2b20      	cmp	r3, #32
  404654:	d1e5      	bne.n	404622 <SystemCoreClockUpdate+0x6a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  404656:	480d      	ldr	r0, [pc, #52]	; (40468c <SystemCoreClockUpdate+0xd4>)
  404658:	6010      	str	r0, [r2, #0]
			break;
  40465a:	e7e2      	b.n	404622 <SystemCoreClockUpdate+0x6a>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
				SystemCoreClock = CHIP_FREQ_XTAL;
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  40465c:	4a0a      	ldr	r2, [pc, #40]	; (404688 <SystemCoreClockUpdate+0xd0>)
  40465e:	480e      	ldr	r0, [pc, #56]	; (404698 <SystemCoreClockUpdate+0xe0>)
  404660:	6010      	str	r0, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  404662:	6a1b      	ldr	r3, [r3, #32]
  404664:	f003 0370 	and.w	r3, r3, #112	; 0x70
  404668:	2b10      	cmp	r3, #16
  40466a:	d004      	beq.n	404676 <SystemCoreClockUpdate+0xbe>
  40466c:	2b20      	cmp	r3, #32
  40466e:	d1b0      	bne.n	4045d2 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  404670:	4806      	ldr	r0, [pc, #24]	; (40468c <SystemCoreClockUpdate+0xd4>)
  404672:	6010      	str	r0, [r2, #0]
					break;
  404674:	e7ad      	b.n	4045d2 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  404676:	4809      	ldr	r0, [pc, #36]	; (40469c <SystemCoreClockUpdate+0xe4>)
  404678:	6010      	str	r0, [r2, #0]
					break;
  40467a:	e7aa      	b.n	4045d2 <SystemCoreClockUpdate+0x1a>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  40467c:	4807      	ldr	r0, [pc, #28]	; (40469c <SystemCoreClockUpdate+0xe4>)
  40467e:	6010      	str	r0, [r2, #0]
			break;
  404680:	e7cf      	b.n	404622 <SystemCoreClockUpdate+0x6a>
  404682:	bf00      	nop
  404684:	400e0400 	.word	0x400e0400
  404688:	200001e8 	.word	0x200001e8
  40468c:	00b71b00 	.word	0x00b71b00
  404690:	aaaaaaab 	.word	0xaaaaaaab
  404694:	400e1410 	.word	0x400e1410
  404698:	003d0900 	.word	0x003d0900
  40469c:	007a1200 	.word	0x007a1200

004046a0 <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  4046a0:	4b0f      	ldr	r3, [pc, #60]	; (4046e0 <system_init_flash+0x40>)
  4046a2:	4298      	cmp	r0, r3
  4046a4:	d912      	bls.n	4046cc <system_init_flash+0x2c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  4046a6:	4b0f      	ldr	r3, [pc, #60]	; (4046e4 <system_init_flash+0x44>)
  4046a8:	4298      	cmp	r0, r3
  4046aa:	d90b      	bls.n	4046c4 <system_init_flash+0x24>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  4046ac:	4b0e      	ldr	r3, [pc, #56]	; (4046e8 <system_init_flash+0x48>)
  4046ae:	4298      	cmp	r0, r3
  4046b0:	d911      	bls.n	4046d6 <system_init_flash+0x36>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  4046b2:	4b0e      	ldr	r3, [pc, #56]	; (4046ec <system_init_flash+0x4c>)
  4046b4:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  4046b6:	4b0e      	ldr	r3, [pc, #56]	; (4046f0 <system_init_flash+0x50>)
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4046b8:	bf8c      	ite	hi
  4046ba:	4a0e      	ldrhi	r2, [pc, #56]	; (4046f4 <system_init_flash+0x54>)
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  4046bc:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  4046c0:	601a      	str	r2, [r3, #0]
  4046c2:	4770      	bx	lr
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  4046c4:	4b0a      	ldr	r3, [pc, #40]	; (4046f0 <system_init_flash+0x50>)
  4046c6:	4a0c      	ldr	r2, [pc, #48]	; (4046f8 <system_init_flash+0x58>)
  4046c8:	601a      	str	r2, [r3, #0]
  4046ca:	4770      	bx	lr
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  4046cc:	4b08      	ldr	r3, [pc, #32]	; (4046f0 <system_init_flash+0x50>)
  4046ce:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  4046d2:	601a      	str	r2, [r3, #0]
  4046d4:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  4046d6:	4b06      	ldr	r3, [pc, #24]	; (4046f0 <system_init_flash+0x50>)
  4046d8:	4a08      	ldr	r2, [pc, #32]	; (4046fc <system_init_flash+0x5c>)
  4046da:	601a      	str	r2, [r3, #0]
  4046dc:	4770      	bx	lr
  4046de:	bf00      	nop
  4046e0:	01ba813f 	.word	0x01ba813f
  4046e4:	0375027f 	.word	0x0375027f
  4046e8:	053ec5ff 	.word	0x053ec5ff
  4046ec:	07270dff 	.word	0x07270dff
  4046f0:	400e0a00 	.word	0x400e0a00
  4046f4:	04000500 	.word	0x04000500
  4046f8:	04000100 	.word	0x04000100
  4046fc:	04000200 	.word	0x04000200

00404700 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  404700:	4a07      	ldr	r2, [pc, #28]	; (404720 <_sbrk+0x20>)

extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  404702:	4908      	ldr	r1, [pc, #32]	; (404724 <_sbrk+0x24>)

	if (heap == NULL) {
  404704:	6813      	ldr	r3, [r2, #0]
  404706:	b13b      	cbz	r3, 404718 <_sbrk+0x18>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
  404708:	4418      	add	r0, r3
  40470a:	4281      	cmp	r1, r0
		return (caddr_t) -1;	
	}

	heap += incr;
  40470c:	bfa6      	itte	ge
  40470e:	6010      	strge	r0, [r2, #0]

	return (caddr_t) prev_heap;
  404710:	4618      	movge	r0, r3
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  404712:	f04f 30ff 	movlt.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  404716:	4770      	bx	lr
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
		heap = (unsigned char *)&_end;
  404718:	4b03      	ldr	r3, [pc, #12]	; (404728 <_sbrk+0x28>)
  40471a:	6013      	str	r3, [r2, #0]
  40471c:	e7f4      	b.n	404708 <_sbrk+0x8>
  40471e:	bf00      	nop
  404720:	20000ffc 	.word	0x20000ffc
  404724:	2000fffc 	.word	0x2000fffc
  404728:	200054d0 	.word	0x200054d0

0040472c <HardFault_Handler>:
extern drv_uart_config_t usart1Config;
extern brainSettings_t brainSettings; 
volatile unsigned long sgSysTickCount = 0;

void HardFault_Handler()
{
  40472c:	e7fe      	b.n	40472c <HardFault_Handler>
  40472e:	bf00      	nop

00404730 <MemManage_Handler>:
	while(1); 
}
void MemManage_Handler()
{
  404730:	e7fe      	b.n	404730 <MemManage_Handler>
  404732:	bf00      	nop

00404734 <BusFault_Handler>:
	while(1); 
}
void BusFault_Handler()
{
  404734:	e7fe      	b.n	404734 <BusFault_Handler>
  404736:	bf00      	nop

00404738 <UsageFault_Handler>:
	while(1); 
}
void UsageFault_Handler()
{
  404738:	e7fe      	b.n	404738 <UsageFault_Handler>
  40473a:	bf00      	nop

0040473c <SysTick_Handler>:

/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
  40473c:	b508      	push	{r3, lr}
	sgSysTickCount++;
  40473e:	4b03      	ldr	r3, [pc, #12]	; (40474c <SysTick_Handler+0x10>)
	xPortSysTickHandler();
  404740:	4a03      	ldr	r2, [pc, #12]	; (404750 <SysTick_Handler+0x14>)
/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
	sgSysTickCount++;
  404742:	6819      	ldr	r1, [r3, #0]
  404744:	3101      	adds	r1, #1
  404746:	6019      	str	r1, [r3, #0]
	xPortSysTickHandler();
  404748:	4790      	blx	r2
  40474a:	bd08      	pop	{r3, pc}
  40474c:	20001000 	.word	0x20001000
  404750:	004035b1 	.word	0x004035b1

00404754 <main>:
}


int main (void)
{
  404754:	b508      	push	{r3, lr}
	irq_initialize_vectors();
	cpu_irq_enable();
  404756:	4b07      	ldr	r3, [pc, #28]	; (404774 <main+0x20>)
  404758:	2201      	movs	r2, #1
  40475a:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  40475c:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  404760:	b662      	cpsie	i
	//Initialize system clock and peripherals
	sysclk_init();
  404762:	4b05      	ldr	r3, [pc, #20]	; (404778 <main+0x24>)
  404764:	4c05      	ldr	r4, [pc, #20]	; (40477c <main+0x28>)
  404766:	4798      	blx	r3
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
  404768:	4b05      	ldr	r3, [pc, #20]	; (404780 <main+0x2c>)
  40476a:	4798      	blx	r3
	//we should never get here. 
	/*	Debug code */
	while (1) 
	{		

		delay_ms(1000);
  40476c:	4805      	ldr	r0, [pc, #20]	; (404784 <main+0x30>)
  40476e:	47a0      	blx	r4
  404770:	e7fc      	b.n	40476c <main+0x18>
  404772:	bf00      	nop
  404774:	200001e4 	.word	0x200001e4
  404778:	00403f61 	.word	0x00403f61
  40477c:	20000085 	.word	0x20000085
  404780:	00400505 	.word	0x00400505
  404784:	0082ca25 	.word	0x0082ca25

00404788 <__libc_init_array>:
  404788:	b570      	push	{r4, r5, r6, lr}
  40478a:	4e0f      	ldr	r6, [pc, #60]	; (4047c8 <__libc_init_array+0x40>)
  40478c:	4d0f      	ldr	r5, [pc, #60]	; (4047cc <__libc_init_array+0x44>)
  40478e:	1b76      	subs	r6, r6, r5
  404790:	10b6      	asrs	r6, r6, #2
  404792:	d007      	beq.n	4047a4 <__libc_init_array+0x1c>
  404794:	3d04      	subs	r5, #4
  404796:	2400      	movs	r4, #0
  404798:	3401      	adds	r4, #1
  40479a:	f855 3f04 	ldr.w	r3, [r5, #4]!
  40479e:	4798      	blx	r3
  4047a0:	42a6      	cmp	r6, r4
  4047a2:	d1f9      	bne.n	404798 <__libc_init_array+0x10>
  4047a4:	4e0a      	ldr	r6, [pc, #40]	; (4047d0 <__libc_init_array+0x48>)
  4047a6:	4d0b      	ldr	r5, [pc, #44]	; (4047d4 <__libc_init_array+0x4c>)
  4047a8:	1b76      	subs	r6, r6, r5
  4047aa:	f001 f8d3 	bl	405954 <_init>
  4047ae:	10b6      	asrs	r6, r6, #2
  4047b0:	d008      	beq.n	4047c4 <__libc_init_array+0x3c>
  4047b2:	3d04      	subs	r5, #4
  4047b4:	2400      	movs	r4, #0
  4047b6:	3401      	adds	r4, #1
  4047b8:	f855 3f04 	ldr.w	r3, [r5, #4]!
  4047bc:	4798      	blx	r3
  4047be:	42a6      	cmp	r6, r4
  4047c0:	d1f9      	bne.n	4047b6 <__libc_init_array+0x2e>
  4047c2:	bd70      	pop	{r4, r5, r6, pc}
  4047c4:	bd70      	pop	{r4, r5, r6, pc}
  4047c6:	bf00      	nop
  4047c8:	00405960 	.word	0x00405960
  4047cc:	00405960 	.word	0x00405960
  4047d0:	00405968 	.word	0x00405968
  4047d4:	00405960 	.word	0x00405960

004047d8 <malloc>:
  4047d8:	4b02      	ldr	r3, [pc, #8]	; (4047e4 <malloc+0xc>)
  4047da:	4601      	mov	r1, r0
  4047dc:	6818      	ldr	r0, [r3, #0]
  4047de:	f000 b803 	b.w	4047e8 <_malloc_r>
  4047e2:	bf00      	nop
  4047e4:	20000618 	.word	0x20000618

004047e8 <_malloc_r>:
  4047e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4047ec:	f101 050b 	add.w	r5, r1, #11
  4047f0:	2d16      	cmp	r5, #22
  4047f2:	b083      	sub	sp, #12
  4047f4:	4606      	mov	r6, r0
  4047f6:	d927      	bls.n	404848 <_malloc_r+0x60>
  4047f8:	f035 0507 	bics.w	r5, r5, #7
  4047fc:	d427      	bmi.n	40484e <_malloc_r+0x66>
  4047fe:	42a9      	cmp	r1, r5
  404800:	d825      	bhi.n	40484e <_malloc_r+0x66>
  404802:	4630      	mov	r0, r6
  404804:	f000 fb70 	bl	404ee8 <__malloc_lock>
  404808:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  40480c:	d226      	bcs.n	40485c <_malloc_r+0x74>
  40480e:	4fc1      	ldr	r7, [pc, #772]	; (404b14 <_malloc_r+0x32c>)
  404810:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
  404814:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
  404818:	68dc      	ldr	r4, [r3, #12]
  40481a:	429c      	cmp	r4, r3
  40481c:	f000 81d2 	beq.w	404bc4 <_malloc_r+0x3dc>
  404820:	6863      	ldr	r3, [r4, #4]
  404822:	68e2      	ldr	r2, [r4, #12]
  404824:	68a1      	ldr	r1, [r4, #8]
  404826:	f023 0303 	bic.w	r3, r3, #3
  40482a:	4423      	add	r3, r4
  40482c:	4630      	mov	r0, r6
  40482e:	685d      	ldr	r5, [r3, #4]
  404830:	60ca      	str	r2, [r1, #12]
  404832:	f045 0501 	orr.w	r5, r5, #1
  404836:	6091      	str	r1, [r2, #8]
  404838:	605d      	str	r5, [r3, #4]
  40483a:	f000 fb57 	bl	404eec <__malloc_unlock>
  40483e:	3408      	adds	r4, #8
  404840:	4620      	mov	r0, r4
  404842:	b003      	add	sp, #12
  404844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404848:	2510      	movs	r5, #16
  40484a:	42a9      	cmp	r1, r5
  40484c:	d9d9      	bls.n	404802 <_malloc_r+0x1a>
  40484e:	2400      	movs	r4, #0
  404850:	230c      	movs	r3, #12
  404852:	4620      	mov	r0, r4
  404854:	6033      	str	r3, [r6, #0]
  404856:	b003      	add	sp, #12
  404858:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40485c:	ea5f 2c55 	movs.w	ip, r5, lsr #9
  404860:	f000 808a 	beq.w	404978 <_malloc_r+0x190>
  404864:	f1bc 0f04 	cmp.w	ip, #4
  404868:	f200 8160 	bhi.w	404b2c <_malloc_r+0x344>
  40486c:	ea4f 1c95 	mov.w	ip, r5, lsr #6
  404870:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
  404874:	ea4f 014c 	mov.w	r1, ip, lsl #1
  404878:	4fa6      	ldr	r7, [pc, #664]	; (404b14 <_malloc_r+0x32c>)
  40487a:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  40487e:	68cc      	ldr	r4, [r1, #12]
  404880:	42a1      	cmp	r1, r4
  404882:	d105      	bne.n	404890 <_malloc_r+0xa8>
  404884:	e00c      	b.n	4048a0 <_malloc_r+0xb8>
  404886:	2b00      	cmp	r3, #0
  404888:	da7a      	bge.n	404980 <_malloc_r+0x198>
  40488a:	68e4      	ldr	r4, [r4, #12]
  40488c:	42a1      	cmp	r1, r4
  40488e:	d007      	beq.n	4048a0 <_malloc_r+0xb8>
  404890:	6862      	ldr	r2, [r4, #4]
  404892:	f022 0203 	bic.w	r2, r2, #3
  404896:	1b53      	subs	r3, r2, r5
  404898:	2b0f      	cmp	r3, #15
  40489a:	ddf4      	ble.n	404886 <_malloc_r+0x9e>
  40489c:	f10c 3cff 	add.w	ip, ip, #4294967295
  4048a0:	f10c 0c01 	add.w	ip, ip, #1
  4048a4:	4b9b      	ldr	r3, [pc, #620]	; (404b14 <_malloc_r+0x32c>)
  4048a6:	693c      	ldr	r4, [r7, #16]
  4048a8:	f103 0e08 	add.w	lr, r3, #8
  4048ac:	4574      	cmp	r4, lr
  4048ae:	f000 817e 	beq.w	404bae <_malloc_r+0x3c6>
  4048b2:	6861      	ldr	r1, [r4, #4]
  4048b4:	f021 0103 	bic.w	r1, r1, #3
  4048b8:	1b4a      	subs	r2, r1, r5
  4048ba:	2a0f      	cmp	r2, #15
  4048bc:	f300 8164 	bgt.w	404b88 <_malloc_r+0x3a0>
  4048c0:	2a00      	cmp	r2, #0
  4048c2:	f8c3 e014 	str.w	lr, [r3, #20]
  4048c6:	f8c3 e010 	str.w	lr, [r3, #16]
  4048ca:	da6a      	bge.n	4049a2 <_malloc_r+0x1ba>
  4048cc:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  4048d0:	f080 813a 	bcs.w	404b48 <_malloc_r+0x360>
  4048d4:	08c9      	lsrs	r1, r1, #3
  4048d6:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
  4048da:	ea4f 08a1 	mov.w	r8, r1, asr #2
  4048de:	685a      	ldr	r2, [r3, #4]
  4048e0:	6881      	ldr	r1, [r0, #8]
  4048e2:	60a1      	str	r1, [r4, #8]
  4048e4:	f04f 0901 	mov.w	r9, #1
  4048e8:	fa09 f808 	lsl.w	r8, r9, r8
  4048ec:	ea48 0202 	orr.w	r2, r8, r2
  4048f0:	60e0      	str	r0, [r4, #12]
  4048f2:	605a      	str	r2, [r3, #4]
  4048f4:	6084      	str	r4, [r0, #8]
  4048f6:	60cc      	str	r4, [r1, #12]
  4048f8:	ea4f 03ac 	mov.w	r3, ip, asr #2
  4048fc:	2001      	movs	r0, #1
  4048fe:	4098      	lsls	r0, r3
  404900:	4290      	cmp	r0, r2
  404902:	d85b      	bhi.n	4049bc <_malloc_r+0x1d4>
  404904:	4202      	tst	r2, r0
  404906:	d106      	bne.n	404916 <_malloc_r+0x12e>
  404908:	f02c 0c03 	bic.w	ip, ip, #3
  40490c:	0040      	lsls	r0, r0, #1
  40490e:	4202      	tst	r2, r0
  404910:	f10c 0c04 	add.w	ip, ip, #4
  404914:	d0fa      	beq.n	40490c <_malloc_r+0x124>
  404916:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
  40491a:	4644      	mov	r4, r8
  40491c:	46e1      	mov	r9, ip
  40491e:	68e3      	ldr	r3, [r4, #12]
  404920:	429c      	cmp	r4, r3
  404922:	d107      	bne.n	404934 <_malloc_r+0x14c>
  404924:	e145      	b.n	404bb2 <_malloc_r+0x3ca>
  404926:	2a00      	cmp	r2, #0
  404928:	f280 8156 	bge.w	404bd8 <_malloc_r+0x3f0>
  40492c:	68db      	ldr	r3, [r3, #12]
  40492e:	429c      	cmp	r4, r3
  404930:	f000 813f 	beq.w	404bb2 <_malloc_r+0x3ca>
  404934:	6859      	ldr	r1, [r3, #4]
  404936:	f021 0103 	bic.w	r1, r1, #3
  40493a:	1b4a      	subs	r2, r1, r5
  40493c:	2a0f      	cmp	r2, #15
  40493e:	ddf2      	ble.n	404926 <_malloc_r+0x13e>
  404940:	461c      	mov	r4, r3
  404942:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  404946:	f854 8f08 	ldr.w	r8, [r4, #8]!
  40494a:	1959      	adds	r1, r3, r5
  40494c:	f045 0901 	orr.w	r9, r5, #1
  404950:	f042 0501 	orr.w	r5, r2, #1
  404954:	f8c3 9004 	str.w	r9, [r3, #4]
  404958:	4630      	mov	r0, r6
  40495a:	f8c8 c00c 	str.w	ip, [r8, #12]
  40495e:	f8cc 8008 	str.w	r8, [ip, #8]
  404962:	6179      	str	r1, [r7, #20]
  404964:	6139      	str	r1, [r7, #16]
  404966:	f8c1 e00c 	str.w	lr, [r1, #12]
  40496a:	f8c1 e008 	str.w	lr, [r1, #8]
  40496e:	604d      	str	r5, [r1, #4]
  404970:	508a      	str	r2, [r1, r2]
  404972:	f000 fabb 	bl	404eec <__malloc_unlock>
  404976:	e763      	b.n	404840 <_malloc_r+0x58>
  404978:	217e      	movs	r1, #126	; 0x7e
  40497a:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  40497e:	e77b      	b.n	404878 <_malloc_r+0x90>
  404980:	4422      	add	r2, r4
  404982:	68e3      	ldr	r3, [r4, #12]
  404984:	6850      	ldr	r0, [r2, #4]
  404986:	68a1      	ldr	r1, [r4, #8]
  404988:	f040 0501 	orr.w	r5, r0, #1
  40498c:	60cb      	str	r3, [r1, #12]
  40498e:	4630      	mov	r0, r6
  404990:	6099      	str	r1, [r3, #8]
  404992:	6055      	str	r5, [r2, #4]
  404994:	f000 faaa 	bl	404eec <__malloc_unlock>
  404998:	3408      	adds	r4, #8
  40499a:	4620      	mov	r0, r4
  40499c:	b003      	add	sp, #12
  40499e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4049a2:	4421      	add	r1, r4
  4049a4:	4630      	mov	r0, r6
  4049a6:	684b      	ldr	r3, [r1, #4]
  4049a8:	f043 0301 	orr.w	r3, r3, #1
  4049ac:	604b      	str	r3, [r1, #4]
  4049ae:	f000 fa9d 	bl	404eec <__malloc_unlock>
  4049b2:	3408      	adds	r4, #8
  4049b4:	4620      	mov	r0, r4
  4049b6:	b003      	add	sp, #12
  4049b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4049bc:	68bc      	ldr	r4, [r7, #8]
  4049be:	6863      	ldr	r3, [r4, #4]
  4049c0:	f023 0903 	bic.w	r9, r3, #3
  4049c4:	45a9      	cmp	r9, r5
  4049c6:	d304      	bcc.n	4049d2 <_malloc_r+0x1ea>
  4049c8:	ebc5 0309 	rsb	r3, r5, r9
  4049cc:	2b0f      	cmp	r3, #15
  4049ce:	f300 8091 	bgt.w	404af4 <_malloc_r+0x30c>
  4049d2:	4b51      	ldr	r3, [pc, #324]	; (404b18 <_malloc_r+0x330>)
  4049d4:	4a51      	ldr	r2, [pc, #324]	; (404b1c <_malloc_r+0x334>)
  4049d6:	6819      	ldr	r1, [r3, #0]
  4049d8:	6813      	ldr	r3, [r2, #0]
  4049da:	3301      	adds	r3, #1
  4049dc:	eb05 0a01 	add.w	sl, r5, r1
  4049e0:	eb04 0b09 	add.w	fp, r4, r9
  4049e4:	f000 8161 	beq.w	404caa <_malloc_r+0x4c2>
  4049e8:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
  4049ec:	f10a 0a0f 	add.w	sl, sl, #15
  4049f0:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
  4049f4:	f02a 0a0f 	bic.w	sl, sl, #15
  4049f8:	4630      	mov	r0, r6
  4049fa:	4651      	mov	r1, sl
  4049fc:	9201      	str	r2, [sp, #4]
  4049fe:	f000 fa77 	bl	404ef0 <_sbrk_r>
  404a02:	f1b0 3fff 	cmp.w	r0, #4294967295
  404a06:	4680      	mov	r8, r0
  404a08:	9a01      	ldr	r2, [sp, #4]
  404a0a:	f000 8100 	beq.w	404c0e <_malloc_r+0x426>
  404a0e:	4583      	cmp	fp, r0
  404a10:	f200 80fa 	bhi.w	404c08 <_malloc_r+0x420>
  404a14:	f8df c110 	ldr.w	ip, [pc, #272]	; 404b28 <_malloc_r+0x340>
  404a18:	f8dc 3000 	ldr.w	r3, [ip]
  404a1c:	45c3      	cmp	fp, r8
  404a1e:	4453      	add	r3, sl
  404a20:	f8cc 3000 	str.w	r3, [ip]
  404a24:	f000 814a 	beq.w	404cbc <_malloc_r+0x4d4>
  404a28:	6812      	ldr	r2, [r2, #0]
  404a2a:	493c      	ldr	r1, [pc, #240]	; (404b1c <_malloc_r+0x334>)
  404a2c:	3201      	adds	r2, #1
  404a2e:	bf1b      	ittet	ne
  404a30:	ebcb 0b08 	rsbne	fp, fp, r8
  404a34:	445b      	addne	r3, fp
  404a36:	f8c1 8000 	streq.w	r8, [r1]
  404a3a:	f8cc 3000 	strne.w	r3, [ip]
  404a3e:	f018 0307 	ands.w	r3, r8, #7
  404a42:	f000 8113 	beq.w	404c6c <_malloc_r+0x484>
  404a46:	f1c3 0208 	rsb	r2, r3, #8
  404a4a:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
  404a4e:	4490      	add	r8, r2
  404a50:	3308      	adds	r3, #8
  404a52:	44c2      	add	sl, r8
  404a54:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
  404a58:	ebca 0a03 	rsb	sl, sl, r3
  404a5c:	4651      	mov	r1, sl
  404a5e:	4630      	mov	r0, r6
  404a60:	f8cd c004 	str.w	ip, [sp, #4]
  404a64:	f000 fa44 	bl	404ef0 <_sbrk_r>
  404a68:	1c43      	adds	r3, r0, #1
  404a6a:	f8dd c004 	ldr.w	ip, [sp, #4]
  404a6e:	f000 8135 	beq.w	404cdc <_malloc_r+0x4f4>
  404a72:	ebc8 0200 	rsb	r2, r8, r0
  404a76:	4452      	add	r2, sl
  404a78:	f042 0201 	orr.w	r2, r2, #1
  404a7c:	f8dc 3000 	ldr.w	r3, [ip]
  404a80:	f8c7 8008 	str.w	r8, [r7, #8]
  404a84:	4453      	add	r3, sl
  404a86:	42bc      	cmp	r4, r7
  404a88:	f8c8 2004 	str.w	r2, [r8, #4]
  404a8c:	f8cc 3000 	str.w	r3, [ip]
  404a90:	f8df a094 	ldr.w	sl, [pc, #148]	; 404b28 <_malloc_r+0x340>
  404a94:	d015      	beq.n	404ac2 <_malloc_r+0x2da>
  404a96:	f1b9 0f0f 	cmp.w	r9, #15
  404a9a:	f240 80ea 	bls.w	404c72 <_malloc_r+0x48a>
  404a9e:	6861      	ldr	r1, [r4, #4]
  404aa0:	f1a9 020c 	sub.w	r2, r9, #12
  404aa4:	f022 0207 	bic.w	r2, r2, #7
  404aa8:	f001 0e01 	and.w	lr, r1, #1
  404aac:	18a1      	adds	r1, r4, r2
  404aae:	2005      	movs	r0, #5
  404ab0:	ea42 0e0e 	orr.w	lr, r2, lr
  404ab4:	2a0f      	cmp	r2, #15
  404ab6:	f8c4 e004 	str.w	lr, [r4, #4]
  404aba:	6048      	str	r0, [r1, #4]
  404abc:	6088      	str	r0, [r1, #8]
  404abe:	f200 8111 	bhi.w	404ce4 <_malloc_r+0x4fc>
  404ac2:	4a17      	ldr	r2, [pc, #92]	; (404b20 <_malloc_r+0x338>)
  404ac4:	68bc      	ldr	r4, [r7, #8]
  404ac6:	6811      	ldr	r1, [r2, #0]
  404ac8:	428b      	cmp	r3, r1
  404aca:	bf88      	it	hi
  404acc:	6013      	strhi	r3, [r2, #0]
  404ace:	4a15      	ldr	r2, [pc, #84]	; (404b24 <_malloc_r+0x33c>)
  404ad0:	6811      	ldr	r1, [r2, #0]
  404ad2:	428b      	cmp	r3, r1
  404ad4:	bf88      	it	hi
  404ad6:	6013      	strhi	r3, [r2, #0]
  404ad8:	6862      	ldr	r2, [r4, #4]
  404ada:	f022 0203 	bic.w	r2, r2, #3
  404ade:	4295      	cmp	r5, r2
  404ae0:	ebc5 0302 	rsb	r3, r5, r2
  404ae4:	d801      	bhi.n	404aea <_malloc_r+0x302>
  404ae6:	2b0f      	cmp	r3, #15
  404ae8:	dc04      	bgt.n	404af4 <_malloc_r+0x30c>
  404aea:	4630      	mov	r0, r6
  404aec:	f000 f9fe 	bl	404eec <__malloc_unlock>
  404af0:	2400      	movs	r4, #0
  404af2:	e6a5      	b.n	404840 <_malloc_r+0x58>
  404af4:	1962      	adds	r2, r4, r5
  404af6:	f043 0301 	orr.w	r3, r3, #1
  404afa:	f045 0501 	orr.w	r5, r5, #1
  404afe:	6065      	str	r5, [r4, #4]
  404b00:	4630      	mov	r0, r6
  404b02:	60ba      	str	r2, [r7, #8]
  404b04:	6053      	str	r3, [r2, #4]
  404b06:	f000 f9f1 	bl	404eec <__malloc_unlock>
  404b0a:	3408      	adds	r4, #8
  404b0c:	4620      	mov	r0, r4
  404b0e:	b003      	add	sp, #12
  404b10:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404b14:	2000061c 	.word	0x2000061c
  404b18:	2000100c 	.word	0x2000100c
  404b1c:	20000a28 	.word	0x20000a28
  404b20:	20001008 	.word	0x20001008
  404b24:	20001004 	.word	0x20001004
  404b28:	20001010 	.word	0x20001010
  404b2c:	f1bc 0f14 	cmp.w	ip, #20
  404b30:	d961      	bls.n	404bf6 <_malloc_r+0x40e>
  404b32:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
  404b36:	f200 808f 	bhi.w	404c58 <_malloc_r+0x470>
  404b3a:	ea4f 3c15 	mov.w	ip, r5, lsr #12
  404b3e:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
  404b42:	ea4f 014c 	mov.w	r1, ip, lsl #1
  404b46:	e697      	b.n	404878 <_malloc_r+0x90>
  404b48:	0a4b      	lsrs	r3, r1, #9
  404b4a:	2b04      	cmp	r3, #4
  404b4c:	d958      	bls.n	404c00 <_malloc_r+0x418>
  404b4e:	2b14      	cmp	r3, #20
  404b50:	f200 80ae 	bhi.w	404cb0 <_malloc_r+0x4c8>
  404b54:	f103 025b 	add.w	r2, r3, #91	; 0x5b
  404b58:	0050      	lsls	r0, r2, #1
  404b5a:	eb07 0080 	add.w	r0, r7, r0, lsl #2
  404b5e:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 404d1c <_malloc_r+0x534>
  404b62:	6883      	ldr	r3, [r0, #8]
  404b64:	4283      	cmp	r3, r0
  404b66:	f000 808a 	beq.w	404c7e <_malloc_r+0x496>
  404b6a:	685a      	ldr	r2, [r3, #4]
  404b6c:	f022 0203 	bic.w	r2, r2, #3
  404b70:	4291      	cmp	r1, r2
  404b72:	d202      	bcs.n	404b7a <_malloc_r+0x392>
  404b74:	689b      	ldr	r3, [r3, #8]
  404b76:	4298      	cmp	r0, r3
  404b78:	d1f7      	bne.n	404b6a <_malloc_r+0x382>
  404b7a:	68d9      	ldr	r1, [r3, #12]
  404b7c:	687a      	ldr	r2, [r7, #4]
  404b7e:	60e1      	str	r1, [r4, #12]
  404b80:	60a3      	str	r3, [r4, #8]
  404b82:	608c      	str	r4, [r1, #8]
  404b84:	60dc      	str	r4, [r3, #12]
  404b86:	e6b7      	b.n	4048f8 <_malloc_r+0x110>
  404b88:	1961      	adds	r1, r4, r5
  404b8a:	f042 0701 	orr.w	r7, r2, #1
  404b8e:	f045 0501 	orr.w	r5, r5, #1
  404b92:	6065      	str	r5, [r4, #4]
  404b94:	4630      	mov	r0, r6
  404b96:	6159      	str	r1, [r3, #20]
  404b98:	6119      	str	r1, [r3, #16]
  404b9a:	f8c1 e00c 	str.w	lr, [r1, #12]
  404b9e:	f8c1 e008 	str.w	lr, [r1, #8]
  404ba2:	604f      	str	r7, [r1, #4]
  404ba4:	508a      	str	r2, [r1, r2]
  404ba6:	3408      	adds	r4, #8
  404ba8:	f000 f9a0 	bl	404eec <__malloc_unlock>
  404bac:	e648      	b.n	404840 <_malloc_r+0x58>
  404bae:	685a      	ldr	r2, [r3, #4]
  404bb0:	e6a2      	b.n	4048f8 <_malloc_r+0x110>
  404bb2:	f109 0901 	add.w	r9, r9, #1
  404bb6:	f019 0f03 	tst.w	r9, #3
  404bba:	f104 0408 	add.w	r4, r4, #8
  404bbe:	f47f aeae 	bne.w	40491e <_malloc_r+0x136>
  404bc2:	e02d      	b.n	404c20 <_malloc_r+0x438>
  404bc4:	f104 0308 	add.w	r3, r4, #8
  404bc8:	6964      	ldr	r4, [r4, #20]
  404bca:	42a3      	cmp	r3, r4
  404bcc:	bf08      	it	eq
  404bce:	f10c 0c02 	addeq.w	ip, ip, #2
  404bd2:	f43f ae67 	beq.w	4048a4 <_malloc_r+0xbc>
  404bd6:	e623      	b.n	404820 <_malloc_r+0x38>
  404bd8:	4419      	add	r1, r3
  404bda:	461c      	mov	r4, r3
  404bdc:	6848      	ldr	r0, [r1, #4]
  404bde:	68db      	ldr	r3, [r3, #12]
  404be0:	f854 2f08 	ldr.w	r2, [r4, #8]!
  404be4:	f040 0501 	orr.w	r5, r0, #1
  404be8:	604d      	str	r5, [r1, #4]
  404bea:	4630      	mov	r0, r6
  404bec:	60d3      	str	r3, [r2, #12]
  404bee:	609a      	str	r2, [r3, #8]
  404bf0:	f000 f97c 	bl	404eec <__malloc_unlock>
  404bf4:	e624      	b.n	404840 <_malloc_r+0x58>
  404bf6:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
  404bfa:	ea4f 014c 	mov.w	r1, ip, lsl #1
  404bfe:	e63b      	b.n	404878 <_malloc_r+0x90>
  404c00:	098a      	lsrs	r2, r1, #6
  404c02:	3238      	adds	r2, #56	; 0x38
  404c04:	0050      	lsls	r0, r2, #1
  404c06:	e7a8      	b.n	404b5a <_malloc_r+0x372>
  404c08:	42bc      	cmp	r4, r7
  404c0a:	f43f af03 	beq.w	404a14 <_malloc_r+0x22c>
  404c0e:	68bc      	ldr	r4, [r7, #8]
  404c10:	6862      	ldr	r2, [r4, #4]
  404c12:	f022 0203 	bic.w	r2, r2, #3
  404c16:	e762      	b.n	404ade <_malloc_r+0x2f6>
  404c18:	f8d8 8000 	ldr.w	r8, [r8]
  404c1c:	4598      	cmp	r8, r3
  404c1e:	d17b      	bne.n	404d18 <_malloc_r+0x530>
  404c20:	f01c 0f03 	tst.w	ip, #3
  404c24:	f1a8 0308 	sub.w	r3, r8, #8
  404c28:	f10c 3cff 	add.w	ip, ip, #4294967295
  404c2c:	d1f4      	bne.n	404c18 <_malloc_r+0x430>
  404c2e:	687b      	ldr	r3, [r7, #4]
  404c30:	ea23 0300 	bic.w	r3, r3, r0
  404c34:	607b      	str	r3, [r7, #4]
  404c36:	0040      	lsls	r0, r0, #1
  404c38:	4298      	cmp	r0, r3
  404c3a:	f63f aebf 	bhi.w	4049bc <_malloc_r+0x1d4>
  404c3e:	2800      	cmp	r0, #0
  404c40:	f43f aebc 	beq.w	4049bc <_malloc_r+0x1d4>
  404c44:	4203      	tst	r3, r0
  404c46:	46cc      	mov	ip, r9
  404c48:	f47f ae65 	bne.w	404916 <_malloc_r+0x12e>
  404c4c:	0040      	lsls	r0, r0, #1
  404c4e:	4203      	tst	r3, r0
  404c50:	f10c 0c04 	add.w	ip, ip, #4
  404c54:	d0fa      	beq.n	404c4c <_malloc_r+0x464>
  404c56:	e65e      	b.n	404916 <_malloc_r+0x12e>
  404c58:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
  404c5c:	d81a      	bhi.n	404c94 <_malloc_r+0x4ac>
  404c5e:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
  404c62:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
  404c66:	ea4f 014c 	mov.w	r1, ip, lsl #1
  404c6a:	e605      	b.n	404878 <_malloc_r+0x90>
  404c6c:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  404c70:	e6ef      	b.n	404a52 <_malloc_r+0x26a>
  404c72:	2301      	movs	r3, #1
  404c74:	f8c8 3004 	str.w	r3, [r8, #4]
  404c78:	4644      	mov	r4, r8
  404c7a:	2200      	movs	r2, #0
  404c7c:	e72f      	b.n	404ade <_malloc_r+0x2f6>
  404c7e:	1091      	asrs	r1, r2, #2
  404c80:	2001      	movs	r0, #1
  404c82:	f8d8 2004 	ldr.w	r2, [r8, #4]
  404c86:	fa00 f101 	lsl.w	r1, r0, r1
  404c8a:	430a      	orrs	r2, r1
  404c8c:	f8c8 2004 	str.w	r2, [r8, #4]
  404c90:	4619      	mov	r1, r3
  404c92:	e774      	b.n	404b7e <_malloc_r+0x396>
  404c94:	f240 5354 	movw	r3, #1364	; 0x554
  404c98:	459c      	cmp	ip, r3
  404c9a:	d81b      	bhi.n	404cd4 <_malloc_r+0x4ec>
  404c9c:	ea4f 4c95 	mov.w	ip, r5, lsr #18
  404ca0:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
  404ca4:	ea4f 014c 	mov.w	r1, ip, lsl #1
  404ca8:	e5e6      	b.n	404878 <_malloc_r+0x90>
  404caa:	f10a 0a10 	add.w	sl, sl, #16
  404cae:	e6a3      	b.n	4049f8 <_malloc_r+0x210>
  404cb0:	2b54      	cmp	r3, #84	; 0x54
  404cb2:	d81f      	bhi.n	404cf4 <_malloc_r+0x50c>
  404cb4:	0b0a      	lsrs	r2, r1, #12
  404cb6:	326e      	adds	r2, #110	; 0x6e
  404cb8:	0050      	lsls	r0, r2, #1
  404cba:	e74e      	b.n	404b5a <_malloc_r+0x372>
  404cbc:	f3cb 010b 	ubfx	r1, fp, #0, #12
  404cc0:	2900      	cmp	r1, #0
  404cc2:	f47f aeb1 	bne.w	404a28 <_malloc_r+0x240>
  404cc6:	eb0a 0109 	add.w	r1, sl, r9
  404cca:	68ba      	ldr	r2, [r7, #8]
  404ccc:	f041 0101 	orr.w	r1, r1, #1
  404cd0:	6051      	str	r1, [r2, #4]
  404cd2:	e6f6      	b.n	404ac2 <_malloc_r+0x2da>
  404cd4:	21fc      	movs	r1, #252	; 0xfc
  404cd6:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
  404cda:	e5cd      	b.n	404878 <_malloc_r+0x90>
  404cdc:	2201      	movs	r2, #1
  404cde:	f04f 0a00 	mov.w	sl, #0
  404ce2:	e6cb      	b.n	404a7c <_malloc_r+0x294>
  404ce4:	f104 0108 	add.w	r1, r4, #8
  404ce8:	4630      	mov	r0, r6
  404cea:	f000 f9b9 	bl	405060 <_free_r>
  404cee:	f8da 3000 	ldr.w	r3, [sl]
  404cf2:	e6e6      	b.n	404ac2 <_malloc_r+0x2da>
  404cf4:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  404cf8:	d803      	bhi.n	404d02 <_malloc_r+0x51a>
  404cfa:	0bca      	lsrs	r2, r1, #15
  404cfc:	3277      	adds	r2, #119	; 0x77
  404cfe:	0050      	lsls	r0, r2, #1
  404d00:	e72b      	b.n	404b5a <_malloc_r+0x372>
  404d02:	f240 5254 	movw	r2, #1364	; 0x554
  404d06:	4293      	cmp	r3, r2
  404d08:	d803      	bhi.n	404d12 <_malloc_r+0x52a>
  404d0a:	0c8a      	lsrs	r2, r1, #18
  404d0c:	327c      	adds	r2, #124	; 0x7c
  404d0e:	0050      	lsls	r0, r2, #1
  404d10:	e723      	b.n	404b5a <_malloc_r+0x372>
  404d12:	20fc      	movs	r0, #252	; 0xfc
  404d14:	227e      	movs	r2, #126	; 0x7e
  404d16:	e720      	b.n	404b5a <_malloc_r+0x372>
  404d18:	687b      	ldr	r3, [r7, #4]
  404d1a:	e78c      	b.n	404c36 <_malloc_r+0x44e>
  404d1c:	2000061c 	.word	0x2000061c

00404d20 <memcpy>:
  404d20:	4684      	mov	ip, r0
  404d22:	ea41 0300 	orr.w	r3, r1, r0
  404d26:	f013 0303 	ands.w	r3, r3, #3
  404d2a:	d16d      	bne.n	404e08 <memcpy+0xe8>
  404d2c:	3a40      	subs	r2, #64	; 0x40
  404d2e:	d341      	bcc.n	404db4 <memcpy+0x94>
  404d30:	f851 3b04 	ldr.w	r3, [r1], #4
  404d34:	f840 3b04 	str.w	r3, [r0], #4
  404d38:	f851 3b04 	ldr.w	r3, [r1], #4
  404d3c:	f840 3b04 	str.w	r3, [r0], #4
  404d40:	f851 3b04 	ldr.w	r3, [r1], #4
  404d44:	f840 3b04 	str.w	r3, [r0], #4
  404d48:	f851 3b04 	ldr.w	r3, [r1], #4
  404d4c:	f840 3b04 	str.w	r3, [r0], #4
  404d50:	f851 3b04 	ldr.w	r3, [r1], #4
  404d54:	f840 3b04 	str.w	r3, [r0], #4
  404d58:	f851 3b04 	ldr.w	r3, [r1], #4
  404d5c:	f840 3b04 	str.w	r3, [r0], #4
  404d60:	f851 3b04 	ldr.w	r3, [r1], #4
  404d64:	f840 3b04 	str.w	r3, [r0], #4
  404d68:	f851 3b04 	ldr.w	r3, [r1], #4
  404d6c:	f840 3b04 	str.w	r3, [r0], #4
  404d70:	f851 3b04 	ldr.w	r3, [r1], #4
  404d74:	f840 3b04 	str.w	r3, [r0], #4
  404d78:	f851 3b04 	ldr.w	r3, [r1], #4
  404d7c:	f840 3b04 	str.w	r3, [r0], #4
  404d80:	f851 3b04 	ldr.w	r3, [r1], #4
  404d84:	f840 3b04 	str.w	r3, [r0], #4
  404d88:	f851 3b04 	ldr.w	r3, [r1], #4
  404d8c:	f840 3b04 	str.w	r3, [r0], #4
  404d90:	f851 3b04 	ldr.w	r3, [r1], #4
  404d94:	f840 3b04 	str.w	r3, [r0], #4
  404d98:	f851 3b04 	ldr.w	r3, [r1], #4
  404d9c:	f840 3b04 	str.w	r3, [r0], #4
  404da0:	f851 3b04 	ldr.w	r3, [r1], #4
  404da4:	f840 3b04 	str.w	r3, [r0], #4
  404da8:	f851 3b04 	ldr.w	r3, [r1], #4
  404dac:	f840 3b04 	str.w	r3, [r0], #4
  404db0:	3a40      	subs	r2, #64	; 0x40
  404db2:	d2bd      	bcs.n	404d30 <memcpy+0x10>
  404db4:	3230      	adds	r2, #48	; 0x30
  404db6:	d311      	bcc.n	404ddc <memcpy+0xbc>
  404db8:	f851 3b04 	ldr.w	r3, [r1], #4
  404dbc:	f840 3b04 	str.w	r3, [r0], #4
  404dc0:	f851 3b04 	ldr.w	r3, [r1], #4
  404dc4:	f840 3b04 	str.w	r3, [r0], #4
  404dc8:	f851 3b04 	ldr.w	r3, [r1], #4
  404dcc:	f840 3b04 	str.w	r3, [r0], #4
  404dd0:	f851 3b04 	ldr.w	r3, [r1], #4
  404dd4:	f840 3b04 	str.w	r3, [r0], #4
  404dd8:	3a10      	subs	r2, #16
  404dda:	d2ed      	bcs.n	404db8 <memcpy+0x98>
  404ddc:	320c      	adds	r2, #12
  404dde:	d305      	bcc.n	404dec <memcpy+0xcc>
  404de0:	f851 3b04 	ldr.w	r3, [r1], #4
  404de4:	f840 3b04 	str.w	r3, [r0], #4
  404de8:	3a04      	subs	r2, #4
  404dea:	d2f9      	bcs.n	404de0 <memcpy+0xc0>
  404dec:	3204      	adds	r2, #4
  404dee:	d008      	beq.n	404e02 <memcpy+0xe2>
  404df0:	07d2      	lsls	r2, r2, #31
  404df2:	bf1c      	itt	ne
  404df4:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404df8:	f800 3b01 	strbne.w	r3, [r0], #1
  404dfc:	d301      	bcc.n	404e02 <memcpy+0xe2>
  404dfe:	880b      	ldrh	r3, [r1, #0]
  404e00:	8003      	strh	r3, [r0, #0]
  404e02:	4660      	mov	r0, ip
  404e04:	4770      	bx	lr
  404e06:	bf00      	nop
  404e08:	2a08      	cmp	r2, #8
  404e0a:	d313      	bcc.n	404e34 <memcpy+0x114>
  404e0c:	078b      	lsls	r3, r1, #30
  404e0e:	d08d      	beq.n	404d2c <memcpy+0xc>
  404e10:	f010 0303 	ands.w	r3, r0, #3
  404e14:	d08a      	beq.n	404d2c <memcpy+0xc>
  404e16:	f1c3 0304 	rsb	r3, r3, #4
  404e1a:	1ad2      	subs	r2, r2, r3
  404e1c:	07db      	lsls	r3, r3, #31
  404e1e:	bf1c      	itt	ne
  404e20:	f811 3b01 	ldrbne.w	r3, [r1], #1
  404e24:	f800 3b01 	strbne.w	r3, [r0], #1
  404e28:	d380      	bcc.n	404d2c <memcpy+0xc>
  404e2a:	f831 3b02 	ldrh.w	r3, [r1], #2
  404e2e:	f820 3b02 	strh.w	r3, [r0], #2
  404e32:	e77b      	b.n	404d2c <memcpy+0xc>
  404e34:	3a04      	subs	r2, #4
  404e36:	d3d9      	bcc.n	404dec <memcpy+0xcc>
  404e38:	3a01      	subs	r2, #1
  404e3a:	f811 3b01 	ldrb.w	r3, [r1], #1
  404e3e:	f800 3b01 	strb.w	r3, [r0], #1
  404e42:	d2f9      	bcs.n	404e38 <memcpy+0x118>
  404e44:	780b      	ldrb	r3, [r1, #0]
  404e46:	7003      	strb	r3, [r0, #0]
  404e48:	784b      	ldrb	r3, [r1, #1]
  404e4a:	7043      	strb	r3, [r0, #1]
  404e4c:	788b      	ldrb	r3, [r1, #2]
  404e4e:	7083      	strb	r3, [r0, #2]
  404e50:	4660      	mov	r0, ip
  404e52:	4770      	bx	lr

00404e54 <memset>:
  404e54:	b4f0      	push	{r4, r5, r6, r7}
  404e56:	0784      	lsls	r4, r0, #30
  404e58:	d043      	beq.n	404ee2 <memset+0x8e>
  404e5a:	1e54      	subs	r4, r2, #1
  404e5c:	2a00      	cmp	r2, #0
  404e5e:	d03e      	beq.n	404ede <memset+0x8a>
  404e60:	b2cd      	uxtb	r5, r1
  404e62:	4603      	mov	r3, r0
  404e64:	e003      	b.n	404e6e <memset+0x1a>
  404e66:	1e62      	subs	r2, r4, #1
  404e68:	2c00      	cmp	r4, #0
  404e6a:	d038      	beq.n	404ede <memset+0x8a>
  404e6c:	4614      	mov	r4, r2
  404e6e:	f803 5b01 	strb.w	r5, [r3], #1
  404e72:	079a      	lsls	r2, r3, #30
  404e74:	d1f7      	bne.n	404e66 <memset+0x12>
  404e76:	2c03      	cmp	r4, #3
  404e78:	d92a      	bls.n	404ed0 <memset+0x7c>
  404e7a:	b2cd      	uxtb	r5, r1
  404e7c:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  404e80:	2c0f      	cmp	r4, #15
  404e82:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  404e86:	d915      	bls.n	404eb4 <memset+0x60>
  404e88:	f1a4 0710 	sub.w	r7, r4, #16
  404e8c:	093f      	lsrs	r7, r7, #4
  404e8e:	f103 0610 	add.w	r6, r3, #16
  404e92:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  404e96:	461a      	mov	r2, r3
  404e98:	6015      	str	r5, [r2, #0]
  404e9a:	6055      	str	r5, [r2, #4]
  404e9c:	6095      	str	r5, [r2, #8]
  404e9e:	60d5      	str	r5, [r2, #12]
  404ea0:	3210      	adds	r2, #16
  404ea2:	42b2      	cmp	r2, r6
  404ea4:	d1f8      	bne.n	404e98 <memset+0x44>
  404ea6:	f004 040f 	and.w	r4, r4, #15
  404eaa:	3701      	adds	r7, #1
  404eac:	2c03      	cmp	r4, #3
  404eae:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  404eb2:	d90d      	bls.n	404ed0 <memset+0x7c>
  404eb4:	461e      	mov	r6, r3
  404eb6:	4622      	mov	r2, r4
  404eb8:	3a04      	subs	r2, #4
  404eba:	2a03      	cmp	r2, #3
  404ebc:	f846 5b04 	str.w	r5, [r6], #4
  404ec0:	d8fa      	bhi.n	404eb8 <memset+0x64>
  404ec2:	1f22      	subs	r2, r4, #4
  404ec4:	f022 0203 	bic.w	r2, r2, #3
  404ec8:	3204      	adds	r2, #4
  404eca:	4413      	add	r3, r2
  404ecc:	f004 0403 	and.w	r4, r4, #3
  404ed0:	b12c      	cbz	r4, 404ede <memset+0x8a>
  404ed2:	b2c9      	uxtb	r1, r1
  404ed4:	441c      	add	r4, r3
  404ed6:	f803 1b01 	strb.w	r1, [r3], #1
  404eda:	42a3      	cmp	r3, r4
  404edc:	d1fb      	bne.n	404ed6 <memset+0x82>
  404ede:	bcf0      	pop	{r4, r5, r6, r7}
  404ee0:	4770      	bx	lr
  404ee2:	4614      	mov	r4, r2
  404ee4:	4603      	mov	r3, r0
  404ee6:	e7c6      	b.n	404e76 <memset+0x22>

00404ee8 <__malloc_lock>:
  404ee8:	4770      	bx	lr
  404eea:	bf00      	nop

00404eec <__malloc_unlock>:
  404eec:	4770      	bx	lr
  404eee:	bf00      	nop

00404ef0 <_sbrk_r>:
  404ef0:	b538      	push	{r3, r4, r5, lr}
  404ef2:	4c07      	ldr	r4, [pc, #28]	; (404f10 <_sbrk_r+0x20>)
  404ef4:	2300      	movs	r3, #0
  404ef6:	4605      	mov	r5, r0
  404ef8:	4608      	mov	r0, r1
  404efa:	6023      	str	r3, [r4, #0]
  404efc:	f7ff fc00 	bl	404700 <_sbrk>
  404f00:	1c43      	adds	r3, r0, #1
  404f02:	d000      	beq.n	404f06 <_sbrk_r+0x16>
  404f04:	bd38      	pop	{r3, r4, r5, pc}
  404f06:	6823      	ldr	r3, [r4, #0]
  404f08:	2b00      	cmp	r3, #0
  404f0a:	d0fb      	beq.n	404f04 <_sbrk_r+0x14>
  404f0c:	602b      	str	r3, [r5, #0]
  404f0e:	bd38      	pop	{r3, r4, r5, pc}
  404f10:	200024c8 	.word	0x200024c8

00404f14 <strlen>:
  404f14:	f020 0103 	bic.w	r1, r0, #3
  404f18:	f010 0003 	ands.w	r0, r0, #3
  404f1c:	f1c0 0000 	rsb	r0, r0, #0
  404f20:	f851 3b04 	ldr.w	r3, [r1], #4
  404f24:	f100 0c04 	add.w	ip, r0, #4
  404f28:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  404f2c:	f06f 0200 	mvn.w	r2, #0
  404f30:	bf1c      	itt	ne
  404f32:	fa22 f20c 	lsrne.w	r2, r2, ip
  404f36:	4313      	orrne	r3, r2
  404f38:	f04f 0c01 	mov.w	ip, #1
  404f3c:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  404f40:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  404f44:	eba3 020c 	sub.w	r2, r3, ip
  404f48:	ea22 0203 	bic.w	r2, r2, r3
  404f4c:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  404f50:	bf04      	itt	eq
  404f52:	f851 3b04 	ldreq.w	r3, [r1], #4
  404f56:	3004      	addeq	r0, #4
  404f58:	d0f4      	beq.n	404f44 <strlen+0x30>
  404f5a:	f013 0fff 	tst.w	r3, #255	; 0xff
  404f5e:	bf1f      	itttt	ne
  404f60:	3001      	addne	r0, #1
  404f62:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
  404f66:	3001      	addne	r0, #1
  404f68:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
  404f6c:	bf18      	it	ne
  404f6e:	3001      	addne	r0, #1
  404f70:	4770      	bx	lr
  404f72:	bf00      	nop

00404f74 <register_fini>:
  404f74:	4b02      	ldr	r3, [pc, #8]	; (404f80 <register_fini+0xc>)
  404f76:	b113      	cbz	r3, 404f7e <register_fini+0xa>
  404f78:	4802      	ldr	r0, [pc, #8]	; (404f84 <register_fini+0x10>)
  404f7a:	f000 b805 	b.w	404f88 <atexit>
  404f7e:	4770      	bx	lr
  404f80:	00000000 	.word	0x00000000
  404f84:	00404f95 	.word	0x00404f95

00404f88 <atexit>:
  404f88:	4601      	mov	r1, r0
  404f8a:	2000      	movs	r0, #0
  404f8c:	4602      	mov	r2, r0
  404f8e:	4603      	mov	r3, r0
  404f90:	f000 b934 	b.w	4051fc <__register_exitproc>

00404f94 <__libc_fini_array>:
  404f94:	b538      	push	{r3, r4, r5, lr}
  404f96:	4d09      	ldr	r5, [pc, #36]	; (404fbc <__libc_fini_array+0x28>)
  404f98:	4c09      	ldr	r4, [pc, #36]	; (404fc0 <__libc_fini_array+0x2c>)
  404f9a:	1b64      	subs	r4, r4, r5
  404f9c:	10a4      	asrs	r4, r4, #2
  404f9e:	bf18      	it	ne
  404fa0:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  404fa4:	d005      	beq.n	404fb2 <__libc_fini_array+0x1e>
  404fa6:	3c01      	subs	r4, #1
  404fa8:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  404fac:	4798      	blx	r3
  404fae:	2c00      	cmp	r4, #0
  404fb0:	d1f9      	bne.n	404fa6 <__libc_fini_array+0x12>
  404fb2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  404fb6:	f000 bcd7 	b.w	405968 <_fini>
  404fba:	bf00      	nop
  404fbc:	00405974 	.word	0x00405974
  404fc0:	00405978 	.word	0x00405978

00404fc4 <_malloc_trim_r>:
  404fc4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  404fc6:	4d23      	ldr	r5, [pc, #140]	; (405054 <_malloc_trim_r+0x90>)
  404fc8:	460f      	mov	r7, r1
  404fca:	4604      	mov	r4, r0
  404fcc:	f7ff ff8c 	bl	404ee8 <__malloc_lock>
  404fd0:	68ab      	ldr	r3, [r5, #8]
  404fd2:	685e      	ldr	r6, [r3, #4]
  404fd4:	f026 0603 	bic.w	r6, r6, #3
  404fd8:	1bf1      	subs	r1, r6, r7
  404fda:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  404fde:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  404fe2:	f021 010f 	bic.w	r1, r1, #15
  404fe6:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
  404fea:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
  404fee:	db07      	blt.n	405000 <_malloc_trim_r+0x3c>
  404ff0:	4620      	mov	r0, r4
  404ff2:	2100      	movs	r1, #0
  404ff4:	f7ff ff7c 	bl	404ef0 <_sbrk_r>
  404ff8:	68ab      	ldr	r3, [r5, #8]
  404ffa:	4433      	add	r3, r6
  404ffc:	4298      	cmp	r0, r3
  404ffe:	d004      	beq.n	40500a <_malloc_trim_r+0x46>
  405000:	4620      	mov	r0, r4
  405002:	f7ff ff73 	bl	404eec <__malloc_unlock>
  405006:	2000      	movs	r0, #0
  405008:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40500a:	4620      	mov	r0, r4
  40500c:	4279      	negs	r1, r7
  40500e:	f7ff ff6f 	bl	404ef0 <_sbrk_r>
  405012:	3001      	adds	r0, #1
  405014:	d00d      	beq.n	405032 <_malloc_trim_r+0x6e>
  405016:	4b10      	ldr	r3, [pc, #64]	; (405058 <_malloc_trim_r+0x94>)
  405018:	68aa      	ldr	r2, [r5, #8]
  40501a:	6819      	ldr	r1, [r3, #0]
  40501c:	1bf6      	subs	r6, r6, r7
  40501e:	f046 0601 	orr.w	r6, r6, #1
  405022:	4620      	mov	r0, r4
  405024:	1bc9      	subs	r1, r1, r7
  405026:	6056      	str	r6, [r2, #4]
  405028:	6019      	str	r1, [r3, #0]
  40502a:	f7ff ff5f 	bl	404eec <__malloc_unlock>
  40502e:	2001      	movs	r0, #1
  405030:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  405032:	4620      	mov	r0, r4
  405034:	2100      	movs	r1, #0
  405036:	f7ff ff5b 	bl	404ef0 <_sbrk_r>
  40503a:	68ab      	ldr	r3, [r5, #8]
  40503c:	1ac2      	subs	r2, r0, r3
  40503e:	2a0f      	cmp	r2, #15
  405040:	ddde      	ble.n	405000 <_malloc_trim_r+0x3c>
  405042:	4d06      	ldr	r5, [pc, #24]	; (40505c <_malloc_trim_r+0x98>)
  405044:	4904      	ldr	r1, [pc, #16]	; (405058 <_malloc_trim_r+0x94>)
  405046:	682d      	ldr	r5, [r5, #0]
  405048:	f042 0201 	orr.w	r2, r2, #1
  40504c:	1b40      	subs	r0, r0, r5
  40504e:	605a      	str	r2, [r3, #4]
  405050:	6008      	str	r0, [r1, #0]
  405052:	e7d5      	b.n	405000 <_malloc_trim_r+0x3c>
  405054:	2000061c 	.word	0x2000061c
  405058:	20001010 	.word	0x20001010
  40505c:	20000a28 	.word	0x20000a28

00405060 <_free_r>:
  405060:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  405064:	460d      	mov	r5, r1
  405066:	4606      	mov	r6, r0
  405068:	2900      	cmp	r1, #0
  40506a:	d055      	beq.n	405118 <_free_r+0xb8>
  40506c:	f7ff ff3c 	bl	404ee8 <__malloc_lock>
  405070:	f855 1c04 	ldr.w	r1, [r5, #-4]
  405074:	f8df c174 	ldr.w	ip, [pc, #372]	; 4051ec <_free_r+0x18c>
  405078:	f021 0301 	bic.w	r3, r1, #1
  40507c:	f1a5 0408 	sub.w	r4, r5, #8
  405080:	18e2      	adds	r2, r4, r3
  405082:	f8dc 0008 	ldr.w	r0, [ip, #8]
  405086:	6857      	ldr	r7, [r2, #4]
  405088:	4290      	cmp	r0, r2
  40508a:	f027 0703 	bic.w	r7, r7, #3
  40508e:	d069      	beq.n	405164 <_free_r+0x104>
  405090:	f011 0101 	ands.w	r1, r1, #1
  405094:	6057      	str	r7, [r2, #4]
  405096:	d032      	beq.n	4050fe <_free_r+0x9e>
  405098:	2100      	movs	r1, #0
  40509a:	19d0      	adds	r0, r2, r7
  40509c:	6840      	ldr	r0, [r0, #4]
  40509e:	07c0      	lsls	r0, r0, #31
  4050a0:	d406      	bmi.n	4050b0 <_free_r+0x50>
  4050a2:	443b      	add	r3, r7
  4050a4:	6890      	ldr	r0, [r2, #8]
  4050a6:	2900      	cmp	r1, #0
  4050a8:	d04e      	beq.n	405148 <_free_r+0xe8>
  4050aa:	68d2      	ldr	r2, [r2, #12]
  4050ac:	60c2      	str	r2, [r0, #12]
  4050ae:	6090      	str	r0, [r2, #8]
  4050b0:	f043 0201 	orr.w	r2, r3, #1
  4050b4:	6062      	str	r2, [r4, #4]
  4050b6:	50e3      	str	r3, [r4, r3]
  4050b8:	b9e1      	cbnz	r1, 4050f4 <_free_r+0x94>
  4050ba:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  4050be:	d32d      	bcc.n	40511c <_free_r+0xbc>
  4050c0:	0a5a      	lsrs	r2, r3, #9
  4050c2:	2a04      	cmp	r2, #4
  4050c4:	d86a      	bhi.n	40519c <_free_r+0x13c>
  4050c6:	0998      	lsrs	r0, r3, #6
  4050c8:	3038      	adds	r0, #56	; 0x38
  4050ca:	0041      	lsls	r1, r0, #1
  4050cc:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
  4050d0:	4946      	ldr	r1, [pc, #280]	; (4051ec <_free_r+0x18c>)
  4050d2:	f8dc 2008 	ldr.w	r2, [ip, #8]
  4050d6:	4562      	cmp	r2, ip
  4050d8:	d066      	beq.n	4051a8 <_free_r+0x148>
  4050da:	6851      	ldr	r1, [r2, #4]
  4050dc:	f021 0103 	bic.w	r1, r1, #3
  4050e0:	428b      	cmp	r3, r1
  4050e2:	d202      	bcs.n	4050ea <_free_r+0x8a>
  4050e4:	6892      	ldr	r2, [r2, #8]
  4050e6:	4594      	cmp	ip, r2
  4050e8:	d1f7      	bne.n	4050da <_free_r+0x7a>
  4050ea:	68d3      	ldr	r3, [r2, #12]
  4050ec:	60e3      	str	r3, [r4, #12]
  4050ee:	60a2      	str	r2, [r4, #8]
  4050f0:	609c      	str	r4, [r3, #8]
  4050f2:	60d4      	str	r4, [r2, #12]
  4050f4:	4630      	mov	r0, r6
  4050f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4050fa:	f7ff bef7 	b.w	404eec <__malloc_unlock>
  4050fe:	f855 5c08 	ldr.w	r5, [r5, #-8]
  405102:	1b64      	subs	r4, r4, r5
  405104:	f10c 0808 	add.w	r8, ip, #8
  405108:	68a0      	ldr	r0, [r4, #8]
  40510a:	4540      	cmp	r0, r8
  40510c:	442b      	add	r3, r5
  40510e:	d043      	beq.n	405198 <_free_r+0x138>
  405110:	68e5      	ldr	r5, [r4, #12]
  405112:	60c5      	str	r5, [r0, #12]
  405114:	60a8      	str	r0, [r5, #8]
  405116:	e7c0      	b.n	40509a <_free_r+0x3a>
  405118:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40511c:	08db      	lsrs	r3, r3, #3
  40511e:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
  405122:	2501      	movs	r5, #1
  405124:	f8dc 0004 	ldr.w	r0, [ip, #4]
  405128:	6891      	ldr	r1, [r2, #8]
  40512a:	60a1      	str	r1, [r4, #8]
  40512c:	109b      	asrs	r3, r3, #2
  40512e:	fa05 f303 	lsl.w	r3, r5, r3
  405132:	4318      	orrs	r0, r3
  405134:	60e2      	str	r2, [r4, #12]
  405136:	f8cc 0004 	str.w	r0, [ip, #4]
  40513a:	6094      	str	r4, [r2, #8]
  40513c:	4630      	mov	r0, r6
  40513e:	60cc      	str	r4, [r1, #12]
  405140:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  405144:	f7ff bed2 	b.w	404eec <__malloc_unlock>
  405148:	4d29      	ldr	r5, [pc, #164]	; (4051f0 <_free_r+0x190>)
  40514a:	42a8      	cmp	r0, r5
  40514c:	d1ad      	bne.n	4050aa <_free_r+0x4a>
  40514e:	f043 0201 	orr.w	r2, r3, #1
  405152:	f8cc 4014 	str.w	r4, [ip, #20]
  405156:	f8cc 4010 	str.w	r4, [ip, #16]
  40515a:	60e0      	str	r0, [r4, #12]
  40515c:	60a0      	str	r0, [r4, #8]
  40515e:	6062      	str	r2, [r4, #4]
  405160:	50e3      	str	r3, [r4, r3]
  405162:	e7c7      	b.n	4050f4 <_free_r+0x94>
  405164:	441f      	add	r7, r3
  405166:	07cb      	lsls	r3, r1, #31
  405168:	d407      	bmi.n	40517a <_free_r+0x11a>
  40516a:	f855 3c08 	ldr.w	r3, [r5, #-8]
  40516e:	1ae4      	subs	r4, r4, r3
  405170:	441f      	add	r7, r3
  405172:	68a2      	ldr	r2, [r4, #8]
  405174:	68e3      	ldr	r3, [r4, #12]
  405176:	60d3      	str	r3, [r2, #12]
  405178:	609a      	str	r2, [r3, #8]
  40517a:	4b1e      	ldr	r3, [pc, #120]	; (4051f4 <_free_r+0x194>)
  40517c:	681b      	ldr	r3, [r3, #0]
  40517e:	f047 0201 	orr.w	r2, r7, #1
  405182:	429f      	cmp	r7, r3
  405184:	6062      	str	r2, [r4, #4]
  405186:	f8cc 4008 	str.w	r4, [ip, #8]
  40518a:	d3b3      	bcc.n	4050f4 <_free_r+0x94>
  40518c:	4b1a      	ldr	r3, [pc, #104]	; (4051f8 <_free_r+0x198>)
  40518e:	4630      	mov	r0, r6
  405190:	6819      	ldr	r1, [r3, #0]
  405192:	f7ff ff17 	bl	404fc4 <_malloc_trim_r>
  405196:	e7ad      	b.n	4050f4 <_free_r+0x94>
  405198:	2101      	movs	r1, #1
  40519a:	e77e      	b.n	40509a <_free_r+0x3a>
  40519c:	2a14      	cmp	r2, #20
  40519e:	d80c      	bhi.n	4051ba <_free_r+0x15a>
  4051a0:	f102 005b 	add.w	r0, r2, #91	; 0x5b
  4051a4:	0041      	lsls	r1, r0, #1
  4051a6:	e791      	b.n	4050cc <_free_r+0x6c>
  4051a8:	684b      	ldr	r3, [r1, #4]
  4051aa:	1080      	asrs	r0, r0, #2
  4051ac:	2501      	movs	r5, #1
  4051ae:	fa05 f000 	lsl.w	r0, r5, r0
  4051b2:	4303      	orrs	r3, r0
  4051b4:	604b      	str	r3, [r1, #4]
  4051b6:	4613      	mov	r3, r2
  4051b8:	e798      	b.n	4050ec <_free_r+0x8c>
  4051ba:	2a54      	cmp	r2, #84	; 0x54
  4051bc:	d803      	bhi.n	4051c6 <_free_r+0x166>
  4051be:	0b18      	lsrs	r0, r3, #12
  4051c0:	306e      	adds	r0, #110	; 0x6e
  4051c2:	0041      	lsls	r1, r0, #1
  4051c4:	e782      	b.n	4050cc <_free_r+0x6c>
  4051c6:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  4051ca:	d803      	bhi.n	4051d4 <_free_r+0x174>
  4051cc:	0bd8      	lsrs	r0, r3, #15
  4051ce:	3077      	adds	r0, #119	; 0x77
  4051d0:	0041      	lsls	r1, r0, #1
  4051d2:	e77b      	b.n	4050cc <_free_r+0x6c>
  4051d4:	f240 5154 	movw	r1, #1364	; 0x554
  4051d8:	428a      	cmp	r2, r1
  4051da:	d803      	bhi.n	4051e4 <_free_r+0x184>
  4051dc:	0c98      	lsrs	r0, r3, #18
  4051de:	307c      	adds	r0, #124	; 0x7c
  4051e0:	0041      	lsls	r1, r0, #1
  4051e2:	e773      	b.n	4050cc <_free_r+0x6c>
  4051e4:	21fc      	movs	r1, #252	; 0xfc
  4051e6:	207e      	movs	r0, #126	; 0x7e
  4051e8:	e770      	b.n	4050cc <_free_r+0x6c>
  4051ea:	bf00      	nop
  4051ec:	2000061c 	.word	0x2000061c
  4051f0:	20000624 	.word	0x20000624
  4051f4:	20000a24 	.word	0x20000a24
  4051f8:	2000100c 	.word	0x2000100c

004051fc <__register_exitproc>:
  4051fc:	b5f0      	push	{r4, r5, r6, r7, lr}
  4051fe:	4c27      	ldr	r4, [pc, #156]	; (40529c <__register_exitproc+0xa0>)
  405200:	6826      	ldr	r6, [r4, #0]
  405202:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  405206:	b085      	sub	sp, #20
  405208:	4607      	mov	r7, r0
  40520a:	2c00      	cmp	r4, #0
  40520c:	d041      	beq.n	405292 <__register_exitproc+0x96>
  40520e:	6865      	ldr	r5, [r4, #4]
  405210:	2d1f      	cmp	r5, #31
  405212:	dd1e      	ble.n	405252 <__register_exitproc+0x56>
  405214:	4822      	ldr	r0, [pc, #136]	; (4052a0 <__register_exitproc+0xa4>)
  405216:	b918      	cbnz	r0, 405220 <__register_exitproc+0x24>
  405218:	f04f 30ff 	mov.w	r0, #4294967295
  40521c:	b005      	add	sp, #20
  40521e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  405220:	f44f 70c8 	mov.w	r0, #400	; 0x190
  405224:	9103      	str	r1, [sp, #12]
  405226:	9202      	str	r2, [sp, #8]
  405228:	9301      	str	r3, [sp, #4]
  40522a:	f7ff fad5 	bl	4047d8 <malloc>
  40522e:	9903      	ldr	r1, [sp, #12]
  405230:	9a02      	ldr	r2, [sp, #8]
  405232:	9b01      	ldr	r3, [sp, #4]
  405234:	4604      	mov	r4, r0
  405236:	2800      	cmp	r0, #0
  405238:	d0ee      	beq.n	405218 <__register_exitproc+0x1c>
  40523a:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  40523e:	6025      	str	r5, [r4, #0]
  405240:	2000      	movs	r0, #0
  405242:	6060      	str	r0, [r4, #4]
  405244:	4605      	mov	r5, r0
  405246:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  40524a:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  40524e:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  405252:	b93f      	cbnz	r7, 405264 <__register_exitproc+0x68>
  405254:	1cab      	adds	r3, r5, #2
  405256:	2000      	movs	r0, #0
  405258:	3501      	adds	r5, #1
  40525a:	6065      	str	r5, [r4, #4]
  40525c:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  405260:	b005      	add	sp, #20
  405262:	bdf0      	pop	{r4, r5, r6, r7, pc}
  405264:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  405268:	f04f 0c01 	mov.w	ip, #1
  40526c:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  405270:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  405274:	fa0c f205 	lsl.w	r2, ip, r5
  405278:	4316      	orrs	r6, r2
  40527a:	2f02      	cmp	r7, #2
  40527c:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  405280:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  405284:	d1e6      	bne.n	405254 <__register_exitproc+0x58>
  405286:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  40528a:	431a      	orrs	r2, r3
  40528c:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  405290:	e7e0      	b.n	405254 <__register_exitproc+0x58>
  405292:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  405296:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  40529a:	e7b8      	b.n	40520e <__register_exitproc+0x12>
  40529c:	00405950 	.word	0x00405950
  4052a0:	004047d9 	.word	0x004047d9
  4052a4:	69663a30 	.word	0x69663a30
  4052a8:	61776d72 	.word	0x61776d72
  4052ac:	622e6572 	.word	0x622e6572
  4052b0:	00006e69 	.word	0x00006e69

004052b4 <sd_trans_multipliers>:
  4052b4:	00000000 0000000a 0000000c 0000000d     ................
  4052c4:	0000000f 00000014 00000019 0000001e     ................
  4052d4:	00000023 00000028 0000002d 00000032     #...(...-...2...
  4052e4:	00000037 0000003c 00000046 00000050     7...<...F...P...

004052f4 <sd_mmc_trans_units>:
  4052f4:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00405310 <mmc_trans_multipliers>:
  405310:	00000000 0000000a 0000000c 0000000d     ................
  405320:	0000000f 00000014 0000001a 0000001e     ................
  405330:	00000023 00000028 0000002d 00000034     #...(...-...4...
  405340:	00000037 0000003c 00000046 00000050     7...<...F...P...

00405350 <lun_desc>:
  405350:	0040123d 0040127d 0040129d 004012b5     =.@.}.@...@...@.
  405360:	004012d5 00401319 0040137d 00405390     ..@...@.}.@..S@.
  405370:	0040124d 0040128d 004012a9 004012c5     M.@...@...@...@.
  405380:	004012d9 0040132d 00401391 004053a8     ..@.-.@...@..S@.
  405390:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  4053a0:	22302074 00000000 2f445322 20434d4d     t 0"...."SD/MMC 
  4053b0:	64726143 6f6c5320 22312074 00000000     Card Slot 1"....

004053c0 <excvt.4554>:
  4053c0:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  4053d0:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  4053e0:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  4053f0:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  405400:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  405410:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  405420:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  405430:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
  405440:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
  405450:	00005d5b                                []..

00405454 <LfnOfs>:
  405454:	07050301 12100e09 1c181614 0000001e     ................

00405464 <tbl_lower.4258>:
  405464:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  405474:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  405484:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  405494:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  4054a4:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  4054b4:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  4054c4:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  4054d4:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  4054e4:	01050103 01090107 010d010b 0111010f     ................
  4054f4:	01150113 01190117 011d011b 0121011f     ..............!.
  405504:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  405514:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  405524:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  405534:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  405544:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  405554:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  405564:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  405574:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  405584:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  405594:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  4055a4:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  4055b4:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  4055c4:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  4055d4:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  4055e4:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  4055f4:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  405604:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  405614:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  405624:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  405634:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...

00405644 <Tbl>:
  405644:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  405654:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  405664:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  405674:	00d600ff 00f800dc 00d800a3 019200d7     ................
  405684:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  405694:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  4056a4:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  4056b4:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  4056c4:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  4056d4:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  4056e4:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  4056f4:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  405704:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  405714:	00da00de 00d900db 00dd00fd 00b400af     ................
  405724:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  405734:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00405744 <tbl_upper.4259>:
  405744:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  405754:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  405764:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  405774:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  405784:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  405794:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  4057a4:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  4057b4:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  4057c4:	01040102 01080106 010c010a 0110010e     ................
  4057d4:	01140112 01180116 011c011a 0120011e     .............. .
  4057e4:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  4057f4:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  405804:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  405814:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  405824:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  405834:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  405844:	03940393 03960395 03980397 039a0399     ................
  405854:	039c039b 039e039d 03a0039f 03a303a1     ................
  405864:	03a503a4 03a703a6 03a903a8 041003aa     ................
  405874:	04120411 04140413 04160415 04180417     ................
  405884:	041a0419 041c041b 041e041d 0420041f     .............. .
  405894:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  4058a4:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  4058b4:	04030402 04050404 04070406 04090408     ................
  4058c4:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  4058d4:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  4058e4:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  4058f4:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  405904:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  405914:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...
  405924:	74736552 69747261 7320676e 65747379     Restarting syste
  405934:	2121216d 0000000d                       m!!!....

0040593c <CSWTCH.19>:
  40593c:	00000070 00000050 00000030 00000010     p...P...0.......
  40594c:	00000043                                C...

00405950 <_global_impure_ptr>:
  405950:	200001f0                                ... 

00405954 <_init>:
  405954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  405956:	bf00      	nop
  405958:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40595a:	bc08      	pop	{r3}
  40595c:	469e      	mov	lr, r3
  40595e:	4770      	bx	lr

00405960 <__init_array_start>:
  405960:	00404f75 	.word	0x00404f75

00405964 <__frame_dummy_init_array_entry>:
  405964:	004000f1                                ..@.

00405968 <_fini>:
  405968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  40596a:	bf00      	nop
  40596c:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40596e:	bc08      	pop	{r3}
  405970:	469e      	mov	lr, r3
  405972:	4770      	bx	lr

00405974 <__fini_array_start>:
  405974:	004000cd 	.word	0x004000cd

Disassembly of section .relocate:

20000000 <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
20000000:	b470      	push	{r4, r5, r6}
20000002:	b083      	sub	sp, #12
20000004:	9e06      	ldr	r6, [sp, #24]
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
20000006:	b343      	cbz	r3, 2000005a <efc_perform_read_sequence+0x5a>
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000008:	6804      	ldr	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
2000000a:	b2c9      	uxtb	r1, r1
2000000c:	f041 41b4 	orr.w	r1, r1, #1509949440	; 0x5a000000

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000010:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
20000014:	6004      	str	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
20000016:	6041      	str	r1, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000018:	6881      	ldr	r1, [r0, #8]
2000001a:	9101      	str	r1, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
2000001c:	9901      	ldr	r1, [sp, #4]
2000001e:	f011 0101 	ands.w	r1, r1, #1
20000022:	d1f9      	bne.n	20000018 <efc_perform_read_sequence+0x18>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000024:	b146      	cbz	r6, 20000038 <efc_perform_read_sequence+0x38>
20000026:	4c0f      	ldr	r4, [pc, #60]	; (20000064 <efc_perform_read_sequence+0x64>)
20000028:	eb03 0686 	add.w	r6, r3, r6, lsl #2
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
2000002c:	f854 5f04 	ldr.w	r5, [r4, #4]!
20000030:	f843 5b04 	str.w	r5, [r3], #4
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000034:	42b3      	cmp	r3, r6
20000036:	d1f9      	bne.n	2000002c <efc_perform_read_sequence+0x2c>

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000038:	b2d2      	uxtb	r2, r2
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000003a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
2000003e:	6042      	str	r2, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	6883      	ldr	r3, [r0, #8]
20000042:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000044:	9b01      	ldr	r3, [sp, #4]
20000046:	07db      	lsls	r3, r3, #31
20000048:	d5fa      	bpl.n	20000040 <efc_perform_read_sequence+0x40>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
2000004a:	6803      	ldr	r3, [r0, #0]
2000004c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20000050:	6003      	str	r3, [r0, #0]

	return EFC_RC_OK;
}
20000052:	4608      	mov	r0, r1
20000054:	b003      	add	sp, #12
20000056:	bc70      	pop	{r4, r5, r6}
20000058:	4770      	bx	lr
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
2000005a:	2102      	movs	r1, #2
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);

	p_efc->EEFC_FMR &= ~(0x1u << 16);

	return EFC_RC_OK;
}
2000005c:	4608      	mov	r0, r1
2000005e:	b003      	add	sp, #12
20000060:	bc70      	pop	{r4, r5, r6}
20000062:	4770      	bx	lr
20000064:	003ffffc 	.word	0x003ffffc

20000068 <efc_write_fmr>:
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
20000068:	6001      	str	r1, [r0, #0]
2000006a:	4770      	bx	lr

2000006c <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
2000006c:	b082      	sub	sp, #8
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
2000006e:	6041      	str	r1, [r0, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
20000070:	6883      	ldr	r3, [r0, #8]
20000072:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000074:	9b01      	ldr	r3, [sp, #4]
20000076:	07db      	lsls	r3, r3, #31
20000078:	d5fa      	bpl.n	20000070 <efc_perform_fcr+0x4>

	return (ul_status & EEFC_ERROR_FLAGS);
2000007a:	9801      	ldr	r0, [sp, #4]
}
2000007c:	f000 000e 	and.w	r0, r0, #14
20000080:	b002      	add	sp, #8
20000082:	4770      	bx	lr

20000084 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000084:	f3bf 8f5f 	dmb	sy
20000088:	3801      	subs	r0, #1
2000008a:	d1fb      	bne.n	20000084 <portable_delay_cycles>
2000008c:	4770      	bx	lr
2000008e:	bf00      	nop

20000090 <sd_mmc_cards>:
	...
20000098:	002b 0000 0000 0000 0000 0000 0000 0000     +...............
	...

200000b4 <uxPreviousTask>:
200000b4:	00ff 0000                                   ....

200000b8 <xNextTaskUnblockTime>:
200000b8:	ffff ffff                                   ....

200000bc <uart0Config>:
200000bc:	0600 400e c200 0001 00c0 0000 0800 0000     ...@............
	...

200000d4 <gpioConfig>:
200000d4:	0000 0000 0001 0001 3a19 0040 0101 0000     .........:@.....
200000e4:	0001 0000 0001 0001 39d9 0040 0101 0000     .........9@.....
200000f4:	0014 0000 0001 0001 3995 0040 0101 0000     .........9@.....
20000104:	0010 0000 0001 0001 3951 0040 0101 0000     ........Q9@.....
20000114:	000f 0000 0001 0001 390d 0040 0101 0000     .........9@.....
20000124:	0018 0000 0001 0001 38c9 0040 0101 0000     .........8@.....
20000134:	0019 0000 0001 0001 3885 0040 0101 0000     .........8@.....
20000144:	0013 0000 0100 0004 0000 0000 0000 0000     ................
20000154:	0017 0000 0100 0004 0000 0000 0000 0000     ................
20000164:	002a 0000 0100 0004 0000 0000 0100 0000     *...............
20000174:	0011 0000 0100 0004 0000 0000 0100 0000     ................
20000184:	0012 0000 0100 0004 0000 0000 0100 0000     ................
20000194:	002d 0000 0100 0004 0000 0000 0000 0000     -...............
200001a4:	0020 0000 0100 0004 0000 0000 0000 0000      ...............
200001b4:	0021 0000 0100 0004 0000 0000 0000 0000     !...............
200001c4:	000b 0000 0001 0001 3841 0040 0101 0000     ........A8@.....
200001d4:	002b 0000 0001 0001 37fd 0040 0101 0000     +........7@.....

200001e4 <g_interrupt_enabled>:
200001e4:	0001 0000                                   ....

200001e8 <SystemCoreClock>:
200001e8:	0900 003d 0000 0000                         ..=.....

200001f0 <impure_data>:
200001f0:	0000 0000 04dc 2000 0544 2000 05ac 2000     ....... D.. ... 
	...
20000224:	594c 0040 0000 0000 0000 0000 0000 0000     LY@.............
	...
20000298:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
200002a8:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000618 <_impure_ptr>:
20000618:	01f0 2000                                   ... 

2000061c <__malloc_av_>:
	...
20000624:	061c 2000 061c 2000 0624 2000 0624 2000     ... ... $.. $.. 
20000634:	062c 2000 062c 2000 0634 2000 0634 2000     ,.. ,.. 4.. 4.. 
20000644:	063c 2000 063c 2000 0644 2000 0644 2000     <.. <.. D.. D.. 
20000654:	064c 2000 064c 2000 0654 2000 0654 2000     L.. L.. T.. T.. 
20000664:	065c 2000 065c 2000 0664 2000 0664 2000     \.. \.. d.. d.. 
20000674:	066c 2000 066c 2000 0674 2000 0674 2000     l.. l.. t.. t.. 
20000684:	067c 2000 067c 2000 0684 2000 0684 2000     |.. |.. ... ... 
20000694:	068c 2000 068c 2000 0694 2000 0694 2000     ... ... ... ... 
200006a4:	069c 2000 069c 2000 06a4 2000 06a4 2000     ... ... ... ... 
200006b4:	06ac 2000 06ac 2000 06b4 2000 06b4 2000     ... ... ... ... 
200006c4:	06bc 2000 06bc 2000 06c4 2000 06c4 2000     ... ... ... ... 
200006d4:	06cc 2000 06cc 2000 06d4 2000 06d4 2000     ... ... ... ... 
200006e4:	06dc 2000 06dc 2000 06e4 2000 06e4 2000     ... ... ... ... 
200006f4:	06ec 2000 06ec 2000 06f4 2000 06f4 2000     ... ... ... ... 
20000704:	06fc 2000 06fc 2000 0704 2000 0704 2000     ... ... ... ... 
20000714:	070c 2000 070c 2000 0714 2000 0714 2000     ... ... ... ... 
20000724:	071c 2000 071c 2000 0724 2000 0724 2000     ... ... $.. $.. 
20000734:	072c 2000 072c 2000 0734 2000 0734 2000     ,.. ,.. 4.. 4.. 
20000744:	073c 2000 073c 2000 0744 2000 0744 2000     <.. <.. D.. D.. 
20000754:	074c 2000 074c 2000 0754 2000 0754 2000     L.. L.. T.. T.. 
20000764:	075c 2000 075c 2000 0764 2000 0764 2000     \.. \.. d.. d.. 
20000774:	076c 2000 076c 2000 0774 2000 0774 2000     l.. l.. t.. t.. 
20000784:	077c 2000 077c 2000 0784 2000 0784 2000     |.. |.. ... ... 
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 

20000a24 <__malloc_trim_threshold>:
20000a24:	0000 0002                                   ....

20000a28 <__malloc_sbrk_base>:
20000a28:	ffff ffff                                   ....
