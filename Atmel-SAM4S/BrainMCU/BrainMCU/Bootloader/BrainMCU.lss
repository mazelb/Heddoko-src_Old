
BrainMCU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006dd8  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00406dd8  00406dd8  0000edd8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000a8c  20000000  00406de0  00010000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000192c  20000a8c  0040786c  00010a8c  2**2
                  ALLOC
  4 .stack        00003000  200023b8  00409198  00010a8c  2**0
                  ALLOC
  5 .ARM.attributes 0000002a  00000000  00000000  00010a8c  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00010ab6  2**0
                  CONTENTS, READONLY
  7 .debug_info   00026845  00000000  00000000  00010b11  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00005e66  00000000  00000000  00037356  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0001461a  00000000  00000000  0003d1bc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001580  00000000  00000000  000517d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000027c0  00000000  00000000  00052d56  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000f731  00000000  00000000  00055516  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00020c6e  00000000  00000000  00064c47  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005c195  00000000  00000000  000858b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  000038b4  00000000  00000000  000e1a4c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	200053b8 	.word	0x200053b8
  400004:	00405371 	.word	0x00405371
  400008:	0040536d 	.word	0x0040536d
  40000c:	0040557d 	.word	0x0040557d
  400010:	00405581 	.word	0x00405581
  400014:	00405585 	.word	0x00405585
  400018:	00405589 	.word	0x00405589
	...
  40002c:	00403b89 	.word	0x00403b89
  400030:	0040536d 	.word	0x0040536d
  400034:	00000000 	.word	0x00000000
  400038:	00403be9 	.word	0x00403be9
  40003c:	0040558d 	.word	0x0040558d
  400040:	0040536d 	.word	0x0040536d
  400044:	0040536d 	.word	0x0040536d
  400048:	0040536d 	.word	0x0040536d
  40004c:	0040536d 	.word	0x0040536d
  400050:	00404569 	.word	0x00404569
  400054:	0040536d 	.word	0x0040536d
  400058:	0040536d 	.word	0x0040536d
  40005c:	00000000 	.word	0x00000000
  400060:	00404c71 	.word	0x00404c71
  400064:	00404cb9 	.word	0x00404cb9
  400068:	00000000 	.word	0x00000000
  40006c:	00405219 	.word	0x00405219
  400070:	0040522d 	.word	0x0040522d
  400074:	00000000 	.word	0x00000000
  400078:	00404d09 	.word	0x00404d09
  40007c:	00404d59 	.word	0x00404d59
	...
  400088:	0040536d 	.word	0x0040536d
  40008c:	0040536d 	.word	0x0040536d
  400090:	0040536d 	.word	0x0040536d
  400094:	0040536d 	.word	0x0040536d
  400098:	0040536d 	.word	0x0040536d
  40009c:	0040536d 	.word	0x0040536d
  4000a0:	0040536d 	.word	0x0040536d
  4000a4:	0040536d 	.word	0x0040536d
	...
  4000b4:	0040536d 	.word	0x0040536d
  4000b8:	0040536d 	.word	0x0040536d
  4000bc:	0040536d 	.word	0x0040536d
  4000c0:	0040536d 	.word	0x0040536d
  4000c4:	0040536d 	.word	0x0040536d
  4000c8:	0040536d 	.word	0x0040536d

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000a8c 	.word	0x20000a8c
  4000e8:	00000000 	.word	0x00000000
  4000ec:	00406de0 	.word	0x00406de0

004000f0 <frame_dummy>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4b06      	ldr	r3, [pc, #24]	; (40010c <frame_dummy+0x1c>)
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4806      	ldr	r0, [pc, #24]	; (400110 <frame_dummy+0x20>)
  4000f8:	4906      	ldr	r1, [pc, #24]	; (400114 <frame_dummy+0x24>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4806      	ldr	r0, [pc, #24]	; (400118 <frame_dummy+0x28>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b113      	cbz	r3, 40010a <frame_dummy+0x1a>
  400104:	4b05      	ldr	r3, [pc, #20]	; (40011c <frame_dummy+0x2c>)
  400106:	b103      	cbz	r3, 40010a <frame_dummy+0x1a>
  400108:	4798      	blx	r3
  40010a:	bd08      	pop	{r3, pc}
  40010c:	00000000 	.word	0x00000000
  400110:	00406de0 	.word	0x00406de0
  400114:	20000a90 	.word	0x20000a90
  400118:	00406de0 	.word	0x00406de0
  40011c:	00000000 	.word	0x00000000

00400120 <efc_get_wait_state>:
 *
 * \return The number of wait states in cycle (no shift).
 */
uint32_t efc_get_wait_state(Efc *p_efc)
{
	return ((p_efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos);
  400120:	6800      	ldr	r0, [r0, #0]
}
  400122:	f3c0 2003 	ubfx	r0, r0, #8, #4
  400126:	4770      	bx	lr

00400128 <efc_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
  400128:	b508      	push	{r3, lr}
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws) | EEFC_FMR_CLOE);
  40012a:	0212      	lsls	r2, r2, #8
  40012c:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  400130:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400134:	4311      	orrs	r1, r2
  400136:	4b02      	ldr	r3, [pc, #8]	; (400140 <efc_init+0x18>)
  400138:	4798      	blx	r3
#else
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
#endif	
	return EFC_RC_OK;
}
  40013a:	2000      	movs	r0, #0
  40013c:	bd08      	pop	{r3, pc}
  40013e:	bf00      	nop
  400140:	20000069 	.word	0x20000069

00400144 <efc_set_wait_state>:
 *
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
  400144:	b508      	push	{r3, lr}
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  400146:	6802      	ldr	r2, [r0, #0]

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400148:	4b04      	ldr	r3, [pc, #16]	; (40015c <efc_set_wait_state+0x18>)
  40014a:	0209      	lsls	r1, r1, #8
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  40014c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400150:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
  400154:	4311      	orrs	r1, r2
  400156:	4798      	blx	r3
  400158:	bd08      	pop	{r3, pc}
  40015a:	bf00      	nop
  40015c:	20000069 	.word	0x20000069

00400160 <efc_perform_command>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
  400160:	b508      	push	{r3, lr}
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
  400162:	f1a1 030e 	sub.w	r3, r1, #14
  400166:	2b01      	cmp	r3, #1
  400168:	d802      	bhi.n	400170 <efc_perform_command+0x10>
		return EFC_RC_NOT_SUPPORT;
  40016a:	f04f 30ff 	mov.w	r0, #4294967295

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
}
  40016e:	bd08      	pop	{r3, pc}
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
  400170:	0212      	lsls	r2, r2, #8
  400172:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  400176:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  40017a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
  40017e:	b2c9      	uxtb	r1, r1
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
  400180:	4311      	orrs	r1, r2
  400182:	4b01      	ldr	r3, [pc, #4]	; (400188 <efc_perform_command+0x28>)
  400184:	4798      	blx	r3
  400186:	bd08      	pop	{r3, pc}
  400188:	2000006d 	.word	0x2000006d

0040018c <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
  40018c:	b508      	push	{r3, lr}
  40018e:	460a      	mov	r2, r1
	efc_init(EFC, ul_mode, ul_fws);
  400190:	4b02      	ldr	r3, [pc, #8]	; (40019c <flash_init+0x10>)
  400192:	4601      	mov	r1, r0
  400194:	4802      	ldr	r0, [pc, #8]	; (4001a0 <flash_init+0x14>)
  400196:	4798      	blx	r3
#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
#endif

	return FLASH_RC_OK;
}
  400198:	2000      	movs	r0, #0
  40019a:	bd08      	pop	{r3, pc}
  40019c:	00400129 	.word	0x00400129
  4001a0:	400e0a00 	.word	0x400e0a00

004001a4 <flash_erase_page>:
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4001a4:	2903      	cmp	r1, #3
 * \param ul_address Flash bank start address.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
  4001a6:	b508      	push	{r3, lr}
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4001a8:	d901      	bls.n	4001ae <flash_erase_page+0xa>
		return FLASH_RC_INVALID;
  4001aa:	2011      	movs	r0, #17
					(us_page | uc_page_num))) {
		return FLASH_RC_ERROR;
	}

	return FLASH_RC_OK;
}
  4001ac:	bd08      	pop	{r3, pc}

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
		return FLASH_RC_INVALID;
	}

	if (ul_address & (IFLASH_PAGE_SIZE - 1)) {
  4001ae:	f3c0 0308 	ubfx	r3, r0, #0, #9
  4001b2:	2b00      	cmp	r3, #0
  4001b4:	d1f9      	bne.n	4001aa <flash_erase_page+0x6>
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4001b6:	f5a0 0280 	sub.w	r2, r0, #4194304	; 0x400000
  4001ba:	f3c2 224f 	ubfx	r2, r2, #9, #16
		return FLASH_RC_INVALID;
	}

	translate_address(&p_efc, ul_address, &us_page, NULL);

	if (EFC_RC_OK != efc_perform_command(p_efc, EFC_FCMD_EPA,
  4001be:	430a      	orrs	r2, r1
  4001c0:	4b04      	ldr	r3, [pc, #16]	; (4001d4 <flash_erase_page+0x30>)
  4001c2:	4805      	ldr	r0, [pc, #20]	; (4001d8 <flash_erase_page+0x34>)
  4001c4:	2107      	movs	r1, #7
  4001c6:	4798      	blx	r3
					(us_page | uc_page_num))) {
		return FLASH_RC_ERROR;
  4001c8:	2800      	cmp	r0, #0
  4001ca:	bf14      	ite	ne
  4001cc:	2010      	movne	r0, #16
  4001ce:	2000      	moveq	r0, #0
  4001d0:	bd08      	pop	{r3, pc}
  4001d2:	bf00      	nop
  4001d4:	00400161 	.word	0x00400161
  4001d8:	400e0a00 	.word	0x400e0a00

004001dc <flash_write>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4001dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4001e0:	b085      	sub	sp, #20
  4001e2:	4604      	mov	r4, r0
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4001e4:	f5a0 0880 	sub.w	r8, r0, #4194304	; 0x400000
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001e8:	4d32      	ldr	r5, [pc, #200]	; (4002b4 <flash_write+0xd8>)
  4001ea:	4833      	ldr	r0, [pc, #204]	; (4002b8 <flash_write+0xdc>)
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4001ec:	9302      	str	r3, [sp, #8]
  4001ee:	468b      	mov	fp, r1
  4001f0:	4691      	mov	r9, r2
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001f2:	47a8      	blx	r5
	efc_set_wait_state(p_efc, 6);
  4001f4:	2106      	movs	r1, #6
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  4001f6:	9003      	str	r0, [sp, #12]
	efc_set_wait_state(p_efc, 6);
  4001f8:	4b30      	ldr	r3, [pc, #192]	; (4002bc <flash_write+0xe0>)
  4001fa:	482f      	ldr	r0, [pc, #188]	; (4002b8 <flash_write+0xdc>)
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4001fc:	f3c8 284f 	ubfx	r8, r8, #9, #16
	us_offset = (ul_addr - IFLASH_ADDR) % IFLASH_PAGE_SIZE;
  400200:	f3c4 0a08 	ubfx	sl, r4, #0, #9

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);
  400204:	4798      	blx	r3

	/* Write all pages */
	while (ul_size > 0) {
  400206:	f1b9 0f00 	cmp.w	r9, #0
  40020a:	d04a      	beq.n	4002a2 <flash_write+0xc6>
  40020c:	4f2c      	ldr	r7, [pc, #176]	; (4002c0 <flash_write+0xe4>)
  40020e:	4654      	mov	r4, sl
  400210:	463d      	mov	r5, r7
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  400212:	f508 5a00 	add.w	sl, r8, #8192	; 0x2000
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  400216:	f5c4 7300 	rsb	r3, r4, #512	; 0x200
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  40021a:	ea4f 2a4a 	mov.w	sl, sl, lsl #9
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  40021e:	454b      	cmp	r3, r9
  400220:	bf34      	ite	cc
  400222:	461e      	movcc	r6, r3
  400224:	464e      	movcs	r6, r9
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
  400226:	9301      	str	r3, [sp, #4]
  400228:	4651      	mov	r1, sl
  40022a:	4622      	mov	r2, r4
  40022c:	f8df c094 	ldr.w	ip, [pc, #148]	; 4002c4 <flash_write+0xe8>
  400230:	4823      	ldr	r0, [pc, #140]	; (4002c0 <flash_write+0xe4>)
  400232:	47e0      	blx	ip

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);
  400234:	4632      	mov	r2, r6
  400236:	1938      	adds	r0, r7, r4
  400238:	4659      	mov	r1, fp
  40023a:	f8df c088 	ldr.w	ip, [pc, #136]	; 4002c4 <flash_write+0xe8>
  40023e:	47e0      	blx	ip
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  400240:	9b01      	ldr	r3, [sp, #4]

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  400242:	1930      	adds	r0, r6, r4
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  400244:	1b9a      	subs	r2, r3, r6
		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
				(void *)(ul_page_addr + us_offset + writeSize),
  400246:	eb06 010a 	add.w	r1, r6, sl

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  40024a:	4438      	add	r0, r7
  40024c:	4421      	add	r1, r4
  40024e:	4b1d      	ldr	r3, [pc, #116]	; (4002c4 <flash_write+0xe8>)
  400250:	b292      	uxth	r2, r2
  400252:	4798      	blx	r3
  400254:	4b1c      	ldr	r3, [pc, #112]	; (4002c8 <flash_write+0xec>)
  400256:	1d1f      	adds	r7, r3, #4
  400258:	f507 71fe 	add.w	r1, r7, #508	; 0x1fc
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  40025c:	f853 0f04 	ldr.w	r0, [r3, #4]!
  400260:	1b5a      	subs	r2, r3, r5
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  400262:	428b      	cmp	r3, r1
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  400264:	f842 000a 	str.w	r0, [r2, sl]
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  400268:	d1f8      	bne.n	40025c <flash_write+0x80>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  40026a:	9b02      	ldr	r3, [sp, #8]
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  40026c:	4812      	ldr	r0, [pc, #72]	; (4002b8 <flash_write+0xdc>)
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  40026e:	b17b      	cbz	r3, 400290 <flash_write+0xb4>
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  400270:	2103      	movs	r1, #3
  400272:	4642      	mov	r2, r8
  400274:	f8df c054 	ldr.w	ip, [pc, #84]	; 4002cc <flash_write+0xf0>
  400278:	47e0      	blx	ip
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
					us_page);
		}

		if (ul_error) {
  40027a:	b978      	cbnz	r0, 40029c <flash_write+0xc0>
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
  40027c:	f108 0c01 	add.w	ip, r8, #1
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  400280:	ebb9 0906 	subs.w	r9, r9, r6
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
  400284:	fa1f f88c 	uxth.w	r8, ip
		if (ul_error) {
			return ul_error;
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
  400288:	44b3      	add	fp, r6
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  40028a:	d00a      	beq.n	4002a2 <flash_write+0xc6>

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
		ul_size -= writeSize;
		us_page++;
		us_offset = 0;
  40028c:	4604      	mov	r4, r0
  40028e:	e7c0      	b.n	400212 <flash_write+0x36>

		if (ul_erase_flag) {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
					us_page);
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
  400290:	2101      	movs	r1, #1
  400292:	4642      	mov	r2, r8
  400294:	4b0d      	ldr	r3, [pc, #52]	; (4002cc <flash_write+0xf0>)
  400296:	4798      	blx	r3
					us_page);
		}

		if (ul_error) {
  400298:	2800      	cmp	r0, #0
  40029a:	d0ef      	beq.n	40027c <flash_write+0xa0>

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);

	return FLASH_RC_OK;
}
  40029c:	b005      	add	sp, #20
  40029e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		us_page++;
		us_offset = 0;
	}

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);
  4002a2:	9903      	ldr	r1, [sp, #12]
  4002a4:	4804      	ldr	r0, [pc, #16]	; (4002b8 <flash_write+0xdc>)
  4002a6:	f8df c014 	ldr.w	ip, [pc, #20]	; 4002bc <flash_write+0xe0>
  4002aa:	47e0      	blx	ip

	return FLASH_RC_OK;
  4002ac:	2000      	movs	r0, #0
}
  4002ae:	b005      	add	sp, #20
  4002b0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4002b4:	00400121 	.word	0x00400121
  4002b8:	400e0a00 	.word	0x400e0a00
  4002bc:	00400145 	.word	0x00400145
  4002c0:	20000aa8 	.word	0x20000aa8
  4002c4:	0040611d 	.word	0x0040611d
  4002c8:	20000aa4 	.word	0x20000aa4
  4002cc:	00400161 	.word	0x00400161

004002d0 <flash_unlock>:
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002d0:	f421 51ff 	bic.w	r1, r1, #8160	; 0x1fe0
  4002d4:	f021 011f 	bic.w	r1, r1, #31
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_unlock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
  4002d8:	b570      	push	{r4, r5, r6, lr}
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  4002da:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002de:	f501 54ff 	add.w	r4, r1, #8160	; 0x1fe0
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  4002e2:	f020 001f 	bic.w	r0, r0, #31
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  4002e6:	341f      	adds	r4, #31
	uint16_t us_num_pages_in_region =
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual unlock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);
	if (pul_actual_start != NULL) {
  4002e8:	b102      	cbz	r2, 4002ec <flash_unlock+0x1c>
		*pul_actual_start = ul_actual_start;
  4002ea:	6010      	str	r0, [r2, #0]
	}
	if (pul_actual_end != NULL) {
  4002ec:	b103      	cbz	r3, 4002f0 <flash_unlock+0x20>
		*pul_actual_end = ul_actual_end;
  4002ee:	601c      	str	r4, [r3, #0]
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4002f0:	4d0c      	ldr	r5, [pc, #48]	; (400324 <flash_unlock+0x54>)
  4002f2:	f5a0 0480 	sub.w	r4, r0, #4194304	; 0x400000
  4002f6:	0a64      	lsrs	r4, r4, #9
  4002f8:	440d      	add	r5, r1
  4002fa:	b2a4      	uxth	r4, r4
  4002fc:	f3c5 254f 	ubfx	r5, r5, #9, #16
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
  400300:	42ac      	cmp	r4, r5
  400302:	d20c      	bcs.n	40031e <flash_unlock+0x4e>
  400304:	4e08      	ldr	r6, [pc, #32]	; (400328 <flash_unlock+0x58>)
  400306:	e001      	b.n	40030c <flash_unlock+0x3c>
  400308:	42ac      	cmp	r4, r5
  40030a:	d208      	bcs.n	40031e <flash_unlock+0x4e>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
  40030c:	4622      	mov	r2, r4
  40030e:	4807      	ldr	r0, [pc, #28]	; (40032c <flash_unlock+0x5c>)
  400310:	2109      	movs	r1, #9
  400312:	47b0      	blx	r6
				us_start_page);
		if (ul_error) {
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
  400314:	3410      	adds	r4, #16
  400316:	b2a4      	uxth	r4, r4

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
				us_start_page);
		if (ul_error) {
  400318:	2800      	cmp	r0, #0
  40031a:	d0f5      	beq.n	400308 <flash_unlock+0x38>
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
}
  40031c:	bd70      	pop	{r4, r5, r6, pc}
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
  40031e:	2000      	movs	r0, #0
  400320:	bd70      	pop	{r4, r5, r6, pc}
  400322:	bf00      	nop
  400324:	ffc01fff 	.word	0xffc01fff
  400328:	00400161 	.word	0x00400161
  40032c:	400e0a00 	.word	0x400e0a00

00400330 <loadNewFirmware>:
 * loadNewFirmware(char* filename)
 * @brief Load new firmware function. 
 * @return status_t returns STATUS_PASS if successful and STATUS_FAIL if there is a failure. 
 */
status_t __attribute__((optimize("O0"))) loadNewFirmware(char* filename)
{	
  400330:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
  400334:	f5ad 6dd1 	sub.w	sp, sp, #1672	; 0x688
  400338:	af00      	add	r7, sp, #0
  40033a:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40033e:	6018      	str	r0, [r3, #0]
	status_t result = STATUS_PASS;
  400340:	2300      	movs	r3, #0
  400342:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
	FIL firmwareFileObj = {0};
  400346:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40034a:	f44f 720a 	mov.w	r2, #552	; 0x228
  40034e:	4618      	mov	r0, r3
  400350:	2100      	movs	r1, #0
  400352:	4b76      	ldr	r3, [pc, #472]	; (40052c <loadNewFirmware+0x1fc>)
  400354:	4798      	blx	r3
	//initialize the suitNumber

	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  400356:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40035a:	681b      	ldr	r3, [r3, #0]
  40035c:	2230      	movs	r2, #48	; 0x30
  40035e:	701a      	strb	r2, [r3, #0]
	wdt_disable(WDT);
  400360:	4873      	ldr	r0, [pc, #460]	; (400530 <loadNewFirmware+0x200>)
  400362:	4b74      	ldr	r3, [pc, #464]	; (400534 <loadNewFirmware+0x204>)
  400364:	4798      	blx	r3
	
	FRESULT res = f_open(&firmwareFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  400366:	f207 423c 	addw	r2, r7, #1084	; 0x43c
  40036a:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40036e:	4610      	mov	r0, r2
  400370:	6819      	ldr	r1, [r3, #0]
  400372:	2201      	movs	r2, #1
  400374:	4b70      	ldr	r3, [pc, #448]	; (400538 <loadNewFirmware+0x208>)
  400376:	4798      	blx	r3
  400378:	4603      	mov	r3, r0
  40037a:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  40037e:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  400382:	2b00      	cmp	r3, #0
  400384:	d001      	beq.n	40038a <loadNewFirmware+0x5a>
	{
		return STATUS_FAIL;
  400386:	2301      	movs	r3, #1
  400388:	e2d6      	b.n	400938 <loadNewFirmware+0x608>
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
  40038a:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  40038e:	2200      	movs	r2, #0
  400390:	601a      	str	r2, [r3, #0]
  400392:	3304      	adds	r3, #4
  400394:	2200      	movs	r2, #0
  400396:	601a      	str	r2, [r3, #0]
  400398:	3304      	adds	r3, #4
  40039a:	2200      	movs	r2, #0
  40039c:	601a      	str	r2, [r3, #0]
  40039e:	3304      	adds	r3, #4
	uint32_t bytes_read = 0, total_bytes_read = 0;	
  4003a0:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4003a4:	2200      	movs	r2, #0
  4003a6:	601a      	str	r2, [r3, #0]
  4003a8:	2300      	movs	r3, #0
  4003aa:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  4003ae:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4003b2:	f507 6286 	add.w	r2, r7, #1072	; 0x430
  4003b6:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  4003ba:	4618      	mov	r0, r3
  4003bc:	4611      	mov	r1, r2
  4003be:	220c      	movs	r2, #12
  4003c0:	4623      	mov	r3, r4
  4003c2:	4c5e      	ldr	r4, [pc, #376]	; (40053c <loadNewFirmware+0x20c>)
  4003c4:	47a0      	blx	r4
  4003c6:	4603      	mov	r3, r0
  4003c8:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	//confirm that the file has a valid header, with the CRC bytes matching. 
	if(header.fileHeaderBytes != FIRMWARE_FILE_HEADER_BYTES ) //|| header.crc1 != header.crc2
  4003cc:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  4003d0:	681a      	ldr	r2, [r3, #0]
  4003d2:	4b5b      	ldr	r3, [pc, #364]	; (400540 <loadNewFirmware+0x210>)
  4003d4:	429a      	cmp	r2, r3
  4003d6:	d006      	beq.n	4003e6 <loadNewFirmware+0xb6>
	{
		//bad header, don't even try to load this crap!
		f_close(&firmwareFileObj); 
  4003d8:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4003dc:	4618      	mov	r0, r3
  4003de:	4b59      	ldr	r3, [pc, #356]	; (400544 <loadNewFirmware+0x214>)
  4003e0:	4798      	blx	r3
		return STATUS_FAIL; 
  4003e2:	2301      	movs	r3, #1
  4003e4:	e2a8      	b.n	400938 <loadNewFirmware+0x608>
	}	
	uint32_t destAddress = FIRMWARE_TEMPORARY_LOCATION; //that where we are writing
  4003e6:	4b58      	ldr	r3, [pc, #352]	; (400548 <loadNewFirmware+0x218>)
  4003e8:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
	uint32_t retVal = 0;
  4003ec:	2300      	movs	r3, #0
  4003ee:	f8c7 366c 	str.w	r3, [r7, #1644]	; 0x66c
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6); //	| EEFC_FMR_CLOE | EEFC_FMR_SCOD 
  4003f2:	2000      	movs	r0, #0
  4003f4:	2106      	movs	r1, #6
  4003f6:	4b55      	ldr	r3, [pc, #340]	; (40054c <loadNewFirmware+0x21c>)
  4003f8:	4798      	blx	r3
  4003fa:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	int resultTest = 	efc_perform_fcr(EFC0,
  4003fe:	4854      	ldr	r0, [pc, #336]	; (400550 <loadNewFirmware+0x220>)
  400400:	4954      	ldr	r1, [pc, #336]	; (400554 <loadNewFirmware+0x224>)
  400402:	4b55      	ldr	r3, [pc, #340]	; (400558 <loadNewFirmware+0x228>)
  400404:	4798      	blx	r3
  400406:	4603      	mov	r3, r0
  400408:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
	EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0x0123) |
	0x07u);
	
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);			
  40040c:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400410:	68da      	ldr	r2, [r3, #12]
  400412:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  400416:	4413      	add	r3, r2
  400418:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  40041c:	4619      	mov	r1, r3
  40041e:	2200      	movs	r2, #0
  400420:	2300      	movs	r3, #0
  400422:	4c4e      	ldr	r4, [pc, #312]	; (40055c <loadNewFirmware+0x22c>)
  400424:	47a0      	blx	r4
  400426:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
  40042a:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  40042e:	f44f 7200 	mov.w	r2, #512	; 0x200
  400432:	4618      	mov	r0, r3
  400434:	2100      	movs	r1, #0
  400436:	4b3d      	ldr	r3, [pc, #244]	; (40052c <loadNewFirmware+0x1fc>)
  400438:	4798      	blx	r3
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
  40043a:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  40043e:	f44f 7200 	mov.w	r2, #512	; 0x200
  400442:	4618      	mov	r0, r3
  400444:	2100      	movs	r1, #0
  400446:	4b39      	ldr	r3, [pc, #228]	; (40052c <loadNewFirmware+0x1fc>)
  400448:	4798      	blx	r3
		
	uint32_t i = 0, error = 0;
  40044a:	2300      	movs	r3, #0
  40044c:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400450:	2300      	movs	r3, #0
  400452:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  400456:	4b3c      	ldr	r3, [pc, #240]	; (400548 <loadNewFirmware+0x218>)
  400458:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  40045c:	e016      	b.n	40048c <loadNewFirmware+0x15c>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_32);
  40045e:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  400462:	2103      	movs	r1, #3
  400464:	4b3e      	ldr	r3, [pc, #248]	; (400560 <loadNewFirmware+0x230>)
  400466:	4798      	blx	r3
  400468:	4603      	mov	r3, r0
  40046a:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  40046e:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  400472:	2b00      	cmp	r3, #0
  400474:	d004      	beq.n	400480 <loadNewFirmware+0x150>
		{
			error++;
  400476:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  40047a:	3301      	adds	r3, #1
  40047c:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
		
	uint32_t i = 0, error = 0;
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  400480:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400484:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  400488:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  40048c:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400490:	f5b3 0f88 	cmp.w	r3, #4456448	; 0x440000
  400494:	d3e3      	bcc.n	40045e <loadNewFirmware+0x12e>
		if(resultTest != 0)
		{
			error++;
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  400496:	200e      	movs	r0, #14
  400498:	2101      	movs	r1, #1
  40049a:	4b32      	ldr	r3, [pc, #200]	; (400564 <loadNewFirmware+0x234>)
  40049c:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  40049e:	200c      	movs	r0, #12
  4004a0:	2101      	movs	r1, #1
  4004a2:	4b30      	ldr	r3, [pc, #192]	; (400564 <loadNewFirmware+0x234>)
  4004a4:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
  4004a6:	200d      	movs	r0, #13
  4004a8:	2101      	movs	r1, #1
  4004aa:	4b2e      	ldr	r3, [pc, #184]	; (400564 <loadNewFirmware+0x234>)
  4004ac:	4798      	blx	r3
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  4004ae:	e093      	b.n	4005d8 <loadNewFirmware+0x2a8>
	{
		res = f_read(&firmwareFileObj, buf, FIRMWARE_BUFFER_SIZE, &bytes_read);
  4004b0:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4004b4:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  4004b8:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  4004bc:	4618      	mov	r0, r3
  4004be:	4611      	mov	r1, r2
  4004c0:	f44f 7200 	mov.w	r2, #512	; 0x200
  4004c4:	4623      	mov	r3, r4
  4004c6:	4c1d      	ldr	r4, [pc, #116]	; (40053c <loadNewFirmware+0x20c>)
  4004c8:	47a0      	blx	r4
  4004ca:	4603      	mov	r3, r0
  4004cc:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
		if(bytes_read != 0)
  4004d0:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4004d4:	681b      	ldr	r3, [r3, #0]
  4004d6:	2b00      	cmp	r3, #0
  4004d8:	d016      	beq.n	400508 <loadNewFirmware+0x1d8>
		{		
			if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
  4004da:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  4004de:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4004e2:	441a      	add	r2, r3
  4004e4:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4004e8:	681c      	ldr	r4, [r3, #0]
  4004ea:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  4004ee:	4610      	mov	r0, r2
  4004f0:	4619      	mov	r1, r3
  4004f2:	4622      	mov	r2, r4
  4004f4:	2300      	movs	r3, #0
  4004f6:	4c1c      	ldr	r4, [pc, #112]	; (400568 <loadNewFirmware+0x238>)
  4004f8:	47a0      	blx	r4
  4004fa:	4603      	mov	r3, r0
  4004fc:	2b00      	cmp	r3, #0
  4004fe:	d003      	beq.n	400508 <loadNewFirmware+0x1d8>
			{
				result = STATUS_FAIL;
  400500:	2301      	movs	r3, #1
  400502:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  400506:	e075      	b.n	4005f4 <loadNewFirmware+0x2c4>
			}
		}
		total_bytes_read += bytes_read; 
  400508:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  40050c:	681b      	ldr	r3, [r3, #0]
  40050e:	f8d7 2680 	ldr.w	r2, [r7, #1664]	; 0x680
  400512:	4413      	add	r3, r2
  400514:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		if(total_bytes_read ==  firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400518:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40051c:	68db      	ldr	r3, [r3, #12]
  40051e:	f1a3 020c 	sub.w	r2, r3, #12
  400522:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400526:	429a      	cmp	r2, r3
  400528:	d120      	bne.n	40056c <loadNewFirmware+0x23c>
		{
			break; //this is redundant
  40052a:	e063      	b.n	4005f4 <loadNewFirmware+0x2c4>
  40052c:	00406251 	.word	0x00406251
  400530:	400e1450 	.word	0x400e1450
  400534:	00405361 	.word	0x00405361
  400538:	0040353d 	.word	0x0040353d
  40053c:	004037e1 	.word	0x004037e1
  400540:	aa55aa55 	.word	0xaa55aa55
  400544:	00403a49 	.word	0x00403a49
  400548:	00424000 	.word	0x00424000
  40054c:	0040018d 	.word	0x0040018d
  400550:	400e0a00 	.word	0x400e0a00
  400554:	5a012307 	.word	0x5a012307
  400558:	2000006d 	.word	0x2000006d
  40055c:	004002d1 	.word	0x004002d1
  400560:	004001a5 	.word	0x004001a5
  400564:	004049a5 	.word	0x004049a5
  400568:	004001dd 	.word	0x004001dd
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
  40056c:	200c      	movs	r0, #12
  40056e:	4bac      	ldr	r3, [pc, #688]	; (400820 <loadNewFirmware+0x4f0>)
  400570:	4798      	blx	r3
  400572:	4bac      	ldr	r3, [pc, #688]	; (400824 <loadNewFirmware+0x4f4>)
		delay_ms(100);
  400574:	4618      	mov	r0, r3
  400576:	f04f 0100 	mov.w	r1, #0
  40057a:	4602      	mov	r2, r0
  40057c:	460b      	mov	r3, r1
  40057e:	1892      	adds	r2, r2, r2
  400580:	eb43 0303 	adc.w	r3, r3, r3
  400584:	1812      	adds	r2, r2, r0
  400586:	eb43 0301 	adc.w	r3, r3, r1
  40058a:	015c      	lsls	r4, r3, #5
  40058c:	61fc      	str	r4, [r7, #28]
  40058e:	69fd      	ldr	r5, [r7, #28]
  400590:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
  400594:	61fd      	str	r5, [r7, #28]
  400596:	ea4f 1c42 	mov.w	ip, r2, lsl #5
  40059a:	f8c7 c018 	str.w	ip, [r7, #24]
  40059e:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
  4005a2:	1912      	adds	r2, r2, r4
  4005a4:	eb43 0305 	adc.w	r3, r3, r5
  4005a8:	1880      	adds	r0, r0, r2
  4005aa:	eb41 0103 	adc.w	r1, r1, r3
  4005ae:	f243 62af 	movw	r2, #13999	; 0x36af
  4005b2:	f04f 0300 	mov.w	r3, #0
  4005b6:	1812      	adds	r2, r2, r0
  4005b8:	eb43 0301 	adc.w	r3, r3, r1
  4005bc:	4c9a      	ldr	r4, [pc, #616]	; (400828 <loadNewFirmware+0x4f8>)
  4005be:	4610      	mov	r0, r2
  4005c0:	4619      	mov	r1, r3
  4005c2:	f243 62b0 	movw	r2, #14000	; 0x36b0
  4005c6:	f04f 0300 	mov.w	r3, #0
  4005ca:	47a0      	blx	r4
  4005cc:	4602      	mov	r2, r0
  4005ce:	460b      	mov	r3, r1
  4005d0:	4613      	mov	r3, r2
  4005d2:	4618      	mov	r0, r3
  4005d4:	4b95      	ldr	r3, [pc, #596]	; (40082c <loadNewFirmware+0x4fc>)
  4005d6:	4798      	blx	r3
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  4005d8:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4005dc:	68db      	ldr	r3, [r3, #12]
  4005de:	f1a3 020c 	sub.w	r2, r3, #12
  4005e2:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4005e6:	429a      	cmp	r2, r3
  4005e8:	d904      	bls.n	4005f4 <loadNewFirmware+0x2c4>
  4005ea:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  4005ee:	2b00      	cmp	r3, #0
  4005f0:	f43f af5e 	beq.w	4004b0 <loadNewFirmware+0x180>
			break; //this is redundant
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
		delay_ms(100);
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
  4005f4:	200d      	movs	r0, #13
  4005f6:	2100      	movs	r1, #0
  4005f8:	4b8d      	ldr	r3, [pc, #564]	; (400830 <loadNewFirmware+0x500>)
  4005fa:	4798      	blx	r3
  4005fc:	4b89      	ldr	r3, [pc, #548]	; (400824 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  4005fe:	4618      	mov	r0, r3
  400600:	f04f 0100 	mov.w	r1, #0
  400604:	4602      	mov	r2, r0
  400606:	460b      	mov	r3, r1
  400608:	1892      	adds	r2, r2, r2
  40060a:	eb43 0303 	adc.w	r3, r3, r3
  40060e:	1812      	adds	r2, r2, r0
  400610:	eb43 0301 	adc.w	r3, r3, r1
  400614:	015d      	lsls	r5, r3, #5
  400616:	617d      	str	r5, [r7, #20]
  400618:	f8d7 c014 	ldr.w	ip, [r7, #20]
  40061c:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  400620:	f8c7 c014 	str.w	ip, [r7, #20]
  400624:	0154      	lsls	r4, r2, #5
  400626:	613c      	str	r4, [r7, #16]
  400628:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
  40062c:	1912      	adds	r2, r2, r4
  40062e:	eb43 0305 	adc.w	r3, r3, r5
  400632:	1880      	adds	r0, r0, r2
  400634:	eb41 0103 	adc.w	r1, r1, r3
  400638:	f243 62af 	movw	r2, #13999	; 0x36af
  40063c:	f04f 0300 	mov.w	r3, #0
  400640:	1812      	adds	r2, r2, r0
  400642:	eb43 0301 	adc.w	r3, r3, r1
  400646:	4c78      	ldr	r4, [pc, #480]	; (400828 <loadNewFirmware+0x4f8>)
  400648:	4610      	mov	r0, r2
  40064a:	4619      	mov	r1, r3
  40064c:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400650:	f04f 0300 	mov.w	r3, #0
  400654:	47a0      	blx	r4
  400656:	4602      	mov	r2, r0
  400658:	460b      	mov	r3, r1
  40065a:	4613      	mov	r3, r2
  40065c:	4618      	mov	r0, r3
  40065e:	4b73      	ldr	r3, [pc, #460]	; (40082c <loadNewFirmware+0x4fc>)
  400660:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
  400662:	200d      	movs	r0, #13
  400664:	2101      	movs	r1, #1
  400666:	4b72      	ldr	r3, [pc, #456]	; (400830 <loadNewFirmware+0x500>)
  400668:	4798      	blx	r3
  40066a:	4b6e      	ldr	r3, [pc, #440]	; (400824 <loadNewFirmware+0x4f4>)
	delay_ms(100);	
  40066c:	4618      	mov	r0, r3
  40066e:	f04f 0100 	mov.w	r1, #0
  400672:	4602      	mov	r2, r0
  400674:	460b      	mov	r3, r1
  400676:	1892      	adds	r2, r2, r2
  400678:	eb43 0303 	adc.w	r3, r3, r3
  40067c:	1812      	adds	r2, r2, r0
  40067e:	eb43 0301 	adc.w	r3, r3, r1
  400682:	015d      	lsls	r5, r3, #5
  400684:	60fd      	str	r5, [r7, #12]
  400686:	f8d7 c00c 	ldr.w	ip, [r7, #12]
  40068a:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  40068e:	f8c7 c00c 	str.w	ip, [r7, #12]
  400692:	0154      	lsls	r4, r2, #5
  400694:	60bc      	str	r4, [r7, #8]
  400696:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
  40069a:	1912      	adds	r2, r2, r4
  40069c:	eb43 0305 	adc.w	r3, r3, r5
  4006a0:	1880      	adds	r0, r0, r2
  4006a2:	eb41 0103 	adc.w	r1, r1, r3
  4006a6:	f243 62af 	movw	r2, #13999	; 0x36af
  4006aa:	f04f 0300 	mov.w	r3, #0
  4006ae:	1812      	adds	r2, r2, r0
  4006b0:	eb43 0301 	adc.w	r3, r3, r1
  4006b4:	4c5c      	ldr	r4, [pc, #368]	; (400828 <loadNewFirmware+0x4f8>)
  4006b6:	4610      	mov	r0, r2
  4006b8:	4619      	mov	r1, r3
  4006ba:	f243 62b0 	movw	r2, #14000	; 0x36b0
  4006be:	f04f 0300 	mov.w	r3, #0
  4006c2:	47a0      	blx	r4
  4006c4:	4602      	mov	r2, r0
  4006c6:	460b      	mov	r3, r1
  4006c8:	4613      	mov	r3, r2
  4006ca:	4618      	mov	r0, r3
  4006cc:	4b57      	ldr	r3, [pc, #348]	; (40082c <loadNewFirmware+0x4fc>)
  4006ce:	4798      	blx	r3
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  4006d0:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  4006d4:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  4006d8:	e016      	b.n	400708 <loadNewFirmware+0x3d8>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_16);
  4006da:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  4006de:	2102      	movs	r1, #2
  4006e0:	4b54      	ldr	r3, [pc, #336]	; (400834 <loadNewFirmware+0x504>)
  4006e2:	4798      	blx	r3
  4006e4:	4603      	mov	r3, r0
  4006e6:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  4006ea:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  4006ee:	2b00      	cmp	r3, #0
  4006f0:	d004      	beq.n	4006fc <loadNewFirmware+0x3cc>
		{
			error++;
  4006f2:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  4006f6:	3301      	adds	r3, #1
  4006f8:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
	delay_ms(100);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
	delay_ms(100);	
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  4006fc:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400700:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  400704:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400708:	f8d7 267c 	ldr.w	r2, [r7, #1660]	; 0x67c
  40070c:	4b4a      	ldr	r3, [pc, #296]	; (400838 <loadNewFirmware+0x508>)
  40070e:	429a      	cmp	r2, r3
  400710:	d9e3      	bls.n	4006da <loadNewFirmware+0x3aa>
		{
			error++;
		}
	}	
	//verify firmware
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400712:	200c      	movs	r0, #12
  400714:	2101      	movs	r1, #1
  400716:	4b46      	ldr	r3, [pc, #280]	; (400830 <loadNewFirmware+0x500>)
  400718:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW);
  40071a:	200e      	movs	r0, #14
  40071c:	2100      	movs	r1, #0
  40071e:	4b44      	ldr	r3, [pc, #272]	; (400830 <loadNewFirmware+0x500>)
  400720:	4798      	blx	r3
  400722:	4b40      	ldr	r3, [pc, #256]	; (400824 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  400724:	4618      	mov	r0, r3
  400726:	f04f 0100 	mov.w	r1, #0
  40072a:	4602      	mov	r2, r0
  40072c:	460b      	mov	r3, r1
  40072e:	1892      	adds	r2, r2, r2
  400730:	eb43 0303 	adc.w	r3, r3, r3
  400734:	1812      	adds	r2, r2, r0
  400736:	eb43 0301 	adc.w	r3, r3, r1
  40073a:	ea4f 1b43 	mov.w	fp, r3, lsl #5
  40073e:	ea4b 6bd2 	orr.w	fp, fp, r2, lsr #27
  400742:	ea4f 1a42 	mov.w	sl, r2, lsl #5
  400746:	eb12 020a 	adds.w	r2, r2, sl
  40074a:	eb43 030b 	adc.w	r3, r3, fp
  40074e:	1880      	adds	r0, r0, r2
  400750:	eb41 0103 	adc.w	r1, r1, r3
  400754:	f243 62af 	movw	r2, #13999	; 0x36af
  400758:	f04f 0300 	mov.w	r3, #0
  40075c:	1812      	adds	r2, r2, r0
  40075e:	eb43 0301 	adc.w	r3, r3, r1
  400762:	4c31      	ldr	r4, [pc, #196]	; (400828 <loadNewFirmware+0x4f8>)
  400764:	4610      	mov	r0, r2
  400766:	4619      	mov	r1, r3
  400768:	f243 62b0 	movw	r2, #14000	; 0x36b0
  40076c:	f04f 0300 	mov.w	r3, #0
  400770:	47a0      	blx	r4
  400772:	4602      	mov	r2, r0
  400774:	460b      	mov	r3, r1
  400776:	4613      	mov	r3, r2
  400778:	4618      	mov	r0, r3
  40077a:	4b2c      	ldr	r3, [pc, #176]	; (40082c <loadNewFirmware+0x4fc>)
  40077c:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  40077e:	200e      	movs	r0, #14
  400780:	2101      	movs	r1, #1
  400782:	4b2b      	ldr	r3, [pc, #172]	; (400830 <loadNewFirmware+0x500>)
  400784:	4798      	blx	r3
  400786:	4b27      	ldr	r3, [pc, #156]	; (400824 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  400788:	4618      	mov	r0, r3
  40078a:	f04f 0100 	mov.w	r1, #0
  40078e:	4602      	mov	r2, r0
  400790:	460b      	mov	r3, r1
  400792:	1892      	adds	r2, r2, r2
  400794:	eb43 0303 	adc.w	r3, r3, r3
  400798:	1812      	adds	r2, r2, r0
  40079a:	eb43 0301 	adc.w	r3, r3, r1
  40079e:	ea4f 1943 	mov.w	r9, r3, lsl #5
  4007a2:	ea49 69d2 	orr.w	r9, r9, r2, lsr #27
  4007a6:	ea4f 1842 	mov.w	r8, r2, lsl #5
  4007aa:	eb12 0208 	adds.w	r2, r2, r8
  4007ae:	eb43 0309 	adc.w	r3, r3, r9
  4007b2:	1880      	adds	r0, r0, r2
  4007b4:	eb41 0103 	adc.w	r1, r1, r3
  4007b8:	f243 62af 	movw	r2, #13999	; 0x36af
  4007bc:	f04f 0300 	mov.w	r3, #0
  4007c0:	1812      	adds	r2, r2, r0
  4007c2:	eb43 0301 	adc.w	r3, r3, r1
  4007c6:	4c18      	ldr	r4, [pc, #96]	; (400828 <loadNewFirmware+0x4f8>)
  4007c8:	4610      	mov	r0, r2
  4007ca:	4619      	mov	r1, r3
  4007cc:	f243 62b0 	movw	r2, #14000	; 0x36b0
  4007d0:	f04f 0300 	mov.w	r3, #0
  4007d4:	47a0      	blx	r4
  4007d6:	4602      	mov	r2, r0
  4007d8:	460b      	mov	r3, r1
  4007da:	4613      	mov	r3, r2
  4007dc:	4618      	mov	r0, r3
  4007de:	4b13      	ldr	r3, [pc, #76]	; (40082c <loadNewFirmware+0x4fc>)
  4007e0:	4798      	blx	r3
	//TODO fix CRC problem. 
	//uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	//CRCCU_MR_PTYPE_CASTAGNOLI);
	uint32_t ul_crc =0;
  4007e2:	2300      	movs	r3, #0
  4007e4:	f8c7 3664 	str.w	r3, [r7, #1636]	; 0x664
	fileCRC = ul_crc; 
  4007e8:	4b14      	ldr	r3, [pc, #80]	; (40083c <loadNewFirmware+0x50c>)
  4007ea:	f8d7 2664 	ldr.w	r2, [r7, #1636]	; 0x664
  4007ee:	601a      	str	r2, [r3, #0]
	//if(header.crc == fileCRC)
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
  4007f0:	2300      	movs	r3, #0
  4007f2:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		destAddress = APP_START_ADDRESS;
  4007f6:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  4007fa:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
  4007fe:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400802:	68da      	ldr	r2, [r3, #12]
  400804:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  400808:	4413      	add	r3, r2
  40080a:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  40080e:	4619      	mov	r1, r3
  400810:	2200      	movs	r2, #0
  400812:	2300      	movs	r3, #0
  400814:	4c0a      	ldr	r4, [pc, #40]	; (400840 <loadNewFirmware+0x510>)
  400816:	47a0      	blx	r4
  400818:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  40081c:	e074      	b.n	400908 <loadNewFirmware+0x5d8>
  40081e:	bf00      	nop
  400820:	00404a4d 	.word	0x00404a4d
  400824:	07270e00 	.word	0x07270e00
  400828:	004055d9 	.word	0x004055d9
  40082c:	20000085 	.word	0x20000085
  400830:	004049a5 	.word	0x004049a5
  400834:	004001a5 	.word	0x004001a5
  400838:	00423fff 	.word	0x00423fff
  40083c:	20000ca8 	.word	0x20000ca8
  400840:	004002d1 	.word	0x004002d1
		{			
			memcpy(buf,FIRMWARE_TEMPORARY_LOCATION+total_bytes_read,FIRMWARE_BUFFER_SIZE); 			
  400844:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400848:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
  40084c:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  400850:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  400854:	4611      	mov	r1, r2
  400856:	461a      	mov	r2, r3
  400858:	f44f 7300 	mov.w	r3, #512	; 0x200
  40085c:	4608      	mov	r0, r1
  40085e:	4611      	mov	r1, r2
  400860:	461a      	mov	r2, r3
  400862:	4b38      	ldr	r3, [pc, #224]	; (400944 <loadNewFirmware+0x614>)
  400864:	4798      	blx	r3
			if(flash_write(destAddress+total_bytes_read, (void*)buf,FIRMWARE_BUFFER_SIZE,0) != 0)
  400866:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  40086a:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  40086e:	441a      	add	r2, r3
  400870:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  400874:	4610      	mov	r0, r2
  400876:	4619      	mov	r1, r3
  400878:	f44f 7200 	mov.w	r2, #512	; 0x200
  40087c:	2300      	movs	r3, #0
  40087e:	4c32      	ldr	r4, [pc, #200]	; (400948 <loadNewFirmware+0x618>)
  400880:	47a0      	blx	r4
  400882:	4603      	mov	r3, r0
  400884:	2b00      	cmp	r3, #0
  400886:	d003      	beq.n	400890 <loadNewFirmware+0x560>
			{
				result = STATUS_FAIL;
  400888:	2301      	movs	r3, #1
  40088a:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  40088e:	e044      	b.n	40091a <loadNewFirmware+0x5ea>
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
  400890:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400894:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400898:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
			drv_gpio_togglePin(DRV_GPIO_PIN_BLUE_LED);
  40089c:	200d      	movs	r0, #13
  40089e:	4b2b      	ldr	r3, [pc, #172]	; (40094c <loadNewFirmware+0x61c>)
  4008a0:	4798      	blx	r3
  4008a2:	4b2b      	ldr	r3, [pc, #172]	; (400950 <loadNewFirmware+0x620>)
			delay_ms(100);
  4008a4:	4618      	mov	r0, r3
  4008a6:	f04f 0100 	mov.w	r1, #0
  4008aa:	4602      	mov	r2, r0
  4008ac:	460b      	mov	r3, r1
  4008ae:	1892      	adds	r2, r2, r2
  4008b0:	eb43 0303 	adc.w	r3, r3, r3
  4008b4:	1812      	adds	r2, r2, r0
  4008b6:	eb43 0301 	adc.w	r3, r3, r1
  4008ba:	015d      	lsls	r5, r3, #5
  4008bc:	607d      	str	r5, [r7, #4]
  4008be:	f8d7 c004 	ldr.w	ip, [r7, #4]
  4008c2:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  4008c6:	f8c7 c004 	str.w	ip, [r7, #4]
  4008ca:	0154      	lsls	r4, r2, #5
  4008cc:	603c      	str	r4, [r7, #0]
  4008ce:	e9d7 4500 	ldrd	r4, r5, [r7]
  4008d2:	1912      	adds	r2, r2, r4
  4008d4:	eb43 0305 	adc.w	r3, r3, r5
  4008d8:	1880      	adds	r0, r0, r2
  4008da:	eb41 0103 	adc.w	r1, r1, r3
  4008de:	f243 62af 	movw	r2, #13999	; 0x36af
  4008e2:	f04f 0300 	mov.w	r3, #0
  4008e6:	1812      	adds	r2, r2, r0
  4008e8:	eb43 0301 	adc.w	r3, r3, r1
  4008ec:	4c19      	ldr	r4, [pc, #100]	; (400954 <loadNewFirmware+0x624>)
  4008ee:	4610      	mov	r0, r2
  4008f0:	4619      	mov	r1, r3
  4008f2:	f243 62b0 	movw	r2, #14000	; 0x36b0
  4008f6:	f04f 0300 	mov.w	r3, #0
  4008fa:	47a0      	blx	r4
  4008fc:	4602      	mov	r2, r0
  4008fe:	460b      	mov	r3, r1
  400900:	4613      	mov	r3, r2
  400902:	4618      	mov	r0, r3
  400904:	4b14      	ldr	r3, [pc, #80]	; (400958 <loadNewFirmware+0x628>)
  400906:	4798      	blx	r3
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = APP_START_ADDRESS;
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400908:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40090c:	68db      	ldr	r3, [r3, #12]
  40090e:	f1a3 020c 	sub.w	r2, r3, #12
  400912:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400916:	429a      	cmp	r2, r3
  400918:	d894      	bhi.n	400844 <loadNewFirmware+0x514>
	//else
	//{
		//result = STATUS_FAIL; 
	//}
		//
	res = f_close(&firmwareFileObj);
  40091a:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40091e:	4618      	mov	r0, r3
  400920:	4b0e      	ldr	r3, [pc, #56]	; (40095c <loadNewFirmware+0x62c>)
  400922:	4798      	blx	r3
  400924:	4603      	mov	r3, r0
  400926:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  40092a:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  40092e:	2b00      	cmp	r3, #0
  400930:	d001      	beq.n	400936 <loadNewFirmware+0x606>
	{
		return STATUS_FAIL;
  400932:	2301      	movs	r3, #1
  400934:	e000      	b.n	400938 <loadNewFirmware+0x608>
	}
	return STATUS_PASS; 	
  400936:	2300      	movs	r3, #0
}
  400938:	4618      	mov	r0, r3
  40093a:	f507 67d1 	add.w	r7, r7, #1672	; 0x688
  40093e:	46bd      	mov	sp, r7
  400940:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
  400944:	0040611d 	.word	0x0040611d
  400948:	004001dd 	.word	0x004001dd
  40094c:	00404a4d 	.word	0x00404a4d
  400950:	07270e00 	.word	0x07270e00
  400954:	004055d9 	.word	0x004055d9
  400958:	20000085 	.word	0x20000085
  40095c:	00403a49 	.word	0x00403a49

00400960 <runBootloader>:
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  400960:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  400964:	4b6e      	ldr	r3, [pc, #440]	; (400b20 <runBootloader+0x1c0>)
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400966:	4c6f      	ldr	r4, [pc, #444]	; (400b24 <runBootloader+0x1c4>)
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&lboState);	//Check for Low Battery
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  400968:	4f6f      	ldr	r7, [pc, #444]	; (400b28 <runBootloader+0x1c8>)
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  40096a:	b085      	sub	sp, #20
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  40096c:	4798      	blx	r3
	pmc_enable_periph_clk(ID_CRCCU);   		    
  40096e:	4b6f      	ldr	r3, [pc, #444]	; (400b2c <runBootloader+0x1cc>)
  400970:	2020      	movs	r0, #32
  400972:	4798      	blx	r3
	board_init();	
  400974:	4b6e      	ldr	r3, [pc, #440]	; (400b30 <runBootloader+0x1d0>)
  400976:	4798      	blx	r3
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  400978:	2301      	movs	r3, #1
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40097a:	4618      	mov	r0, r3
  40097c:	a903      	add	r1, sp, #12
{
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  40097e:	f88d 300c 	strb.w	r3, [sp, #12]
  400982:	f88d 300d 	strb.w	r3, [sp, #13]
  400986:	f88d 300e 	strb.w	r3, [sp, #14]
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  40098a:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  40098c:	f10d 010d 	add.w	r1, sp, #13
  400990:	2002      	movs	r0, #2
  400992:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&lboState);	//Check for Low Battery
  400994:	f10d 010e 	add.w	r1, sp, #14
  400998:	2002      	movs	r0, #2
  40099a:	47a0      	blx	r4
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  40099c:	2100      	movs	r1, #0
  40099e:	200c      	movs	r0, #12
  4009a0:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  4009a2:	200d      	movs	r0, #13
  4009a4:	2100      	movs	r1, #0
  4009a6:	47b8      	blx	r7
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
  4009a8:	f89d 300c 	ldrb.w	r3, [sp, #12]
  4009ac:	2b00      	cmp	r3, #0
  4009ae:	d143      	bne.n	400a38 <runBootloader+0xd8>
  4009b0:	f89d 300d 	ldrb.w	r3, [sp, #13]
  4009b4:	2b00      	cmp	r3, #0
  4009b6:	d13f      	bne.n	400a38 <runBootloader+0xd8>
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
  4009b8:	f89d 300e 	ldrb.w	r3, [sp, #14]
  4009bc:	2b00      	cmp	r3, #0
  4009be:	d048      	beq.n	400a52 <runBootloader+0xf2>
  4009c0:	4e5c      	ldr	r6, [pc, #368]	; (400b34 <runBootloader+0x1d4>)
  4009c2:	250a      	movs	r5, #10
  4009c4:	e00a      	b.n	4009dc <runBootloader+0x7c>
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  4009c6:	f89d 800d 	ldrb.w	r8, [sp, #13]
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  4009ca:	485b      	ldr	r0, [pc, #364]	; (400b38 <runBootloader+0x1d8>)
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  4009cc:	f1d8 0801 	rsbs	r8, r8, #1
  4009d0:	bf38      	it	cc
  4009d2:	f04f 0800 	movcc.w	r8, #0
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  4009d6:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  4009d8:	3d01      	subs	r5, #1
  4009da:	d010      	beq.n	4009fe <runBootloader+0x9e>
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  4009dc:	a903      	add	r1, sp, #12
  4009de:	2001      	movs	r0, #1
  4009e0:	47a0      	blx	r4
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  4009e2:	2002      	movs	r0, #2
  4009e4:	f10d 010d 	add.w	r1, sp, #13
  4009e8:	47a0      	blx	r4
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  4009ea:	f89d 300c 	ldrb.w	r3, [sp, #12]
  4009ee:	2b00      	cmp	r3, #0
  4009f0:	d0e9      	beq.n	4009c6 <runBootloader+0x66>
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  4009f2:	4851      	ldr	r0, [pc, #324]	; (400b38 <runBootloader+0x1d8>)
  4009f4:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  4009f6:	3d01      	subs	r5, #1
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
				{
					enterBootloader = 0; 
  4009f8:	f04f 0800 	mov.w	r8, #0
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  4009fc:	d1ee      	bne.n	4009dc <runBootloader+0x7c>
				}
				delay_ms(100); 			
			}		
		}
	}	
	if(enterBootloader == 1)
  4009fe:	f1b8 0f00 	cmp.w	r8, #0
  400a02:	d019      	beq.n	400a38 <runBootloader+0xd8>
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400a04:	a904      	add	r1, sp, #16
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400a06:	2010      	movs	r0, #16
		}
	}	
	if(enterBootloader == 1)
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400a08:	f801 5d01 	strb.w	r5, [r1, #-1]!
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400a0c:	47a0      	blx	r4
		if(sdCardCD != DRV_GPIO_PIN_STATE_HIGH)
  400a0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
  400a12:	2b01      	cmp	r3, #1
  400a14:	d020      	beq.n	400a58 <runBootloader+0xf8>
 * errorBlink()
 * @brief blink led red 5 times to indicate error
 */
static void errorBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400a16:	2101      	movs	r1, #1
  400a18:	200e      	movs	r0, #14
  400a1a:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400a1c:	2101      	movs	r1, #1
  400a1e:	200c      	movs	r0, #12
  400a20:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400a22:	200d      	movs	r0, #13
  400a24:	2101      	movs	r1, #1
  400a26:	47b8      	blx	r7
  400a28:	4d44      	ldr	r5, [pc, #272]	; (400b3c <runBootloader+0x1dc>)
  400a2a:	240a      	movs	r4, #10
	
	int i = 0;
	for(i=0; i<10; i++)
	{
		delay_ms(200); 
  400a2c:	4844      	ldr	r0, [pc, #272]	; (400b40 <runBootloader+0x1e0>)
  400a2e:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_RED_LED); 	
  400a30:	200e      	movs	r0, #14
  400a32:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<10; i++)
  400a34:	3c01      	subs	r4, #1
  400a36:	d1f9      	bne.n	400a2c <runBootloader+0xcc>
 */
static void start_application(void)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
  400a38:	f44f 0381 	mov.w	r3, #4227072	; 0x408000

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
  400a3c:	681a      	ldr	r2, [r3, #0]
  400a3e:	f382 8808 	msr	MSP, r2
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400a42:	4940      	ldr	r1, [pc, #256]	; (400b44 <runBootloader+0x1e4>)
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
  400a44:	4a40      	ldr	r2, [pc, #256]	; (400b48 <runBootloader+0x1e8>)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400a46:	608b      	str	r3, [r1, #8]
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
	/* Jump to application Reset Handler in the application */
	asm("bx %0"::"r"(app_start_address));
  400a48:	6813      	ldr	r3, [r2, #0]
  400a4a:	4718      	bx	r3
		//unmount the drive
		//f_mount(LUN_ID_SD_MMC_0_MEM, NULL);		
	} 	   
	start_application();
	
}
  400a4c:	b005      	add	sp, #20
  400a4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
		{
			//battery is low, don't run bootloader
			lowBatteryBlink();
  400a52:	4b3e      	ldr	r3, [pc, #248]	; (400b4c <runBootloader+0x1ec>)
  400a54:	4798      	blx	r3
  400a56:	e7ef      	b.n	400a38 <runBootloader+0xd8>
static status_t initializeSDCard()
{
	static FRESULT res;
	status_t status = STATUS_PASS; 
	////Initialize SD card
	sd_mmc_init();
  400a58:	4b3d      	ldr	r3, [pc, #244]	; (400b50 <runBootloader+0x1f0>)
  400a5a:	f8df a110 	ldr.w	sl, [pc, #272]	; 400b6c <runBootloader+0x20c>
  400a5e:	f8df 9110 	ldr.w	r9, [pc, #272]	; 400b70 <runBootloader+0x210>
  400a62:	f8df 8110 	ldr.w	r8, [pc, #272]	; 400b74 <runBootloader+0x214>
  400a66:	4798      	blx	r3
	//
	///* Wait card present and ready */
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
  400a68:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
  400a6c:	e008      	b.n	400a80 <runBootloader+0x120>
					break; 
				}
			}
		}
		maxAttemptCount--;
		if(maxAttemptCount == 0)
  400a6e:	3c01      	subs	r4, #1
  400a70:	d049      	beq.n	400b06 <runBootloader+0x1a6>
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400a72:	4838      	ldr	r0, [pc, #224]	; (400b54 <runBootloader+0x1f4>)
		
		
	} while (CTRL_GOOD != res);
  400a74:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 400b70 <runBootloader+0x210>
		if(maxAttemptCount == 0)
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400a78:	47b0      	blx	r6
		
		
	} while (CTRL_GOOD != res);
  400a7a:	f899 3000 	ldrb.w	r3, [r9]
  400a7e:	b17b      	cbz	r3, 400aa0 <runBootloader+0x140>
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400a80:	2000      	movs	r0, #0
  400a82:	47d0      	blx	sl
		if (res == CTRL_FAIL)
  400a84:	2801      	cmp	r0, #1
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400a86:	f889 0000 	strb.w	r0, [r9]
		if (res == CTRL_FAIL)
  400a8a:	d1f0      	bne.n	400a6e <runBootloader+0x10e>
		{
			while (CTRL_NO_PRESENT != sd_mmc_check(0))
  400a8c:	2000      	movs	r0, #0
  400a8e:	47c0      	blx	r8
  400a90:	2802      	cmp	r0, #2
  400a92:	d0ec      	beq.n	400a6e <runBootloader+0x10e>
			{
				maxAttemptCount--; 
				if(maxAttemptCount == 0)
  400a94:	3c01      	subs	r4, #1
  400a96:	d1f9      	bne.n	400a8c <runBootloader+0x12c>
				{
					status = STATUS_FAIL;
  400a98:	2501      	movs	r5, #1
					break; 
				}
			}
		}
		maxAttemptCount--;
  400a9a:	f04f 34ff 	mov.w	r4, #4294967295
  400a9e:	e7e8      	b.n	400a72 <runBootloader+0x112>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400aa0:	4619      	mov	r1, r3
  400aa2:	f44f 720c 	mov.w	r2, #560	; 0x230
  400aa6:	9301      	str	r3, [sp, #4]
  400aa8:	482b      	ldr	r0, [pc, #172]	; (400b58 <runBootloader+0x1f8>)
  400aaa:	4c2c      	ldr	r4, [pc, #176]	; (400b5c <runBootloader+0x1fc>)
  400aac:	47a0      	blx	r4
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400aae:	9b01      	ldr	r3, [sp, #4]
  400ab0:	4929      	ldr	r1, [pc, #164]	; (400b58 <runBootloader+0x1f8>)
  400ab2:	4618      	mov	r0, r3
  400ab4:	4b2a      	ldr	r3, [pc, #168]	; (400b60 <runBootloader+0x200>)
  400ab6:	4798      	blx	r3
	if (res == FR_INVALID_DRIVE)
  400ab8:	280b      	cmp	r0, #11
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400aba:	f88b 0000 	strb.w	r0, [fp]
	if (res == FR_INVALID_DRIVE)
  400abe:	d0aa      	beq.n	400a16 <runBootloader+0xb6>
		if(status == STATUS_PASS)
		{
			status = initializeSDCard(); 	
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
  400ac0:	2d00      	cmp	r5, #0
  400ac2:	d1a8      	bne.n	400a16 <runBootloader+0xb6>
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400ac4:	2101      	movs	r1, #1
  400ac6:	200c      	movs	r0, #12
  400ac8:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400aca:	4629      	mov	r1, r5
  400acc:	200d      	movs	r0, #13
  400ace:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
  400ad0:	4629      	mov	r1, r5
  400ad2:	200e      	movs	r0, #14
  400ad4:	47b8      	blx	r7
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400ad6:	4823      	ldr	r0, [pc, #140]	; (400b64 <runBootloader+0x204>)
  400ad8:	4b23      	ldr	r3, [pc, #140]	; (400b68 <runBootloader+0x208>)
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400ada:	4c13      	ldr	r4, [pc, #76]	; (400b28 <runBootloader+0x1c8>)
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400adc:	4798      	blx	r3
		}
		if(status != STATUS_PASS)
  400ade:	2800      	cmp	r0, #0
  400ae0:	d199      	bne.n	400a16 <runBootloader+0xb6>
 * successBlink()
 * @brief blink led green 3 times if successful
 */
static void successBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ae2:	2101      	movs	r1, #1
  400ae4:	200e      	movs	r0, #14
  400ae6:	47a0      	blx	r4
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ae8:	2101      	movs	r1, #1
  400aea:	200c      	movs	r0, #12
  400aec:	47a0      	blx	r4
  400aee:	4d13      	ldr	r5, [pc, #76]	; (400b3c <runBootloader+0x1dc>)
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400af0:	200d      	movs	r0, #13
  400af2:	2101      	movs	r1, #1
  400af4:	47a0      	blx	r4
  400af6:	2406      	movs	r4, #6
	
	int i = 0;
	for(i=0; i<6; i++)
	{
		delay_ms(200); 
  400af8:	4811      	ldr	r0, [pc, #68]	; (400b40 <runBootloader+0x1e0>)
  400afa:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 	
  400afc:	200c      	movs	r0, #12
  400afe:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<6; i++)
  400b00:	3c01      	subs	r4, #1
  400b02:	d1f9      	bne.n	400af8 <runBootloader+0x198>
  400b04:	e798      	b.n	400a38 <runBootloader+0xd8>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400b06:	4b15      	ldr	r3, [pc, #84]	; (400b5c <runBootloader+0x1fc>)
  400b08:	4813      	ldr	r0, [pc, #76]	; (400b58 <runBootloader+0x1f8>)
  400b0a:	4621      	mov	r1, r4
  400b0c:	f44f 720c 	mov.w	r2, #560	; 0x230
  400b10:	4798      	blx	r3
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400b12:	4620      	mov	r0, r4
  400b14:	4910      	ldr	r1, [pc, #64]	; (400b58 <runBootloader+0x1f8>)
  400b16:	4b12      	ldr	r3, [pc, #72]	; (400b60 <runBootloader+0x200>)
  400b18:	4798      	blx	r3
  400b1a:	f889 0000 	strb.w	r0, [r9]
  400b1e:	e77a      	b.n	400a16 <runBootloader+0xb6>
  400b20:	00404969 	.word	0x00404969
  400b24:	00404a1d 	.word	0x00404a1d
  400b28:	004049a5 	.word	0x004049a5
  400b2c:	0040531d 	.word	0x0040531d
  400b30:	00404e0d 	.word	0x00404e0d
  400b34:	20000085 	.word	0x20000085
  400b38:	000d1437 	.word	0x000d1437
  400b3c:	00404a4d 	.word	0x00404a4d
  400b40:	001a286e 	.word	0x001a286e
  400b44:	e000ed00 	.word	0xe000ed00
  400b48:	00408004 	.word	0x00408004
  400b4c:	00400cb5 	.word	0x00400cb5
  400b50:	00400e41 	.word	0x00400e41
  400b54:	00014ed3 	.word	0x00014ed3
  400b58:	20001100 	.word	0x20001100
  400b5c:	00406251 	.word	0x00406251
  400b60:	004034fd 	.word	0x004034fd
  400b64:	00406704 	.word	0x00406704
  400b68:	00400331 	.word	0x00400331
  400b6c:	004017e9 	.word	0x004017e9
  400b70:	20000cac 	.word	0x20000cac
  400b74:	00400e61 	.word	0x00400e61

00400b78 <debugPrintString>:
		task_debugLogWriteEntry(timeStampedStr, length);
	}
}

void __attribute__((optimize("O0"))) debugPrintString(char* str)
{
  400b78:	b580      	push	{r7, lr}
  400b7a:	b0b6      	sub	sp, #216	; 0xd8
  400b7c:	af00      	add	r7, sp, #0
  400b7e:	6078      	str	r0, [r7, #4]
	size_t length = 0;
  400b80:	2300      	movs	r3, #0
  400b82:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	char timeStampedStr[200];
	int len = itoa(sgSysTickCount, timeStampedStr, 10);
  400b86:	4b27      	ldr	r3, [pc, #156]	; (400c24 <debugPrintString+0xac>)
  400b88:	681b      	ldr	r3, [r3, #0]
  400b8a:	461a      	mov	r2, r3
  400b8c:	f107 0308 	add.w	r3, r7, #8
  400b90:	4610      	mov	r0, r2
  400b92:	4619      	mov	r1, r3
  400b94:	220a      	movs	r2, #10
  400b96:	4b24      	ldr	r3, [pc, #144]	; (400c28 <debugPrintString+0xb0>)
  400b98:	4798      	blx	r3
  400b9a:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[len++] = ',';
  400b9e:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400ba2:	1c5a      	adds	r2, r3, #1
  400ba4:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
  400ba8:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  400bac:	4413      	add	r3, r2
  400bae:	222c      	movs	r2, #44	; 0x2c
  400bb0:	f803 2cd0 	strb.w	r2, [r3, #-208]
	strncpy(timeStampedStr+len, str, 200-len);
  400bb4:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400bb8:	f107 0208 	add.w	r2, r7, #8
  400bbc:	441a      	add	r2, r3
  400bbe:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400bc2:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
  400bc6:	4610      	mov	r0, r2
  400bc8:	6879      	ldr	r1, [r7, #4]
  400bca:	461a      	mov	r2, r3
  400bcc:	4b17      	ldr	r3, [pc, #92]	; (400c2c <debugPrintString+0xb4>)
  400bce:	4798      	blx	r3
	
	//uint32_t time = sgSysTickCount;
	//#else
	//length = snprintf(timeStampedStr,100,"%08ld, %s",sgSysTickCount,str); 
	//#endif
	length = strlen(timeStampedStr); 
  400bd0:	f107 0308 	add.w	r3, r7, #8
  400bd4:	4618      	mov	r0, r3
  400bd6:	4b16      	ldr	r3, [pc, #88]	; (400c30 <debugPrintString+0xb8>)
  400bd8:	4798      	blx	r3
  400bda:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
	if(length > 0)
  400bde:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400be2:	2b00      	cmp	r3, #0
  400be4:	d01a      	beq.n	400c1c <debugPrintString+0xa4>
	{
		if(brainSettings.debugPrintsEnabled)
  400be6:	4b13      	ldr	r3, [pc, #76]	; (400c34 <debugPrintString+0xbc>)
  400be8:	f893 303c 	ldrb.w	r3, [r3, #60]	; 0x3c
  400bec:	2b00      	cmp	r3, #0
  400bee:	d00e      	beq.n	400c0e <debugPrintString+0x96>
		{
			if(config != NULL)
  400bf0:	4b11      	ldr	r3, [pc, #68]	; (400c38 <debugPrintString+0xc0>)
  400bf2:	681b      	ldr	r3, [r3, #0]
  400bf4:	2b00      	cmp	r3, #0
  400bf6:	d00a      	beq.n	400c0e <debugPrintString+0x96>
			{
				drv_uart_putData((config->uart), timeStampedStr, length);
  400bf8:	4b0f      	ldr	r3, [pc, #60]	; (400c38 <debugPrintString+0xc0>)
  400bfa:	681b      	ldr	r3, [r3, #0]
  400bfc:	681a      	ldr	r2, [r3, #0]
  400bfe:	f107 0308 	add.w	r3, r7, #8
  400c02:	4610      	mov	r0, r2
  400c04:	4619      	mov	r1, r3
  400c06:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
  400c0a:	4b0c      	ldr	r3, [pc, #48]	; (400c3c <debugPrintString+0xc4>)
  400c0c:	4798      	blx	r3
			}
		}
		task_debugLogWriteEntry(timeStampedStr, length);
  400c0e:	f107 0308 	add.w	r3, r7, #8
  400c12:	4618      	mov	r0, r3
  400c14:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
  400c18:	4b09      	ldr	r3, [pc, #36]	; (400c40 <debugPrintString+0xc8>)
  400c1a:	4798      	blx	r3
		//if(config != NULL)
		//{
			//drv_uart_putData((config->uart), str, length);
		//}
	//}
}
  400c1c:	37d8      	adds	r7, #216	; 0xd8
  400c1e:	46bd      	mov	sp, r7
  400c20:	bd80      	pop	{r7, pc}
  400c22:	bf00      	nop
  400c24:	200010c8 	.word	0x200010c8
  400c28:	00404589 	.word	0x00404589
  400c2c:	00406371 	.word	0x00406371
  400c30:	00406311 	.word	0x00406311
  400c34:	200000c0 	.word	0x200000c0
  400c38:	20000cb0 	.word	0x20000cb0
  400c3c:	00404c41 	.word	0x00404c41
  400c40:	00400c45 	.word	0x00400c45

00400c44 <task_debugLogWriteEntry>:

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400c44:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400c46:	4c15      	ldr	r4, [pc, #84]	; (400c9c <task_debugLogWriteEntry+0x58>)
  400c48:	6823      	ldr	r3, [r4, #0]

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400c4a:	4607      	mov	r7, r0
  400c4c:	460e      	mov	r6, r1
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400c4e:	b13b      	cbz	r3, 400c60 <task_debugLogWriteEntry+0x1c>
	{
		return STATUS_FAIL; 
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  400c50:	2100      	movs	r1, #0
  400c52:	4618      	mov	r0, r3
  400c54:	2205      	movs	r2, #5
  400c56:	460b      	mov	r3, r1
  400c58:	4d11      	ldr	r5, [pc, #68]	; (400ca0 <task_debugLogWriteEntry+0x5c>)
  400c5a:	47a8      	blx	r5
  400c5c:	2801      	cmp	r0, #1
  400c5e:	d001      	beq.n	400c64 <task_debugLogWriteEntry+0x20>
{
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
	{
		return STATUS_FAIL; 
  400c60:	2001      	movs	r0, #1
  400c62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
  400c64:	4d0f      	ldr	r5, [pc, #60]	; (400ca4 <task_debugLogWriteEntry+0x60>)
  400c66:	682a      	ldr	r2, [r5, #0]
  400c68:	4432      	add	r2, r6
  400c6a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  400c6e:	d308      	bcc.n	400c82 <task_debugLogWriteEntry+0x3e>
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
			debugLogBufferPointer += length;
		}
		else
		{
			status = STATUS_FAIL;
  400c70:	4605      	mov	r5, r0
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  400c72:	2100      	movs	r1, #0
  400c74:	6820      	ldr	r0, [r4, #0]
  400c76:	4c0c      	ldr	r4, [pc, #48]	; (400ca8 <task_debugLogWriteEntry+0x64>)
  400c78:	460a      	mov	r2, r1
  400c7a:	460b      	mov	r3, r1
  400c7c:	47a0      	blx	r4
  400c7e:	4628      	mov	r0, r5
	{
		status = STATUS_FAIL;
	}	
	return status;
	
}
  400c80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
		{
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
  400c82:	682a      	ldr	r2, [r5, #0]
  400c84:	4809      	ldr	r0, [pc, #36]	; (400cac <task_debugLogWriteEntry+0x68>)
  400c86:	4b0a      	ldr	r3, [pc, #40]	; (400cb0 <task_debugLogWriteEntry+0x6c>)
  400c88:	4410      	add	r0, r2
  400c8a:	4639      	mov	r1, r7
  400c8c:	4632      	mov	r2, r6
  400c8e:	4798      	blx	r3
			debugLogBufferPointer += length;
  400c90:	682b      	ldr	r3, [r5, #0]
  400c92:	441e      	add	r6, r3
  400c94:	602e      	str	r6, [r5, #0]
	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
	status_t status = STATUS_PASS;
  400c96:	2500      	movs	r5, #0
  400c98:	e7eb      	b.n	400c72 <task_debugLogWriteEntry+0x2e>
  400c9a:	bf00      	nop
  400c9c:	20000cb4 	.word	0x20000cb4
  400ca0:	00403e9d 	.word	0x00403e9d
  400ca4:	20000eb8 	.word	0x20000eb8
  400ca8:	00403d8d 	.word	0x00403d8d
  400cac:	20000cb8 	.word	0x20000cb8
  400cb0:	0040611d 	.word	0x0040611d

00400cb4 <lowBatteryBlink>:
 * @brief Blink the LED to indicate low battery 
 * @param void
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
  400cb4:	b570      	push	{r4, r5, r6, lr}
  400cb6:	4e08      	ldr	r6, [pc, #32]	; (400cd8 <lowBatteryBlink+0x24>)
  400cb8:	4d08      	ldr	r5, [pc, #32]	; (400cdc <lowBatteryBlink+0x28>)
  400cba:	2403      	movs	r4, #3
	//Blink the LED connected to STAT pin to indicate battery low
	for (int i = 0; i < 3; i++)
	{
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_HIGH);
  400cbc:	2101      	movs	r1, #1
  400cbe:	2012      	movs	r0, #18
  400cc0:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  400cc2:	4807      	ldr	r0, [pc, #28]	; (400ce0 <lowBatteryBlink+0x2c>)
  400cc4:	47a8      	blx	r5
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_LOW);
  400cc6:	2100      	movs	r1, #0
  400cc8:	2012      	movs	r0, #18
  400cca:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  400ccc:	4804      	ldr	r0, [pc, #16]	; (400ce0 <lowBatteryBlink+0x2c>)
  400cce:	47a8      	blx	r5
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
	//Blink the LED connected to STAT pin to indicate battery low
	for (int i = 0; i < 3; i++)
  400cd0:	3c01      	subs	r4, #1
  400cd2:	d1f3      	bne.n	400cbc <lowBatteryBlink+0x8>
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_HIGH);
		delay_ms(LED_BLINK_RATE);
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_LOW);
		delay_ms(LED_BLINK_RATE);
	}
  400cd4:	bd70      	pop	{r4, r5, r6, pc}
  400cd6:	bf00      	nop
  400cd8:	004049a5 	.word	0x004049a5
  400cdc:	20000085 	.word	0x20000085
  400ce0:	0020b28a 	.word	0x0020b28a

00400ce4 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  400ce4:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  400ce6:	4a07      	ldr	r2, [pc, #28]	; (400d04 <sd_mmc_configure_slot+0x20>)
  400ce8:	4b07      	ldr	r3, [pc, #28]	; (400d08 <sd_mmc_configure_slot+0x24>)
  400cea:	6812      	ldr	r2, [r2, #0]
  400cec:	7818      	ldrb	r0, [r3, #0]
  400cee:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
  400cf2:	6811      	ldr	r1, [r2, #0]
  400cf4:	4c05      	ldr	r4, [pc, #20]	; (400d0c <sd_mmc_configure_slot+0x28>)
  400cf6:	7c52      	ldrb	r2, [r2, #17]
  400cf8:	3300      	adds	r3, #0
  400cfa:	bf18      	it	ne
  400cfc:	2301      	movne	r3, #1
  400cfe:	47a0      	blx	r4
  400d00:	bd10      	pop	{r4, pc}
  400d02:	bf00      	nop
  400d04:	20000ec0 	.word	0x20000ec0
  400d08:	20000ec6 	.word	0x20000ec6
  400d0c:	00401b59 	.word	0x00401b59

00400d10 <sd_mmc_select_slot.part.0>:
 * \retval SD_MMC_ERR_NO_CARD  No card present on slot
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
  400d10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (ioport_get_pin_level(sd_mmc_cards[slot].cd_gpio)
  400d12:	00c5      	lsls	r5, r0, #3
  400d14:	4c34      	ldr	r4, [pc, #208]	; (400de8 <sd_mmc_select_slot.part.0+0xd8>)
  400d16:	1829      	adds	r1, r5, r0
  400d18:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400d1c:	2601      	movs	r6, #1
  400d1e:	688a      	ldr	r2, [r1, #8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400d20:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400d22:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400d26:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400d2a:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400d2c:	f002 021f 	and.w	r2, r2, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  400d30:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400d32:	fa06 f202 	lsl.w	r2, r6, r2
  400d36:	4013      	ands	r3, r2
  400d38:	f101 0108 	add.w	r1, r1, #8
  400d3c:	d110      	bne.n	400d60 <sd_mmc_select_slot.part.0+0x50>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  400d3e:	7989      	ldrb	r1, [r1, #6]
  400d40:	42b1      	cmp	r1, r6
  400d42:	d006      	beq.n	400d52 <sd_mmc_select_slot.part.0+0x42>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400d44:	4428      	add	r0, r5
  400d46:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  400d4a:	2304      	movs	r3, #4
  400d4c:	73a3      	strb	r3, [r4, #14]
		return SD_MMC_ERR_NO_CARD;
  400d4e:	2002      	movs	r0, #2
  400d50:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
  400d52:	4a26      	ldr	r2, [pc, #152]	; (400dec <sd_mmc_select_slot.part.0+0xdc>)
  400d54:	7812      	ldrb	r2, [r2, #0]
  400d56:	2a00      	cmp	r2, #0
  400d58:	d0f4      	beq.n	400d44 <sd_mmc_select_slot.part.0+0x34>
		SysTick->CTRL = 0;
  400d5a:	4a25      	ldr	r2, [pc, #148]	; (400df0 <sd_mmc_select_slot.part.0+0xe0>)
  400d5c:	6013      	str	r3, [r2, #0]
  400d5e:	e7f1      	b.n	400d44 <sd_mmc_select_slot.part.0+0x34>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
  400d60:	798b      	ldrb	r3, [r1, #6]
  400d62:	2b04      	cmp	r3, #4
  400d64:	d02a      	beq.n	400dbc <sd_mmc_select_slot.part.0+0xac>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  400d66:	2b01      	cmp	r3, #1
  400d68:	d003      	beq.n	400d72 <sd_mmc_select_slot.part.0+0x62>
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
  400d6a:	2b03      	cmp	r3, #3
  400d6c:	d118      	bne.n	400da0 <sd_mmc_select_slot.part.0+0x90>
		return SD_MMC_ERR_UNUSABLE;
  400d6e:	4618      	mov	r0, r3
  400d70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
  400d72:	4b1e      	ldr	r3, [pc, #120]	; (400dec <sd_mmc_select_slot.part.0+0xdc>)
  400d74:	781b      	ldrb	r3, [r3, #0]
  400d76:	b12b      	cbz	r3, 400d84 <sd_mmc_select_slot.part.0+0x74>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
  400d78:	4b1d      	ldr	r3, [pc, #116]	; (400df0 <sd_mmc_select_slot.part.0+0xe0>)
  400d7a:	681a      	ldr	r2, [r3, #0]
  400d7c:	03d2      	lsls	r2, r2, #15
  400d7e:	d530      	bpl.n	400de2 <sd_mmc_select_slot.part.0+0xd2>
		SysTick->CTRL = 0;
  400d80:	2200      	movs	r2, #0
  400d82:	601a      	str	r2, [r3, #0]
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  400d84:	1829      	adds	r1, r5, r0
  400d86:	0089      	lsls	r1, r1, #2
  400d88:	1863      	adds	r3, r4, r1
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  400d8a:	4f1a      	ldr	r7, [pc, #104]	; (400df4 <sd_mmc_select_slot.part.0+0xe4>)
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  400d8c:	2602      	movs	r6, #2
  400d8e:	739e      	strb	r6, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  400d90:	5067      	str	r7, [r4, r1]
		sd_mmc_cards[slot].bus_width = 1;
  400d92:	2701      	movs	r7, #1
		sd_mmc_cards[slot].high_speed = 0;
  400d94:	2100      	movs	r1, #0
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
  400d96:	745f      	strb	r7, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
  400d98:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  400d9c:	7b9b      	ldrb	r3, [r3, #14]
  400d9e:	e7e4      	b.n	400d6a <sd_mmc_select_slot.part.0+0x5a>
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
  400da0:	4405      	add	r5, r0
  400da2:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  400da6:	4914      	ldr	r1, [pc, #80]	; (400df8 <sd_mmc_select_slot.part.0+0xe8>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  400da8:	4a14      	ldr	r2, [pc, #80]	; (400dfc <sd_mmc_select_slot.part.0+0xec>)
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
  400daa:	4b15      	ldr	r3, [pc, #84]	; (400e00 <sd_mmc_select_slot.part.0+0xf0>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  400dac:	7010      	strb	r0, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  400dae:	600c      	str	r4, [r1, #0]
	sd_mmc_configure_slot();
  400db0:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  400db2:	7ba0      	ldrb	r0, [r4, #14]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  400db4:	1e83      	subs	r3, r0, #2
  400db6:	4258      	negs	r0, r3
  400db8:	4158      	adcs	r0, r3
  400dba:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  400dbc:	4b0c      	ldr	r3, [pc, #48]	; (400df0 <sd_mmc_select_slot.part.0+0xe0>)
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
  400dbe:	718e      	strb	r6, [r1, #6]
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  400dc0:	681a      	ldr	r2, [r3, #0]
  400dc2:	b932      	cbnz	r2, 400dd2 <sd_mmc_select_slot.part.0+0xc2>
		sd_mmc_sam_systick_used = true;
  400dc4:	4909      	ldr	r1, [pc, #36]	; (400dec <sd_mmc_select_slot.part.0+0xdc>)
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  400dc6:	4a0f      	ldr	r2, [pc, #60]	; (400e04 <sd_mmc_select_slot.part.0+0xf4>)
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
  400dc8:	700e      	strb	r6, [r1, #0]
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  400dca:	605a      	str	r2, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
  400dcc:	601e      	str	r6, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  400dce:	2002      	movs	r0, #2
  400dd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  400dd2:	4a06      	ldr	r2, [pc, #24]	; (400dec <sd_mmc_select_slot.part.0+0xdc>)
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  400dd4:	480c      	ldr	r0, [pc, #48]	; (400e08 <sd_mmc_select_slot.part.0+0xf8>)
  400dd6:	4b0d      	ldr	r3, [pc, #52]	; (400e0c <sd_mmc_select_slot.part.0+0xfc>)
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  400dd8:	2100      	movs	r1, #0
  400dda:	7011      	strb	r1, [r2, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  400ddc:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  400dde:	2002      	movs	r0, #2
  400de0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
  400de2:	2002      	movs	r0, #2
  400de4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  400de6:	bf00      	nop
  400de8:	20000090 	.word	0x20000090
  400dec:	20000ebe 	.word	0x20000ebe
  400df0:	e000e010 	.word	0xe000e010
  400df4:	00061a80 	.word	0x00061a80
  400df8:	20000ec0 	.word	0x20000ec0
  400dfc:	20000ec6 	.word	0x20000ec6
  400e00:	00400ce5 	.word	0x00400ce5
  400e04:	00e4e1c0 	.word	0x00e4e1c0
  400e08:	0082ca25 	.word	0x0082ca25
  400e0c:	20000085 	.word	0x20000085

00400e10 <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  400e10:	b538      	push	{r3, r4, r5, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  400e12:	4d08      	ldr	r5, [pc, #32]	; (400e34 <sd_mmc_cmd9_mci+0x24>)
  400e14:	4a08      	ldr	r2, [pc, #32]	; (400e38 <sd_mmc_cmd9_mci+0x28>)
  400e16:	682b      	ldr	r3, [r5, #0]
  400e18:	8999      	ldrh	r1, [r3, #12]
  400e1a:	f641 3009 	movw	r0, #6921	; 0x1b09
  400e1e:	0409      	lsls	r1, r1, #16
  400e20:	4790      	blx	r2
  400e22:	4604      	mov	r4, r0
  400e24:	b118      	cbz	r0, 400e2e <sd_mmc_cmd9_mci+0x1e>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  400e26:	6828      	ldr	r0, [r5, #0]
  400e28:	4b04      	ldr	r3, [pc, #16]	; (400e3c <sd_mmc_cmd9_mci+0x2c>)
  400e2a:	3012      	adds	r0, #18
  400e2c:	4798      	blx	r3
	return true;
}
  400e2e:	4620      	mov	r0, r4
  400e30:	bd38      	pop	{r3, r4, r5, pc}
  400e32:	bf00      	nop
  400e34:	20000ec0 	.word	0x20000ec0
  400e38:	00401bfd 	.word	0x00401bfd
  400e3c:	00401c31 	.word	0x00401c31

00400e40 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  400e40:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400e42:	4804      	ldr	r0, [pc, #16]	; (400e54 <sd_mmc_init+0x14>)
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400e44:	4a04      	ldr	r2, [pc, #16]	; (400e58 <sd_mmc_init+0x18>)
	driver_init();
  400e46:	4b05      	ldr	r3, [pc, #20]	; (400e5c <sd_mmc_init+0x1c>)
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400e48:	2404      	movs	r4, #4
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400e4a:	21ff      	movs	r1, #255	; 0xff
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  400e4c:	7384      	strb	r4, [r0, #14]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  400e4e:	7011      	strb	r1, [r2, #0]
	driver_init();
  400e50:	4798      	blx	r3
  400e52:	bd10      	pop	{r4, pc}
  400e54:	20000090 	.word	0x20000090
  400e58:	20000ec6 	.word	0x20000ec6
  400e5c:	00401b21 	.word	0x00401b21

00400e60 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  400e60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400e64:	4605      	mov	r5, r0
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  400e66:	b095      	sub	sp, #84	; 0x54
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  400e68:	2800      	cmp	r0, #0
  400e6a:	f000 80ea 	beq.w	401042 <sd_mmc_check+0x1e2>
		return SD_MMC_ERR_SLOT;
  400e6e:	2404      	movs	r4, #4
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  400e70:	4b9e      	ldr	r3, [pc, #632]	; (4010ec <sd_mmc_check+0x28c>)
  400e72:	7818      	ldrb	r0, [r3, #0]
  400e74:	2800      	cmp	r0, #0
  400e76:	f000 80de 	beq.w	401036 <sd_mmc_check+0x1d6>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  400e7a:	4620      	mov	r0, r4
  400e7c:	b015      	add	sp, #84	; 0x54
  400e7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  400e82:	f245 5008 	movw	r0, #21768	; 0x5508
  400e86:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  400e8a:	47b0      	blx	r6
  400e8c:	2800      	cmp	r0, #0
  400e8e:	f040 80f7 	bne.w	401080 <sd_mmc_check+0x220>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  400e92:	f04f 0900 	mov.w	r9, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400e96:	683b      	ldr	r3, [r7, #0]
  400e98:	7bdb      	ldrb	r3, [r3, #15]
  400e9a:	07da      	lsls	r2, r3, #31
  400e9c:	f100 80fc 	bmi.w	401098 <sd_mmc_check+0x238>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  400ea0:	f245 1003 	movw	r0, #20739	; 0x5103
  400ea4:	2100      	movs	r1, #0
  400ea6:	47b0      	blx	r6
  400ea8:	2800      	cmp	r0, #0
  400eaa:	f000 80e0 	beq.w	40106e <sd_mmc_check+0x20e>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  400eae:	f8df 9274 	ldr.w	r9, [pc, #628]	; 401124 <sd_mmc_check+0x2c4>
  400eb2:	683d      	ldr	r5, [r7, #0]
  400eb4:	f8df a268 	ldr.w	sl, [pc, #616]	; 401120 <sd_mmc_check+0x2c0>
  400eb8:	47c8      	blx	r9

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400eba:	683b      	ldr	r3, [r7, #0]
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  400ebc:	0c00      	lsrs	r0, r0, #16
  400ebe:	81a8      	strh	r0, [r5, #12]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400ec0:	7bda      	ldrb	r2, [r3, #15]
  400ec2:	07d5      	lsls	r5, r2, #31
  400ec4:	d53a      	bpl.n	400f3c <sd_mmc_check+0xdc>
		if (!sd_mmc_cmd9_mci()) {
  400ec6:	4b8a      	ldr	r3, [pc, #552]	; (4010f0 <sd_mmc_check+0x290>)
  400ec8:	4798      	blx	r3
  400eca:	2800      	cmp	r0, #0
  400ecc:	f000 80cf 	beq.w	40106e <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  400ed0:	f8da 3000 	ldr.w	r3, [sl]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400ed4:	4d87      	ldr	r5, [pc, #540]	; (4010f4 <sd_mmc_check+0x294>)
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400ed6:	7d5a      	ldrb	r2, [r3, #21]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  400ed8:	4887      	ldr	r0, [pc, #540]	; (4010f8 <sd_mmc_check+0x298>)
  400eda:	7c99      	ldrb	r1, [r3, #18]
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  400edc:	f002 0e07 	and.w	lr, r2, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  400ee0:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  400ee4:	f855 502e 	ldr.w	r5, [r5, lr, lsl #2]
  400ee8:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  400eec:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  400ef0:	fb02 f205 	mul.w	r2, r2, r5
  400ef4:	fb00 f202 	mul.w	r2, r0, r2
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400ef8:	0989      	lsrs	r1, r1, #6

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  400efa:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  400efc:	f040 8179 	bne.w	4011f2 <sd_mmc_check+0x392>
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f00:	7e58      	ldrb	r0, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400f02:	f893 c018 	ldrb.w	ip, [r3, #24]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f06:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400f08:	f893 e01a 	ldrb.w	lr, [r3, #26]
  400f0c:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400f0e:	7dda      	ldrb	r2, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f10:	0080      	lsls	r0, r0, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400f12:	ea40 208c 	orr.w	r0, r0, ip, lsl #10
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f16:	0049      	lsls	r1, r1, #1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  400f18:	ea40 109e 	orr.w	r0, r0, lr, lsr #6
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  400f1c:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  400f20:	f3c0 000b 	ubfx	r0, r0, #0, #12
  400f24:	f001 0107 	and.w	r1, r1, #7
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400f28:	3001      	adds	r0, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  400f2a:	3102      	adds	r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  400f2c:	fa00 f101 	lsl.w	r1, r0, r1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400f30:	f002 020f 	and.w	r2, r2, #15
  400f34:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  400f38:	0a92      	lsrs	r2, r2, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  400f3a:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  400f3c:	8999      	ldrh	r1, [r3, #12]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  400f3e:	4d6f      	ldr	r5, [pc, #444]	; (4010fc <sd_mmc_check+0x29c>)
  400f40:	0409      	lsls	r1, r1, #16
  400f42:	f243 1007 	movw	r0, #12551	; 0x3107
  400f46:	47b0      	blx	r6
  400f48:	2800      	cmp	r0, #0
  400f4a:	f000 8090 	beq.w	40106e <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  400f4e:	683b      	ldr	r3, [r7, #0]
  400f50:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 401120 <sd_mmc_check+0x2c0>
  400f54:	7bda      	ldrb	r2, [r3, #15]
  400f56:	07d0      	lsls	r0, r2, #31
  400f58:	d530      	bpl.n	400fbc <sd_mmc_check+0x15c>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400f5a:	8999      	ldrh	r1, [r3, #12]
  400f5c:	f241 1037 	movw	r0, #4407	; 0x1137
  400f60:	0409      	lsls	r1, r1, #16
  400f62:	47a8      	blx	r5
  400f64:	2800      	cmp	r0, #0
  400f66:	f000 8082 	beq.w	40106e <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  400f6a:	2501      	movs	r5, #1
  400f6c:	9500      	str	r5, [sp, #0]
  400f6e:	462b      	mov	r3, r5
  400f70:	4863      	ldr	r0, [pc, #396]	; (401100 <sd_mmc_check+0x2a0>)
  400f72:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 40112c <sd_mmc_check+0x2cc>
  400f76:	2100      	movs	r1, #0
  400f78:	2208      	movs	r2, #8
  400f7a:	47e0      	blx	ip
  400f7c:	2800      	cmp	r0, #0
  400f7e:	d076      	beq.n	40106e <sd_mmc_check+0x20e>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  400f80:	4629      	mov	r1, r5
  400f82:	a804      	add	r0, sp, #16
  400f84:	4b5f      	ldr	r3, [pc, #380]	; (401104 <sd_mmc_check+0x2a4>)
  400f86:	4798      	blx	r3
  400f88:	2800      	cmp	r0, #0
  400f8a:	d070      	beq.n	40106e <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  400f8c:	4b5e      	ldr	r3, [pc, #376]	; (401108 <sd_mmc_check+0x2a8>)
  400f8e:	4798      	blx	r3
  400f90:	2800      	cmp	r0, #0
  400f92:	d06c      	beq.n	40106e <sd_mmc_check+0x20e>
  400f94:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  400f98:	f003 030f 	and.w	r3, r3, #15
  400f9c:	2b01      	cmp	r3, #1
  400f9e:	f000 8223 	beq.w	4013e8 <sd_mmc_check+0x588>
  400fa2:	f0c0 821c 	bcc.w	4013de <sd_mmc_check+0x57e>
  400fa6:	2b02      	cmp	r3, #2
  400fa8:	f040 8219 	bne.w	4013de <sd_mmc_check+0x57e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  400fac:	f89d 3012 	ldrb.w	r3, [sp, #18]
	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  400fb0:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  400fb2:	683b      	ldr	r3, [r7, #0]
  400fb4:	bf14      	ite	ne
  400fb6:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  400fb8:	2220      	moveq	r2, #32
  400fba:	741a      	strb	r2, [r3, #16]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  400fbc:	4d4b      	ldr	r5, [pc, #300]	; (4010ec <sd_mmc_check+0x28c>)
  400fbe:	4b53      	ldr	r3, [pc, #332]	; (40110c <sd_mmc_check+0x2ac>)
  400fc0:	7828      	ldrb	r0, [r5, #0]
  400fc2:	4798      	blx	r3
  400fc4:	2803      	cmp	r0, #3
  400fc6:	d91a      	bls.n	400ffe <sd_mmc_check+0x19e>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  400fc8:	683b      	ldr	r3, [r7, #0]
  400fca:	f8df a154 	ldr.w	sl, [pc, #340]	; 401120 <sd_mmc_check+0x2c0>
  400fce:	7bda      	ldrb	r2, [r3, #15]
  400fd0:	07d1      	lsls	r1, r2, #31
  400fd2:	d512      	bpl.n	400ffa <sd_mmc_check+0x19a>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  400fd4:	8999      	ldrh	r1, [r3, #12]
  400fd6:	f8df b124 	ldr.w	fp, [pc, #292]	; 4010fc <sd_mmc_check+0x29c>
  400fda:	0409      	lsls	r1, r1, #16
  400fdc:	f241 1037 	movw	r0, #4407	; 0x1137
  400fe0:	47b0      	blx	r6
  400fe2:	2800      	cmp	r0, #0
  400fe4:	d044      	beq.n	401070 <sd_mmc_check+0x210>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  400fe6:	f241 1006 	movw	r0, #4358	; 0x1106
  400fea:	2102      	movs	r1, #2
  400fec:	47d8      	blx	fp
  400fee:	2800      	cmp	r0, #0
  400ff0:	d03e      	beq.n	401070 <sd_mmc_check+0x210>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  400ff2:	f8da 3000 	ldr.w	r3, [sl]
  400ff6:	2204      	movs	r2, #4
  400ff8:	745a      	strb	r2, [r3, #17]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  400ffa:	4b45      	ldr	r3, [pc, #276]	; (401110 <sd_mmc_check+0x2b0>)
  400ffc:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  400ffe:	4b45      	ldr	r3, [pc, #276]	; (401114 <sd_mmc_check+0x2b4>)
  401000:	4798      	blx	r3
  401002:	b158      	cbz	r0, 40101c <sd_mmc_check+0x1bc>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  401004:	683b      	ldr	r3, [r7, #0]
  401006:	f8df b118 	ldr.w	fp, [pc, #280]	; 401120 <sd_mmc_check+0x2c0>
  40100a:	7bda      	ldrb	r2, [r3, #15]
  40100c:	07d2      	lsls	r2, r2, #31
  40100e:	d503      	bpl.n	401018 <sd_mmc_check+0x1b8>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  401010:	7c1b      	ldrb	r3, [r3, #16]
  401012:	2b10      	cmp	r3, #16
  401014:	f200 80fa 	bhi.w	40120c <sd_mmc_check+0x3ac>
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  401018:	4b3d      	ldr	r3, [pc, #244]	; (401110 <sd_mmc_check+0x2b0>)
  40101a:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40101c:	683a      	ldr	r2, [r7, #0]
  40101e:	f8df 8100 	ldr.w	r8, [pc, #256]	; 401120 <sd_mmc_check+0x2c0>
  401022:	7bd3      	ldrb	r3, [r2, #15]
  401024:	07d9      	lsls	r1, r3, #31
  401026:	f100 80d9 	bmi.w	4011dc <sd_mmc_check+0x37c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40102a:	7828      	ldrb	r0, [r5, #0]
	//if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			//: sd_mmc_mci_card_init())
	if(sd_mmc_mci_card_init()) 
	{
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  40102c:	2300      	movs	r3, #0
  40102e:	7393      	strb	r3, [r2, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401030:	2800      	cmp	r0, #0
  401032:	f47f af22 	bne.w	400e7a <sd_mmc_check+0x1a>
		driver_deselect_device(sd_mmc_slot_sel);
  401036:	4b38      	ldr	r3, [pc, #224]	; (401118 <sd_mmc_check+0x2b8>)
  401038:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  40103a:	4620      	mov	r0, r4
  40103c:	b015      	add	sp, #84	; 0x54
  40103e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401042:	4b36      	ldr	r3, [pc, #216]	; (40111c <sd_mmc_check+0x2bc>)
  401044:	4798      	blx	r3
sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  401046:	2801      	cmp	r0, #1
  401048:	4604      	mov	r4, r0
  40104a:	f47f af11 	bne.w	400e70 <sd_mmc_check+0x10>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  40104e:	4f34      	ldr	r7, [pc, #208]	; (401120 <sd_mmc_check+0x2c0>)
	sd_mmc_card->version = CARD_VER_UNKNOWN;
	sd_mmc_card->rca = 0;
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  401050:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 401130 <sd_mmc_check+0x2d0>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  401054:	683b      	ldr	r3, [r7, #0]

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  401056:	4e29      	ldr	r6, [pc, #164]	; (4010fc <sd_mmc_check+0x29c>)
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  401058:	73d8      	strb	r0, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  40105a:	741d      	strb	r5, [r3, #16]
	sd_mmc_card->rca = 0;
  40105c:	819d      	strh	r5, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  40105e:	47c0      	blx	r8

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  401060:	4629      	mov	r1, r5
  401062:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  401066:	47b0      	blx	r6
  401068:	2800      	cmp	r0, #0
  40106a:	f47f af0a 	bne.w	400e82 <sd_mmc_check+0x22>
  40106e:	4d1f      	ldr	r5, [pc, #124]	; (4010ec <sd_mmc_check+0x28c>)
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401070:	683b      	ldr	r3, [r7, #0]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401072:	7828      	ldrb	r0, [r5, #0]
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401074:	2403      	movs	r4, #3
  401076:	739c      	strb	r4, [r3, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401078:	2800      	cmp	r0, #0
  40107a:	f47f aefe 	bne.w	400e7a <sd_mmc_check+0x1a>
  40107e:	e7da      	b.n	401036 <sd_mmc_check+0x1d6>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  401080:	4b28      	ldr	r3, [pc, #160]	; (401124 <sd_mmc_check+0x2c4>)
  401082:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  401084:	1c45      	adds	r5, r0, #1
  401086:	f43f af04 	beq.w	400e92 <sd_mmc_check+0x32>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  40108a:	f3c0 000b 	ubfx	r0, r0, #0, #12
  40108e:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  401092:	d1ec      	bne.n	40106e <sd_mmc_check+0x20e>
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  401094:	46a1      	mov	r9, r4
  401096:	e6fe      	b.n	400e96 <sd_mmc_check+0x36>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401098:	f640 0535 	movw	r5, #2101	; 0x835
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  40109c:	f8df a088 	ldr.w	sl, [pc, #136]	; 401128 <sd_mmc_check+0x2c8>
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  4010a0:	f8df b080 	ldr.w	fp, [pc, #128]	; 401124 <sd_mmc_check+0x2c4>
  4010a4:	e00e      	b.n	4010c4 <sd_mmc_check+0x264>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  4010a6:	f1b9 0f00 	cmp.w	r9, #0
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  4010aa:	bf14      	ite	ne
  4010ac:	4651      	movne	r1, sl
  4010ae:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  4010b2:	f244 5029 	movw	r0, #17705	; 0x4529
  4010b6:	47b0      	blx	r6
  4010b8:	b150      	cbz	r0, 4010d0 <sd_mmc_check+0x270>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  4010ba:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  4010bc:	2800      	cmp	r0, #0
  4010be:	db78      	blt.n	4011b2 <sd_mmc_check+0x352>
			if ((resp & OCR_CCS) != 0) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  4010c0:	3d01      	subs	r5, #1
  4010c2:	d005      	beq.n	4010d0 <sd_mmc_check+0x270>
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  4010c4:	f241 1037 	movw	r0, #4407	; 0x1137
  4010c8:	2100      	movs	r1, #0
  4010ca:	47b0      	blx	r6
  4010cc:	2800      	cmp	r0, #0
  4010ce:	d1ea      	bne.n	4010a6 <sd_mmc_check+0x246>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  4010d0:	683b      	ldr	r3, [r7, #0]
  4010d2:	2202      	movs	r2, #2
  4010d4:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  4010d6:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  4010da:	2100      	movs	r1, #0
  4010dc:	47b0      	blx	r6
  4010de:	2800      	cmp	r0, #0
  4010e0:	d0c5      	beq.n	40106e <sd_mmc_check+0x20e>
  4010e2:	f241 0569 	movw	r5, #4201	; 0x1069
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4010e6:	f8df 803c 	ldr.w	r8, [pc, #60]	; 401124 <sd_mmc_check+0x2c4>
  4010ea:	e025      	b.n	401138 <sd_mmc_check+0x2d8>
  4010ec:	20000ec6 	.word	0x20000ec6
  4010f0:	00400e11 	.word	0x00400e11
  4010f4:	00406754 	.word	0x00406754
  4010f8:	00406714 	.word	0x00406714
  4010fc:	00401bfd 	.word	0x00401bfd
  401100:	00081133 	.word	0x00081133
  401104:	00401da9 	.word	0x00401da9
  401108:	00401e11 	.word	0x00401e11
  40110c:	00401b49 	.word	0x00401b49
  401110:	00400ce5 	.word	0x00400ce5
  401114:	00401b55 	.word	0x00401b55
  401118:	00401bd9 	.word	0x00401bd9
  40111c:	00400d11 	.word	0x00400d11
  401120:	20000ec0 	.word	0x20000ec0
  401124:	00401c29 	.word	0x00401c29
  401128:	401f8000 	.word	0x401f8000
  40112c:	00401c55 	.word	0x00401c55
  401130:	00401bdd 	.word	0x00401bdd
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  401134:	3d01      	subs	r5, #1
  401136:	d09a      	beq.n	40106e <sd_mmc_check+0x20e>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  401138:	49af      	ldr	r1, [pc, #700]	; (4013f8 <sd_mmc_check+0x598>)
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  40113a:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 401438 <sd_mmc_check+0x5d8>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  40113e:	f244 5001 	movw	r0, #17665	; 0x4501
  401142:	47b0      	blx	r6
  401144:	2800      	cmp	r0, #0
  401146:	d092      	beq.n	40106e <sd_mmc_check+0x20e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  401148:	47c0      	blx	r8
		if (resp & OCR_POWER_UP_BUSY) {
  40114a:	2800      	cmp	r0, #0
  40114c:	daf2      	bge.n	401134 <sd_mmc_check+0x2d4>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  40114e:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  401152:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  401156:	d104      	bne.n	401162 <sd_mmc_check+0x302>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  401158:	683b      	ldr	r3, [r7, #0]
  40115a:	7bda      	ldrb	r2, [r3, #15]
  40115c:	f042 0208 	orr.w	r2, r2, #8
  401160:	73da      	strb	r2, [r3, #15]
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  401162:	f645 3002 	movw	r0, #23298	; 0x5b02
  401166:	2100      	movs	r1, #0
  401168:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 40143c <sd_mmc_check+0x5dc>
  40116c:	47b0      	blx	r6
  40116e:	2800      	cmp	r0, #0
  401170:	f43f af7d 	beq.w	40106e <sd_mmc_check+0x20e>
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  401174:	683b      	ldr	r3, [r7, #0]
  401176:	4da1      	ldr	r5, [pc, #644]	; (4013fc <sd_mmc_check+0x59c>)
  401178:	2201      	movs	r2, #1
  40117a:	819a      	strh	r2, [r3, #12]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  40117c:	f241 1003 	movw	r0, #4355	; 0x1103
  401180:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  401184:	47c0      	blx	r8
  401186:	2800      	cmp	r0, #0
  401188:	f43f af71 	beq.w	40106e <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  40118c:	4b9c      	ldr	r3, [pc, #624]	; (401400 <sd_mmc_check+0x5a0>)
  40118e:	4798      	blx	r3
  401190:	2800      	cmp	r0, #0
  401192:	f43f af6c 	beq.w	40106e <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  401196:	682b      	ldr	r3, [r5, #0]
  401198:	7c9a      	ldrb	r2, [r3, #18]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  40119a:	f3c2 0283 	ubfx	r2, r2, #2, #4
  40119e:	3a01      	subs	r2, #1
  4011a0:	2a03      	cmp	r2, #3
  4011a2:	f200 817c 	bhi.w	40149e <sd_mmc_check+0x63e>
  4011a6:	e8df f012 	tbh	[pc, r2, lsl #1]
  4011aa:	0177      	.short	0x0177
  4011ac:	0124017d 	.word	0x0124017d
  4011b0:	0068      	.short	0x0068
			return false;
		}
		resp = driver_get_response();
		if (resp & OCR_POWER_UP_BUSY) {
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  4011b2:	0041      	lsls	r1, r0, #1
  4011b4:	d50f      	bpl.n	4011d6 <sd_mmc_check+0x376>
				sd_mmc_card->type |= CARD_TYPE_HC;
  4011b6:	683a      	ldr	r2, [r7, #0]
  4011b8:	7bd3      	ldrb	r3, [r2, #15]
  4011ba:	f043 0308 	orr.w	r3, r3, #8
  4011be:	73d3      	strb	r3, [r2, #15]
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4011c0:	07db      	lsls	r3, r3, #31
  4011c2:	f57f ae6d 	bpl.w	400ea0 <sd_mmc_check+0x40>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  4011c6:	f645 3002 	movw	r0, #23298	; 0x5b02
  4011ca:	2100      	movs	r1, #0
  4011cc:	47b0      	blx	r6
  4011ce:	2800      	cmp	r0, #0
  4011d0:	f47f ae66 	bne.w	400ea0 <sd_mmc_check+0x40>
  4011d4:	e74b      	b.n	40106e <sd_mmc_check+0x20e>
  4011d6:	683b      	ldr	r3, [r7, #0]
  4011d8:	7bdb      	ldrb	r3, [r3, #15]
  4011da:	e7f1      	b.n	4011c0 <sd_mmc_check+0x360>
		// Valid new configuration
		sd_mmc_configure_slot();
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  4011dc:	f241 1010 	movw	r0, #4368	; 0x1110
  4011e0:	f44f 7100 	mov.w	r1, #512	; 0x200
  4011e4:	47b0      	blx	r6
  4011e6:	2800      	cmp	r0, #0
  4011e8:	f43f af42 	beq.w	401070 <sd_mmc_check+0x210>
  4011ec:	f8d8 2000 	ldr.w	r2, [r8]
  4011f0:	e71b      	b.n	40102a <sd_mmc_check+0x1ca>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011f2:	7e59      	ldrb	r1, [r3, #25]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011f4:	7e98      	ldrb	r0, [r3, #26]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4011f6:	7eda      	ldrb	r2, [r3, #27]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011f8:	0409      	lsls	r1, r1, #16
  4011fa:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011fe:	430a      	orrs	r2, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  401200:	f3c2 0215 	ubfx	r2, r2, #0, #22
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  401204:	3201      	adds	r2, #1
  401206:	0252      	lsls	r2, r2, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  401208:	605a      	str	r2, [r3, #4]
  40120a:	e697      	b.n	400f3c <sd_mmc_check+0xdc>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  40120c:	f04f 0a01 	mov.w	sl, #1
  401210:	f8cd a000 	str.w	sl, [sp]
  401214:	4653      	mov	r3, sl
  401216:	487b      	ldr	r0, [pc, #492]	; (401404 <sd_mmc_check+0x5a4>)
  401218:	497b      	ldr	r1, [pc, #492]	; (401408 <sd_mmc_check+0x5a8>)
  40121a:	f8df c204 	ldr.w	ip, [pc, #516]	; 401420 <sd_mmc_check+0x5c0>
  40121e:	2240      	movs	r2, #64	; 0x40
  401220:	47e0      	blx	ip
  401222:	2800      	cmp	r0, #0
  401224:	f43f af24 	beq.w	401070 <sd_mmc_check+0x210>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  401228:	a804      	add	r0, sp, #16
  40122a:	4651      	mov	r1, sl
  40122c:	4b77      	ldr	r3, [pc, #476]	; (40140c <sd_mmc_check+0x5ac>)
  40122e:	4798      	blx	r3
  401230:	2800      	cmp	r0, #0
  401232:	f43f af1d 	beq.w	401070 <sd_mmc_check+0x210>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  401236:	4b76      	ldr	r3, [pc, #472]	; (401410 <sd_mmc_check+0x5b0>)
  401238:	4798      	blx	r3
  40123a:	2800      	cmp	r0, #0
  40123c:	f43f af18 	beq.w	401070 <sd_mmc_check+0x210>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401240:	47c8      	blx	r9
  401242:	0600      	lsls	r0, r0, #24
  401244:	f53f af14 	bmi.w	401070 <sd_mmc_check+0x210>
  401248:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  40124c:	f003 030f 	and.w	r3, r3, #15
  401250:	2b0f      	cmp	r3, #15
  401252:	f43f aee1 	beq.w	401018 <sd_mmc_check+0x1b8>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401256:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40125a:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  40125e:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  401262:	f47f af05 	bne.w	401070 <sd_mmc_check+0x210>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  401266:	47c0      	blx	r8
	sd_mmc_card->high_speed = 1;
  401268:	f8db 3000 	ldr.w	r3, [fp]
	sd_mmc_card->clock *= 2;
  40126c:	681a      	ldr	r2, [r3, #0]
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
	sd_mmc_card->high_speed = 1;
  40126e:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
	sd_mmc_card->clock *= 2;
  401272:	fa02 f20a 	lsl.w	r2, r2, sl
  401276:	601a      	str	r2, [r3, #0]
  401278:	e6ce      	b.n	401018 <sd_mmc_check+0x1b8>
	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  40127a:	2240      	movs	r2, #64	; 0x40
  40127c:	741a      	strb	r2, [r3, #16]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40127e:	7d5a      	ldrb	r2, [r3, #21]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401280:	f893 e019 	ldrb.w	lr, [r3, #25]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401284:	4963      	ldr	r1, [pc, #396]	; (401414 <sd_mmc_check+0x5b4>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  401286:	4864      	ldr	r0, [pc, #400]	; (401418 <sd_mmc_check+0x5b8>)
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401288:	f893 c018 	ldrb.w	ip, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40128c:	7e9d      	ldrb	r5, [r3, #26]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  40128e:	f002 0807 	and.w	r8, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  401292:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  401296:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  40129a:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40129e:	ea4f 028e 	mov.w	r2, lr, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4012a2:	ea42 228c 	orr.w	r2, r2, ip, lsl #10
  4012a6:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
  4012aa:	fb0e f101 	mul.w	r1, lr, r1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4012ae:	ea42 1295 	orr.w	r2, r2, r5, lsr #6
  4012b2:	fb00 f001 	mul.w	r0, r0, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  4012b6:	f3c2 020b 	ubfx	r2, r2, #0, #12
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  4012ba:	f640 71ff 	movw	r1, #4095	; 0xfff
  4012be:	428a      	cmp	r2, r1

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  4012c0:	6018      	str	r0, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  4012c2:	d011      	beq.n	4012e8 <sd_mmc_check+0x488>
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4012c4:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4012c6:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4012c8:	7dd8      	ldrb	r0, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4012ca:	0049      	lsls	r1, r1, #1
  4012cc:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4012d0:	f001 0107 	and.w	r1, r1, #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4012d4:	3201      	adds	r2, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4012d6:	3102      	adds	r1, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  4012d8:	fa02 f101 	lsl.w	r1, r2, r1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4012dc:	f000 020f 	and.w	r2, r0, #15
  4012e0:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4012e4:	0a92      	lsrs	r2, r2, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4012e6:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4012e8:	8999      	ldrh	r1, [r3, #12]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4012ea:	f243 1007 	movw	r0, #12551	; 0x3107
  4012ee:	0409      	lsls	r1, r1, #16
  4012f0:	47b0      	blx	r6
  4012f2:	2800      	cmp	r0, #0
  4012f4:	f43f aebb 	beq.w	40106e <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  4012f8:	683b      	ldr	r3, [r7, #0]
  4012fa:	7c1b      	ldrb	r3, [r3, #16]
  4012fc:	2b3f      	cmp	r3, #63	; 0x3f
  4012fe:	f240 80b1 	bls.w	401464 <sd_mmc_check+0x604>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  401302:	2100      	movs	r1, #0
  401304:	9100      	str	r1, [sp, #0]
  401306:	4845      	ldr	r0, [pc, #276]	; (40141c <sd_mmc_check+0x5bc>)
  401308:	4d45      	ldr	r5, [pc, #276]	; (401420 <sd_mmc_check+0x5c0>)
  40130a:	f44f 7200 	mov.w	r2, #512	; 0x200
  40130e:	2301      	movs	r3, #1
  401310:	47a8      	blx	r5
  401312:	2800      	cmp	r0, #0
  401314:	f43f aeab 	beq.w	40106e <sd_mmc_check+0x20e>
  401318:	f8df 8124 	ldr.w	r8, [pc, #292]	; 401440 <sd_mmc_check+0x5e0>
  40131c:	2532      	movs	r5, #50	; 0x32
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  40131e:	a803      	add	r0, sp, #12
  401320:	47c0      	blx	r8
  401322:	3d01      	subs	r5, #1
  401324:	b2ad      	uxth	r5, r5
  401326:	2800      	cmp	r0, #0
  401328:	f43f aea1 	beq.w	40106e <sd_mmc_check+0x20e>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  40132c:	2d00      	cmp	r5, #0
  40132e:	d1f6      	bne.n	40131e <sd_mmc_check+0x4be>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401330:	683b      	ldr	r3, [r7, #0]
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  401332:	9a03      	ldr	r2, [sp, #12]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401334:	7e5d      	ldrb	r5, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401336:	7e18      	ldrb	r0, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401338:	7e99      	ldrb	r1, [r3, #26]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40133a:	00ab      	lsls	r3, r5, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40133c:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401340:	ea43 1191 	orr.w	r1, r3, r1, lsr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  401344:	f3c1 010b 	ubfx	r1, r1, #0, #12
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401348:	f640 73ff 	movw	r3, #4095	; 0xfff
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  40134c:	f002 0202 	and.w	r2, r2, #2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401350:	4299      	cmp	r1, r3
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  401352:	fa5f fa82 	uxtb.w	sl, r2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401356:	f04f 0532 	mov.w	r5, #50	; 0x32
  40135a:	f10d 0b10 	add.w	fp, sp, #16
  40135e:	d073      	beq.n	401448 <sd_mmc_check+0x5e8>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  401360:	4658      	mov	r0, fp
  401362:	47c0      	blx	r8
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  401364:	3501      	adds	r5, #1
  401366:	b2ad      	uxth	r5, r5
		if (!driver_read_word(&sec_count)) {
  401368:	2800      	cmp	r0, #0
  40136a:	f43f ae80 	beq.w	40106e <sd_mmc_check+0x20e>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  40136e:	2d7f      	cmp	r5, #127	; 0x7f
  401370:	d9f6      	bls.n	401360 <sd_mmc_check+0x500>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  401372:	4d2c      	ldr	r5, [pc, #176]	; (401424 <sd_mmc_check+0x5c4>)
  401374:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 401444 <sd_mmc_check+0x5e4>
  401378:	7828      	ldrb	r0, [r5, #0]
  40137a:	47c0      	blx	r8
  40137c:	2803      	cmp	r0, #3
  40137e:	d918      	bls.n	4013b2 <sd_mmc_check+0x552>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401380:	7828      	ldrb	r0, [r5, #0]
  401382:	47c0      	blx	r8
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  401384:	2804      	cmp	r0, #4
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401386:	4680      	mov	r8, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  401388:	d070      	beq.n	40146c <sd_mmc_check+0x60c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  40138a:	4927      	ldr	r1, [pc, #156]	; (401428 <sd_mmc_check+0x5c8>)
  40138c:	4b27      	ldr	r3, [pc, #156]	; (40142c <sd_mmc_check+0x5cc>)
  40138e:	2808      	cmp	r0, #8
  401390:	bf18      	it	ne
  401392:	4619      	movne	r1, r3
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  401394:	f243 1006 	movw	r0, #12550	; 0x3106
  401398:	47b0      	blx	r6
  40139a:	2800      	cmp	r0, #0
  40139c:	f43f ae68 	beq.w	401070 <sd_mmc_check+0x210>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  4013a0:	47c8      	blx	r9
  4013a2:	0602      	lsls	r2, r0, #24
  4013a4:	f53f ae64 	bmi.w	401070 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  4013a8:	683b      	ldr	r3, [r7, #0]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  4013aa:	4a21      	ldr	r2, [pc, #132]	; (401430 <sd_mmc_check+0x5d0>)
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  4013ac:	f883 8011 	strb.w	r8, [r3, #17]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  4013b0:	4790      	blx	r2
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  4013b2:	4b20      	ldr	r3, [pc, #128]	; (401434 <sd_mmc_check+0x5d4>)
  4013b4:	4798      	blx	r3
  4013b6:	b110      	cbz	r0, 4013be <sd_mmc_check+0x55e>
  4013b8:	f1ba 0f00 	cmp.w	sl, #0
  4013bc:	d158      	bne.n	401470 <sd_mmc_check+0x610>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  4013be:	f04f 080a 	mov.w	r8, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  4013c2:	f241 1010 	movw	r0, #4368	; 0x1110
  4013c6:	f44f 7100 	mov.w	r1, #512	; 0x200
  4013ca:	47b0      	blx	r6
  4013cc:	f108 38ff 	add.w	r8, r8, #4294967295
  4013d0:	2800      	cmp	r0, #0
  4013d2:	d16a      	bne.n	4014aa <sd_mmc_check+0x64a>
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  4013d4:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
  4013d8:	f43f ae4a 	beq.w	401070 <sd_mmc_check+0x210>
  4013dc:	e7f1      	b.n	4013c2 <sd_mmc_check+0x562>
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  4013de:	f8da 3000 	ldr.w	r3, [sl]
  4013e2:	2210      	movs	r2, #16
  4013e4:	741a      	strb	r2, [r3, #16]
  4013e6:	e5e9      	b.n	400fbc <sd_mmc_check+0x15c>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  4013e8:	f8da 3000 	ldr.w	r3, [sl]
  4013ec:	221a      	movs	r2, #26
  4013ee:	741a      	strb	r2, [r3, #16]
  4013f0:	e5e4      	b.n	400fbc <sd_mmc_check+0x15c>
	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  4013f2:	2230      	movs	r2, #48	; 0x30
  4013f4:	741a      	strb	r2, [r3, #16]
  4013f6:	e742      	b.n	40127e <sd_mmc_check+0x41e>
  4013f8:	401f8000 	.word	0x401f8000
  4013fc:	20000ec0 	.word	0x20000ec0
  401400:	00400e11 	.word	0x00400e11
  401404:	00081106 	.word	0x00081106
  401408:	80ffff01 	.word	0x80ffff01
  40140c:	00401da9 	.word	0x00401da9
  401410:	00401e11 	.word	0x00401e11
  401414:	00406754 	.word	0x00406754
  401418:	00406770 	.word	0x00406770
  40141c:	00081108 	.word	0x00081108
  401420:	00401c55 	.word	0x00401c55
  401424:	20000ec6 	.word	0x20000ec6
  401428:	01b70200 	.word	0x01b70200
  40142c:	01b70000 	.word	0x01b70000
  401430:	00400ce5 	.word	0x00400ce5
  401434:	00401b55 	.word	0x00401b55
  401438:	00401c29 	.word	0x00401c29
  40143c:	00401bfd 	.word	0x00401bfd
  401440:	00401d05 	.word	0x00401d05
  401444:	00401b49 	.word	0x00401b49

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  401448:	4658      	mov	r0, fp
  40144a:	47c0      	blx	r8
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  40144c:	3501      	adds	r5, #1
  40144e:	b2ad      	uxth	r5, r5
			if (!driver_read_word(&sec_count)) {
  401450:	2800      	cmp	r0, #0
  401452:	f43f ae0c 	beq.w	40106e <sd_mmc_check+0x20e>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  401456:	2d36      	cmp	r5, #54	; 0x36
  401458:	d1f6      	bne.n	401448 <sd_mmc_check+0x5e8>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  40145a:	9a04      	ldr	r2, [sp, #16]
  40145c:	683b      	ldr	r3, [r7, #0]
  40145e:	0852      	lsrs	r2, r2, #1
  401460:	605a      	str	r2, [r3, #4]
  401462:	e77d      	b.n	401360 <sd_mmc_check+0x500>
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  401464:	4b12      	ldr	r3, [pc, #72]	; (4014b0 <sd_mmc_check+0x650>)
  401466:	4d13      	ldr	r5, [pc, #76]	; (4014b4 <sd_mmc_check+0x654>)
  401468:	4798      	blx	r3
  40146a:	e7a8      	b.n	4013be <sd_mmc_check+0x55e>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  40146c:	4912      	ldr	r1, [pc, #72]	; (4014b8 <sd_mmc_check+0x658>)
  40146e:	e791      	b.n	401394 <sd_mmc_check+0x534>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  401470:	f243 1006 	movw	r0, #12550	; 0x3106
  401474:	4911      	ldr	r1, [pc, #68]	; (4014bc <sd_mmc_check+0x65c>)
  401476:	47b0      	blx	r6
  401478:	2800      	cmp	r0, #0
  40147a:	f43f adf9 	beq.w	401070 <sd_mmc_check+0x210>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  40147e:	47c8      	blx	r9
  401480:	0603      	lsls	r3, r0, #24
  401482:	f53f adf5 	bmi.w	401070 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  401486:	683b      	ldr	r3, [r7, #0]
	sd_mmc_card->clock = 52000000lu;
  401488:	4a0d      	ldr	r2, [pc, #52]	; (4014c0 <sd_mmc_check+0x660>)
  40148a:	601a      	str	r2, [r3, #0]
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  40148c:	2201      	movs	r2, #1
  40148e:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  401492:	4b07      	ldr	r3, [pc, #28]	; (4014b0 <sd_mmc_check+0x650>)
  401494:	4798      	blx	r3
  401496:	e792      	b.n	4013be <sd_mmc_check+0x55e>
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  401498:	2214      	movs	r2, #20
  40149a:	741a      	strb	r2, [r3, #16]
  40149c:	e6ef      	b.n	40127e <sd_mmc_check+0x41e>

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  40149e:	2212      	movs	r2, #18
  4014a0:	741a      	strb	r2, [r3, #16]
  4014a2:	e6ec      	b.n	40127e <sd_mmc_check+0x41e>
	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  4014a4:	2222      	movs	r2, #34	; 0x22
  4014a6:	741a      	strb	r2, [r3, #16]
  4014a8:	e6e9      	b.n	40127e <sd_mmc_check+0x41e>
  4014aa:	683a      	ldr	r2, [r7, #0]
  4014ac:	e5bd      	b.n	40102a <sd_mmc_check+0x1ca>
  4014ae:	bf00      	nop
  4014b0:	00400ce5 	.word	0x00400ce5
  4014b4:	20000ec6 	.word	0x20000ec6
  4014b8:	01b70100 	.word	0x01b70100
  4014bc:	03b90100 	.word	0x03b90100
  4014c0:	03197500 	.word	0x03197500

004014c4 <sd_mmc_get_type>:
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
  4014c4:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4014c6:	b108      	cbz	r0, 4014cc <sd_mmc_get_type+0x8>
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  4014c8:	2000      	movs	r0, #0
  4014ca:	bd08      	pop	{r3, pc}
  4014cc:	4b08      	ldr	r3, [pc, #32]	; (4014f0 <sd_mmc_get_type+0x2c>)
  4014ce:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4014d0:	2800      	cmp	r0, #0
  4014d2:	d1f9      	bne.n	4014c8 <sd_mmc_get_type+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4014d4:	4b07      	ldr	r3, [pc, #28]	; (4014f4 <sd_mmc_get_type+0x30>)
  4014d6:	781b      	ldrb	r3, [r3, #0]
  4014d8:	b11b      	cbz	r3, 4014e2 <sd_mmc_get_type+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  4014da:	4b07      	ldr	r3, [pc, #28]	; (4014f8 <sd_mmc_get_type+0x34>)
  4014dc:	681b      	ldr	r3, [r3, #0]
  4014de:	7bd8      	ldrb	r0, [r3, #15]
}
  4014e0:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4014e2:	4b06      	ldr	r3, [pc, #24]	; (4014fc <sd_mmc_get_type+0x38>)
  4014e4:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  4014e6:	4b04      	ldr	r3, [pc, #16]	; (4014f8 <sd_mmc_get_type+0x34>)
  4014e8:	681b      	ldr	r3, [r3, #0]
  4014ea:	7bd8      	ldrb	r0, [r3, #15]
}
  4014ec:	bd08      	pop	{r3, pc}
  4014ee:	bf00      	nop
  4014f0:	00400d11 	.word	0x00400d11
  4014f4:	20000ec6 	.word	0x20000ec6
  4014f8:	20000ec0 	.word	0x20000ec0
  4014fc:	00401bd9 	.word	0x00401bd9

00401500 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  401500:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  401502:	b108      	cbz	r0, 401508 <sd_mmc_get_capacity+0x8>
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  401504:	2000      	movs	r0, #0
  401506:	bd08      	pop	{r3, pc}
  401508:	4b08      	ldr	r3, [pc, #32]	; (40152c <sd_mmc_get_capacity+0x2c>)
  40150a:	4798      	blx	r3
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  40150c:	2800      	cmp	r0, #0
  40150e:	d1f9      	bne.n	401504 <sd_mmc_get_capacity+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401510:	4b07      	ldr	r3, [pc, #28]	; (401530 <sd_mmc_get_capacity+0x30>)
  401512:	781b      	ldrb	r3, [r3, #0]
  401514:	b11b      	cbz	r3, 40151e <sd_mmc_get_capacity+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  401516:	4b07      	ldr	r3, [pc, #28]	; (401534 <sd_mmc_get_capacity+0x34>)
  401518:	681b      	ldr	r3, [r3, #0]
  40151a:	6858      	ldr	r0, [r3, #4]
}
  40151c:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  40151e:	4b06      	ldr	r3, [pc, #24]	; (401538 <sd_mmc_get_capacity+0x38>)
  401520:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  401522:	4b04      	ldr	r3, [pc, #16]	; (401534 <sd_mmc_get_capacity+0x34>)
  401524:	681b      	ldr	r3, [r3, #0]
  401526:	6858      	ldr	r0, [r3, #4]
}
  401528:	bd08      	pop	{r3, pc}
  40152a:	bf00      	nop
  40152c:	00400d11 	.word	0x00400d11
  401530:	20000ec6 	.word	0x20000ec6
  401534:	20000ec0 	.word	0x20000ec0
  401538:	00401bd9 	.word	0x00401bd9

0040153c <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  40153c:	2000      	movs	r0, #0
  40153e:	4770      	bx	lr

00401540 <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401540:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401544:	468b      	mov	fp, r1
  401546:	b083      	sub	sp, #12
  401548:	4692      	mov	sl, r2
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40154a:	b128      	cbz	r0, 401558 <sd_mmc_init_read_blocks+0x18>
		return SD_MMC_ERR_SLOT;
  40154c:	f04f 0904 	mov.w	r9, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401550:	4648      	mov	r0, r9
  401552:	b003      	add	sp, #12
  401554:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401558:	4b26      	ldr	r3, [pc, #152]	; (4015f4 <sd_mmc_init_read_blocks+0xb4>)
  40155a:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  40155c:	4681      	mov	r9, r0
  40155e:	2800      	cmp	r0, #0
  401560:	d1f6      	bne.n	401550 <sd_mmc_init_read_blocks+0x10>
  401562:	4c25      	ldr	r4, [pc, #148]	; (4015f8 <sd_mmc_init_read_blocks+0xb8>)
  401564:	4d25      	ldr	r5, [pc, #148]	; (4015fc <sd_mmc_init_read_blocks+0xbc>)
  401566:	4e26      	ldr	r6, [pc, #152]	; (401600 <sd_mmc_init_read_blocks+0xc0>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401568:	4f26      	ldr	r7, [pc, #152]	; (401604 <sd_mmc_init_read_blocks+0xc4>)
  40156a:	e004      	b.n	401576 <sd_mmc_init_read_blocks+0x36>
  40156c:	47b8      	blx	r7
  40156e:	05c2      	lsls	r2, r0, #23
  401570:	d414      	bmi.n	40159c <sd_mmc_init_read_blocks+0x5c>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  401572:	3c01      	subs	r4, #1
  401574:	d009      	beq.n	40158a <sd_mmc_init_read_blocks+0x4a>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  401576:	682b      	ldr	r3, [r5, #0]
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  401578:	f8df 8088 	ldr.w	r8, [pc, #136]	; 401604 <sd_mmc_init_read_blocks+0xc4>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40157c:	8999      	ldrh	r1, [r3, #12]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  40157e:	f241 100d 	movw	r0, #4365	; 0x110d
  401582:	0409      	lsls	r1, r1, #16
  401584:	47b0      	blx	r6
  401586:	2800      	cmp	r0, #0
  401588:	d1f0      	bne.n	40156c <sd_mmc_init_read_blocks+0x2c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40158a:	4b1f      	ldr	r3, [pc, #124]	; (401608 <sd_mmc_init_read_blocks+0xc8>)
  40158c:	781b      	ldrb	r3, [r3, #0]
  40158e:	b33b      	cbz	r3, 4015e0 <sd_mmc_init_read_blocks+0xa0>
		arg = (start * SD_MMC_BLOCK_SIZE);
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401590:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401594:	4648      	mov	r0, r9
  401596:	b003      	add	sp, #12
  401598:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40159c:	682b      	ldr	r3, [r5, #0]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  40159e:	481b      	ldr	r0, [pc, #108]	; (40160c <sd_mmc_init_read_blocks+0xcc>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4015a0:	7bdb      	ldrb	r3, [r3, #15]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  4015a2:	4a1b      	ldr	r2, [pc, #108]	; (401610 <sd_mmc_init_read_blocks+0xd0>)
  4015a4:	f1ba 0f01 	cmp.w	sl, #1
  4015a8:	bf98      	it	ls
  4015aa:	4610      	movls	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4015ac:	071b      	lsls	r3, r3, #28
  4015ae:	d401      	bmi.n	4015b4 <sd_mmc_init_read_blocks+0x74>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4015b0:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4015b4:	2301      	movs	r3, #1
  4015b6:	9300      	str	r3, [sp, #0]
  4015b8:	4659      	mov	r1, fp
  4015ba:	f44f 7200 	mov.w	r2, #512	; 0x200
  4015be:	4653      	mov	r3, sl
  4015c0:	4c14      	ldr	r4, [pc, #80]	; (401614 <sd_mmc_init_read_blocks+0xd4>)
  4015c2:	47a0      	blx	r4
  4015c4:	2800      	cmp	r0, #0
  4015c6:	d0e0      	beq.n	40158a <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4015c8:	47c0      	blx	r8
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4015ca:	4b13      	ldr	r3, [pc, #76]	; (401618 <sd_mmc_init_read_blocks+0xd8>)
  4015cc:	4003      	ands	r3, r0
  4015ce:	2b00      	cmp	r3, #0
  4015d0:	d1db      	bne.n	40158a <sd_mmc_init_read_blocks+0x4a>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4015d2:	4a12      	ldr	r2, [pc, #72]	; (40161c <sd_mmc_init_read_blocks+0xdc>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  4015d4:	4b12      	ldr	r3, [pc, #72]	; (401620 <sd_mmc_init_read_blocks+0xe0>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4015d6:	f8a2 a000 	strh.w	sl, [r2]
	sd_mmc_nb_block_to_tranfer = nb_block;
  4015da:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  4015de:	e7b7      	b.n	401550 <sd_mmc_init_read_blocks+0x10>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4015e0:	2000      	movs	r0, #0
  4015e2:	4b10      	ldr	r3, [pc, #64]	; (401624 <sd_mmc_init_read_blocks+0xe4>)
  4015e4:	4798      	blx	r3
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  4015e6:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4015ea:	4648      	mov	r0, r9
  4015ec:	b003      	add	sp, #12
  4015ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4015f2:	bf00      	nop
  4015f4:	00400d11 	.word	0x00400d11
  4015f8:	00030d41 	.word	0x00030d41
  4015fc:	20000ec0 	.word	0x20000ec0
  401600:	00401bfd 	.word	0x00401bfd
  401604:	00401c29 	.word	0x00401c29
  401608:	20000ec6 	.word	0x20000ec6
  40160c:	00101112 	.word	0x00101112
  401610:	00081111 	.word	0x00081111
  401614:	00401c55 	.word	0x00401c55
  401618:	e4580000 	.word	0xe4580000
  40161c:	20000ec4 	.word	0x20000ec4
  401620:	20000ebc 	.word	0x20000ebc
  401624:	00401bd9 	.word	0x00401bd9

00401628 <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  401628:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  40162a:	4b07      	ldr	r3, [pc, #28]	; (401648 <sd_mmc_start_read_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  40162c:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  40162e:	4798      	blx	r3
  401630:	4603      	mov	r3, r0
  401632:	b918      	cbnz	r0, 40163c <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  401634:	4a05      	ldr	r2, [pc, #20]	; (40164c <sd_mmc_start_read_blocks+0x24>)
  401636:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  401638:	2005      	movs	r0, #5
  40163a:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  40163c:	4b03      	ldr	r3, [pc, #12]	; (40164c <sd_mmc_start_read_blocks+0x24>)
  40163e:	881a      	ldrh	r2, [r3, #0]
  401640:	1b14      	subs	r4, r2, r4
  401642:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401644:	2000      	movs	r0, #0
}
  401646:	bd10      	pop	{r4, pc}
  401648:	00401da9 	.word	0x00401da9
  40164c:	20000ec4 	.word	0x20000ec4

00401650 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  401650:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
  401652:	4b12      	ldr	r3, [pc, #72]	; (40169c <sd_mmc_wait_end_of_read_blocks+0x4c>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  401654:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  401656:	4798      	blx	r3
  401658:	b908      	cbnz	r0, 40165e <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  40165a:	2005      	movs	r0, #5
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  40165c:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  40165e:	4b10      	ldr	r3, [pc, #64]	; (4016a0 <sd_mmc_wait_end_of_read_blocks+0x50>)
sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401660:	b99c      	cbnz	r4, 40168a <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  401662:	881b      	ldrh	r3, [r3, #0]
  401664:	b97b      	cbnz	r3, 401686 <sd_mmc_wait_end_of_read_blocks+0x36>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401666:	4b0f      	ldr	r3, [pc, #60]	; (4016a4 <sd_mmc_wait_end_of_read_blocks+0x54>)
  401668:	881b      	ldrh	r3, [r3, #0]
  40166a:	2b01      	cmp	r3, #1
  40166c:	d005      	beq.n	40167a <sd_mmc_wait_end_of_read_blocks+0x2a>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  40166e:	f243 100c 	movw	r0, #12556	; 0x310c
  401672:	2100      	movs	r1, #0
  401674:	4c0c      	ldr	r4, [pc, #48]	; (4016a8 <sd_mmc_wait_end_of_read_blocks+0x58>)
  401676:	47a0      	blx	r4
  401678:	b150      	cbz	r0, 401690 <sd_mmc_wait_end_of_read_blocks+0x40>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40167a:	4b0c      	ldr	r3, [pc, #48]	; (4016ac <sd_mmc_wait_end_of_read_blocks+0x5c>)
  40167c:	781b      	ldrb	r3, [r3, #0]
  40167e:	b913      	cbnz	r3, 401686 <sd_mmc_wait_end_of_read_blocks+0x36>
		driver_deselect_device(sd_mmc_slot_sel);
  401680:	2000      	movs	r0, #0
  401682:	4b0b      	ldr	r3, [pc, #44]	; (4016b0 <sd_mmc_wait_end_of_read_blocks+0x60>)
  401684:	4798      	blx	r3

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  401686:	2000      	movs	r0, #0
  401688:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  40168a:	2200      	movs	r2, #0
  40168c:	801a      	strh	r2, [r3, #0]
  40168e:	e7ea      	b.n	401666 <sd_mmc_wait_end_of_read_blocks+0x16>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  401690:	4601      	mov	r1, r0
  401692:	f243 100c 	movw	r0, #12556	; 0x310c
  401696:	47a0      	blx	r4
  401698:	e7ef      	b.n	40167a <sd_mmc_wait_end_of_read_blocks+0x2a>
  40169a:	bf00      	nop
  40169c:	00401e11 	.word	0x00401e11
  4016a0:	20000ec4 	.word	0x20000ec4
  4016a4:	20000ebc 	.word	0x20000ebc
  4016a8:	00401bfd 	.word	0x00401bfd
  4016ac:	20000ec6 	.word	0x20000ec6
  4016b0:	00401bd9 	.word	0x00401bd9

004016b4 <sd_mmc_init_write_blocks>:
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  4016b4:	b570      	push	{r4, r5, r6, lr}
  4016b6:	4615      	mov	r5, r2
  4016b8:	b084      	sub	sp, #16
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4016ba:	b118      	cbz	r0, 4016c4 <sd_mmc_init_write_blocks+0x10>
		return SD_MMC_ERR_SLOT;
  4016bc:	2404      	movs	r4, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4016be:	4620      	mov	r0, r4
  4016c0:	b004      	add	sp, #16
  4016c2:	bd70      	pop	{r4, r5, r6, pc}
  4016c4:	9103      	str	r1, [sp, #12]
  4016c6:	4b18      	ldr	r3, [pc, #96]	; (401728 <sd_mmc_init_write_blocks+0x74>)
  4016c8:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  4016ca:	9903      	ldr	r1, [sp, #12]
  4016cc:	4604      	mov	r4, r0
  4016ce:	2800      	cmp	r0, #0
  4016d0:	d1f5      	bne.n	4016be <sd_mmc_init_write_blocks+0xa>
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4016d2:	4b16      	ldr	r3, [pc, #88]	; (40172c <sd_mmc_init_write_blocks+0x78>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4016d4:	4a16      	ldr	r2, [pc, #88]	; (401730 <sd_mmc_init_write_blocks+0x7c>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4016d6:	681b      	ldr	r3, [r3, #0]
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4016d8:	4816      	ldr	r0, [pc, #88]	; (401734 <sd_mmc_init_write_blocks+0x80>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4016da:	7bdb      	ldrb	r3, [r3, #15]
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4016dc:	4e16      	ldr	r6, [pc, #88]	; (401738 <sd_mmc_init_write_blocks+0x84>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4016de:	2d01      	cmp	r5, #1
  4016e0:	bf88      	it	hi
  4016e2:	4610      	movhi	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4016e4:	071b      	lsls	r3, r3, #28
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4016e6:	f04f 0301 	mov.w	r3, #1
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4016ea:	bf58      	it	pl
  4016ec:	0249      	lslpl	r1, r1, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4016ee:	9300      	str	r3, [sp, #0]
  4016f0:	f44f 7200 	mov.w	r2, #512	; 0x200
  4016f4:	462b      	mov	r3, r5
  4016f6:	47b0      	blx	r6
  4016f8:	b930      	cbnz	r0, 401708 <sd_mmc_init_write_blocks+0x54>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4016fa:	4b10      	ldr	r3, [pc, #64]	; (40173c <sd_mmc_init_write_blocks+0x88>)
  4016fc:	781b      	ldrb	r3, [r3, #0]
  4016fe:	b173      	cbz	r3, 40171e <sd_mmc_init_write_blocks+0x6a>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401700:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401702:	4620      	mov	r0, r4
  401704:	b004      	add	sp, #16
  401706:	bd70      	pop	{r4, r5, r6, pc}
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  401708:	4b0d      	ldr	r3, [pc, #52]	; (401740 <sd_mmc_init_write_blocks+0x8c>)
  40170a:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  40170c:	4b0d      	ldr	r3, [pc, #52]	; (401744 <sd_mmc_init_write_blocks+0x90>)
  40170e:	4003      	ands	r3, r0
  401710:	2b00      	cmp	r3, #0
  401712:	d1f2      	bne.n	4016fa <sd_mmc_init_write_blocks+0x46>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  401714:	4a0c      	ldr	r2, [pc, #48]	; (401748 <sd_mmc_init_write_blocks+0x94>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  401716:	4b0d      	ldr	r3, [pc, #52]	; (40174c <sd_mmc_init_write_blocks+0x98>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  401718:	8015      	strh	r5, [r2, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  40171a:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  40171c:	e7cf      	b.n	4016be <sd_mmc_init_write_blocks+0xa>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  40171e:	2000      	movs	r0, #0
  401720:	4b0b      	ldr	r3, [pc, #44]	; (401750 <sd_mmc_init_write_blocks+0x9c>)
  401722:	4798      	blx	r3
  401724:	e7ec      	b.n	401700 <sd_mmc_init_write_blocks+0x4c>
  401726:	bf00      	nop
  401728:	00400d11 	.word	0x00400d11
  40172c:	20000ec0 	.word	0x20000ec0
  401730:	00109119 	.word	0x00109119
  401734:	00089118 	.word	0x00089118
  401738:	00401c55 	.word	0x00401c55
  40173c:	20000ec6 	.word	0x20000ec6
  401740:	00401c29 	.word	0x00401c29
  401744:	e4580000 	.word	0xe4580000
  401748:	20000ec4 	.word	0x20000ec4
  40174c:	20000ebc 	.word	0x20000ebc
  401750:	00401bd9 	.word	0x00401bd9

00401754 <sd_mmc_start_write_blocks>:
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  401754:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  401756:	4b07      	ldr	r3, [pc, #28]	; (401774 <sd_mmc_start_write_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  401758:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  40175a:	4798      	blx	r3
  40175c:	4603      	mov	r3, r0
  40175e:	b918      	cbnz	r0, 401768 <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  401760:	4a05      	ldr	r2, [pc, #20]	; (401778 <sd_mmc_start_write_blocks+0x24>)
  401762:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  401764:	2005      	movs	r0, #5
  401766:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401768:	4b03      	ldr	r3, [pc, #12]	; (401778 <sd_mmc_start_write_blocks+0x24>)
  40176a:	881a      	ldrh	r2, [r3, #0]
  40176c:	1b14      	subs	r4, r2, r4
  40176e:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401770:	2000      	movs	r0, #0
}
  401772:	bd10      	pop	{r4, pc}
  401774:	00401eb5 	.word	0x00401eb5
  401778:	20000ec4 	.word	0x20000ec4

0040177c <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  40177c:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
  40177e:	4b14      	ldr	r3, [pc, #80]	; (4017d0 <sd_mmc_wait_end_of_write_blocks+0x54>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401780:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  401782:	4798      	blx	r3
  401784:	b908      	cbnz	r0, 40178a <sd_mmc_wait_end_of_write_blocks+0xe>
	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
  401786:	2005      	movs	r0, #5
  401788:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  40178a:	4b12      	ldr	r3, [pc, #72]	; (4017d4 <sd_mmc_wait_end_of_write_blocks+0x58>)
sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  40178c:	b994      	cbnz	r4, 4017b4 <sd_mmc_wait_end_of_write_blocks+0x38>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  40178e:	881b      	ldrh	r3, [r3, #0]
  401790:	b9e3      	cbnz	r3, 4017cc <sd_mmc_wait_end_of_write_blocks+0x50>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401792:	4b11      	ldr	r3, [pc, #68]	; (4017d8 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  401794:	881b      	ldrh	r3, [r3, #0]
  401796:	2b01      	cmp	r3, #1
  401798:	d012      	beq.n	4017c0 <sd_mmc_wait_end_of_write_blocks+0x44>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  40179a:	f243 100c 	movw	r0, #12556	; 0x310c
  40179e:	2100      	movs	r1, #0
  4017a0:	4b0e      	ldr	r3, [pc, #56]	; (4017dc <sd_mmc_wait_end_of_write_blocks+0x60>)
  4017a2:	4798      	blx	r3
  4017a4:	b960      	cbnz	r0, 4017c0 <sd_mmc_wait_end_of_write_blocks+0x44>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4017a6:	4b0e      	ldr	r3, [pc, #56]	; (4017e0 <sd_mmc_wait_end_of_write_blocks+0x64>)
  4017a8:	781b      	ldrb	r3, [r3, #0]
  4017aa:	2b00      	cmp	r3, #0
  4017ac:	d1eb      	bne.n	401786 <sd_mmc_wait_end_of_write_blocks+0xa>
		driver_deselect_device(sd_mmc_slot_sel);
  4017ae:	4b0d      	ldr	r3, [pc, #52]	; (4017e4 <sd_mmc_wait_end_of_write_blocks+0x68>)
  4017b0:	4798      	blx	r3
  4017b2:	e7e8      	b.n	401786 <sd_mmc_wait_end_of_write_blocks+0xa>
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  4017b4:	2200      	movs	r2, #0
  4017b6:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  4017b8:	4b07      	ldr	r3, [pc, #28]	; (4017d8 <sd_mmc_wait_end_of_write_blocks+0x5c>)
  4017ba:	881b      	ldrh	r3, [r3, #0]
  4017bc:	2b01      	cmp	r3, #1
  4017be:	d1ec      	bne.n	40179a <sd_mmc_wait_end_of_write_blocks+0x1e>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4017c0:	4b07      	ldr	r3, [pc, #28]	; (4017e0 <sd_mmc_wait_end_of_write_blocks+0x64>)
  4017c2:	781b      	ldrb	r3, [r3, #0]
  4017c4:	b913      	cbnz	r3, 4017cc <sd_mmc_wait_end_of_write_blocks+0x50>
		driver_deselect_device(sd_mmc_slot_sel);
  4017c6:	2000      	movs	r0, #0
  4017c8:	4b06      	ldr	r3, [pc, #24]	; (4017e4 <sd_mmc_wait_end_of_write_blocks+0x68>)
  4017ca:	4798      	blx	r3

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  4017cc:	2000      	movs	r0, #0
  4017ce:	bd10      	pop	{r4, pc}
  4017d0:	00401f21 	.word	0x00401f21
  4017d4:	20000ec4 	.word	0x20000ec4
  4017d8:	20000ebc 	.word	0x20000ebc
  4017dc:	00401bfd 	.word	0x00401bfd
  4017e0:	20000ec6 	.word	0x20000ec6
  4017e4:	00401bd9 	.word	0x00401bd9

004017e8 <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  4017e8:	b510      	push	{r4, lr}
	switch (sd_mmc_check(slot))
  4017ea:	4b0f      	ldr	r3, [pc, #60]	; (401828 <sd_mmc_test_unit_ready+0x40>)
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  4017ec:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  4017ee:	4798      	blx	r3
  4017f0:	2801      	cmp	r0, #1
  4017f2:	d00d      	beq.n	401810 <sd_mmc_test_unit_ready+0x28>
  4017f4:	d307      	bcc.n	401806 <sd_mmc_test_unit_ready+0x1e>
  4017f6:	2802      	cmp	r0, #2
  4017f8:	d103      	bne.n	401802 <sd_mmc_test_unit_ready+0x1a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  4017fa:	4b0c      	ldr	r3, [pc, #48]	; (40182c <sd_mmc_test_unit_ready+0x44>)
  4017fc:	2200      	movs	r2, #0
  4017fe:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  401800:	bd10      	pop	{r4, pc}

	default:
		return CTRL_FAIL;
  401802:	2001      	movs	r0, #1
  401804:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  401806:	4b09      	ldr	r3, [pc, #36]	; (40182c <sd_mmc_test_unit_ready+0x44>)
  401808:	5d1b      	ldrb	r3, [r3, r4]
  40180a:	b11b      	cbz	r3, 401814 <sd_mmc_test_unit_ready+0x2c>
			return CTRL_NO_PRESENT;
  40180c:	2002      	movs	r0, #2
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  40180e:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  401810:	2003      	movs	r0, #3
  401812:	bd10      	pop	{r4, pc}
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  401814:	4620      	mov	r0, r4
  401816:	4b06      	ldr	r3, [pc, #24]	; (401830 <sd_mmc_test_unit_ready+0x48>)
  401818:	4798      	blx	r3
  40181a:	f010 0f03 	tst.w	r0, #3
			return CTRL_GOOD;
  40181e:	bf0c      	ite	eq
  401820:	2002      	moveq	r0, #2
  401822:	2000      	movne	r0, #0
  401824:	bd10      	pop	{r4, pc}
  401826:	bf00      	nop
  401828:	00400e61 	.word	0x00400e61
  40182c:	20000ec8 	.word	0x20000ec8
  401830:	004014c5 	.word	0x004014c5

00401834 <sd_mmc_test_unit_ready_0>:
		return CTRL_FAIL;
	}
}

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  401834:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  401836:	2000      	movs	r0, #0
  401838:	4b01      	ldr	r3, [pc, #4]	; (401840 <sd_mmc_test_unit_ready_0+0xc>)
  40183a:	4798      	blx	r3
}
  40183c:	bd08      	pop	{r3, pc}
  40183e:	bf00      	nop
  401840:	004017e9 	.word	0x004017e9

00401844 <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  401844:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  401846:	2001      	movs	r0, #1
  401848:	4b01      	ldr	r3, [pc, #4]	; (401850 <sd_mmc_test_unit_ready_1+0xc>)
  40184a:	4798      	blx	r3
}
  40184c:	bd08      	pop	{r3, pc}
  40184e:	bf00      	nop
  401850:	004017e9 	.word	0x004017e9

00401854 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401854:	b538      	push	{r3, r4, r5, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401856:	4b05      	ldr	r3, [pc, #20]	; (40186c <sd_mmc_read_capacity+0x18>)
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401858:	460d      	mov	r5, r1
  40185a:	4604      	mov	r4, r0
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  40185c:	4798      	blx	r3
  40185e:	0040      	lsls	r0, r0, #1
  401860:	3801      	subs	r0, #1
  401862:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  401864:	4b02      	ldr	r3, [pc, #8]	; (401870 <sd_mmc_read_capacity+0x1c>)
  401866:	4620      	mov	r0, r4
  401868:	4798      	blx	r3
}
  40186a:	bd38      	pop	{r3, r4, r5, pc}
  40186c:	00401501 	.word	0x00401501
  401870:	004017e9 	.word	0x004017e9

00401874 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  401874:	b508      	push	{r3, lr}
  401876:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  401878:	4b01      	ldr	r3, [pc, #4]	; (401880 <sd_mmc_read_capacity_0+0xc>)
  40187a:	2000      	movs	r0, #0
  40187c:	4798      	blx	r3
}
  40187e:	bd08      	pop	{r3, pc}
  401880:	00401855 	.word	0x00401855

00401884 <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  401884:	b508      	push	{r3, lr}
  401886:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  401888:	4b01      	ldr	r3, [pc, #4]	; (401890 <sd_mmc_read_capacity_1+0xc>)
  40188a:	2001      	movs	r0, #1
  40188c:	4798      	blx	r3
}
  40188e:	bd08      	pop	{r3, pc}
  401890:	00401855 	.word	0x00401855

00401894 <sd_mmc_unload_0>:

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  401894:	4b01      	ldr	r3, [pc, #4]	; (40189c <sd_mmc_unload_0+0x8>)
  401896:	7018      	strb	r0, [r3, #0]
}

bool sd_mmc_unload_0(bool unload)
{
	return sd_mmc_unload(0, unload);
}
  401898:	2001      	movs	r0, #1
  40189a:	4770      	bx	lr
  40189c:	20000ec8 	.word	0x20000ec8

004018a0 <sd_mmc_unload_1>:
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  4018a0:	4b01      	ldr	r3, [pc, #4]	; (4018a8 <sd_mmc_unload_1+0x8>)
  4018a2:	7058      	strb	r0, [r3, #1]
}

bool sd_mmc_unload_1(bool unload)
{
	return sd_mmc_unload(1, unload);
}
  4018a4:	2001      	movs	r0, #1
  4018a6:	4770      	bx	lr
  4018a8:	20000ec8 	.word	0x20000ec8

004018ac <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
  4018ac:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  4018ae:	2000      	movs	r0, #0
  4018b0:	4b01      	ldr	r3, [pc, #4]	; (4018b8 <sd_mmc_wr_protect_0+0xc>)
  4018b2:	4798      	blx	r3
}

bool sd_mmc_wr_protect_0(void)
{
	return sd_mmc_wr_protect(0);
}
  4018b4:	bd08      	pop	{r3, pc}
  4018b6:	bf00      	nop
  4018b8:	0040153d 	.word	0x0040153d

004018bc <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  4018bc:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  4018be:	2001      	movs	r0, #1
  4018c0:	4b01      	ldr	r3, [pc, #4]	; (4018c8 <sd_mmc_wr_protect_1+0xc>)
  4018c2:	4798      	blx	r3
}

bool sd_mmc_wr_protect_1(void)
{
	return sd_mmc_wr_protect(1);
}
  4018c4:	bd08      	pop	{r3, pc}
  4018c6:	bf00      	nop
  4018c8:	0040153d 	.word	0x0040153d

004018cc <sd_mmc_removal_0>:
}

bool sd_mmc_removal_0(void)
{
	return sd_mmc_removal(0);
}
  4018cc:	2001      	movs	r0, #1
  4018ce:	4770      	bx	lr

004018d0 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
	return sd_mmc_removal(1);
}
  4018d0:	2001      	movs	r0, #1
  4018d2:	4770      	bx	lr

004018d4 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  4018d4:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  4018d6:	4b0b      	ldr	r3, [pc, #44]	; (401904 <sd_mmc_mem_2_ram+0x30>)
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  4018d8:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  4018da:	2201      	movs	r2, #1
  4018dc:	4798      	blx	r3
  4018de:	b120      	cbz	r0, 4018ea <sd_mmc_mem_2_ram+0x16>
  4018e0:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  4018e2:	bf0c      	ite	eq
  4018e4:	2002      	moveq	r0, #2
  4018e6:	2001      	movne	r0, #1
  4018e8:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  4018ea:	4620      	mov	r0, r4
  4018ec:	2101      	movs	r1, #1
  4018ee:	4b06      	ldr	r3, [pc, #24]	; (401908 <sd_mmc_mem_2_ram+0x34>)
  4018f0:	4798      	blx	r3
  4018f2:	b108      	cbz	r0, 4018f8 <sd_mmc_mem_2_ram+0x24>
		return CTRL_FAIL;
  4018f4:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  4018f6:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
  4018f8:	4b04      	ldr	r3, [pc, #16]	; (40190c <sd_mmc_mem_2_ram+0x38>)
  4018fa:	4798      	blx	r3
		return CTRL_FAIL;
  4018fc:	3000      	adds	r0, #0
  4018fe:	bf18      	it	ne
  401900:	2001      	movne	r0, #1
  401902:	bd10      	pop	{r4, pc}
  401904:	00401541 	.word	0x00401541
  401908:	00401629 	.word	0x00401629
  40190c:	00401651 	.word	0x00401651

00401910 <sd_mmc_mem_2_ram_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  401910:	b508      	push	{r3, lr}
  401912:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  401914:	4b02      	ldr	r3, [pc, #8]	; (401920 <sd_mmc_mem_2_ram_0+0x10>)
  401916:	4601      	mov	r1, r0
  401918:	2000      	movs	r0, #0
  40191a:	4798      	blx	r3
}
  40191c:	bd08      	pop	{r3, pc}
  40191e:	bf00      	nop
  401920:	004018d5 	.word	0x004018d5

00401924 <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  401924:	b508      	push	{r3, lr}
  401926:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  401928:	4b02      	ldr	r3, [pc, #8]	; (401934 <sd_mmc_mem_2_ram_1+0x10>)
  40192a:	4601      	mov	r1, r0
  40192c:	2001      	movs	r0, #1
  40192e:	4798      	blx	r3
}
  401930:	bd08      	pop	{r3, pc}
  401932:	bf00      	nop
  401934:	004018d5 	.word	0x004018d5

00401938 <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401938:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  40193a:	4b0b      	ldr	r3, [pc, #44]	; (401968 <sd_mmc_ram_2_mem+0x30>)
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  40193c:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  40193e:	2201      	movs	r2, #1
  401940:	4798      	blx	r3
  401942:	b120      	cbz	r0, 40194e <sd_mmc_ram_2_mem+0x16>
  401944:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  401946:	bf0c      	ite	eq
  401948:	2002      	moveq	r0, #2
  40194a:	2001      	movne	r0, #1
  40194c:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  40194e:	4620      	mov	r0, r4
  401950:	2101      	movs	r1, #1
  401952:	4b06      	ldr	r3, [pc, #24]	; (40196c <sd_mmc_ram_2_mem+0x34>)
  401954:	4798      	blx	r3
  401956:	b108      	cbz	r0, 40195c <sd_mmc_ram_2_mem+0x24>
		return CTRL_FAIL;
  401958:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  40195a:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
  40195c:	4b04      	ldr	r3, [pc, #16]	; (401970 <sd_mmc_ram_2_mem+0x38>)
  40195e:	4798      	blx	r3
		return CTRL_FAIL;
  401960:	3000      	adds	r0, #0
  401962:	bf18      	it	ne
  401964:	2001      	movne	r0, #1
  401966:	bd10      	pop	{r4, pc}
  401968:	004016b5 	.word	0x004016b5
  40196c:	00401755 	.word	0x00401755
  401970:	0040177d 	.word	0x0040177d

00401974 <sd_mmc_ram_2_mem_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  401974:	b508      	push	{r3, lr}
  401976:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  401978:	4b02      	ldr	r3, [pc, #8]	; (401984 <sd_mmc_ram_2_mem_0+0x10>)
  40197a:	4601      	mov	r1, r0
  40197c:	2000      	movs	r0, #0
  40197e:	4798      	blx	r3
}
  401980:	bd08      	pop	{r3, pc}
  401982:	bf00      	nop
  401984:	00401939 	.word	0x00401939

00401988 <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  401988:	b508      	push	{r3, lr}
  40198a:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  40198c:	4b02      	ldr	r3, [pc, #8]	; (401998 <sd_mmc_ram_2_mem_1+0x10>)
  40198e:	4601      	mov	r1, r0
  401990:	2001      	movs	r0, #1
  401992:	4798      	blx	r3
}
  401994:	bd08      	pop	{r3, pc}
  401996:	bf00      	nop
  401998:	00401939 	.word	0x00401939

0040199c <mem_test_unit_ready>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  40199c:	2801      	cmp	r0, #1
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  40199e:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4019a0:	d901      	bls.n	4019a6 <mem_test_unit_ready+0xa>
  4019a2:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  4019a4:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  4019a6:	0140      	lsls	r0, r0, #5
  4019a8:	4b01      	ldr	r3, [pc, #4]	; (4019b0 <mem_test_unit_ready+0x14>)
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4019aa:	581b      	ldr	r3, [r3, r0]
  4019ac:	4798      	blx	r3
  4019ae:	bd08      	pop	{r3, pc}
  4019b0:	004067b0 	.word	0x004067b0

004019b4 <mem_read_capacity>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4019b4:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  4019b6:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4019b8:	d901      	bls.n	4019be <mem_read_capacity+0xa>
  4019ba:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  4019bc:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  4019be:	4b03      	ldr	r3, [pc, #12]	; (4019cc <mem_read_capacity+0x18>)
  4019c0:	eb03 1340 	add.w	r3, r3, r0, lsl #5
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  4019c4:	4608      	mov	r0, r1
  4019c6:	685b      	ldr	r3, [r3, #4]
  4019c8:	4798      	blx	r3
  4019ca:	bd08      	pop	{r3, pc}
  4019cc:	004067b0 	.word	0x004067b0

004019d0 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  4019d0:	2801      	cmp	r0, #1
  4019d2:	bf8c      	ite	hi
  4019d4:	2000      	movhi	r0, #0
  4019d6:	2001      	movls	r0, #1
  4019d8:	4770      	bx	lr
  4019da:	bf00      	nop

004019dc <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4019dc:	2801      	cmp	r0, #1

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
  4019de:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4019e0:	d901      	bls.n	4019e6 <mem_wr_protect+0xa>
  4019e2:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  4019e4:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  4019e6:	4b03      	ldr	r3, [pc, #12]	; (4019f4 <mem_wr_protect+0x18>)
  4019e8:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  4019ec:	68c3      	ldr	r3, [r0, #12]
  4019ee:	4798      	blx	r3
  4019f0:	bd08      	pop	{r3, pc}
  4019f2:	bf00      	nop
  4019f4:	004067b0 	.word	0x004067b0

004019f8 <memory_2_ram>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  4019f8:	2801      	cmp	r0, #1
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  4019fa:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  4019fc:	d901      	bls.n	401a02 <memory_2_ram+0xa>
  4019fe:	2001      	movs	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  401a00:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  401a02:	4b04      	ldr	r3, [pc, #16]	; (401a14 <memory_2_ram+0x1c>)
  401a04:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401a08:	4608      	mov	r0, r1
  401a0a:	695b      	ldr	r3, [r3, #20]
  401a0c:	4611      	mov	r1, r2
  401a0e:	4798      	blx	r3
  401a10:	bd08      	pop	{r3, pc}
  401a12:	bf00      	nop
  401a14:	004067b0 	.word	0x004067b0

00401a18 <ram_2_memory>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401a18:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
  401a1a:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401a1c:	d901      	bls.n	401a22 <ram_2_memory+0xa>
  401a1e:	2001      	movs	r0, #1
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
  401a20:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  401a22:	4b04      	ldr	r3, [pc, #16]	; (401a34 <ram_2_memory+0x1c>)
  401a24:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401a28:	4608      	mov	r0, r1
  401a2a:	699b      	ldr	r3, [r3, #24]
  401a2c:	4611      	mov	r1, r2
  401a2e:	4798      	blx	r3
  401a30:	bd08      	pop	{r3, pc}
  401a32:	bf00      	nop
  401a34:	004067b0 	.word	0x004067b0

00401a38 <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  401a38:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401a3c:	f001 033f 	and.w	r3, r1, #63	; 0x3f
	if (cmd & SDMMC_RESP_PRESENT) {
  401a40:	05cf      	lsls	r7, r1, #23
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401a42:	ea43 0000 	orr.w	r0, r3, r0
	if (cmd & SDMMC_RESP_PRESENT) {
  401a46:	d503      	bpl.n	401a50 <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  401a48:	050e      	lsls	r6, r1, #20
  401a4a:	d530      	bpl.n	401aae <hsmci_send_cmd_execute+0x76>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  401a4c:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
	if (cmd & SDMMC_CMD_OPENDRAIN) {
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401a50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  401a54:	044c      	lsls	r4, r1, #17
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  401a56:	bf48      	it	mi
  401a58:	f440 6000 	orrmi.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401a5c:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401a5e:	461d      	mov	r5, r3
  401a60:	f401 5480 	and.w	r4, r1, #4096	; 0x1000
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  401a64:	6158      	str	r0, [r3, #20]
  401a66:	e004      	b.n	401a72 <hsmci_send_cmd_execute+0x3a>

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
		if (cmd & SDMMC_RESP_CRC) {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401a68:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  401a6c:	d12c      	bne.n	401ac8 <hsmci_send_cmd_execute+0x90>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401a6e:	07da      	lsls	r2, r3, #31
  401a70:	d424      	bmi.n	401abc <hsmci_send_cmd_execute+0x84>
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401a72:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  401a76:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  401a78:	2c00      	cmp	r4, #0
  401a7a:	d1f5      	bne.n	401a68 <hsmci_send_cmd_execute+0x30>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401a7c:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401a80:	d0f5      	beq.n	401a6e <hsmci_send_cmd_execute+0x36>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401a82:	f8d2 c004 	ldr.w	ip, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401a86:	6897      	ldr	r7, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401a88:	68d6      	ldr	r6, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401a8a:	69d5      	ldr	r5, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401a8c:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401a8e:	f04f 0880 	mov.w	r8, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401a92:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401a94:	f8c2 8000 	str.w	r8, [r2]
	HSMCI->HSMCI_MR = mr;
  401a98:	f8c2 c004 	str.w	ip, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401a9c:	6097      	str	r7, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401a9e:	60d6      	str	r6, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401aa0:	61d5      	str	r5, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401aa2:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401aa4:	6013      	str	r3, [r2, #0]
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401aa6:	4620      	mov	r0, r4
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401aa8:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401aac:	4770      	bx	lr
	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  401aae:	048d      	lsls	r5, r1, #18
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  401ab0:	bf4c      	ite	mi
  401ab2:	f440 5086 	orrmi.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  401ab6:	f440 5082 	orrpl.w	r0, r0, #4160	; 0x1040
  401aba:	e7c9      	b.n	401a50 <hsmci_send_cmd_execute+0x18>
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));

	if (cmd & SDMMC_RESP_BUSY) {
  401abc:	048b      	lsls	r3, r1, #18
  401abe:	d415      	bmi.n	401aec <hsmci_send_cmd_execute+0xb4>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401ac0:	2001      	movs	r0, #1
}
  401ac2:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401ac6:	4770      	bx	lr
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401ac8:	2080      	movs	r0, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401aca:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401acc:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401ace:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401ad0:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401ad2:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401ad4:	6010      	str	r0, [r2, #0]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401ad6:	2305      	movs	r3, #5
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401ad8:	2000      	movs	r0, #0
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
	HSMCI->HSMCI_MR = mr;
  401ada:	6057      	str	r7, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401adc:	6096      	str	r6, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401ade:	60d5      	str	r5, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401ae0:	61d4      	str	r4, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401ae2:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401ae4:	6013      	str	r3, [r2, #0]
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401ae6:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401aea:	4770      	bx	lr
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401aec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401af0:	4619      	mov	r1, r3
  401af2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401af4:	f04f 30ff 	mov.w	r0, #4294967295
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401af8:	f003 0330 	and.w	r3, r3, #48	; 0x30
  401afc:	2b20      	cmp	r3, #32
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401afe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401b02:	d0dd      	beq.n	401ac0 <hsmci_send_cmd_execute+0x88>
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
		if (busy_wait-- == 0) {
  401b04:	3801      	subs	r0, #1
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401b06:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  401b08:	d1f6      	bne.n	401af8 <hsmci_send_cmd_execute+0xc0>
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401b0a:	f04f 0c80 	mov.w	ip, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401b0e:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401b10:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401b12:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401b14:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401b16:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401b18:	f8c2 c000 	str.w	ip, [r2]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401b1c:	2305      	movs	r3, #5
  401b1e:	e7dc      	b.n	401ada <hsmci_send_cmd_execute+0xa2>

00401b20 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401b20:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  401b22:	4b08      	ldr	r3, [pc, #32]	; (401b44 <hsmci_init+0x24>)
  401b24:	2012      	movs	r0, #18
  401b26:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401b28:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401b2c:	2272      	movs	r2, #114	; 0x72
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401b2e:	2411      	movs	r4, #17
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401b30:	f44f 60e0 	mov.w	r0, #1792	; 0x700

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401b34:	2105      	movs	r1, #5
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401b36:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  401b38:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401b3a:	655c      	str	r4, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401b3c:	6058      	str	r0, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401b3e:	6019      	str	r1, [r3, #0]
  401b40:	bd10      	pop	{r4, pc}
  401b42:	bf00      	nop
  401b44:	0040531d 	.word	0x0040531d

00401b48 <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  401b48:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401b4a:	bf0c      	ite	eq
  401b4c:	2004      	moveq	r0, #4
  401b4e:	2000      	movne	r0, #0
  401b50:	4770      	bx	lr
  401b52:	bf00      	nop

00401b54 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  401b54:	2001      	movs	r0, #1
  401b56:	4770      	bx	lr

00401b58 <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  401b58:	b33b      	cbz	r3, 401baa <hsmci_select_device+0x52>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401b5a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401b5e:	0049      	lsls	r1, r1, #1
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401b60:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401b62:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  401b66:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401b68:	4b1a      	ldr	r3, [pc, #104]	; (401bd4 <hsmci_select_device+0x7c>)
  401b6a:	4299      	cmp	r1, r3
  401b6c:	d827      	bhi.n	401bbe <hsmci_select_device+0x66>
		clkdiv = mck / (2 * speed);
  401b6e:	3301      	adds	r3, #1
		rest = mck % (2 * speed);
  401b70:	4618      	mov	r0, r3
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
		clkdiv = mck / (2 * speed);
  401b72:	fbb3 f3f1 	udiv	r3, r3, r1
		rest = mck % (2 * speed);
  401b76:	fb01 f103 	mul.w	r1, r1, r3
  401b7a:	1a40      	subs	r0, r0, r1
		if (rest > 0) {
  401b7c:	bb08      	cbnz	r0, 401bc2 <hsmci_select_device+0x6a>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
		}
		if (clkdiv > 0) {
  401b7e:	bb0b      	cbnz	r3, 401bc4 <hsmci_select_device+0x6c>
  401b80:	4619      	mov	r1, r3
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401b82:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401b86:	2a04      	cmp	r2, #4
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401b88:	6858      	ldr	r0, [r3, #4]
  401b8a:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  401b8e:	6058      	str	r0, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  401b90:	6858      	ldr	r0, [r3, #4]
  401b92:	ea41 0100 	orr.w	r1, r1, r0
  401b96:	6059      	str	r1, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401b98:	d017      	beq.n	401bca <hsmci_select_device+0x72>
  401b9a:	2a08      	cmp	r2, #8
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401b9c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401ba0:	bf0c      	ite	eq
  401ba2:	22c0      	moveq	r2, #192	; 0xc0
  401ba4:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401ba6:	60da      	str	r2, [r3, #12]
  401ba8:	4770      	bx	lr
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401baa:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401bae:	0049      	lsls	r1, r1, #1
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401bb0:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401bb2:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  401bb6:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401bb8:	4b06      	ldr	r3, [pc, #24]	; (401bd4 <hsmci_select_device+0x7c>)
  401bba:	4299      	cmp	r1, r3
  401bbc:	d9d7      	bls.n	401b6e <hsmci_select_device+0x16>
  401bbe:	2100      	movs	r1, #0
  401bc0:	e7df      	b.n	401b82 <hsmci_select_device+0x2a>
		clkdiv = mck / (2 * speed);
		rest = mck % (2 * speed);
		if (rest > 0) {
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  401bc2:	3301      	adds	r3, #1
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
  401bc4:	3b01      	subs	r3, #1
  401bc6:	b2d9      	uxtb	r1, r3
  401bc8:	e7db      	b.n	401b82 <hsmci_select_device+0x2a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401bca:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401bce:	2280      	movs	r2, #128	; 0x80
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401bd0:	60da      	str	r2, [r3, #12]
  401bd2:	4770      	bx	lr
  401bd4:	07270dff 	.word	0x07270dff

00401bd8 <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  401bd8:	4770      	bx	lr
  401bda:	bf00      	nop

00401bdc <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401bdc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401be0:	2000      	movs	r0, #0
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401be2:	685a      	ldr	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401be4:	f44f 6110 	mov.w	r1, #2304	; 0x900
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401be8:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401bec:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401bee:	6118      	str	r0, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401bf0:	461a      	mov	r2, r3
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401bf2:	6159      	str	r1, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401bf4:	6c13      	ldr	r3, [r2, #64]	; 0x40
  401bf6:	07db      	lsls	r3, r3, #31
  401bf8:	d5fc      	bpl.n	401bf4 <hsmci_send_clock+0x18>
}
  401bfa:	4770      	bx	lr

00401bfc <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401bfc:	b570      	push	{r4, r5, r6, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401bfe:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401c02:	2400      	movs	r4, #0
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401c04:	685a      	ldr	r2, [r3, #4]
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401c06:	4d07      	ldr	r5, [pc, #28]	; (401c24 <hsmci_send_cmd+0x28>)
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401c08:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401c0c:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401c0e:	685e      	ldr	r6, [r3, #4]
  401c10:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401c14:	460a      	mov	r2, r1
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401c16:	605e      	str	r6, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401c18:	4601      	mov	r1, r0
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401c1a:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401c1c:	4620      	mov	r0, r4
  401c1e:	47a8      	blx	r5
}
  401c20:	bd70      	pop	{r4, r5, r6, pc}
  401c22:	bf00      	nop
  401c24:	00401a39 	.word	0x00401a39

00401c28 <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401c28:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401c2c:	6a18      	ldr	r0, [r3, #32]
}
  401c2e:	4770      	bx	lr

00401c30 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  401c30:	b430      	push	{r4, r5}
  401c32:	f100 0510 	add.w	r5, r0, #16
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  401c36:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401c3a:	6a23      	ldr	r3, [r4, #32]
		response++;
		*response = (response_32 >> 16) & 0xFF;
		response++;
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
  401c3c:	70c3      	strb	r3, [r0, #3]
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401c3e:	0e19      	lsrs	r1, r3, #24
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401c40:	0c1a      	lsrs	r2, r3, #16
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401c42:	0a1b      	lsrs	r3, r3, #8
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401c44:	7001      	strb	r1, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401c46:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401c48:	7083      	strb	r3, [r0, #2]
  401c4a:	3004      	adds	r0, #4

void hsmci_get_response_128(uint8_t* response)
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  401c4c:	42a8      	cmp	r0, r5
  401c4e:	d1f4      	bne.n	401c3a <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  401c50:	bc30      	pop	{r4, r5}
  401c52:	4770      	bx	lr

00401c54 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401c54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401c56:	460e      	mov	r6, r1
  401c58:	f89d 5018 	ldrb.w	r5, [sp, #24]
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401c5c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		response++;
	}
}

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401c60:	4604      	mov	r4, r0
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401c62:	6848      	ldr	r0, [r1, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  401c64:	b34d      	cbz	r5, 401cba <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401c66:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  401c6a:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401c6c:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	// Force byte transfer if needed
	if (block_size & 0x3) {
  401c70:	0797      	lsls	r7, r2, #30
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401c72:	6841      	ldr	r1, [r0, #4]
  401c74:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  401c78:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401c7a:	6841      	ldr	r1, [r0, #4]
  401c7c:	bf14      	ite	ne
  401c7e:	f441 5100 	orrne.w	r1, r1, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401c82:	f421 5100 	biceq.w	r1, r1, #8192	; 0x2000
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401c86:	f414 4f00 	tst.w	r4, #32768	; 0x8000
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401c8a:	6041      	str	r1, [r0, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401c8c:	bf0c      	ite	eq
  401c8e:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  401c92:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401c96:	03e5      	lsls	r5, r4, #15
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401c98:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401c9c:	d421      	bmi.n	401ce2 <hsmci_adtc_start+0x8e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401c9e:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  401ca2:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  401ca4:	03a1      	lsls	r1, r4, #14
  401ca6:	d40c      	bmi.n	401cc2 <hsmci_adtc_start+0x6e>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401ca8:	0367      	lsls	r7, r4, #13
  401caa:	d420      	bmi.n	401cee <hsmci_adtc_start+0x9a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  401cac:	0325      	lsls	r5, r4, #12
  401cae:	d40a      	bmi.n	401cc6 <hsmci_adtc_start+0x72>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  401cb0:	02e1      	lsls	r1, r4, #11
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401cb2:	bf48      	it	mi
  401cb4:	f440 2000 	orrmi.w	r0, r0, #524288	; 0x80000
  401cb8:	e005      	b.n	401cc6 <hsmci_adtc_start+0x72>
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401cba:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  401cbe:	6048      	str	r0, [r1, #4]
  401cc0:	e7d4      	b.n	401c6c <hsmci_adtc_start+0x18>
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  401cc2:	f440 1020 	orr.w	r0, r0, #2621440	; 0x280000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401cc6:	490b      	ldr	r1, [pc, #44]	; (401cf4 <hsmci_adtc_start+0xa0>)
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401cc8:	f8df e034 	ldr.w	lr, [pc, #52]	; 401d00 <hsmci_adtc_start+0xac>
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401ccc:	4f0a      	ldr	r7, [pc, #40]	; (401cf8 <hsmci_adtc_start+0xa4>)
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401cce:	800a      	strh	r2, [r1, #0]
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401cd0:	4d0a      	ldr	r5, [pc, #40]	; (401cfc <hsmci_adtc_start+0xa8>)
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401cd2:	803b      	strh	r3, [r7, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401cd4:	4621      	mov	r1, r4
  401cd6:	4632      	mov	r2, r6
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401cd8:	2400      	movs	r4, #0
  401cda:	f8ce 4000 	str.w	r4, [lr]
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401cde:	47a8      	blx	r5
}
  401ce0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401ce2:	f3c2 0508 	ubfx	r5, r2, #0, #9
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  401ce6:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401cea:	618d      	str	r5, [r1, #24]
  401cec:	e7eb      	b.n	401cc6 <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  401cee:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  401cf2:	e7e8      	b.n	401cc6 <hsmci_adtc_start+0x72>
  401cf4:	20000ecc 	.word	0x20000ecc
  401cf8:	20000ece 	.word	0x20000ece
  401cfc:	00401a39 	.word	0x00401a39
  401d00:	20000ed0 	.word	0x20000ed0

00401d04 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  401d04:	b4f0      	push	{r4, r5, r6, r7}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401d06:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401d0a:	e001      	b.n	401d10 <hsmci_read_word+0xc>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  401d0c:	0792      	lsls	r2, r2, #30
  401d0e:	d417      	bmi.n	401d40 <hsmci_read_word+0x3c>

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401d10:	6c22      	ldr	r2, [r4, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401d12:	4b21      	ldr	r3, [pc, #132]	; (401d98 <hsmci_read_word+0x94>)
  401d14:	4013      	ands	r3, r2

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401d16:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401d1a:	2b00      	cmp	r3, #0
  401d1c:	d0f6      	beq.n	401d0c <hsmci_read_word+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d1e:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d20:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d22:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d24:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d26:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d28:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d2a:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d2c:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401d2e:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401d30:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401d32:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401d34:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401d36:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d38:	600b      	str	r3, [r1, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401d3a:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401d3c:	bcf0      	pop	{r4, r5, r6, r7}
  401d3e:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401d40:	4a16      	ldr	r2, [pc, #88]	; (401d9c <hsmci_read_word+0x98>)
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401d42:	4c17      	ldr	r4, [pc, #92]	; (401da0 <hsmci_read_word+0x9c>)
  401d44:	4d17      	ldr	r5, [pc, #92]	; (401da4 <hsmci_read_word+0xa0>)
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401d46:	6813      	ldr	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401d48:	8826      	ldrh	r6, [r4, #0]
  401d4a:	882d      	ldrh	r5, [r5, #0]
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
  401d4c:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  401d4e:	6004      	str	r4, [r0, #0]
	hsmci_transfert_pos += 4;
  401d50:	3304      	adds	r3, #4
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401d52:	fb06 f005 	mul.w	r0, r6, r5
  401d56:	4283      	cmp	r3, r0
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  401d58:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  401d5a:	d202      	bcs.n	401d62 <hsmci_read_word+0x5e>
  401d5c:	e019      	b.n	401d92 <hsmci_read_word+0x8e>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401d5e:	0113      	lsls	r3, r2, #4
  401d60:	d417      	bmi.n	401d92 <hsmci_read_word+0x8e>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  401d62:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401d64:	4b0c      	ldr	r3, [pc, #48]	; (401d98 <hsmci_read_word+0x94>)
  401d66:	4013      	ands	r3, r2
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  401d68:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401d6c:	2b00      	cmp	r3, #0
  401d6e:	d0f6      	beq.n	401d5e <hsmci_read_word+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d70:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d72:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d74:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d76:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d78:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d7a:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d7c:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d7e:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  401d80:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401d82:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401d84:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401d86:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  401d88:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d8a:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401d8c:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401d8e:	bcf0      	pop	{r4, r5, r6, r7}
  401d90:	4770      	bx	lr

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  401d92:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401d94:	bcf0      	pop	{r4, r5, r6, r7}
  401d96:	4770      	bx	lr
  401d98:	c0600000 	.word	0xc0600000
  401d9c:	20000ed0 	.word	0x20000ed0
  401da0:	20000ecc 	.word	0x20000ecc
  401da4:	20000ece 	.word	0x20000ece

00401da8 <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  401da8:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401daa:	4b17      	ldr	r3, [pc, #92]	; (401e08 <hsmci_start_read_blocks+0x60>)
  401dac:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  401dae:	0784      	lsls	r4, r0, #30
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401db0:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  401db4:	d101      	bne.n	401dba <hsmci_start_read_blocks+0x12>
  401db6:	079a      	lsls	r2, r3, #30
  401db8:	d01e      	beq.n	401df8 <hsmci_start_read_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401dba:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401dbe:	685a      	ldr	r2, [r3, #4]
  401dc0:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  401dc4:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  401dc6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  401dca:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  401dcc:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401dd0:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
	hsmci_transfert_pos += nb_data;
  401dd2:	4a0e      	ldr	r2, [pc, #56]	; (401e0c <hsmci_start_read_blocks+0x64>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  401dd4:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401dd6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  401dda:	bf54      	ite	pl
  401ddc:	088d      	lsrpl	r5, r1, #2
  401dde:	460d      	movmi	r5, r1
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  401de0:	2001      	movs	r0, #1
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401de2:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  401de6:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  401dea:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401dee:	6813      	ldr	r3, [r2, #0]
  401df0:	4419      	add	r1, r3
  401df2:	6011      	str	r1, [r2, #0]
	return true;
}
  401df4:	bc30      	pop	{r4, r5}
  401df6:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401df8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401dfc:	685a      	ldr	r2, [r3, #4]
  401dfe:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  401e02:	605a      	str	r2, [r3, #4]
  401e04:	e7df      	b.n	401dc6 <hsmci_start_read_blocks+0x1e>
  401e06:	bf00      	nop
  401e08:	20000ecc 	.word	0x20000ecc
  401e0c:	20000ed0 	.word	0x20000ed0

00401e10 <hsmci_wait_end_of_read_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_read_blocks(void)
{
  401e10:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401e12:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  401e16:	e001      	b.n	401e1c <hsmci_wait_end_of_read_blocks+0xc>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  401e18:	0452      	lsls	r2, r2, #17
  401e1a:	d41b      	bmi.n	401e54 <hsmci_wait_end_of_read_blocks+0x44>
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401e1c:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401e1e:	4b21      	ldr	r3, [pc, #132]	; (401ea4 <hsmci_wait_end_of_read_blocks+0x94>)
  401e20:	4013      	ands	r3, r2
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401e22:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401e26:	2b00      	cmp	r3, #0
  401e28:	d0f6      	beq.n	401e18 <hsmci_wait_end_of_read_blocks+0x8>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401e2a:	f240 2302 	movw	r3, #514	; 0x202
  401e2e:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401e32:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401e34:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401e36:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401e38:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401e3a:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401e3c:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401e3e:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401e40:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401e42:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401e44:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401e46:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401e48:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401e4a:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401e4c:	600b      	str	r3, [r1, #0]
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
  401e4e:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401e50:	bcf0      	pop	{r4, r5, r6, r7}
  401e52:	4770      	bx	lr
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401e54:	4a14      	ldr	r2, [pc, #80]	; (401ea8 <hsmci_wait_end_of_read_blocks+0x98>)
  401e56:	4815      	ldr	r0, [pc, #84]	; (401eac <hsmci_wait_end_of_read_blocks+0x9c>)
  401e58:	4b15      	ldr	r3, [pc, #84]	; (401eb0 <hsmci_wait_end_of_read_blocks+0xa0>)
  401e5a:	8812      	ldrh	r2, [r2, #0]
  401e5c:	8800      	ldrh	r0, [r0, #0]
  401e5e:	681b      	ldr	r3, [r3, #0]
  401e60:	fb00 f202 	mul.w	r2, r0, r2
  401e64:	429a      	cmp	r2, r3
  401e66:	d902      	bls.n	401e6e <hsmci_wait_end_of_read_blocks+0x5e>
  401e68:	e019      	b.n	401e9e <hsmci_wait_end_of_read_blocks+0x8e>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  401e6a:	0113      	lsls	r3, r2, #4
  401e6c:	d417      	bmi.n	401e9e <hsmci_wait_end_of_read_blocks+0x8e>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401e6e:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401e70:	4b0c      	ldr	r3, [pc, #48]	; (401ea4 <hsmci_wait_end_of_read_blocks+0x94>)
  401e72:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401e74:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401e78:	2b00      	cmp	r3, #0
  401e7a:	d0f6      	beq.n	401e6a <hsmci_wait_end_of_read_blocks+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401e7c:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401e7e:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401e80:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401e82:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401e84:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401e86:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401e88:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401e8a:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  401e8c:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401e8e:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401e90:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401e92:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  401e94:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401e96:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401e98:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401e9a:	bcf0      	pop	{r4, r5, r6, r7}
  401e9c:	4770      	bx	lr
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401e9e:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  401ea0:	bcf0      	pop	{r4, r5, r6, r7}
  401ea2:	4770      	bx	lr
  401ea4:	c0600000 	.word	0xc0600000
  401ea8:	20000ece 	.word	0x20000ece
  401eac:	20000ecc 	.word	0x20000ecc
  401eb0:	20000ed0 	.word	0x20000ed0

00401eb4 <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
  401eb4:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401eb6:	4b18      	ldr	r3, [pc, #96]	; (401f18 <hsmci_start_write_blocks+0x64>)
  401eb8:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  401eba:	0784      	lsls	r4, r0, #30

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  401ebc:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  401ec0:	d101      	bne.n	401ec6 <hsmci_start_write_blocks+0x12>
  401ec2:	079a      	lsls	r2, r3, #30
  401ec4:	d020      	beq.n	401f08 <hsmci_start_write_blocks+0x54>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401ec6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401eca:	685a      	ldr	r2, [r3, #4]
  401ecc:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  401ed0:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  401ed2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  401ed6:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  401ed8:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401edc:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
	hsmci_transfert_pos += nb_data;
  401ede:	4a0f      	ldr	r2, [pc, #60]	; (401f1c <hsmci_start_write_blocks+0x68>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  401ee0:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401ee2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  401ee6:	bf54      	ite	pl
  401ee8:	088d      	lsrpl	r5, r1, #2
  401eea:	460d      	movmi	r5, r1
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401eec:	f44f 7080 	mov.w	r0, #256	; 0x100
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  401ef0:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  401ef4:	f8c3 411c 	str.w	r4, [r3, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  401ef8:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  401efc:	6813      	ldr	r3, [r2, #0]
  401efe:	4419      	add	r1, r3
  401f00:	6011      	str	r1, [r2, #0]
	return true;
}
  401f02:	2001      	movs	r0, #1
  401f04:	bc30      	pop	{r4, r5}
  401f06:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401f08:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401f0c:	685a      	ldr	r2, [r3, #4]
  401f0e:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  401f12:	605a      	str	r2, [r3, #4]
  401f14:	e7dd      	b.n	401ed2 <hsmci_start_write_blocks+0x1e>
  401f16:	bf00      	nop
  401f18:	20000ecc 	.word	0x20000ecc
  401f1c:	20000ed0 	.word	0x20000ed0

00401f20 <hsmci_wait_end_of_write_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_write_blocks(void)
{
  401f20:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401f22:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  401f26:	e001      	b.n	401f2c <hsmci_wait_end_of_write_blocks+0xc>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  401f28:	0412      	lsls	r2, r2, #16
  401f2a:	d41d      	bmi.n	401f68 <hsmci_wait_end_of_write_blocks+0x48>
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401f2c:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr &
  401f2e:	4b22      	ldr	r3, [pc, #136]	; (401fb8 <hsmci_wait_end_of_write_blocks+0x98>)
  401f30:	4013      	ands	r3, r2
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401f32:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  401f36:	2b00      	cmp	r3, #0
  401f38:	d0f6      	beq.n	401f28 <hsmci_wait_end_of_write_blocks+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401f3a:	f8d1 c004 	ldr.w	ip, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401f3e:	688f      	ldr	r7, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401f40:	68ce      	ldr	r6, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401f42:	69cd      	ldr	r5, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401f44:	6d4c      	ldr	r4, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401f46:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401f48:	2205      	movs	r2, #5
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401f4a:	f240 2302 	movw	r3, #514	; 0x202
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401f4e:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401f50:	f8c1 c004 	str.w	ip, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401f54:	608f      	str	r7, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401f56:	60ce      	str	r6, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401f58:	61cd      	str	r5, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401f5a:	654c      	str	r4, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401f5c:	600a      	str	r2, [r1, #0]
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  401f5e:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
			return false;
  401f62:	2000      	movs	r0, #0
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  401f64:	bcf0      	pop	{r4, r5, r6, r7}
  401f66:	4770      	bx	lr
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  401f68:	4a14      	ldr	r2, [pc, #80]	; (401fbc <hsmci_wait_end_of_write_blocks+0x9c>)
  401f6a:	4815      	ldr	r0, [pc, #84]	; (401fc0 <hsmci_wait_end_of_write_blocks+0xa0>)
  401f6c:	4b15      	ldr	r3, [pc, #84]	; (401fc4 <hsmci_wait_end_of_write_blocks+0xa4>)
  401f6e:	8812      	ldrh	r2, [r2, #0]
  401f70:	8800      	ldrh	r0, [r0, #0]
  401f72:	681b      	ldr	r3, [r3, #0]
  401f74:	fb00 f202 	mul.w	r2, r0, r2
  401f78:	429a      	cmp	r2, r3
  401f7a:	d902      	bls.n	401f82 <hsmci_wait_end_of_write_blocks+0x62>
  401f7c:	e019      	b.n	401fb2 <hsmci_wait_end_of_write_blocks+0x92>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  401f7e:	0693      	lsls	r3, r2, #26
  401f80:	d417      	bmi.n	401fb2 <hsmci_wait_end_of_write_blocks+0x92>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401f82:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401f84:	4b0c      	ldr	r3, [pc, #48]	; (401fb8 <hsmci_wait_end_of_write_blocks+0x98>)
  401f86:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  401f88:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401f8c:	2b00      	cmp	r3, #0
  401f8e:	d0f6      	beq.n	401f7e <hsmci_wait_end_of_write_blocks+0x5e>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401f90:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401f92:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401f94:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401f96:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401f98:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401f9a:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401f9c:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401f9e:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  401fa0:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401fa2:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401fa4:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401fa6:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  401fa8:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401faa:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401fac:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  401fae:	bcf0      	pop	{r4, r5, r6, r7}
  401fb0:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  401fb2:	2001      	movs	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  401fb4:	bcf0      	pop	{r4, r5, r6, r7}
  401fb6:	4770      	bx	lr
  401fb8:	c0600000 	.word	0xc0600000
  401fbc:	20000ece 	.word	0x20000ece
  401fc0:	20000ecc 	.word	0x20000ecc
  401fc4:	20000ed0 	.word	0x20000ed0

00401fc8 <rtc_set_hour_mode>:
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  401fc8:	6843      	ldr	r3, [r0, #4]
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  401fca:	b919      	cbnz	r1, 401fd4 <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  401fcc:	f023 0301 	bic.w	r3, r3, #1
  401fd0:	6043      	str	r3, [r0, #4]
  401fd2:	4770      	bx	lr
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  401fd4:	f043 0301 	orr.w	r3, r3, #1
  401fd8:	6043      	str	r3, [r0, #4]
  401fda:	4770      	bx	lr

00401fdc <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  401fdc:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  401fde:	6884      	ldr	r4, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  401fe0:	6885      	ldr	r5, [r0, #8]
  401fe2:	42ac      	cmp	r4, r5
  401fe4:	d003      	beq.n	401fee <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  401fe6:	6884      	ldr	r4, [r0, #8]
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
	while (ul_time != p_rtc->RTC_TIMR) {
  401fe8:	6885      	ldr	r5, [r0, #8]
  401fea:	42a5      	cmp	r5, r4
  401fec:	d1fb      	bne.n	401fe6 <rtc_get_time+0xa>
		ul_time = p_rtc->RTC_TIMR;
	}

	/* Hour */
	if (pul_hour) {
  401fee:	b161      	cbz	r1, 40200a <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
  401ff0:	f404 107c 	and.w	r0, r4, #4128768	; 0x3f0000
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  401ff4:	0d05      	lsrs	r5, r0, #20
  401ff6:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  401ffa:	f3c0 4003 	ubfx	r0, r0, #16, #4
  401ffe:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  402002:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  402004:	bf48      	it	mi
  402006:	300c      	addmi	r0, #12
  402008:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  40200a:	b14a      	cbz	r2, 402020 <rtc_get_time+0x44>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
  40200c:	f404 41fe 	and.w	r1, r4, #32512	; 0x7f00
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  402010:	0b08      	lsrs	r0, r1, #12
  402012:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402016:	f3c1 2103 	ubfx	r1, r1, #8, #4
  40201a:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  40201e:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  402020:	b143      	cbz	r3, 402034 <rtc_get_time+0x58>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402022:	f3c4 1202 	ubfx	r2, r4, #4, #3
  402026:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  40202a:	f004 040f 	and.w	r4, r4, #15
  40202e:	eb04 0242 	add.w	r2, r4, r2, lsl #1
  402032:	601a      	str	r2, [r3, #0]
	}
}
  402034:	bc30      	pop	{r4, r5}
  402036:	4770      	bx	lr

00402038 <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  402038:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  40203a:	68c4      	ldr	r4, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  40203c:	68c5      	ldr	r5, [r0, #12]
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  40203e:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  402040:	42ac      	cmp	r4, r5
  402042:	d003      	beq.n	40204c <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  402044:	68c4      	ldr	r4, [r0, #12]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  402046:	68c5      	ldr	r5, [r0, #12]
  402048:	42a5      	cmp	r5, r4
  40204a:	d1fb      	bne.n	402044 <rtc_get_date+0xc>
		ul_date = p_rtc->RTC_CALR;
	}

	/* Retrieve year */
	if (pul_year) {
  40204c:	b1a1      	cbz	r1, 402078 <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
  40204e:	f404 457f 	and.w	r5, r4, #65280	; 0xff00
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402052:	0b2f      	lsrs	r7, r5, #12
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402054:	f3c4 1002 	ubfx	r0, r4, #4, #3
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402058:	eb07 0c87 	add.w	ip, r7, r7, lsl #2
  40205c:	f3c5 2503 	ubfx	r5, r5, #8, #4
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402060:	f004 070f 	and.w	r7, r4, #15
  402064:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402068:	eb07 0040 	add.w	r0, r7, r0, lsl #1
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  40206c:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  402070:	2764      	movs	r7, #100	; 0x64
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402072:	fb07 5000 	mla	r0, r7, r0, r5
	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  402076:	6008      	str	r0, [r1, #0]
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
	}

	/* Retrieve month */
	if (pul_month) {
  402078:	b14a      	cbz	r2, 40208e <rtc_get_date+0x56>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
  40207a:	f404 10f8 	and.w	r0, r4, #2031616	; 0x1f0000
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40207e:	0d01      	lsrs	r1, r0, #20
  402080:	008d      	lsls	r5, r1, #2
  402082:	f3c0 4003 	ubfx	r0, r0, #16, #4
  402086:	4429      	add	r1, r5
  402088:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  40208c:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  40208e:	b14b      	cbz	r3, 4020a4 <rtc_get_date+0x6c>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
  402090:	f004 527c 	and.w	r2, r4, #1056964608	; 0x3f000000
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402094:	0f11      	lsrs	r1, r2, #28
  402096:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40209a:	f3c2 6203 	ubfx	r2, r2, #24, #4
  40209e:	eb02 0241 	add.w	r2, r2, r1, lsl #1
  4020a2:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  4020a4:	b116      	cbz	r6, 4020ac <rtc_get_date+0x74>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  4020a6:	f3c4 5442 	ubfx	r4, r4, #21, #3
  4020aa:	6034      	str	r4, [r6, #0]
	}
}
  4020ac:	bcf0      	pop	{r4, r5, r6, r7}
  4020ae:	4770      	bx	lr

004020b0 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  4020b0:	60c1      	str	r1, [r0, #12]
  4020b2:	4770      	bx	lr

004020b4 <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  4020b4:	6940      	ldr	r0, [r0, #20]
}
  4020b6:	4770      	bx	lr

004020b8 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  4020b8:	6943      	ldr	r3, [r0, #20]
  4020ba:	079b      	lsls	r3, r3, #30
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  4020bc:	bf46      	itte	mi
  4020be:	61c1      	strmi	r1, [r0, #28]
	return 0;
  4020c0:	2000      	movmi	r0, #0
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  4020c2:	2001      	movpl	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  4020c4:	4770      	bx	lr
  4020c6:	bf00      	nop

004020c8 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  4020c8:	6081      	str	r1, [r0, #8]
  4020ca:	4770      	bx	lr

004020cc <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  4020cc:	60c1      	str	r1, [r0, #12]
  4020ce:	4770      	bx	lr

004020d0 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  4020d0:	6943      	ldr	r3, [r0, #20]
  4020d2:	079b      	lsls	r3, r3, #30
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  4020d4:	bf43      	ittte	mi
  4020d6:	f3c1 0108 	ubfxmi	r1, r1, #0, #9
  4020da:	61c1      	strmi	r1, [r0, #28]
	return 0;
  4020dc:	2000      	movmi	r0, #0
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  4020de:	2001      	movpl	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  4020e0:	4770      	bx	lr
  4020e2:	bf00      	nop

004020e4 <usart_getchar>:
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	/* Wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  4020e4:	6943      	ldr	r3, [r0, #20]
  4020e6:	07db      	lsls	r3, r3, #31
  4020e8:	d5fc      	bpl.n	4020e4 <usart_getchar>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  4020ea:	6983      	ldr	r3, [r0, #24]
  4020ec:	f3c3 0308 	ubfx	r3, r3, #0, #9
  4020f0:	600b      	str	r3, [r1, #0]

	return 0;
}
  4020f2:	2000      	movs	r0, #0
  4020f4:	4770      	bx	lr
  4020f6:	bf00      	nop

004020f8 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  4020f8:	b538      	push	{r3, r4, r5, lr}
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  4020fa:	2100      	movs	r1, #0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  4020fc:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  4020fe:	4b0b      	ldr	r3, [pc, #44]	; (40212c <disk_initialize+0x34>)
  402100:	480b      	ldr	r0, [pc, #44]	; (402130 <disk_initialize+0x38>)
  402102:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  402104:	2c02      	cmp	r4, #2
  402106:	d807      	bhi.n	402118 <disk_initialize+0x20>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  402108:	4620      	mov	r0, r4
  40210a:	4d0a      	ldr	r5, [pc, #40]	; (402134 <disk_initialize+0x3c>)
  40210c:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
  40210e:	2803      	cmp	r0, #3
  402110:	d101      	bne.n	402116 <disk_initialize+0x1e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  402112:	4620      	mov	r0, r4
  402114:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  402116:	b108      	cbz	r0, 40211c <disk_initialize+0x24>
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  402118:	2001      	movs	r0, #1
  40211a:	bd38      	pop	{r3, r4, r5, pc}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  40211c:	4620      	mov	r0, r4
  40211e:	4b06      	ldr	r3, [pc, #24]	; (402138 <disk_initialize+0x40>)
  402120:	4798      	blx	r3
  402122:	2800      	cmp	r0, #0
		return STA_PROTECT;
  402124:	bf0c      	ite	eq
  402126:	2000      	moveq	r0, #0
  402128:	2004      	movne	r0, #4
	}

	/* The memory should already be initialized */
	return 0;
}
  40212a:	bd38      	pop	{r3, r4, r5, pc}
  40212c:	00401fc9 	.word	0x00401fc9
  402130:	400e1460 	.word	0x400e1460
  402134:	0040199d 	.word	0x0040199d
  402138:	004019dd 	.word	0x004019dd

0040213c <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  40213c:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  40213e:	4b04      	ldr	r3, [pc, #16]	; (402150 <disk_status+0x14>)
  402140:	4798      	blx	r3
  402142:	b118      	cbz	r0, 40214c <disk_status+0x10>
  402144:	2802      	cmp	r0, #2
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  402146:	bf0c      	ite	eq
  402148:	2003      	moveq	r0, #3
  40214a:	2001      	movne	r0, #1
	}
}
  40214c:	bd08      	pop	{r3, pc}
  40214e:	bf00      	nop
  402150:	0040199d 	.word	0x0040199d

00402154 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  402154:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402158:	4c18      	ldr	r4, [pc, #96]	; (4021bc <disk_read+0x68>)
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  40215a:	b083      	sub	sp, #12
  40215c:	460e      	mov	r6, r1
  40215e:	4615      	mov	r5, r2
  402160:	4698      	mov	r8, r3
  402162:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402164:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  402166:	4604      	mov	r4, r0
  402168:	b918      	cbnz	r0, 402172 <disk_read+0x1e>
		return RES_ERROR;
  40216a:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40216c:	b003      	add	sp, #12
  40216e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  402172:	4b13      	ldr	r3, [pc, #76]	; (4021c0 <disk_read+0x6c>)
  402174:	4648      	mov	r0, r9
  402176:	a901      	add	r1, sp, #4
  402178:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  40217a:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  40217c:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  402180:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402184:	442a      	add	r2, r5
  402186:	429a      	cmp	r2, r3
  402188:	d903      	bls.n	402192 <disk_read+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  40218a:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40218c:	b003      	add	sp, #12
  40218e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402192:	f1b8 0f00 	cmp.w	r8, #0
  402196:	d00f      	beq.n	4021b8 <disk_read+0x64>
  402198:	f8df b028 	ldr.w	fp, [pc, #40]	; 4021c4 <disk_read+0x70>
  40219c:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  4021a0:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  4021a2:	4629      	mov	r1, r5
  4021a4:	4632      	mov	r2, r6
  4021a6:	4648      	mov	r0, r9
  4021a8:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  4021aa:	3701      	adds	r7, #1
  4021ac:	4425      	add	r5, r4
  4021ae:	4456      	add	r6, sl
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  4021b0:	2800      	cmp	r0, #0
  4021b2:	d1da      	bne.n	40216a <disk_read+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  4021b4:	4547      	cmp	r7, r8
  4021b6:	d3f4      	bcc.n	4021a2 <disk_read+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  4021b8:	2000      	movs	r0, #0
  4021ba:	e7d7      	b.n	40216c <disk_read+0x18>
  4021bc:	004019d1 	.word	0x004019d1
  4021c0:	004019b5 	.word	0x004019b5
  4021c4:	004019f9 	.word	0x004019f9

004021c8 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  4021c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  4021cc:	4c18      	ldr	r4, [pc, #96]	; (402230 <disk_write+0x68>)
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  4021ce:	b083      	sub	sp, #12
  4021d0:	460e      	mov	r6, r1
  4021d2:	4615      	mov	r5, r2
  4021d4:	4698      	mov	r8, r3
  4021d6:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  4021d8:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  4021da:	4604      	mov	r4, r0
  4021dc:	b918      	cbnz	r0, 4021e6 <disk_write+0x1e>
		return RES_ERROR;
  4021de:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  4021e0:	b003      	add	sp, #12
  4021e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  4021e6:	4b13      	ldr	r3, [pc, #76]	; (402234 <disk_write+0x6c>)
  4021e8:	4648      	mov	r0, r9
  4021ea:	a901      	add	r1, sp, #4
  4021ec:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  4021ee:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  4021f0:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  4021f4:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  4021f8:	442a      	add	r2, r5
  4021fa:	429a      	cmp	r2, r3
  4021fc:	d903      	bls.n	402206 <disk_write+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  4021fe:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  402200:	b003      	add	sp, #12
  402202:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  402206:	f1b8 0f00 	cmp.w	r8, #0
  40220a:	d00f      	beq.n	40222c <disk_write+0x64>
  40220c:	f8df b028 	ldr.w	fp, [pc, #40]	; 402238 <disk_write+0x70>
  402210:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  402214:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  402216:	4629      	mov	r1, r5
  402218:	4632      	mov	r2, r6
  40221a:	4648      	mov	r0, r9
  40221c:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  40221e:	3701      	adds	r7, #1
  402220:	4425      	add	r5, r4
  402222:	4456      	add	r6, sl
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  402224:	2800      	cmp	r0, #0
  402226:	d1da      	bne.n	4021de <disk_write+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  402228:	4547      	cmp	r7, r8
  40222a:	d3f4      	bcc.n	402216 <disk_write+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  40222c:	2000      	movs	r0, #0
  40222e:	e7d7      	b.n	4021e0 <disk_write+0x18>
  402230:	004019d1 	.word	0x004019d1
  402234:	004019b5 	.word	0x004019b5
  402238:	00401a19 	.word	0x00401a19

0040223c <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  40223c:	b510      	push	{r4, lr}
  40223e:	4614      	mov	r4, r2
  402240:	b082      	sub	sp, #8
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  402242:	2903      	cmp	r1, #3
  402244:	d829      	bhi.n	40229a <disk_ioctl+0x5e>
  402246:	e8df f001 	tbb	[pc, r1]
  40224a:	131c      	.short	0x131c
  40224c:	0207      	.short	0x0207
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  40224e:	2301      	movs	r3, #1
  402250:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  402252:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  402254:	b002      	add	sp, #8
  402256:	bd10      	pop	{r4, pc}
	break;

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
  402258:	4b11      	ldr	r3, [pc, #68]	; (4022a0 <disk_ioctl+0x64>)
  40225a:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
  40225c:	1e43      	subs	r3, r0, #1
  40225e:	b2db      	uxtb	r3, r3
  402260:	2b01      	cmp	r3, #1
  402262:	d916      	bls.n	402292 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_1024) &&
  402264:	2804      	cmp	r0, #4
  402266:	d014      	beq.n	402292 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_2048) &&
  402268:	2808      	cmp	r0, #8
  40226a:	d012      	beq.n	402292 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
  40226c:	2001      	movs	r0, #1
  40226e:	e7f1      	b.n	402254 <disk_ioctl+0x18>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
  402270:	a901      	add	r1, sp, #4
  402272:	4b0c      	ldr	r3, [pc, #48]	; (4022a4 <disk_ioctl+0x68>)
  402274:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
  402276:	9b01      	ldr	r3, [sp, #4]

		res = RES_OK;
  402278:	2000      	movs	r0, #0
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);

		*(DWORD *)buff = ul_last_sector_num + 1;
  40227a:	3301      	adds	r3, #1
  40227c:	6023      	str	r3, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  40227e:	b002      	add	sp, #8
  402280:	bd10      	pop	{r4, pc}
	}
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  402282:	4b09      	ldr	r3, [pc, #36]	; (4022a8 <disk_ioctl+0x6c>)
  402284:	4798      	blx	r3
			res = RES_OK;
  402286:	2800      	cmp	r0, #0
  402288:	bf14      	ite	ne
  40228a:	2003      	movne	r0, #3
  40228c:	2000      	moveq	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  40228e:	b002      	add	sp, #8
  402290:	bd10      	pop	{r4, pc}
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  402292:	2000      	movs	r0, #0
  402294:	7020      	strb	r0, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  402296:	b002      	add	sp, #8
  402298:	bd10      	pop	{r4, pc}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
  40229a:	2004      	movs	r0, #4
  40229c:	e7da      	b.n	402254 <disk_ioctl+0x18>
  40229e:	bf00      	nop
  4022a0:	004019d1 	.word	0x004019d1
  4022a4:	004019b5 	.word	0x004019b5
  4022a8:	0040199d 	.word	0x0040199d

004022ac <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  4022ac:	b530      	push	{r4, r5, lr}
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  4022ae:	4c12      	ldr	r4, [pc, #72]	; (4022f8 <get_fattime+0x4c>)
  4022b0:	4d12      	ldr	r5, [pc, #72]	; (4022fc <get_fattime+0x50>)
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  4022b2:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  4022b4:	4620      	mov	r0, r4
  4022b6:	a903      	add	r1, sp, #12
  4022b8:	aa04      	add	r2, sp, #16
  4022ba:	ab05      	add	r3, sp, #20
  4022bc:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  4022be:	ab09      	add	r3, sp, #36	; 0x24
  4022c0:	4620      	mov	r0, r4
  4022c2:	9300      	str	r3, [sp, #0]
  4022c4:	a906      	add	r1, sp, #24
  4022c6:	aa07      	add	r2, sp, #28
  4022c8:	ab08      	add	r3, sp, #32
  4022ca:	4c0d      	ldr	r4, [pc, #52]	; (402300 <get_fattime+0x54>)
  4022cc:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  4022ce:	9d08      	ldr	r5, [sp, #32]
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  4022d0:	9c07      	ldr	r4, [sp, #28]
			| (ul_day << 16)
  4022d2:	9805      	ldr	r0, [sp, #20]
			| (ul_hour << 11)
  4022d4:	9903      	ldr	r1, [sp, #12]
			| (ul_minute << 5)
  4022d6:	9a04      	ldr	r2, [sp, #16]

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  4022d8:	9b06      	ldr	r3, [sp, #24]
			| (ul_month << 21)
			| (ul_day << 16)
  4022da:	042d      	lsls	r5, r5, #16
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  4022dc:	ea45 5444 	orr.w	r4, r5, r4, lsl #21
			| (ul_day << 16)
  4022e0:	4320      	orrs	r0, r4
			| (ul_hour << 11)
  4022e2:	ea40 21c1 	orr.w	r1, r0, r1, lsl #11
			| (ul_minute << 5)
  4022e6:	ea41 1042 	orr.w	r0, r1, r2, lsl #5

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  4022ea:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| (ul_second << 0);

	return ul_time;
}
  4022ee:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
  4022f2:	b00b      	add	sp, #44	; 0x2c
  4022f4:	bd30      	pop	{r4, r5, pc}
  4022f6:	bf00      	nop
  4022f8:	400e1460 	.word	0x400e1460
  4022fc:	00401fdd 	.word	0x00401fdd
  402300:	00402039 	.word	0x00402039

00402304 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dj,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  402304:	b470      	push	{r4, r5, r6}
  402306:	4a19      	ldr	r2, [pc, #100]	; (40236c <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  402308:	2600      	movs	r6, #0
  40230a:	4633      	mov	r3, r6
		if (Files[i].fs) {	/* Existing entry */
  40230c:	f852 4c08 	ldr.w	r4, [r2, #-8]
  402310:	b174      	cbz	r4, 402330 <chk_lock+0x2c>
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  402312:	6805      	ldr	r5, [r0, #0]
  402314:	42ac      	cmp	r4, r5
  402316:	d010      	beq.n	40233a <chk_lock+0x36>
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  402318:	3301      	adds	r3, #1
  40231a:	2b03      	cmp	r3, #3
  40231c:	f102 020c 	add.w	r2, r2, #12
  402320:	d1f4      	bne.n	40230c <chk_lock+0x8>
		} else {			/* Blank entry */
			be++;
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  402322:	b93e      	cbnz	r6, 402334 <chk_lock+0x30>
  402324:	2902      	cmp	r1, #2
  402326:	bf14      	ite	ne
  402328:	2012      	movne	r0, #18
  40232a:	2000      	moveq	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  40232c:	bc70      	pop	{r4, r5, r6}
  40232e:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
				Files[i].clu == dj->sclust &&
				Files[i].idx == dj->index) break;
		} else {			/* Blank entry */
			be++;
  402330:	3601      	adds	r6, #1
  402332:	e7f1      	b.n	402318 <chk_lock+0x14>
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  402334:	2000      	movs	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  402336:	bc70      	pop	{r4, r5, r6}
  402338:	4770      	bx	lr
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  40233a:	f852 5c04 	ldr.w	r5, [r2, #-4]
  40233e:	6884      	ldr	r4, [r0, #8]
  402340:	42a5      	cmp	r5, r4
  402342:	d1e9      	bne.n	402318 <chk_lock+0x14>
				Files[i].clu == dj->sclust &&
  402344:	8815      	ldrh	r5, [r2, #0]
  402346:	88c4      	ldrh	r4, [r0, #6]
  402348:	42a5      	cmp	r5, r4
  40234a:	d1e5      	bne.n	402318 <chk_lock+0x14>
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40234c:	b109      	cbz	r1, 402352 <chk_lock+0x4e>
  40234e:	2010      	movs	r0, #16
  402350:	e7ec      	b.n	40232c <chk_lock+0x28>
  402352:	4a07      	ldr	r2, [pc, #28]	; (402370 <chk_lock+0x6c>)
  402354:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  402358:	eb02 0383 	add.w	r3, r2, r3, lsl #2
}
  40235c:	bc70      	pop	{r4, r5, r6}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40235e:	895b      	ldrh	r3, [r3, #10]
  402360:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  402364:	bf14      	ite	ne
  402366:	2000      	movne	r0, #0
  402368:	2010      	moveq	r0, #16
}
  40236a:	4770      	bx	lr
  40236c:	20000ee0 	.word	0x20000ee0
  402370:	20000ed8 	.word	0x20000ed8

00402374 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  402374:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD wsect;


	wsect = fs->winsect;
  402378:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  40237a:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  40237c:	4604      	mov	r4, r0
  40237e:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  402380:	d002      	beq.n	402388 <move_window+0x14>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  402382:	7903      	ldrb	r3, [r0, #4]
  402384:	b973      	cbnz	r3, 4023a4 <move_window+0x30>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  402386:	b916      	cbnz	r6, 40238e <move_window+0x1a>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
  402388:	2000      	movs	r0, #0
  40238a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  40238e:	7860      	ldrb	r0, [r4, #1]
  402390:	4d17      	ldr	r5, [pc, #92]	; (4023f0 <move_window+0x7c>)
  402392:	f104 0130 	add.w	r1, r4, #48	; 0x30
  402396:	4632      	mov	r2, r6
  402398:	2301      	movs	r3, #1
  40239a:	47a8      	blx	r5
  40239c:	bb20      	cbnz	r0, 4023e8 <move_window+0x74>
				return FR_DISK_ERR;
			fs->winsect = sector;
  40239e:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
  4023a0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  4023a4:	f100 0830 	add.w	r8, r0, #48	; 0x30
  4023a8:	4641      	mov	r1, r8
  4023aa:	7840      	ldrb	r0, [r0, #1]
  4023ac:	f8df 9044 	ldr.w	r9, [pc, #68]	; 4023f4 <move_window+0x80>
  4023b0:	462a      	mov	r2, r5
  4023b2:	2301      	movs	r3, #1
  4023b4:	47c8      	blx	r9
  4023b6:	b9b8      	cbnz	r0, 4023e8 <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  4023b8:	69e3      	ldr	r3, [r4, #28]
  4023ba:	6a22      	ldr	r2, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  4023bc:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  4023be:	441a      	add	r2, r3
  4023c0:	4295      	cmp	r5, r2
  4023c2:	d2e0      	bcs.n	402386 <move_window+0x12>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4023c4:	78e7      	ldrb	r7, [r4, #3]
  4023c6:	2f01      	cmp	r7, #1
  4023c8:	d801      	bhi.n	4023ce <move_window+0x5a>
  4023ca:	e7dc      	b.n	402386 <move_window+0x12>
  4023cc:	69e3      	ldr	r3, [r4, #28]
					wsect += fs->fsize;
  4023ce:	441d      	add	r5, r3
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4023d0:	3f01      	subs	r7, #1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  4023d2:	462a      	mov	r2, r5
  4023d4:	7860      	ldrb	r0, [r4, #1]
  4023d6:	4641      	mov	r1, r8
  4023d8:	2301      	movs	r3, #1
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4023da:	b2ff      	uxtb	r7, r7
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  4023dc:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4023de:	2f01      	cmp	r7, #1
  4023e0:	d1f4      	bne.n	4023cc <move_window+0x58>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  4023e2:	2e00      	cmp	r6, #0
  4023e4:	d0d0      	beq.n	402388 <move_window+0x14>
  4023e6:	e7d2      	b.n	40238e <move_window+0x1a>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
  4023e8:	2001      	movs	r0, #1
  4023ea:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4023ee:	bf00      	nop
  4023f0:	00402155 	.word	0x00402155
  4023f4:	004021c9 	.word	0x004021c9

004023f8 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4023f8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;


	res = move_window(fs, 0);
  4023fc:	2100      	movs	r1, #0
  4023fe:	4b31      	ldr	r3, [pc, #196]	; (4024c4 <sync+0xcc>)
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  402400:	4605      	mov	r5, r0
	FRESULT res;


	res = move_window(fs, 0);
  402402:	4798      	blx	r3
  402404:	4603      	mov	r3, r0
	if (res == FR_OK) {
  402406:	b950      	cbnz	r0, 40241e <sync+0x26>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  402408:	782b      	ldrb	r3, [r5, #0]
  40240a:	2b03      	cmp	r3, #3
  40240c:	d00a      	beq.n	402424 <sync+0x2c>
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  40240e:	2100      	movs	r1, #0
  402410:	4b2d      	ldr	r3, [pc, #180]	; (4024c8 <sync+0xd0>)
  402412:	7868      	ldrb	r0, [r5, #1]
  402414:	460a      	mov	r2, r1
  402416:	4798      	blx	r3
  402418:	1c03      	adds	r3, r0, #0
  40241a:	bf18      	it	ne
  40241c:	2301      	movne	r3, #1
			res = FR_DISK_ERR;
	}

	return res;
}
  40241e:	4618      	mov	r0, r3
  402420:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  402424:	796b      	ldrb	r3, [r5, #5]
  402426:	2b00      	cmp	r3, #0
  402428:	d0f1      	beq.n	40240e <sync+0x16>
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  40242a:	f105 0130 	add.w	r1, r5, #48	; 0x30

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
  40242e:	62e8      	str	r0, [r5, #44]	; 0x2c
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402430:	460b      	mov	r3, r1
  402432:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  402436:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  40243a:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
  40243c:	f04f 0400 	mov.w	r4, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402440:	d1f9      	bne.n	402436 <sync+0x3e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402442:	692a      	ldr	r2, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402444:	68eb      	ldr	r3, [r5, #12]
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402446:	f885 2218 	strb.w	r2, [r5, #536]	; 0x218
  40244a:	f3c2 2b07 	ubfx	fp, r2, #8, #8
  40244e:	ea4f 4a12 	mov.w	sl, r2, lsr #16
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402452:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  402456:	ea4f 6e13 	mov.w	lr, r3, lsr #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  40245a:	2052      	movs	r0, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  40245c:	ea4f 6912 	mov.w	r9, r2, lsr #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402460:	f3c3 2807 	ubfx	r8, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402464:	2261      	movs	r2, #97	; 0x61
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402466:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402468:	f885 b219 	strb.w	fp, [r5, #537]	; 0x219
  40246c:	f885 a21a 	strb.w	sl, [r5, #538]	; 0x21a
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402470:	f04f 0b41 	mov.w	fp, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  402474:	f04f 0a72 	mov.w	sl, #114	; 0x72
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402478:	2755      	movs	r7, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40247a:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40247e:	f885 622f 	strb.w	r6, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402482:	f885 0030 	strb.w	r0, [r5, #48]	; 0x30
  402486:	f885 0031 	strb.w	r0, [r5, #49]	; 0x31
  40248a:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  40248e:	f885 2217 	strb.w	r2, [r5, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402492:	f885 921b 	strb.w	r9, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402496:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
  40249a:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
  40249e:	f885 e21f 	strb.w	lr, [r5, #543]	; 0x21f
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  4024a2:	f885 722e 	strb.w	r7, [r5, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  4024a6:	f885 b033 	strb.w	fp, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  4024aa:	f885 b216 	strb.w	fp, [r5, #534]	; 0x216
  4024ae:	f885 a214 	strb.w	sl, [r5, #532]	; 0x214
  4024b2:	f885 a215 	strb.w	sl, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  4024b6:	7868      	ldrb	r0, [r5, #1]
  4024b8:	696a      	ldr	r2, [r5, #20]
  4024ba:	4e04      	ldr	r6, [pc, #16]	; (4024cc <sync+0xd4>)
  4024bc:	2301      	movs	r3, #1
  4024be:	47b0      	blx	r6
			fs->fsi_flag = 0;
  4024c0:	716c      	strb	r4, [r5, #5]
  4024c2:	e7a4      	b.n	40240e <sync+0x16>
  4024c4:	00402375 	.word	0x00402375
  4024c8:	0040223d 	.word	0x0040223d
  4024cc:	004021c9 	.word	0x004021c9

004024d0 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  4024d0:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  4024d2:	b108      	cbz	r0, 4024d8 <validate+0x8>
  4024d4:	7803      	ldrb	r3, [r0, #0]
  4024d6:	b90b      	cbnz	r3, 4024dc <validate+0xc>
		return FR_INVALID_OBJECT;
  4024d8:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  4024da:	bd08      	pop	{r3, pc}
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  4024dc:	88c3      	ldrh	r3, [r0, #6]
  4024de:	428b      	cmp	r3, r1
  4024e0:	d1fa      	bne.n	4024d8 <validate+0x8>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  4024e2:	4b04      	ldr	r3, [pc, #16]	; (4024f4 <validate+0x24>)
  4024e4:	7840      	ldrb	r0, [r0, #1]
  4024e6:	4798      	blx	r3
  4024e8:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
  4024ec:	bf0c      	ite	eq
  4024ee:	2000      	moveq	r0, #0
  4024f0:	2003      	movne	r0, #3
  4024f2:	bd08      	pop	{r3, pc}
  4024f4:	0040213d 	.word	0x0040213d

004024f8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  4024f8:	b570      	push	{r4, r5, r6, lr}
  4024fa:	4604      	mov	r4, r0
  4024fc:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  4024fe:	7840      	ldrb	r0, [r0, #1]
  402500:	4d1d      	ldr	r5, [pc, #116]	; (402578 <check_fs+0x80>)
  402502:	f104 0130 	add.w	r1, r4, #48	; 0x30
  402506:	2301      	movs	r3, #1
  402508:	47a8      	blx	r5
  40250a:	b108      	cbz	r0, 402510 <check_fs+0x18>
		return 3;
  40250c:	2003      	movs	r0, #3
  40250e:	bd70      	pop	{r4, r5, r6, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  402510:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  402514:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
  402518:	4b18      	ldr	r3, [pc, #96]	; (40257c <check_fs+0x84>)
  40251a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  40251e:	b212      	sxth	r2, r2
  402520:	429a      	cmp	r2, r3
  402522:	d001      	beq.n	402528 <check_fs+0x30>
		return 2;
  402524:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  402526:	bd70      	pop	{r4, r5, r6, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  402528:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  40252c:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
  402530:	f894 5066 	ldrb.w	r5, [r4, #102]	; 0x66
  402534:	f894 1067 	ldrb.w	r1, [r4, #103]	; 0x67
  402538:	4b11      	ldr	r3, [pc, #68]	; (402580 <check_fs+0x88>)
  40253a:	0412      	lsls	r2, r2, #16
  40253c:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
  402540:	432a      	orrs	r2, r5
  402542:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  402546:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  40254a:	429a      	cmp	r2, r3
  40254c:	d0eb      	beq.n	402526 <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  40254e:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
  402552:	f894 5085 	ldrb.w	r5, [r4, #133]	; 0x85
  402556:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  40255a:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
  40255e:	0412      	lsls	r2, r2, #16
  402560:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  402564:	430a      	orrs	r2, r1
  402566:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  40256a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
  40256e:	1ac0      	subs	r0, r0, r3
  402570:	bf18      	it	ne
  402572:	2001      	movne	r0, #1
  402574:	bd70      	pop	{r4, r5, r6, pc}
  402576:	bf00      	nop
  402578:	00402155 	.word	0x00402155
  40257c:	ffffaa55 	.word	0xffffaa55
  402580:	00544146 	.word	0x00544146

00402584 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402584:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  402588:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  40258a:	781c      	ldrb	r4, [r3, #0]
  40258c:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  40258e:	2c09      	cmp	r4, #9
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402590:	4615      	mov	r5, r2
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  402592:	d802      	bhi.n	40259a <chk_mounted+0x16>
  402594:	785a      	ldrb	r2, [r3, #1]
  402596:	2a3a      	cmp	r2, #58	; 0x3a
  402598:	d015      	beq.n	4025c6 <chk_mounted+0x42>
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  40259a:	4bbd      	ldr	r3, [pc, #756]	; (402890 <chk_mounted+0x30c>)
  40259c:	681c      	ldr	r4, [r3, #0]
  40259e:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4025a0:	b174      	cbz	r4, 4025c0 <chk_mounted+0x3c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  4025a2:	7823      	ldrb	r3, [r4, #0]
  4025a4:	b1b3      	cbz	r3, 4025d4 <chk_mounted+0x50>
		stat = disk_status(fs->drv);
  4025a6:	4bbb      	ldr	r3, [pc, #748]	; (402894 <chk_mounted+0x310>)
  4025a8:	7860      	ldrb	r0, [r4, #1]
  4025aa:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  4025ac:	07c3      	lsls	r3, r0, #31
  4025ae:	d411      	bmi.n	4025d4 <chk_mounted+0x50>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  4025b0:	b305      	cbz	r5, 4025f4 <chk_mounted+0x70>
				return FR_WRITE_PROTECTED;
  4025b2:	f010 0f04 	tst.w	r0, #4
  4025b6:	bf0c      	ite	eq
  4025b8:	2000      	moveq	r0, #0
  4025ba:	200a      	movne	r0, #10
  4025bc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  4025c0:	200c      	movs	r0, #12
  4025c2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
  4025c6:	3302      	adds	r3, #2
  4025c8:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  4025ca:	2c00      	cmp	r4, #0
  4025cc:	d0e5      	beq.n	40259a <chk_mounted+0x16>
		return FR_INVALID_DRIVE;
  4025ce:	200b      	movs	r0, #11
  4025d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  4025d4:	2000      	movs	r0, #0
  4025d6:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  4025d8:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  4025da:	4baf      	ldr	r3, [pc, #700]	; (402898 <chk_mounted+0x314>)
  4025dc:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  4025de:	07c7      	lsls	r7, r0, #31
  4025e0:	d502      	bpl.n	4025e8 <chk_mounted+0x64>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  4025e2:	2003      	movs	r0, #3
  4025e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  4025e8:	b13d      	cbz	r5, 4025fa <chk_mounted+0x76>
  4025ea:	0746      	lsls	r6, r0, #29
  4025ec:	d505      	bpl.n	4025fa <chk_mounted+0x76>
		return FR_WRITE_PROTECTED;
  4025ee:	200a      	movs	r0, #10
  4025f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  4025f4:	4628      	mov	r0, r5
  4025f6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4025fa:	4620      	mov	r0, r4
  4025fc:	2100      	movs	r1, #0
  4025fe:	4da7      	ldr	r5, [pc, #668]	; (40289c <chk_mounted+0x318>)
  402600:	47a8      	blx	r5
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  402602:	2801      	cmp	r0, #1
  402604:	d007      	beq.n	402616 <chk_mounted+0x92>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  402606:	2600      	movs	r6, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  402608:	2803      	cmp	r0, #3
  40260a:	f000 80bf 	beq.w	40278c <chk_mounted+0x208>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  40260e:	b1c0      	cbz	r0, 402642 <chk_mounted+0xbe>
  402610:	200d      	movs	r0, #13
  402612:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  402616:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
  40261a:	2b00      	cmp	r3, #0
  40261c:	d0f8      	beq.n	402610 <chk_mounted+0x8c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  40261e:	f894 21f8 	ldrb.w	r2, [r4, #504]	; 0x1f8
  402622:	f894 11f9 	ldrb.w	r1, [r4, #505]	; 0x1f9
  402626:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
  40262a:	f894 61f7 	ldrb.w	r6, [r4, #503]	; 0x1f7
  40262e:	0412      	lsls	r2, r2, #16
  402630:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  402634:	4313      	orrs	r3, r2
  402636:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  40263a:	4631      	mov	r1, r6
  40263c:	4620      	mov	r0, r4
  40263e:	47a8      	blx	r5
  402640:	e7e2      	b.n	402608 <chk_mounted+0x84>
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  402642:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  402646:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  40264a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40264e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402652:	d1dd      	bne.n	402610 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  402654:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  402658:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  40265c:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
  402660:	d10d      	bne.n	40267e <chk_mounted+0xfa>
  402662:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
  402666:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
  40266a:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  40266e:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
  402672:	0412      	lsls	r2, r2, #16
  402674:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  402678:	4313      	orrs	r3, r2
  40267a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  40267e:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  402682:	61e1      	str	r1, [r4, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402684:	1e43      	subs	r3, r0, #1
  402686:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  402688:	70e0      	strb	r0, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  40268a:	d8c1      	bhi.n	402610 <chk_mounted+0x8c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  40268c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
  402690:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  402692:	2b00      	cmp	r3, #0
  402694:	d0bc      	beq.n	402610 <chk_mounted+0x8c>
  402696:	1e5a      	subs	r2, r3, #1
  402698:	421a      	tst	r2, r3
  40269a:	d1b9      	bne.n	402610 <chk_mounted+0x8c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  40269c:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
  4026a0:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  4026a4:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  4026a8:	0715      	lsls	r5, r2, #28
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  4026aa:	8122      	strh	r2, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  4026ac:	d1b0      	bne.n	402610 <chk_mounted+0x8c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  4026ae:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
  4026b2:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  4026b6:	ea55 2507 	orrs.w	r5, r5, r7, lsl #8
  4026ba:	d10f      	bne.n	4026dc <chk_mounted+0x158>
  4026bc:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
  4026c0:	f894 8053 	ldrb.w	r8, [r4, #83]	; 0x53
  4026c4:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
  4026c8:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  4026cc:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  4026d0:	ea4c 6c08 	orr.w	ip, ip, r8, lsl #24
  4026d4:	ea4c 0505 	orr.w	r5, ip, r5
  4026d8:	ea45 2507 	orr.w	r5, r5, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  4026dc:	f894 c03f 	ldrb.w	ip, [r4, #63]	; 0x3f
  4026e0:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  4026e4:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  4026e8:	d092      	beq.n	402610 <chk_mounted+0x8c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  4026ea:	fb00 fc01 	mul.w	ip, r0, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  4026ee:	eb07 1012 	add.w	r0, r7, r2, lsr #4
  4026f2:	4460      	add	r0, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  4026f4:	4285      	cmp	r5, r0
  4026f6:	d38b      	bcc.n	402610 <chk_mounted+0x8c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  4026f8:	1a2d      	subs	r5, r5, r0
  4026fa:	fbb5 f3f3 	udiv	r3, r5, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  4026fe:	2b00      	cmp	r3, #0
  402700:	d086      	beq.n	402610 <chk_mounted+0x8c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  402702:	f640 75f5 	movw	r5, #4085	; 0xff5
  402706:	42ab      	cmp	r3, r5
  402708:	f240 80c0 	bls.w	40288c <chk_mounted+0x308>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  40270c:	f64f 75f5 	movw	r5, #65525	; 0xfff5
  402710:	42ab      	cmp	r3, r5
  402712:	f200 80a0 	bhi.w	402856 <chk_mounted+0x2d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  402716:	2502      	movs	r5, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402718:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  40271a:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  40271c:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  40271e:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402720:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402722:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  402724:	2a00      	cmp	r2, #0
  402726:	f43f af73 	beq.w	402610 <chk_mounted+0x8c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  40272a:	4467      	add	r7, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  40272c:	2d02      	cmp	r5, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  40272e:	6267      	str	r7, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402730:	f000 808f 	beq.w	402852 <chk_mounted+0x2ce>
  402734:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  402738:	f003 0301 	and.w	r3, r3, #1
  40273c:	eb03 0352 	add.w	r3, r3, r2, lsr #1
  402740:	2501      	movs	r5, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  402742:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  402746:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
  40274a:	f4ff af61 	bcc.w	402610 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  40274e:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
  402752:	2300      	movs	r3, #0

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  402754:	2d03      	cmp	r5, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  402756:	6122      	str	r2, [r4, #16]
	fs->last_clust = 0;
  402758:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  40275a:	d01a      	beq.n	402792 <chk_mounted+0x20e>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  40275c:	4e50      	ldr	r6, [pc, #320]	; (4028a0 <chk_mounted+0x31c>)
  40275e:	4951      	ldr	r1, [pc, #324]	; (4028a4 <chk_mounted+0x320>)
  402760:	8830      	ldrh	r0, [r6, #0]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  402762:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  402764:	3001      	adds	r0, #1
	fs->winsect = 0;		/* Invalidate sector cache */
  402766:	2200      	movs	r2, #0
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402768:	b280      	uxth	r0, r0
  40276a:	8030      	strh	r0, [r6, #0]
  40276c:	80e0      	strh	r0, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
  40276e:	4613      	mov	r3, r2
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
	fs->winsect = 0;		/* Invalidate sector cache */
  402770:	62e2      	str	r2, [r4, #44]	; 0x2c
	fs->wflag = 0;
  402772:	7122      	strb	r2, [r4, #4]
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  402774:	4615      	mov	r5, r2
  402776:	4608      	mov	r0, r1
  402778:	58ca      	ldr	r2, [r1, r3]
  40277a:	4294      	cmp	r4, r2
  40277c:	bf08      	it	eq
  40277e:	501d      	streq	r5, [r3, r0]
  402780:	330c      	adds	r3, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  402782:	2b24      	cmp	r3, #36	; 0x24
  402784:	d1f8      	bne.n	402778 <chk_mounted+0x1f4>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  402786:	2000      	movs	r0, #0
  402788:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  40278c:	2001      	movs	r0, #1
  40278e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402792:	f894 1061 	ldrb.w	r1, [r4, #97]	; 0x61
  402796:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
  40279a:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  40279c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4027a0:	4432      	add	r2, r6
  4027a2:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4027a4:	7860      	ldrb	r0, [r4, #1]
  4027a6:	4e40      	ldr	r6, [pc, #256]	; (4028a8 <chk_mounted+0x324>)
  4027a8:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4027ac:	2301      	movs	r3, #1
  4027ae:	47b0      	blx	r6
  4027b0:	2800      	cmp	r0, #0
  4027b2:	d1d3      	bne.n	40275c <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4027b4:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  4027b8:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4027bc:	4b3b      	ldr	r3, [pc, #236]	; (4028ac <chk_mounted+0x328>)
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4027be:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  4027c2:	b212      	sxth	r2, r2
  4027c4:	429a      	cmp	r2, r3
  4027c6:	d1c9      	bne.n	40275c <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4027c8:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
  4027cc:	f894 6033 	ldrb.w	r6, [r4, #51]	; 0x33
  4027d0:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  4027d4:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4027d8:	4b35      	ldr	r3, [pc, #212]	; (4028b0 <chk_mounted+0x32c>)
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4027da:	0400      	lsls	r0, r0, #16
  4027dc:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
  4027e0:	4302      	orrs	r2, r0
  4027e2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  4027e6:	429a      	cmp	r2, r3
  4027e8:	d1b8      	bne.n	40275c <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  4027ea:	f894 0216 	ldrb.w	r0, [r4, #534]	; 0x216
  4027ee:	f894 6217 	ldrb.w	r6, [r4, #535]	; 0x217
  4027f2:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
  4027f6:	f894 1215 	ldrb.w	r1, [r4, #533]	; 0x215
  4027fa:	0400      	lsls	r0, r0, #16
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  4027fc:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402800:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402804:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402808:	4302      	orrs	r2, r0
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  40280a:	3320      	adds	r3, #32
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  40280c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402810:	429a      	cmp	r2, r3
  402812:	d1a3      	bne.n	40275c <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402814:	f894 721e 	ldrb.w	r7, [r4, #542]	; 0x21e
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402818:	f894 621a 	ldrb.w	r6, [r4, #538]	; 0x21a
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40281c:	f894 821f 	ldrb.w	r8, [r4, #543]	; 0x21f
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402820:	f894 c21b 	ldrb.w	ip, [r4, #539]	; 0x21b
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402824:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402828:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40282c:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402830:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402834:	043f      	lsls	r7, r7, #16
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402836:	0436      	lsls	r6, r6, #16
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402838:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40283c:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402840:	433a      	orrs	r2, r7
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402842:	4333      	orrs	r3, r6
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402844:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402848:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  40284c:	60e2      	str	r2, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  40284e:	6123      	str	r3, [r4, #16]
  402850:	e784      	b.n	40275c <chk_mounted+0x1d8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402852:	005b      	lsls	r3, r3, #1
  402854:	e775      	b.n	402742 <chk_mounted+0x1be>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402856:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  402858:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  40285a:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  40285c:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  40285e:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402860:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  402862:	2a00      	cmp	r2, #0
  402864:	f47f aed4 	bne.w	402610 <chk_mounted+0x8c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402868:	f894 505e 	ldrb.w	r5, [r4, #94]	; 0x5e
  40286c:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
  402870:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  402874:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  402878:	042d      	lsls	r5, r5, #16
  40287a:	ea45 6507 	orr.w	r5, r5, r7, lsl #24
  40287e:	432a      	orrs	r2, r5
  402880:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  402884:	009b      	lsls	r3, r3, #2
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402886:	6262      	str	r2, [r4, #36]	; 0x24
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402888:	2503      	movs	r5, #3
  40288a:	e75a      	b.n	402742 <chk_mounted+0x1be>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
  40288c:	2501      	movs	r5, #1
  40288e:	e743      	b.n	402718 <chk_mounted+0x194>
  402890:	20000efc 	.word	0x20000efc
  402894:	0040213d 	.word	0x0040213d
  402898:	004020f9 	.word	0x004020f9
  40289c:	004024f9 	.word	0x004024f9
  4028a0:	20000ed4 	.word	0x20000ed4
  4028a4:	20000ed8 	.word	0x20000ed8
  4028a8:	00402155 	.word	0x00402155
  4028ac:	ffffaa55 	.word	0xffffaa55
  4028b0:	41615252 	.word	0x41615252

004028b4 <get_fat.part.3>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  4028b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  4028b8:	7803      	ldrb	r3, [r0, #0]
  4028ba:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  4028bc:	4604      	mov	r4, r0
  4028be:	460d      	mov	r5, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  4028c0:	d048      	beq.n	402954 <get_fat.part.3+0xa0>
  4028c2:	2b03      	cmp	r3, #3
  4028c4:	d029      	beq.n	40291a <get_fat.part.3+0x66>
  4028c6:	2b01      	cmp	r3, #1
  4028c8:	d003      	beq.n	4028d2 <get_fat.part.3+0x1e>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  4028ca:	f04f 30ff 	mov.w	r0, #4294967295
}
  4028ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4028d2:	6a01      	ldr	r1, [r0, #32]
  4028d4:	4f29      	ldr	r7, [pc, #164]	; (40297c <get_fat.part.3+0xc8>)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  4028d6:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4028da:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4028de:	47b8      	blx	r7
  4028e0:	2800      	cmp	r0, #0
  4028e2:	d1f2      	bne.n	4028ca <get_fat.part.3+0x16>
		wc = fs->win[bc % SS(fs)]; bc++;
  4028e4:	f3c6 0308 	ubfx	r3, r6, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4028e8:	6a21      	ldr	r1, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4028ea:	4423      	add	r3, r4
  4028ec:	3601      	adds	r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4028ee:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  4028f2:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  4028f4:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  4028f8:	47b8      	blx	r7
  4028fa:	2800      	cmp	r0, #0
  4028fc:	d1e5      	bne.n	4028ca <get_fat.part.3+0x16>
		wc |= fs->win[bc % SS(fs)] << 8;
  4028fe:	f3c6 0608 	ubfx	r6, r6, #0, #9
  402902:	4434      	add	r4, r6
  402904:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402908:	ea48 2003 	orr.w	r0, r8, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  40290c:	07eb      	lsls	r3, r5, #31
  40290e:	bf4c      	ite	mi
  402910:	0900      	lsrmi	r0, r0, #4
  402912:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  402916:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  40291a:	6a01      	ldr	r1, [r0, #32]
  40291c:	4b17      	ldr	r3, [pc, #92]	; (40297c <get_fat.part.3+0xc8>)
  40291e:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402922:	4798      	blx	r3
  402924:	2800      	cmp	r0, #0
  402926:	d1d0      	bne.n	4028ca <get_fat.part.3+0x16>
		p = &fs->win[clst * 4 % SS(fs)];
  402928:	00ad      	lsls	r5, r5, #2
  40292a:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  40292e:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402932:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
  402934:	442c      	add	r4, r5
  402936:	78d8      	ldrb	r0, [r3, #3]
  402938:	7899      	ldrb	r1, [r3, #2]
  40293a:	785a      	ldrb	r2, [r3, #1]
  40293c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402940:	0600      	lsls	r0, r0, #24
  402942:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  402946:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
  40294a:	4318      	orrs	r0, r3
  40294c:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402950:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402954:	6a01      	ldr	r1, [r0, #32]
  402956:	4b09      	ldr	r3, [pc, #36]	; (40297c <get_fat.part.3+0xc8>)
  402958:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  40295c:	4798      	blx	r3
  40295e:	2800      	cmp	r0, #0
  402960:	d1b3      	bne.n	4028ca <get_fat.part.3+0x16>
		p = &fs->win[clst * 2 % SS(fs)];
  402962:	006d      	lsls	r5, r5, #1
  402964:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
  402968:	1963      	adds	r3, r4, r5
  40296a:	461c      	mov	r4, r3
  40296c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  402970:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
  402974:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402978:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40297c:	00402375 	.word	0x00402375

00402980 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402980:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  402982:	6883      	ldr	r3, [r0, #8]
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402984:	4604      	mov	r4, r0
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402986:	2b01      	cmp	r3, #1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402988:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  40298a:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  40298c:	d003      	beq.n	402996 <dir_sdi+0x16>
  40298e:	6800      	ldr	r0, [r0, #0]
  402990:	6982      	ldr	r2, [r0, #24]
  402992:	4293      	cmp	r3, r2
  402994:	d301      	bcc.n	40299a <dir_sdi+0x1a>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  402996:	2002      	movs	r0, #2
  402998:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  40299a:	b9b3      	cbnz	r3, 4029ca <dir_sdi+0x4a>
  40299c:	7803      	ldrb	r3, [r0, #0]
  40299e:	2b03      	cmp	r3, #3
  4029a0:	d010      	beq.n	4029c4 <dir_sdi+0x44>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  4029a2:	2300      	movs	r3, #0
  4029a4:	60e3      	str	r3, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  4029a6:	8903      	ldrh	r3, [r0, #8]
  4029a8:	42ab      	cmp	r3, r5
  4029aa:	d9f4      	bls.n	402996 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  4029ac:	6a43      	ldr	r3, [r0, #36]	; 0x24
  4029ae:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  4029b2:	6123      	str	r3, [r4, #16]
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  4029b4:	f005 050f 	and.w	r5, r5, #15
  4029b8:	eb00 1045 	add.w	r0, r0, r5, lsl #5
  4029bc:	3030      	adds	r0, #48	; 0x30
  4029be:	6160      	str	r0, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  4029c0:	2000      	movs	r0, #0
  4029c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;
  4029c4:	6a43      	ldr	r3, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  4029c6:	2b00      	cmp	r3, #0
  4029c8:	d0eb      	beq.n	4029a2 <dir_sdi+0x22>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  4029ca:	7886      	ldrb	r6, [r0, #2]
  4029cc:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  4029ce:	42b5      	cmp	r5, r6
  4029d0:	d319      	bcc.n	402a06 <dir_sdi+0x86>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4029d2:	2b01      	cmp	r3, #1
  4029d4:	d9df      	bls.n	402996 <dir_sdi+0x16>
  4029d6:	1bad      	subs	r5, r5, r6
  4029d8:	429a      	cmp	r2, r3
  4029da:	b2ad      	uxth	r5, r5
  4029dc:	d9db      	bls.n	402996 <dir_sdi+0x16>
  4029de:	4f11      	ldr	r7, [pc, #68]	; (402a24 <dir_sdi+0xa4>)
  4029e0:	e008      	b.n	4029f4 <dir_sdi+0x74>
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  4029e2:	2801      	cmp	r0, #1
  4029e4:	d9d7      	bls.n	402996 <dir_sdi+0x16>
  4029e6:	6820      	ldr	r0, [r4, #0]
  4029e8:	6982      	ldr	r2, [r0, #24]
  4029ea:	429a      	cmp	r2, r3
  4029ec:	d9d3      	bls.n	402996 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  4029ee:	42ae      	cmp	r6, r5
  4029f0:	d809      	bhi.n	402a06 <dir_sdi+0x86>
  4029f2:	460d      	mov	r5, r1
  4029f4:	4619      	mov	r1, r3
  4029f6:	47b8      	blx	r7
  4029f8:	1ba9      	subs	r1, r5, r6
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  4029fa:	1c42      	adds	r2, r0, #1
  4029fc:	4603      	mov	r3, r0
  4029fe:	b289      	uxth	r1, r1
  402a00:	d1ef      	bne.n	4029e2 <dir_sdi+0x62>
  402a02:	2001      	movs	r0, #1
  402a04:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  402a06:	60e3      	str	r3, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402a08:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402a0a:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402a0c:	3a02      	subs	r2, #2
  402a0e:	4293      	cmp	r3, r2
	return clst * fs->csize + fs->database;
  402a10:	bf3b      	ittet	cc
  402a12:	7881      	ldrbcc	r1, [r0, #2]
  402a14:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402a16:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
  402a18:	fb01 2303 	mlacc	r3, r1, r3, r2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402a1c:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402a20:	6123      	str	r3, [r4, #16]
  402a22:	e7c7      	b.n	4029b4 <dir_sdi+0x34>
  402a24:	004028b5 	.word	0x004028b5

00402a28 <put_fat.part.4>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402a28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402a2c:	7803      	ldrb	r3, [r0, #0]
  402a2e:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402a30:	4604      	mov	r4, r0
  402a32:	460d      	mov	r5, r1
  402a34:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402a36:	d05b      	beq.n	402af0 <put_fat.part.4+0xc8>
  402a38:	2b03      	cmp	r3, #3
  402a3a:	d039      	beq.n	402ab0 <put_fat.part.4+0x88>
  402a3c:	2b01      	cmp	r3, #1
  402a3e:	d004      	beq.n	402a4a <put_fat.part.4+0x22>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
  402a40:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
  402a42:	2301      	movs	r3, #1
  402a44:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402a46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402a4a:	6a01      	ldr	r1, [r0, #32]
  402a4c:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 402b24 <put_fat.part.4+0xfc>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  402a50:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402a54:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  402a58:	47c0      	blx	r8
			if (res != FR_OK) break;
  402a5a:	2800      	cmp	r0, #0
  402a5c:	d1f1      	bne.n	402a42 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402a5e:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  402a62:	f015 0501 	ands.w	r5, r5, #1
  402a66:	4423      	add	r3, r4
  402a68:	b2f2      	uxtb	r2, r6
  402a6a:	d006      	beq.n	402a7a <put_fat.part.4+0x52>
  402a6c:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
  402a70:	f001 010f 	and.w	r1, r1, #15
  402a74:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
  402a78:	b2d2      	uxtb	r2, r2
  402a7a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402a7e:	6a21      	ldr	r1, [r4, #32]
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
  402a80:	3701      	adds	r7, #1
			fs->wflag = 1;
  402a82:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402a84:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  402a88:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402a8a:	4620      	mov	r0, r4
  402a8c:	47c0      	blx	r8
			if (res != FR_OK) break;
  402a8e:	2800      	cmp	r0, #0
  402a90:	d1d7      	bne.n	402a42 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402a92:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402a96:	2d00      	cmp	r5, #0
  402a98:	d13f      	bne.n	402b1a <put_fat.part.4+0xf2>
  402a9a:	4427      	add	r7, r4
  402a9c:	f3c6 2603 	ubfx	r6, r6, #8, #4
  402aa0:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  402aa4:	f023 030f 	bic.w	r3, r3, #15
  402aa8:	431e      	orrs	r6, r3
  402aaa:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
  402aae:	e7c8      	b.n	402a42 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  402ab0:	6a01      	ldr	r1, [r0, #32]
  402ab2:	4b1c      	ldr	r3, [pc, #112]	; (402b24 <put_fat.part.4+0xfc>)
  402ab4:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402ab8:	4798      	blx	r3
			if (res != FR_OK) break;
  402aba:	2800      	cmp	r0, #0
  402abc:	d1c1      	bne.n	402a42 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
  402abe:	00ad      	lsls	r5, r5, #2
  402ac0:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402ac4:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402ac8:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
  402aca:	4425      	add	r5, r4
  402acc:	78da      	ldrb	r2, [r3, #3]
  402ace:	0612      	lsls	r2, r2, #24
  402ad0:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  402ad4:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
  402ad6:	f3c6 2707 	ubfx	r7, r6, #8, #8
  402ada:	0c31      	lsrs	r1, r6, #16
  402adc:	0e32      	lsrs	r2, r6, #24
  402ade:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
  402ae2:	705f      	strb	r7, [r3, #1]
  402ae4:	7099      	strb	r1, [r3, #2]
  402ae6:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402ae8:	2301      	movs	r3, #1
  402aea:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402aec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  402af0:	6a01      	ldr	r1, [r0, #32]
  402af2:	4b0c      	ldr	r3, [pc, #48]	; (402b24 <put_fat.part.4+0xfc>)
  402af4:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402af8:	4798      	blx	r3
			if (res != FR_OK) break;
  402afa:	2800      	cmp	r0, #0
  402afc:	d1a1      	bne.n	402a42 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
  402afe:	006d      	lsls	r5, r5, #1
  402b00:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  402b04:	1962      	adds	r2, r4, r5
  402b06:	f3c6 2307 	ubfx	r3, r6, #8, #8
  402b0a:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402b0e:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
  402b10:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402b14:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402b16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402b1a:	f3c6 1607 	ubfx	r6, r6, #4, #8
  402b1e:	4427      	add	r7, r4
  402b20:	e7c3      	b.n	402aaa <put_fat.part.4+0x82>
  402b22:	bf00      	nop
  402b24:	00402375 	.word	0x00402375

00402b28 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  402b28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402b2c:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  402b2e:	4688      	mov	r8, r1
  402b30:	bb01      	cbnz	r1, 402b74 <create_chain+0x4c>
		scl = fs->last_clust;			/* Get suggested start point */
  402b32:	68c6      	ldr	r6, [r0, #12]
  402b34:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402b36:	b35e      	cbz	r6, 402b90 <create_chain+0x68>
  402b38:	429e      	cmp	r6, r3
  402b3a:	bf28      	it	cs
  402b3c:	2601      	movcs	r6, #1
  402b3e:	4f2e      	ldr	r7, [pc, #184]	; (402bf8 <create_chain+0xd0>)
  402b40:	4634      	mov	r4, r6
  402b42:	e00f      	b.n	402b64 <create_chain+0x3c>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402b44:	2e01      	cmp	r6, #1
  402b46:	d925      	bls.n	402b94 <create_chain+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402b48:	2b02      	cmp	r3, #2
  402b4a:	d910      	bls.n	402b6e <create_chain+0x46>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
  402b4c:	2402      	movs	r4, #2
  402b4e:	4628      	mov	r0, r5
  402b50:	4621      	mov	r1, r4
  402b52:	47b8      	blx	r7
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
  402b54:	b338      	cbz	r0, 402ba6 <create_chain+0x7e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  402b56:	1c41      	adds	r1, r0, #1
  402b58:	d021      	beq.n	402b9e <create_chain+0x76>
  402b5a:	2801      	cmp	r0, #1
  402b5c:	d007      	beq.n	402b6e <create_chain+0x46>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  402b5e:	42a6      	cmp	r6, r4
  402b60:	d018      	beq.n	402b94 <create_chain+0x6c>
  402b62:	69ab      	ldr	r3, [r5, #24]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  402b64:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  402b66:	429c      	cmp	r4, r3
  402b68:	d2ec      	bcs.n	402b44 <create_chain+0x1c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402b6a:	2c01      	cmp	r4, #1
  402b6c:	d8ef      	bhi.n	402b4e <create_chain+0x26>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402b6e:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
  402b70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402b74:	2901      	cmp	r1, #1
  402b76:	d9fa      	bls.n	402b6e <create_chain+0x46>
  402b78:	6983      	ldr	r3, [r0, #24]
  402b7a:	4299      	cmp	r1, r3
  402b7c:	d2f7      	bcs.n	402b6e <create_chain+0x46>
  402b7e:	4b1e      	ldr	r3, [pc, #120]	; (402bf8 <create_chain+0xd0>)
  402b80:	4798      	blx	r3
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
  402b82:	2801      	cmp	r0, #1
  402b84:	d9f3      	bls.n	402b6e <create_chain+0x46>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  402b86:	69ab      	ldr	r3, [r5, #24]
  402b88:	4283      	cmp	r3, r0
  402b8a:	d8f1      	bhi.n	402b70 <create_chain+0x48>
  402b8c:	4646      	mov	r6, r8
  402b8e:	e7d6      	b.n	402b3e <create_chain+0x16>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402b90:	2601      	movs	r6, #1
  402b92:	e7d4      	b.n	402b3e <create_chain+0x16>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402b94:	2000      	movs	r0, #0
  402b96:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402b9a:	2801      	cmp	r0, #1
  402b9c:	d1e7      	bne.n	402b6e <create_chain+0x46>
  402b9e:	f04f 30ff 	mov.w	r0, #4294967295
  402ba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402ba6:	69ab      	ldr	r3, [r5, #24]
  402ba8:	42a3      	cmp	r3, r4
  402baa:	d9e0      	bls.n	402b6e <create_chain+0x46>
  402bac:	4628      	mov	r0, r5
  402bae:	4621      	mov	r1, r4
  402bb0:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  402bb4:	4e11      	ldr	r6, [pc, #68]	; (402bfc <create_chain+0xd4>)
  402bb6:	47b0      	blx	r6
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
  402bb8:	2800      	cmp	r0, #0
  402bba:	d1ee      	bne.n	402b9a <create_chain+0x72>
  402bbc:	f1b8 0f00 	cmp.w	r8, #0
  402bc0:	d00b      	beq.n	402bda <create_chain+0xb2>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402bc2:	f1b8 0f01 	cmp.w	r8, #1
  402bc6:	d9d2      	bls.n	402b6e <create_chain+0x46>
  402bc8:	69ab      	ldr	r3, [r5, #24]
  402bca:	4598      	cmp	r8, r3
  402bcc:	d2cf      	bcs.n	402b6e <create_chain+0x46>
  402bce:	4641      	mov	r1, r8
  402bd0:	4628      	mov	r0, r5
  402bd2:	4622      	mov	r2, r4
  402bd4:	47b0      	blx	r6

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
  402bd6:	2800      	cmp	r0, #0
  402bd8:	d1df      	bne.n	402b9a <create_chain+0x72>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  402bda:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  402bdc:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  402bde:	1c5a      	adds	r2, r3, #1
  402be0:	d006      	beq.n	402bf0 <create_chain+0xc8>
			fs->free_clust--;
  402be2:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
  402be4:	2201      	movs	r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  402be6:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  402be8:	716a      	strb	r2, [r5, #5]
  402bea:	4620      	mov	r0, r4
  402bec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402bf0:	4620      	mov	r0, r4
  402bf2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402bf6:	bf00      	nop
  402bf8:	004028b5 	.word	0x004028b5
  402bfc:	00402a29 	.word	0x00402a29

00402c00 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402c00:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  402c04:	88c5      	ldrh	r5, [r0, #6]
  402c06:	3501      	adds	r5, #1
  402c08:	b2ad      	uxth	r5, r5
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402c0a:	4604      	mov	r4, r0
  402c0c:	460e      	mov	r6, r1
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402c0e:	b915      	cbnz	r5, 402c16 <dir_next+0x16>
		return FR_NO_FILE;
  402c10:	2004      	movs	r0, #4
  402c12:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402c16:	6903      	ldr	r3, [r0, #16]
  402c18:	2b00      	cmp	r3, #0
  402c1a:	d0f9      	beq.n	402c10 <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402c1c:	f015 070f 	ands.w	r7, r5, #15
  402c20:	d008      	beq.n	402c34 <dir_next+0x34>
  402c22:	6800      	ldr	r0, [r0, #0]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402c24:	eb00 1347 	add.w	r3, r0, r7, lsl #5
  402c28:	3330      	adds	r3, #48	; 0x30
  402c2a:	6163      	str	r3, [r4, #20]
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  402c2c:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  402c2e:	2000      	movs	r0, #0
  402c30:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402c34:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  402c36:	3301      	adds	r3, #1
  402c38:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402c3a:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402c3c:	b161      	cbz	r1, 402c58 <dir_next+0x58>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402c3e:	7882      	ldrb	r2, [r0, #2]
  402c40:	3a01      	subs	r2, #1
  402c42:	ea12 1215 	ands.w	r2, r2, r5, lsr #4
  402c46:	d1ed      	bne.n	402c24 <dir_next+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402c48:	2901      	cmp	r1, #1
  402c4a:	d902      	bls.n	402c52 <dir_next+0x52>
  402c4c:	6982      	ldr	r2, [r0, #24]
  402c4e:	4291      	cmp	r1, r2
  402c50:	d306      	bcc.n	402c60 <dir_next+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402c52:	2002      	movs	r0, #2
  402c54:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402c58:	8902      	ldrh	r2, [r0, #8]
  402c5a:	42aa      	cmp	r2, r5
  402c5c:	d9d8      	bls.n	402c10 <dir_next+0x10>
  402c5e:	e7e1      	b.n	402c24 <dir_next+0x24>
  402c60:	4b34      	ldr	r3, [pc, #208]	; (402d34 <dir_next+0x134>)
  402c62:	4798      	blx	r3
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402c64:	2801      	cmp	r0, #1
  402c66:	4680      	mov	r8, r0
  402c68:	d9f3      	bls.n	402c52 <dir_next+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402c6a:	f1b0 3fff 	cmp.w	r0, #4294967295
  402c6e:	d01c      	beq.n	402caa <dir_next+0xaa>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402c70:	6820      	ldr	r0, [r4, #0]
  402c72:	6982      	ldr	r2, [r0, #24]
  402c74:	4542      	cmp	r2, r8
  402c76:	d90e      	bls.n	402c96 <dir_next+0x96>
  402c78:	f1a8 0602 	sub.w	r6, r8, #2
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402c7c:	f8c4 800c 	str.w	r8, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402c80:	6982      	ldr	r2, [r0, #24]
  402c82:	3a02      	subs	r2, #2
  402c84:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402c86:	bf3b      	ittet	cc
  402c88:	7881      	ldrbcc	r1, [r0, #2]
  402c8a:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402c8c:	2600      	movcs	r6, #0
	return clst * fs->csize + fs->database;
  402c8e:	fb01 2606 	mlacc	r6, r1, r6, r2
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  402c92:	6126      	str	r6, [r4, #16]
  402c94:	e7c6      	b.n	402c24 <dir_next+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  402c96:	2e00      	cmp	r6, #0
  402c98:	d0ba      	beq.n	402c10 <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  402c9a:	68e1      	ldr	r1, [r4, #12]
  402c9c:	4b26      	ldr	r3, [pc, #152]	; (402d38 <dir_next+0x138>)
  402c9e:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  402ca0:	4680      	mov	r8, r0
  402ca2:	b928      	cbnz	r0, 402cb0 <dir_next+0xb0>
  402ca4:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  402ca6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402caa:	2001      	movs	r0, #1
  402cac:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
  402cb0:	2801      	cmp	r0, #1
  402cb2:	d0ce      	beq.n	402c52 <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402cb4:	f1b0 3fff 	cmp.w	r0, #4294967295
  402cb8:	d0f7      	beq.n	402caa <dir_next+0xaa>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  402cba:	6820      	ldr	r0, [r4, #0]
  402cbc:	f8df 907c 	ldr.w	r9, [pc, #124]	; 402d3c <dir_next+0x13c>
  402cc0:	2100      	movs	r1, #0
  402cc2:	47c8      	blx	r9
  402cc4:	2800      	cmp	r0, #0
  402cc6:	d1f0      	bne.n	402caa <dir_next+0xaa>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402cc8:	6822      	ldr	r2, [r4, #0]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402cca:	4601      	mov	r1, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402ccc:	f102 0330 	add.w	r3, r2, #48	; 0x30
  402cd0:	f502 720c 	add.w	r2, r2, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402cd4:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402cd8:	4293      	cmp	r3, r2
  402cda:	d1fb      	bne.n	402cd4 <dir_next+0xd4>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402cdc:	6823      	ldr	r3, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cde:	699a      	ldr	r2, [r3, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402ce0:	f1a8 0602 	sub.w	r6, r8, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402ce4:	3a02      	subs	r2, #2
  402ce6:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402ce8:	bf3b      	ittet	cc
  402cea:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
  402cec:	7899      	ldrbcc	r1, [r3, #2]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cee:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
  402cf0:	fb01 2206 	mlacc	r2, r1, r6, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402cf4:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402cf6:	f04f 0a00 	mov.w	sl, #0
						dj->fs->wflag = 1;
  402cfa:	f04f 0b01 	mov.w	fp, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402cfe:	e00b      	b.n	402d18 <dir_next+0x118>
						dj->fs->wflag = 1;
  402d00:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402d04:	6820      	ldr	r0, [r4, #0]
  402d06:	47c8      	blx	r9
  402d08:	f10a 0a01 	add.w	sl, sl, #1
  402d0c:	2800      	cmp	r0, #0
  402d0e:	d1cc      	bne.n	402caa <dir_next+0xaa>
						dj->fs->winsect++;
  402d10:	6823      	ldr	r3, [r4, #0]
  402d12:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402d14:	3201      	adds	r2, #1
  402d16:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402d18:	6823      	ldr	r3, [r4, #0]
  402d1a:	7898      	ldrb	r0, [r3, #2]
  402d1c:	fa5f f28a 	uxtb.w	r2, sl
  402d20:	4290      	cmp	r0, r2
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402d22:	f04f 0100 	mov.w	r1, #0
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402d26:	d8eb      	bhi.n	402d00 <dir_next+0x100>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  402d28:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  402d2a:	1a8a      	subs	r2, r1, r2
  402d2c:	62da      	str	r2, [r3, #44]	; 0x2c
  402d2e:	6820      	ldr	r0, [r4, #0]
  402d30:	e7a4      	b.n	402c7c <dir_next+0x7c>
  402d32:	bf00      	nop
  402d34:	004028b5 	.word	0x004028b5
  402d38:	00402b29 	.word	0x00402b29
  402d3c:	00402375 	.word	0x00402375

00402d40 <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  402d40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  402d44:	f04f 08ff 	mov.w	r8, #255	; 0xff
  402d48:	b085      	sub	sp, #20
  402d4a:	4f52      	ldr	r7, [pc, #328]	; (402e94 <dir_find.part.5+0x154>)
  402d4c:	f8df 914c 	ldr.w	r9, [pc, #332]	; 402e9c <dir_find.part.5+0x15c>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402d50:	f8df a14c 	ldr.w	sl, [pc, #332]	; 402ea0 <dir_find.part.5+0x160>
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  402d54:	4605      	mov	r5, r0
  402d56:	4646      	mov	r6, r8
  402d58:	e008      	b.n	402d6c <dir_find.part.5+0x2c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402d5a:	290f      	cmp	r1, #15
  402d5c:	d03e      	beq.n	402ddc <dir_find.part.5+0x9c>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402d5e:	26ff      	movs	r6, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  402d60:	4628      	mov	r0, r5
  402d62:	2100      	movs	r1, #0
  402d64:	4b4c      	ldr	r3, [pc, #304]	; (402e98 <dir_find.part.5+0x158>)
  402d66:	4798      	blx	r3
	} while (res == FR_OK);
  402d68:	2800      	cmp	r0, #0
  402d6a:	d134      	bne.n	402dd6 <dir_find.part.5+0x96>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  402d6c:	6828      	ldr	r0, [r5, #0]
  402d6e:	6929      	ldr	r1, [r5, #16]
  402d70:	47b8      	blx	r7
		if (res != FR_OK) break;
  402d72:	bb80      	cbnz	r0, 402dd6 <dir_find.part.5+0x96>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  402d74:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  402d76:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402d78:	2a00      	cmp	r2, #0
  402d7a:	d078      	beq.n	402e6e <dir_find.part.5+0x12e>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  402d7c:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402d7e:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  402d80:	f003 013f 	and.w	r1, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  402d84:	d0eb      	beq.n	402d5e <dir_find.part.5+0x1e>
  402d86:	071b      	lsls	r3, r3, #28
  402d88:	d4e7      	bmi.n	402d5a <dir_find.part.5+0x1a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  402d8a:	290f      	cmp	r1, #15
  402d8c:	d026      	beq.n	402ddc <dir_find.part.5+0x9c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  402d8e:	b98e      	cbnz	r6, 402db4 <dir_find.part.5+0x74>
  402d90:	4694      	mov	ip, r2
  402d92:	f104 060a 	add.w	r6, r4, #10
  402d96:	4622      	mov	r2, r4
  402d98:	4603      	mov	r3, r0
  402d9a:	e001      	b.n	402da0 <dir_find.part.5+0x60>
  402d9c:	f812 cf01 	ldrb.w	ip, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  402da0:	01d9      	lsls	r1, r3, #7
  402da2:	ea41 0353 	orr.w	r3, r1, r3, lsr #1
  402da6:	fa5c f383 	uxtab	r3, ip, r3
  402daa:	42b2      	cmp	r2, r6
  402dac:	b2db      	uxtb	r3, r3
  402dae:	d1f5      	bne.n	402d9c <dir_find.part.5+0x5c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  402db0:	4543      	cmp	r3, r8
  402db2:	d010      	beq.n	402dd6 <dir_find.part.5+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402db4:	f64f 72ff 	movw	r2, #65535	; 0xffff
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  402db8:	69ab      	ldr	r3, [r5, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  402dba:	842a      	strh	r2, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  402dbc:	7ada      	ldrb	r2, [r3, #11]
  402dbe:	07d2      	lsls	r2, r2, #31
  402dc0:	d4cd      	bmi.n	402d5e <dir_find.part.5+0x1e>
  402dc2:	f104 060b 	add.w	r6, r4, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  402dc6:	f814 1b01 	ldrb.w	r1, [r4], #1
  402dca:	f813 2b01 	ldrb.w	r2, [r3], #1
  402dce:	4291      	cmp	r1, r2
  402dd0:	d1c5      	bne.n	402d5e <dir_find.part.5+0x1e>
  402dd2:	42b4      	cmp	r4, r6
  402dd4:	d1f7      	bne.n	402dc6 <dir_find.part.5+0x86>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  402dd6:	b005      	add	sp, #20
  402dd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
  402ddc:	69eb      	ldr	r3, [r5, #28]
  402dde:	2b00      	cmp	r3, #0
  402de0:	d0be      	beq.n	402d60 <dir_find.part.5+0x20>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  402de2:	0651      	lsls	r1, r2, #25
  402de4:	d53f      	bpl.n	402e66 <dir_find.part.5+0x126>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  402de6:	88e9      	ldrh	r1, [r5, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
  402de8:	f894 800d 	ldrb.w	r8, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  402dec:	8429      	strh	r1, [r5, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
  402dee:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402df2:	7b61      	ldrb	r1, [r4, #13]
  402df4:	4541      	cmp	r1, r8
  402df6:	d1b2      	bne.n	402d5e <dir_find.part.5+0x1e>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  402df8:	7822      	ldrb	r2, [r4, #0]
  402dfa:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 402ea4 <dir_find.part.5+0x164>
  402dfe:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  402e02:	3a01      	subs	r2, #1
  402e04:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
  402e08:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  402e0c:	f64f 78ff 	movw	r8, #65535	; 0xffff
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  402e10:	2201      	movs	r2, #1
  402e12:	e003      	b.n	402e1c <dir_find.part.5+0xdc>
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  402e14:	4540      	cmp	r0, r8
  402e16:	d135      	bne.n	402e84 <dir_find.part.5+0x144>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  402e18:	45cb      	cmp	fp, r9
  402e1a:	d02c      	beq.n	402e76 <dir_find.part.5+0x136>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  402e1c:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
  402e20:	eb04 0e00 	add.w	lr, r4, r0
  402e24:	5c20      	ldrb	r0, [r4, r0]
  402e26:	f89e e001 	ldrb.w	lr, [lr, #1]
  402e2a:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		if (wc) {	/* Last char has not been processed */
  402e2e:	2a00      	cmp	r2, #0
  402e30:	d0f0      	beq.n	402e14 <dir_find.part.5+0xd4>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402e32:	f10c 0201 	add.w	r2, ip, #1
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402e36:	e88d 100a 	stmia.w	sp, {r1, r3, ip}
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402e3a:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402e3c:	47d0      	blx	sl
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402e3e:	f8dd c008 	ldr.w	ip, [sp, #8]
  402e42:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  402e46:	4602      	mov	r2, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  402e48:	e89d 000a 	ldmia.w	sp, {r1, r3}
  402e4c:	d81a      	bhi.n	402e84 <dir_find.part.5+0x144>
  402e4e:	f833 001c 	ldrh.w	r0, [r3, ip, lsl #1]
  402e52:	9202      	str	r2, [sp, #8]
  402e54:	47d0      	blx	sl
  402e56:	9a02      	ldr	r2, [sp, #8]
  402e58:	4282      	cmp	r2, r0
  402e5a:	e89d 000a 	ldmia.w	sp, {r1, r3}
  402e5e:	d111      	bne.n	402e84 <dir_find.part.5+0x144>
  402e60:	f8dd c00c 	ldr.w	ip, [sp, #12]
  402e64:	e7d8      	b.n	402e18 <dir_find.part.5+0xd8>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402e66:	42b2      	cmp	r2, r6
  402e68:	f47f af79 	bne.w	402d5e <dir_find.part.5+0x1e>
  402e6c:	e7c1      	b.n	402df2 <dir_find.part.5+0xb2>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  402e6e:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  402e70:	b005      	add	sp, #20
  402e72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  402e76:	7820      	ldrb	r0, [r4, #0]
  402e78:	0640      	lsls	r0, r0, #25
  402e7a:	d506      	bpl.n	402e8a <dir_find.part.5+0x14a>
  402e7c:	b12a      	cbz	r2, 402e8a <dir_find.part.5+0x14a>
  402e7e:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
  402e82:	b113      	cbz	r3, 402e8a <dir_find.part.5+0x14a>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  402e84:	4688      	mov	r8, r1
  402e86:	26ff      	movs	r6, #255	; 0xff
  402e88:	e76a      	b.n	402d60 <dir_find.part.5+0x20>
  402e8a:	3e01      	subs	r6, #1
  402e8c:	b2f6      	uxtb	r6, r6
  402e8e:	4688      	mov	r8, r1
  402e90:	e766      	b.n	402d60 <dir_find.part.5+0x20>
  402e92:	bf00      	nop
  402e94:	00402375 	.word	0x00402375
  402e98:	00402c01 	.word	0x00402c01
  402e9c:	004068c0 	.word	0x004068c0
  402ea0:	00403ae1 	.word	0x00403ae1
  402ea4:	004068b3 	.word	0x004068b3

00402ea8 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  402ea8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  402eac:	f8d0 a018 	ldr.w	sl, [r0, #24]
  402eb0:	69c5      	ldr	r5, [r0, #28]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  402eb2:	b089      	sub	sp, #36	; 0x24
  402eb4:	f10a 36ff 	add.w	r6, sl, #4294967295
  402eb8:	4604      	mov	r4, r0
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  402eba:	4632      	mov	r2, r6
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402ebc:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  402ebe:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  402ec2:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  402ec6:	a908      	add	r1, sp, #32
  402ec8:	428b      	cmp	r3, r1
  402eca:	d1f8      	bne.n	402ebe <dir_register+0x16>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  402ecc:	f89d 301f 	ldrb.w	r3, [sp, #31]
  402ed0:	9301      	str	r3, [sp, #4]
  402ed2:	07da      	lsls	r2, r3, #31
  402ed4:	d456      	bmi.n	402f84 <dir_register+0xdc>
  402ed6:	4fb1      	ldr	r7, [pc, #708]	; (40319c <dir_register+0x2f4>)
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  402ed8:	9b01      	ldr	r3, [sp, #4]
  402eda:	079b      	lsls	r3, r3, #30
  402edc:	f100 80c2 	bmi.w	403064 <dir_register+0x1bc>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
  402ee0:	f04f 0901 	mov.w	r9, #1
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
  402ee4:	4620      	mov	r0, r4
  402ee6:	2100      	movs	r1, #0
  402ee8:	47b8      	blx	r7
	if (res != FR_OK) return res;
  402eea:	2800      	cmp	r0, #0
  402eec:	d147      	bne.n	402f7e <dir_register+0xd6>
  402eee:	4682      	mov	sl, r0
  402ef0:	4eab      	ldr	r6, [pc, #684]	; (4031a0 <dir_register+0x2f8>)
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402ef2:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 4031a8 <dir_register+0x300>
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
  402ef6:	4605      	mov	r5, r0
  402ef8:	e005      	b.n	402f06 <dir_register+0x5e>
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
  402efa:	461d      	mov	r5, r3
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402efc:	47c0      	blx	r8
	} while (res == FR_OK);
  402efe:	4603      	mov	r3, r0
  402f00:	2800      	cmp	r0, #0
  402f02:	f040 80ce 	bne.w	4030a2 <dir_register+0x1fa>
	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
  402f06:	6921      	ldr	r1, [r4, #16]
  402f08:	6820      	ldr	r0, [r4, #0]
  402f0a:	47b0      	blx	r6
		if (res != FR_OK) break;
  402f0c:	4603      	mov	r3, r0
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  402f0e:	f105 0c01 	add.w	ip, r5, #1
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  402f12:	4620      	mov	r0, r4
  402f14:	2101      	movs	r1, #1
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  402f16:	2b00      	cmp	r3, #0
  402f18:	f040 80c3 	bne.w	4030a2 <dir_register+0x1fa>
		c = *dj->dir;				/* Check the entry status */
  402f1c:	6962      	ldr	r2, [r4, #20]
  402f1e:	7812      	ldrb	r2, [r2, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  402f20:	2ae5      	cmp	r2, #229	; 0xe5
  402f22:	d001      	beq.n	402f28 <dir_register+0x80>
  402f24:	2a00      	cmp	r2, #0
  402f26:	d1e8      	bne.n	402efa <dir_register+0x52>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  402f28:	b90d      	cbnz	r5, 402f2e <dir_register+0x86>
  402f2a:	f8b4 a006 	ldrh.w	sl, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  402f2e:	fa1f f58c 	uxth.w	r5, ip
  402f32:	454d      	cmp	r5, r9
  402f34:	d1e2      	bne.n	402efc <dir_register+0x54>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  402f36:	f1b9 0f01 	cmp.w	r9, #1
  402f3a:	f040 80b6 	bne.w	4030aa <dir_register+0x202>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  402f3e:	6820      	ldr	r0, [r4, #0]
  402f40:	6921      	ldr	r1, [r4, #16]
  402f42:	47b0      	blx	r6
		if (res == FR_OK) {
  402f44:	b9d8      	cbnz	r0, 402f7e <dir_register+0xd6>
			dir = dj->dir;
  402f46:	6965      	ldr	r5, [r4, #20]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402f48:	4601      	mov	r1, r0
  402f4a:	f105 0220 	add.w	r2, r5, #32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402f4e:	462b      	mov	r3, r5

	while (cnt--)
		*d++ = (BYTE)val;
  402f50:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402f54:	4293      	cmp	r3, r2
  402f56:	d1fb      	bne.n	402f50 <dir_register+0xa8>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  402f58:	69a2      	ldr	r2, [r4, #24]
  402f5a:	f105 000b 	add.w	r0, r5, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402f5e:	462b      	mov	r3, r5
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  402f60:	f812 1b01 	ldrb.w	r1, [r2], #1
  402f64:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  402f68:	4283      	cmp	r3, r0
  402f6a:	d1f9      	bne.n	402f60 <dir_register+0xb8>
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  402f6c:	69a3      	ldr	r3, [r4, #24]
  402f6e:	7adb      	ldrb	r3, [r3, #11]
  402f70:	f003 0318 	and.w	r3, r3, #24
  402f74:	732b      	strb	r3, [r5, #12]
#endif
			dj->fs->wflag = 1;
  402f76:	6823      	ldr	r3, [r4, #0]
  402f78:	2201      	movs	r2, #1
  402f7a:	711a      	strb	r2, [r3, #4]
  402f7c:	2000      	movs	r0, #0
		}
	}

	return res;
}
  402f7e:	b009      	add	sp, #36	; 0x24
  402f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  402f84:	2300      	movs	r3, #0
  402f86:	4f85      	ldr	r7, [pc, #532]	; (40319c <dir_register+0x2f4>)
  402f88:	f8df 8220 	ldr.w	r8, [pc, #544]	; 4031ac <dir_register+0x304>
  402f8c:	f88a 300b 	strb.w	r3, [sl, #11]
		for (n = 1; n < 100; n++) {
  402f90:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  402f94:	61e3      	str	r3, [r4, #28]
  402f96:	f10d 0b1f 	add.w	fp, sp, #31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402f9a:	4632      	mov	r2, r6
  402f9c:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  402f9e:	f813 1b01 	ldrb.w	r1, [r3], #1
  402fa2:	f802 1f01 	strb.w	r1, [r2, #1]!
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  402fa6:	455b      	cmp	r3, fp
  402fa8:	d1f9      	bne.n	402f9e <dir_register+0xf6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  402faa:	f1b9 0f05 	cmp.w	r9, #5
  402fae:	d957      	bls.n	403060 <dir_register+0x1b8>
  402fb0:	8828      	ldrh	r0, [r5, #0]
  402fb2:	4629      	mov	r1, r5
  402fb4:	464a      	mov	r2, r9
  402fb6:	e000      	b.n	402fba <dir_register+0x112>
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  402fb8:	4618      	mov	r0, r3
  402fba:	03d3      	lsls	r3, r2, #15
  402fbc:	ea43 0252 	orr.w	r2, r3, r2, lsr #1
  402fc0:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  402fc4:	fa10 f282 	uxtah	r2, r0, r2
  402fc8:	b292      	uxth	r2, r2
  402fca:	2b00      	cmp	r3, #0
  402fcc:	d1f4      	bne.n	402fb8 <dir_register+0x110>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  402fce:	2307      	movs	r3, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
  402fd0:	f002 000f 	and.w	r0, r2, #15
  402fd4:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  402fd8:	2939      	cmp	r1, #57	; 0x39
  402fda:	bf88      	it	hi
  402fdc:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  402fe0:	3b01      	subs	r3, #1
  402fe2:	a803      	add	r0, sp, #12
  402fe4:	4418      	add	r0, r3
		seq /= 16;
  402fe6:	f3c2 120f 	ubfx	r2, r2, #4, #16
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
  402fea:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
  402fec:	2a00      	cmp	r2, #0
  402fee:	d1ef      	bne.n	402fd0 <dir_register+0x128>
	ns[i] = '~';
  402ff0:	a908      	add	r1, sp, #32
  402ff2:	4419      	add	r1, r3
  402ff4:	207e      	movs	r0, #126	; 0x7e
  402ff6:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  402ffa:	2b00      	cmp	r3, #0
  402ffc:	d04f      	beq.n	40309e <dir_register+0x1f6>
  402ffe:	f89a 1000 	ldrb.w	r1, [sl]
  403002:	2920      	cmp	r1, #32
  403004:	d014      	beq.n	403030 <dir_register+0x188>
  403006:	4651      	mov	r1, sl
  403008:	e003      	b.n	403012 <dir_register+0x16a>
  40300a:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  40300e:	2820      	cmp	r0, #32
  403010:	d00e      	beq.n	403030 <dir_register+0x188>
  403012:	3201      	adds	r2, #1
  403014:	429a      	cmp	r2, r3
  403016:	d1f8      	bne.n	40300a <dir_register+0x162>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  403018:	2b07      	cmp	r3, #7
  40301a:	d80b      	bhi.n	403034 <dir_register+0x18c>
  40301c:	a908      	add	r1, sp, #32
  40301e:	4419      	add	r1, r3
  403020:	3301      	adds	r3, #1
  403022:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  403026:	f80a 1002 	strb.w	r1, [sl, r2]
  40302a:	3201      	adds	r2, #1
	} while (j < 8);
  40302c:	2a07      	cmp	r2, #7
  40302e:	d807      	bhi.n	403040 <dir_register+0x198>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  403030:	2b07      	cmp	r3, #7
  403032:	d9f3      	bls.n	40301c <dir_register+0x174>
  403034:	2120      	movs	r1, #32
  403036:	f80a 1002 	strb.w	r1, [sl, r2]
  40303a:	3201      	adds	r2, #1
	} while (j < 8);
  40303c:	2a07      	cmp	r2, #7
  40303e:	d9f7      	bls.n	403030 <dir_register+0x188>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  403040:	4620      	mov	r0, r4
  403042:	2100      	movs	r1, #0
  403044:	47b8      	blx	r7
	if (res != FR_OK) return res;
  403046:	bb10      	cbnz	r0, 40308e <dir_register+0x1e6>
  403048:	4620      	mov	r0, r4
  40304a:	47c0      	blx	r8
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
  40304c:	b9f8      	cbnz	r0, 40308e <dir_register+0x1e6>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
  40304e:	f109 0901 	add.w	r9, r9, #1
  403052:	fa1f f989 	uxth.w	r9, r9
  403056:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
  40305a:	d19e      	bne.n	402f9a <dir_register+0xf2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  40305c:	2007      	movs	r0, #7
  40305e:	e78e      	b.n	402f7e <dir_register+0xd6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  403060:	464a      	mov	r2, r9
  403062:	e7b4      	b.n	402fce <dir_register+0x126>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
  403064:	882b      	ldrh	r3, [r5, #0]
  403066:	2b00      	cmp	r3, #0
  403068:	f43f af3a 	beq.w	402ee0 <dir_register+0x38>
  40306c:	2300      	movs	r3, #0
  40306e:	3301      	adds	r3, #1
  403070:	b29b      	uxth	r3, r3
  403072:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
  403076:	2a00      	cmp	r2, #0
  403078:	d1f9      	bne.n	40306e <dir_register+0x1c6>
  40307a:	4a4a      	ldr	r2, [pc, #296]	; (4031a4 <dir_register+0x2fc>)
  40307c:	3319      	adds	r3, #25
  40307e:	fb82 1903 	smull	r1, r9, r2, r3
  403082:	17db      	asrs	r3, r3, #31
  403084:	ebc3 09a9 	rsb	r9, r3, r9, asr #2
  403088:	fa1f f989 	uxth.w	r9, r9
  40308c:	e72a      	b.n	402ee4 <dir_register+0x3c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  40308e:	2804      	cmp	r0, #4
  403090:	f47f af75 	bne.w	402f7e <dir_register+0xd6>
		fn[NS] = sn[NS]; dj->lfn = lfn;
  403094:	9b01      	ldr	r3, [sp, #4]
  403096:	f88a 300b 	strb.w	r3, [sl, #11]
  40309a:	61e5      	str	r5, [r4, #28]
  40309c:	e71c      	b.n	402ed8 <dir_register+0x30>
		seq /= 16;
	} while (seq);
	ns[i] = '~';

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  40309e:	461a      	mov	r2, r3
  4030a0:	e7c6      	b.n	403030 <dir_register+0x188>
  4030a2:	4618      	mov	r0, r3
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  4030a4:	b009      	add	sp, #36	; 0x24
  4030a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
  4030aa:	4651      	mov	r1, sl
  4030ac:	4620      	mov	r0, r4
  4030ae:	47b8      	blx	r7
		if (res == FR_OK) {
  4030b0:	4603      	mov	r3, r0
  4030b2:	2800      	cmp	r0, #0
  4030b4:	d1f5      	bne.n	4030a2 <dir_register+0x1fa>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  4030b6:	69a2      	ldr	r2, [r4, #24]
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  4030b8:	4683      	mov	fp, r0
  4030ba:	f102 000b 	add.w	r0, r2, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  4030be:	f812 3b01 	ldrb.w	r3, [r2], #1
  4030c2:	ea4f 11cb 	mov.w	r1, fp, lsl #7
  4030c6:	ea41 0b5b 	orr.w	fp, r1, fp, lsr #1
  4030ca:	fa53 fb8b 	uxtab	fp, r3, fp
  4030ce:	4282      	cmp	r2, r0
  4030d0:	fa5f fb8b 	uxtb.w	fp, fp
  4030d4:	d1f3      	bne.n	4030be <dir_register+0x216>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
  4030d6:	f109 39ff 	add.w	r9, r9, #4294967295
  4030da:	fa1f f989 	uxth.w	r9, r9
  4030de:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 4031b0 <dir_register+0x308>
  4030e2:	f8cd b000 	str.w	fp, [sp]
  4030e6:	46cb      	mov	fp, r9
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
  4030e8:	6820      	ldr	r0, [r4, #0]
  4030ea:	6921      	ldr	r1, [r4, #16]
  4030ec:	47b0      	blx	r6
  4030ee:	4603      	mov	r3, r0
				if (res != FR_OK) break;
  4030f0:	2800      	cmp	r0, #0
  4030f2:	d1d6      	bne.n	4030a2 <dir_register+0x1fa>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4030f4:	fa5f fa8b 	uxtb.w	sl, fp
  4030f8:	6965      	ldr	r5, [r4, #20]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  4030fa:	9b00      	ldr	r3, [sp, #0]
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4030fc:	f8d4 901c 	ldr.w	r9, [r4, #28]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  403100:	736b      	strb	r3, [r5, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  403102:	f10a 32ff 	add.w	r2, sl, #4294967295
  403106:	eb02 0142 	add.w	r1, r2, r2, lsl #1
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  40310a:	270f      	movs	r7, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  40310c:	4603      	mov	r3, r0
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  40310e:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  403112:	72ef      	strb	r7, [r5, #11]
	dir[LDIR_Type] = 0;
  403114:	7328      	strb	r0, [r5, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  403116:	76a8      	strb	r0, [r5, #26]
  403118:	76e8      	strb	r0, [r5, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  40311a:	4602      	mov	r2, r0
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40311c:	f64f 77ff 	movw	r7, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403120:	20ff      	movs	r0, #255	; 0xff
  403122:	e010      	b.n	403146 <dir_register+0x29e>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  403124:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403128:	f805 300e 	strb.w	r3, [r5, lr]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  40312c:	3201      	adds	r2, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40312e:	44ae      	add	lr, r5
  403130:	ea4f 2c13 	mov.w	ip, r3, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  403134:	2b00      	cmp	r3, #0
  403136:	bf08      	it	eq
  403138:	463b      	moveq	r3, r7
	} while (++s < 13);
  40313a:	2a0d      	cmp	r2, #13
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40313c:	f101 0101 	add.w	r1, r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403140:	f88e c001 	strb.w	ip, [lr, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  403144:	d00c      	beq.n	403160 <dir_register+0x2b8>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  403146:	42bb      	cmp	r3, r7
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403148:	f818 e002 	ldrb.w	lr, [r8, r2]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40314c:	d1ea      	bne.n	403124 <dir_register+0x27c>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40314e:	eb05 0c0e 	add.w	ip, r5, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  403152:	3201      	adds	r2, #1
  403154:	2a0d      	cmp	r2, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403156:	f805 000e 	strb.w	r0, [r5, lr]
  40315a:	f88c 0001 	strb.w	r0, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  40315e:	d1f2      	bne.n	403146 <dir_register+0x29e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  403160:	f64f 72ff 	movw	r2, #65535	; 0xffff
  403164:	4293      	cmp	r3, r2
  403166:	d002      	beq.n	40316e <dir_register+0x2c6>
  403168:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  40316c:	b90b      	cbnz	r3, 403172 <dir_register+0x2ca>
  40316e:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  403172:	f885 a000 	strb.w	sl, [r5]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  403176:	6823      	ldr	r3, [r4, #0]
				res = dir_next(dj, 0);	/* Next entry */
  403178:	4a0b      	ldr	r2, [pc, #44]	; (4031a8 <dir_register+0x300>)
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  40317a:	2101      	movs	r1, #1
  40317c:	7119      	strb	r1, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  40317e:	4620      	mov	r0, r4
  403180:	2100      	movs	r1, #0
  403182:	4790      	blx	r2
			} while (res == FR_OK && --ne);
  403184:	4603      	mov	r3, r0
  403186:	2800      	cmp	r0, #0
  403188:	d18b      	bne.n	4030a2 <dir_register+0x1fa>
  40318a:	f10b 3bff 	add.w	fp, fp, #4294967295
  40318e:	fa1f fb8b 	uxth.w	fp, fp
  403192:	f1bb 0f00 	cmp.w	fp, #0
  403196:	d1a7      	bne.n	4030e8 <dir_register+0x240>
  403198:	e6d1      	b.n	402f3e <dir_register+0x96>
  40319a:	bf00      	nop
  40319c:	00402981 	.word	0x00402981
  4031a0:	00402375 	.word	0x00402375
  4031a4:	4ec4ec4f 	.word	0x4ec4ec4f
  4031a8:	00402c01 	.word	0x00402c01
  4031ac:	00402d41 	.word	0x00402d41
  4031b0:	004068b4 	.word	0x004068b4

004031b4 <remove_chain.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  4031b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4031b8:	4604      	mov	r4, r0
  4031ba:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4031bc:	69a3      	ldr	r3, [r4, #24]
  4031be:	4f16      	ldr	r7, [pc, #88]	; (403218 <remove_chain.part.6+0x64>)
  4031c0:	f8df 8058 	ldr.w	r8, [pc, #88]	; 40321c <remove_chain.part.6+0x68>
  4031c4:	429d      	cmp	r5, r3
  4031c6:	d220      	bcs.n	40320a <remove_chain.part.6+0x56>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  4031c8:	2d01      	cmp	r5, #1
  4031ca:	d90b      	bls.n	4031e4 <remove_chain.part.6+0x30>
  4031cc:	4620      	mov	r0, r4
  4031ce:	4629      	mov	r1, r5
  4031d0:	47b8      	blx	r7

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  4031d2:	4606      	mov	r6, r0
  4031d4:	b1c8      	cbz	r0, 40320a <remove_chain.part.6+0x56>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4031d6:	2801      	cmp	r0, #1
  4031d8:	d004      	beq.n	4031e4 <remove_chain.part.6+0x30>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4031da:	3001      	adds	r0, #1
  4031dc:	d018      	beq.n	403210 <remove_chain.part.6+0x5c>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4031de:	69a3      	ldr	r3, [r4, #24]
  4031e0:	429d      	cmp	r5, r3
  4031e2:	d302      	bcc.n	4031ea <remove_chain.part.6+0x36>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4031e4:	2002      	movs	r0, #2
  4031e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4031ea:	2200      	movs	r2, #0
  4031ec:	4629      	mov	r1, r5
  4031ee:	4620      	mov	r0, r4
  4031f0:	47c0      	blx	r8
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
  4031f2:	2201      	movs	r2, #1
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
  4031f4:	b968      	cbnz	r0, 403212 <remove_chain.part.6+0x5e>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  4031f6:	6923      	ldr	r3, [r4, #16]
  4031f8:	1c59      	adds	r1, r3, #1
  4031fa:	d002      	beq.n	403202 <remove_chain.part.6+0x4e>
				fs->free_clust++;
  4031fc:	4413      	add	r3, r2
  4031fe:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  403200:	7162      	strb	r2, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  403202:	69a3      	ldr	r3, [r4, #24]
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  403204:	4635      	mov	r5, r6
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  403206:	429d      	cmp	r5, r3
  403208:	d3de      	bcc.n	4031c8 <remove_chain.part.6+0x14>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  40320a:	2000      	movs	r0, #0
  40320c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  403210:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  403212:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403216:	bf00      	nop
  403218:	004028b5 	.word	0x004028b5
  40321c:	00402a29 	.word	0x00402a29

00403220 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  403220:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  403224:	780b      	ldrb	r3, [r1, #0]
  403226:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  403228:	b083      	sub	sp, #12
  40322a:	4689      	mov	r9, r1
  40322c:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  40322e:	f000 8133 	beq.w	403498 <follow_path+0x278>
  403232:	2b5c      	cmp	r3, #92	; 0x5c
  403234:	f000 8130 	beq.w	403498 <follow_path+0x278>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
  403238:	2400      	movs	r4, #0
  40323a:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  40323c:	f899 0000 	ldrb.w	r0, [r9]
  403240:	281f      	cmp	r0, #31
  403242:	f240 8132 	bls.w	4034aa <follow_path+0x28a>
  403246:	4da7      	ldr	r5, [pc, #668]	; (4034e4 <follow_path+0x2c4>)
  403248:	e001      	b.n	40324e <follow_path+0x2e>
  40324a:	f819 0f01 	ldrb.w	r0, [r9, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  40324e:	282f      	cmp	r0, #47	; 0x2f
  403250:	d0fb      	beq.n	40324a <follow_path+0x2a>
  403252:	285c      	cmp	r0, #92	; 0x5c
  403254:	d0f9      	beq.n	40324a <follow_path+0x2a>
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  403256:	281f      	cmp	r0, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
  403258:	69f7      	ldr	r7, [r6, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  40325a:	f240 80ec 	bls.w	403436 <follow_path+0x216>
  40325e:	282f      	cmp	r0, #47	; 0x2f
  403260:	d02d      	beq.n	4032be <follow_path+0x9e>
  403262:	285c      	cmp	r0, #92	; 0x5c
  403264:	d02b      	beq.n	4032be <follow_path+0x9e>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403266:	2101      	movs	r1, #1
  403268:	f1a7 0b02 	sub.w	fp, r7, #2
  40326c:	46ca      	mov	sl, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  40326e:	2401      	movs	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403270:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  403272:	b300      	cbz	r0, 4032b6 <follow_path+0x96>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  403274:	287f      	cmp	r0, #127	; 0x7f
  403276:	d809      	bhi.n	40328c <follow_path+0x6c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  403278:	2822      	cmp	r0, #34	; 0x22
  40327a:	d01c      	beq.n	4032b6 <follow_path+0x96>
  40327c:	4a9a      	ldr	r2, [pc, #616]	; (4034e8 <follow_path+0x2c8>)
  40327e:	e001      	b.n	403284 <follow_path+0x64>
  403280:	4298      	cmp	r0, r3
  403282:	d018      	beq.n	4032b6 <follow_path+0x96>
  403284:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  403288:	2b00      	cmp	r3, #0
  40328a:	d1f9      	bne.n	403280 <follow_path+0x60>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  40328c:	f82b 0f02 	strh.w	r0, [fp, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403290:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  403294:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403296:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  40329a:	f240 80ce 	bls.w	40343a <follow_path+0x21a>
  40329e:	282f      	cmp	r0, #47	; 0x2f
  4032a0:	d00f      	beq.n	4032c2 <follow_path+0xa2>
  4032a2:	285c      	cmp	r0, #92	; 0x5c
  4032a4:	d00d      	beq.n	4032c2 <follow_path+0xa2>
		if (di >= _MAX_LFN)				/* Reject too long name */
  4032a6:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  4032aa:	d004      	beq.n	4032b6 <follow_path+0x96>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  4032ac:	2101      	movs	r1, #1
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  4032ae:	461c      	mov	r4, r3
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  4032b0:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  4032b2:	2800      	cmp	r0, #0
  4032b4:	d1de      	bne.n	403274 <follow_path+0x54>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  4032b6:	2006      	movs	r0, #6
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  4032b8:	b003      	add	sp, #12
  4032ba:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  4032be:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  4032c0:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  4032c2:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  4032c4:	f04f 0b00 	mov.w	fp, #0
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  4032c8:	2c00      	cmp	r4, #0
  4032ca:	d0f4      	beq.n	4032b6 <follow_path+0x96>
  4032cc:	eb07 0044 	add.w	r0, r7, r4, lsl #1
		w = lfn[di-1];
  4032d0:	f830 2d02 	ldrh.w	r2, [r0, #-2]!
		if (w != ' ' && w != '.') break;
  4032d4:	2a20      	cmp	r2, #32
  4032d6:	d001      	beq.n	4032dc <follow_path+0xbc>
  4032d8:	2a2e      	cmp	r2, #46	; 0x2e
  4032da:	d102      	bne.n	4032e2 <follow_path+0xc2>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  4032dc:	3c01      	subs	r4, #1
  4032de:	d1f7      	bne.n	4032d0 <follow_path+0xb0>
  4032e0:	e7e9      	b.n	4032b6 <follow_path+0x96>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  4032e2:	2300      	movs	r3, #0
  4032e4:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  4032e8:	69b3      	ldr	r3, [r6, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  4032ea:	eb07 0044 	add.w	r0, r7, r4, lsl #1
  4032ee:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4032f2:	2220      	movs	r2, #32
  4032f4:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4032f8:	428b      	cmp	r3, r1
  4032fa:	d1fb      	bne.n	4032f4 <follow_path+0xd4>
  4032fc:	1ebb      	subs	r3, r7, #2
  4032fe:	f04f 0a00 	mov.w	sl, #0
  403302:	e001      	b.n	403308 <follow_path+0xe8>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  403304:	f10a 0a01 	add.w	sl, sl, #1
  403308:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  40330c:	2a20      	cmp	r2, #32
  40330e:	d0f9      	beq.n	403304 <follow_path+0xe4>
  403310:	2a2e      	cmp	r2, #46	; 0x2e
  403312:	d0f7      	beq.n	403304 <follow_path+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
  403314:	f1ba 0f00 	cmp.w	sl, #0
  403318:	d001      	beq.n	40331e <follow_path+0xfe>
  40331a:	f04b 0b03 	orr.w	fp, fp, #3
  40331e:	4603      	mov	r3, r0
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  403320:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
  403324:	292e      	cmp	r1, #46	; 0x2e
  403326:	d001      	beq.n	40332c <follow_path+0x10c>
  403328:	3c01      	subs	r4, #1
  40332a:	d1f9      	bne.n	403320 <follow_path+0x100>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  40332c:	f04f 0c00 	mov.w	ip, #0
  403330:	4610      	mov	r0, r2
  403332:	46e0      	mov	r8, ip
  403334:	2308      	movs	r3, #8
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  403336:	f10a 0a01 	add.w	sl, sl, #1
		if (!w) break;					/* Break on end of the LFN */
  40333a:	b378      	cbz	r0, 40339c <follow_path+0x17c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  40333c:	2820      	cmp	r0, #32
  40333e:	d01f      	beq.n	403380 <follow_path+0x160>
  403340:	282e      	cmp	r0, #46	; 0x2e
  403342:	d01b      	beq.n	40337c <follow_path+0x15c>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  403344:	459c      	cmp	ip, r3
  403346:	d220      	bcs.n	40338a <follow_path+0x16a>
  403348:	4554      	cmp	r4, sl
  40334a:	d07a      	beq.n	403442 <follow_path+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  40334c:	287f      	cmp	r0, #127	; 0x7f
  40334e:	f200 8083 	bhi.w	403458 <follow_path+0x238>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  403352:	282b      	cmp	r0, #43	; 0x2b
  403354:	f000 8090 	beq.w	403478 <follow_path+0x258>
  403358:	4a64      	ldr	r2, [pc, #400]	; (4034ec <follow_path+0x2cc>)
  40335a:	e002      	b.n	403362 <follow_path+0x142>
  40335c:	4288      	cmp	r0, r1
  40335e:	f000 808b 	beq.w	403478 <follow_path+0x258>
  403362:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  403366:	2900      	cmp	r1, #0
  403368:	d1f8      	bne.n	40335c <follow_path+0x13c>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  40336a:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
  40336e:	2919      	cmp	r1, #25
  403370:	f200 80a6 	bhi.w	4034c0 <follow_path+0x2a0>
					b |= 2;
  403374:	f048 0802 	orr.w	r8, r8, #2
  403378:	b2c0      	uxtb	r0, r0
  40337a:	e080      	b.n	40347e <follow_path+0x25e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  40337c:	4554      	cmp	r4, sl
  40337e:	d060      	beq.n	403442 <follow_path+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
  403380:	f04b 0b03 	orr.w	fp, fp, #3
  403384:	f837 001a 	ldrh.w	r0, [r7, sl, lsl #1]
  403388:	e7d5      	b.n	403336 <follow_path+0x116>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  40338a:	2b0b      	cmp	r3, #11
  40338c:	f000 80a6 	beq.w	4034dc <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  403390:	4554      	cmp	r4, sl
  403392:	d058      	beq.n	403446 <follow_path+0x226>
			if (si > di) break;			/* No extension */
  403394:	45a2      	cmp	sl, r4

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  403396:	f04b 0b03 	orr.w	fp, fp, #3
			if (si > di) break;			/* No extension */
  40339a:	d954      	bls.n	403446 <follow_path+0x226>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  40339c:	69b1      	ldr	r1, [r6, #24]
  40339e:	7808      	ldrb	r0, [r1, #0]
  4033a0:	28e5      	cmp	r0, #229	; 0xe5
  4033a2:	d075      	beq.n	403490 <follow_path+0x270>

	if (ni == 8) b <<= 2;
  4033a4:	2b08      	cmp	r3, #8
  4033a6:	bf04      	itt	eq
  4033a8:	ea4f 0288 	moveq.w	r2, r8, lsl #2
  4033ac:	fa5f f882 	uxtbeq.w	r8, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  4033b0:	f008 030c 	and.w	r3, r8, #12
  4033b4:	2b0c      	cmp	r3, #12
  4033b6:	d068      	beq.n	40348a <follow_path+0x26a>
  4033b8:	f008 0003 	and.w	r0, r8, #3
  4033bc:	2803      	cmp	r0, #3
  4033be:	d064      	beq.n	40348a <follow_path+0x26a>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  4033c0:	f01b 0f02 	tst.w	fp, #2
  4033c4:	d109      	bne.n	4033da <follow_path+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  4033c6:	f008 0203 	and.w	r2, r8, #3
  4033ca:	2a01      	cmp	r2, #1
  4033cc:	bf08      	it	eq
  4033ce:	f04b 0b10 	orreq.w	fp, fp, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  4033d2:	2b04      	cmp	r3, #4
  4033d4:	bf08      	it	eq
  4033d6:	f04b 0b08 	orreq.w	fp, fp, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  4033da:	f881 b00b 	strb.w	fp, [r1, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  4033de:	4630      	mov	r0, r6
  4033e0:	2100      	movs	r1, #0
  4033e2:	4b43      	ldr	r3, [pc, #268]	; (4034f0 <follow_path+0x2d0>)
  4033e4:	4798      	blx	r3
	if (res != FR_OK) return res;
  4033e6:	b9d0      	cbnz	r0, 40341e <follow_path+0x1fe>
  4033e8:	4b42      	ldr	r3, [pc, #264]	; (4034f4 <follow_path+0x2d4>)
  4033ea:	4630      	mov	r0, r6
  4033ec:	4798      	blx	r3
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  4033ee:	69b3      	ldr	r3, [r6, #24]
  4033f0:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  4033f2:	b9b0      	cbnz	r0, 403422 <follow_path+0x202>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  4033f4:	0759      	lsls	r1, r3, #29
  4033f6:	f53f af5f 	bmi.w	4032b8 <follow_path+0x98>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  4033fa:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  4033fc:	7ada      	ldrb	r2, [r3, #11]
  4033fe:	06d2      	lsls	r2, r2, #27
  403400:	d568      	bpl.n	4034d4 <follow_path+0x2b4>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  403402:	7d5c      	ldrb	r4, [r3, #21]
  403404:	7d1a      	ldrb	r2, [r3, #20]
  403406:	7ed8      	ldrb	r0, [r3, #27]
  403408:	7e99      	ldrb	r1, [r3, #26]
  40340a:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  40340e:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  403412:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403416:	60b3      	str	r3, [r6, #8]
  403418:	f899 0000 	ldrb.w	r0, [r9]
		}
  40341c:	e717      	b.n	40324e <follow_path+0x2e>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  40341e:	69b3      	ldr	r3, [r6, #24]
  403420:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  403422:	2804      	cmp	r0, #4
  403424:	f47f af48 	bne.w	4032b8 <follow_path+0x98>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  403428:	f013 0f04 	tst.w	r3, #4
  40342c:	bf08      	it	eq
  40342e:	2005      	moveq	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403430:	b003      	add	sp, #12
  403432:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  403436:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  403438:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  40343a:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  40343c:	f04f 0b04 	mov.w	fp, #4
  403440:	e742      	b.n	4032c8 <follow_path+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  403442:	2b0b      	cmp	r3, #11
  403444:	d04a      	beq.n	4034dc <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  403446:	ea4f 0288 	mov.w	r2, r8, lsl #2
  40344a:	fa5f f882 	uxtb.w	r8, r2
  40344e:	46a2      	mov	sl, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  403450:	230b      	movs	r3, #11
  403452:	f04f 0c08 	mov.w	ip, #8
  403456:	e795      	b.n	403384 <follow_path+0x164>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  403458:	2100      	movs	r1, #0
  40345a:	e88d 1008 	stmia.w	sp, {r3, ip}
  40345e:	47a8      	blx	r5
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  403460:	e89d 1008 	ldmia.w	sp, {r3, ip}
  403464:	b348      	cbz	r0, 4034ba <follow_path+0x29a>
  403466:	4a24      	ldr	r2, [pc, #144]	; (4034f8 <follow_path+0x2d8>)
  403468:	4410      	add	r0, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  40346a:	f04b 0b02 	orr.w	fp, fp, #2
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  40346e:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  403472:	2800      	cmp	r0, #0
  403474:	f47f af6d 	bne.w	403352 <follow_path+0x132>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  403478:	f04b 0b03 	orr.w	fp, fp, #3
  40347c:	205f      	movs	r0, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  40347e:	69b1      	ldr	r1, [r6, #24]
  403480:	f801 000c 	strb.w	r0, [r1, ip]
  403484:	f10c 0c01 	add.w	ip, ip, #1
  403488:	e77c      	b.n	403384 <follow_path+0x164>

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
  40348a:	f04b 0b02 	orr.w	fp, fp, #2
  40348e:	e797      	b.n	4033c0 <follow_path+0x1a0>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  403490:	2005      	movs	r0, #5
  403492:	7008      	strb	r0, [r1, #0]
  403494:	69b1      	ldr	r1, [r6, #24]
  403496:	e785      	b.n	4033a4 <follow_path+0x184>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
  403498:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
  40349c:	2400      	movs	r4, #0
  40349e:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  4034a0:	f899 0000 	ldrb.w	r0, [r9]
  4034a4:	281f      	cmp	r0, #31
  4034a6:	f63f aece 	bhi.w	403246 <follow_path+0x26>
		res = dir_sdi(dj, 0);
  4034aa:	4630      	mov	r0, r6
  4034ac:	4621      	mov	r1, r4
  4034ae:	4b10      	ldr	r3, [pc, #64]	; (4034f0 <follow_path+0x2d0>)
  4034b0:	4798      	blx	r3
		dj->dir = 0;
  4034b2:	6174      	str	r4, [r6, #20]
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  4034b4:	b003      	add	sp, #12
  4034b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  4034ba:	f04b 0b02 	orr.w	fp, fp, #2
  4034be:	e7db      	b.n	403478 <follow_path+0x258>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  4034c0:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
  4034c4:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
  4034c6:	bf97      	itett	ls
  4034c8:	3820      	subls	r0, #32
  4034ca:	b2c0      	uxtbhi	r0, r0
  4034cc:	b2c0      	uxtbls	r0, r0
  4034ce:	f048 0801 	orrls.w	r8, r8, #1
  4034d2:	e7d4      	b.n	40347e <follow_path+0x25e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  4034d4:	2005      	movs	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  4034d6:	b003      	add	sp, #12
  4034d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
  4034dc:	f04b 0b03 	orr.w	fp, fp, #3
  4034e0:	230b      	movs	r3, #11
  4034e2:	e75b      	b.n	40339c <follow_path+0x17c>
  4034e4:	00403a95 	.word	0x00403a95
  4034e8:	004068a0 	.word	0x004068a0
  4034ec:	004068ac 	.word	0x004068ac
  4034f0:	00402981 	.word	0x00402981
  4034f4:	00402d41 	.word	0x00402d41
  4034f8:	00406820 	.word	0x00406820

004034fc <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
  4034fc:	b4f0      	push	{r4, r5, r6, r7}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  4034fe:	b110      	cbz	r0, 403506 <f_mount+0xa>
		return FR_INVALID_DRIVE;
  403500:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  403502:	bcf0      	pop	{r4, r5, r6, r7}
  403504:	4770      	bx	lr
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  403506:	4d0b      	ldr	r5, [pc, #44]	; (403534 <f_mount+0x38>)
  403508:	682b      	ldr	r3, [r5, #0]

	if (rfs) {
  40350a:	b15b      	cbz	r3, 403524 <f_mount+0x28>
  40350c:	4c0a      	ldr	r4, [pc, #40]	; (403538 <f_mount+0x3c>)
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  40350e:	4607      	mov	r7, r0
  403510:	4626      	mov	r6, r4
  403512:	5822      	ldr	r2, [r4, r0]
  403514:	4293      	cmp	r3, r2
  403516:	bf08      	it	eq
  403518:	5187      	streq	r7, [r0, r6]
  40351a:	300c      	adds	r0, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  40351c:	2824      	cmp	r0, #36	; 0x24
  40351e:	d1f8      	bne.n	403512 <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  403520:	2200      	movs	r2, #0
  403522:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  403524:	b109      	cbz	r1, 40352a <f_mount+0x2e>
		fs->fs_type = 0;		/* Clear new fs object */
  403526:	2300      	movs	r3, #0
  403528:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  40352a:	6029      	str	r1, [r5, #0]

	return FR_OK;
  40352c:	2000      	movs	r0, #0
}
  40352e:	bcf0      	pop	{r4, r5, r6, r7}
  403530:	4770      	bx	lr
  403532:	bf00      	nop
  403534:	20000efc 	.word	0x20000efc
  403538:	20000ed8 	.word	0x20000ed8

0040353c <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  40353c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403540:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  403544:	2300      	movs	r3, #0
  403546:	6003      	str	r3, [r0, #0]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  403548:	4616      	mov	r6, r2
  40354a:	9101      	str	r1, [sp, #4]

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  40354c:	f002 021e 	and.w	r2, r2, #30
  403550:	4b9a      	ldr	r3, [pc, #616]	; (4037bc <f_open+0x280>)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  403552:	4604      	mov	r4, r0

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  403554:	a905      	add	r1, sp, #20
  403556:	a801      	add	r0, sp, #4
  403558:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  40355a:	ab02      	add	r3, sp, #8
  40355c:	aa0e      	add	r2, sp, #56	; 0x38
  40355e:	930b      	str	r3, [sp, #44]	; 0x2c
  403560:	920c      	str	r2, [sp, #48]	; 0x30


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  403562:	f006 071f 	and.w	r7, r6, #31
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
  403566:	b130      	cbz	r0, 403576 <f_open+0x3a>
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  403568:	f016 0f1c 	tst.w	r6, #28
  40356c:	d11a      	bne.n	4035a4 <f_open+0x68>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40356e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403572:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
  403576:	9901      	ldr	r1, [sp, #4]
  403578:	4b91      	ldr	r3, [pc, #580]	; (4037c0 <f_open+0x284>)
  40357a:	a805      	add	r0, sp, #20
  40357c:	4798      	blx	r3
	dir = dj.dir;
  40357e:	9d0a      	ldr	r5, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  403580:	2800      	cmp	r0, #0
  403582:	d1f1      	bne.n	403568 <f_open+0x2c>
		if (!dir)	/* Current dir itself */
  403584:	2d00      	cmp	r5, #0
  403586:	f000 80ab 	beq.w	4036e0 <f_open+0x1a4>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40358a:	f037 0801 	bics.w	r8, r7, #1
  40358e:	bf0c      	ite	eq
  403590:	2100      	moveq	r1, #0
  403592:	2101      	movne	r1, #1
  403594:	a805      	add	r0, sp, #20
  403596:	4b8b      	ldr	r3, [pc, #556]	; (4037c4 <f_open+0x288>)
  403598:	4798      	blx	r3
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  40359a:	f016 0f1c 	tst.w	r6, #28
  40359e:	d01b      	beq.n	4035d8 <f_open+0x9c>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  4035a0:	2800      	cmp	r0, #0
  4035a2:	d050      	beq.n	403646 <f_open+0x10a>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  4035a4:	2804      	cmp	r0, #4
  4035a6:	d1e2      	bne.n	40356e <f_open+0x32>
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4035a8:	4b87      	ldr	r3, [pc, #540]	; (4037c8 <f_open+0x28c>)
  4035aa:	681a      	ldr	r2, [r3, #0]
  4035ac:	b12a      	cbz	r2, 4035ba <f_open+0x7e>
  4035ae:	68da      	ldr	r2, [r3, #12]
  4035b0:	b11a      	cbz	r2, 4035ba <f_open+0x7e>
  4035b2:	699b      	ldr	r3, [r3, #24]
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  4035b4:	2012      	movs	r0, #18
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4035b6:	2b00      	cmp	r3, #0
  4035b8:	d1d9      	bne.n	40356e <f_open+0x32>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  4035ba:	a805      	add	r0, sp, #20
  4035bc:	4b83      	ldr	r3, [pc, #524]	; (4037cc <f_open+0x290>)
  4035be:	4798      	blx	r3
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  4035c0:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  4035c4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  4035c6:	2800      	cmp	r0, #0
  4035c8:	d1d1      	bne.n	40356e <f_open+0x32>
  4035ca:	0738      	lsls	r0, r7, #28
  4035cc:	f100 808a 	bmi.w	4036e4 <f_open+0x1a8>
  4035d0:	9e05      	ldr	r6, [sp, #20]
  4035d2:	f027 0801 	bic.w	r8, r7, #1
  4035d6:	e011      	b.n	4035fc <f_open+0xc0>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  4035d8:	2800      	cmp	r0, #0
  4035da:	d1c8      	bne.n	40356e <f_open+0x32>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  4035dc:	7aeb      	ldrb	r3, [r5, #11]
  4035de:	06d9      	lsls	r1, r3, #27
  4035e0:	d43e      	bmi.n	403660 <f_open+0x124>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  4035e2:	07b2      	lsls	r2, r6, #30
  4035e4:	d501      	bpl.n	4035ea <f_open+0xae>
  4035e6:	07db      	lsls	r3, r3, #31
  4035e8:	d435      	bmi.n	403656 <f_open+0x11a>
  4035ea:	f006 0308 	and.w	r3, r6, #8
  4035ee:	b2db      	uxtb	r3, r3
  4035f0:	9e05      	ldr	r6, [sp, #20]
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  4035f2:	b11b      	cbz	r3, 4035fc <f_open+0xc0>
			mode |= FA__WRITTEN;
  4035f4:	f047 0720 	orr.w	r7, r7, #32
  4035f8:	f027 0801 	bic.w	r8, r7, #1
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  4035fc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
			Files[i].clu == dj->sclust &&
  4035fe:	9807      	ldr	r0, [sp, #28]
			Files[i].idx == dj->index) break;
  403600:	f8bd c01a 	ldrh.w	ip, [sp, #26]
  403604:	4a72      	ldr	r2, [pc, #456]	; (4037d0 <f_open+0x294>)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  403606:	61e3      	str	r3, [r4, #28]
		fp->dir_ptr = dir;
  403608:	6225      	str	r5, [r4, #32]
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  40360a:	2300      	movs	r3, #0
		if (Files[i].fs == dj->fs &&
  40360c:	f852 1c08 	ldr.w	r1, [r2, #-8]
  403610:	42b1      	cmp	r1, r6
  403612:	d02a      	beq.n	40366a <f_open+0x12e>
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  403614:	3301      	adds	r3, #1
  403616:	2b03      	cmp	r3, #3
  403618:	f102 020c 	add.w	r2, r2, #12
  40361c:	d1f6      	bne.n	40360c <f_open+0xd0>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  40361e:	4a6a      	ldr	r2, [pc, #424]	; (4037c8 <f_open+0x28c>)
  403620:	6813      	ldr	r3, [r2, #0]
  403622:	2b00      	cmp	r3, #0
  403624:	f000 809a 	beq.w	40375c <f_open+0x220>
  403628:	68d3      	ldr	r3, [r2, #12]
  40362a:	2b00      	cmp	r3, #0
  40362c:	f000 8095 	beq.w	40375a <f_open+0x21e>
  403630:	6993      	ldr	r3, [r2, #24]
  403632:	2b00      	cmp	r3, #0
  403634:	f000 80ac 	beq.w	403790 <f_open+0x254>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403638:	2300      	movs	r3, #0
		if (!fp->lockid) res = FR_INT_ERR;
  40363a:	2002      	movs	r0, #2
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40363c:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40363e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403642:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  403646:	7aeb      	ldrb	r3, [r5, #11]
  403648:	f013 0f11 	tst.w	r3, #17
  40364c:	d103      	bne.n	403656 <f_open+0x11a>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  40364e:	0776      	lsls	r6, r6, #29
  403650:	d5bb      	bpl.n	4035ca <f_open+0x8e>
					res = FR_EXIST;
  403652:	2008      	movs	r0, #8
  403654:	e78b      	b.n	40356e <f_open+0x32>
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
  403656:	2007      	movs	r0, #7
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403658:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40365c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
  403660:	2004      	movs	r0, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403662:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403666:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
  40366a:	f852 1c04 	ldr.w	r1, [r2, #-4]
  40366e:	4281      	cmp	r1, r0
  403670:	d1d0      	bne.n	403614 <f_open+0xd8>
			Files[i].clu == dj->sclust &&
  403672:	8811      	ldrh	r1, [r2, #0]
  403674:	4561      	cmp	r1, ip
  403676:	d1cd      	bne.n	403614 <f_open+0xd8>
  403678:	0059      	lsls	r1, r3, #1
  40367a:	4a53      	ldr	r2, [pc, #332]	; (4037c8 <f_open+0x28c>)
  40367c:	18c8      	adds	r0, r1, r3
  40367e:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  403682:	8940      	ldrh	r0, [r0, #10]
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403684:	f1b8 0f00 	cmp.w	r8, #0
  403688:	d161      	bne.n	40374e <f_open+0x212>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40368a:	3001      	adds	r0, #1
  40368c:	b280      	uxth	r0, r0
  40368e:	4419      	add	r1, r3
  403690:	eb02 0281 	add.w	r2, r2, r1, lsl #2

	return i + 1;
  403694:	3301      	adds	r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  403696:	8150      	strh	r0, [r2, #10]
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403698:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fp->lockid) res = FR_INT_ERR;
  40369a:	2b00      	cmp	r3, #0
  40369c:	d052      	beq.n	403744 <f_open+0x208>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  40369e:	71a7      	strb	r7, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  4036a0:	7d68      	ldrb	r0, [r5, #21]
  4036a2:	7ea9      	ldrb	r1, [r5, #26]
  4036a4:	7d2a      	ldrb	r2, [r5, #20]
  4036a6:	7eeb      	ldrb	r3, [r5, #27]
  4036a8:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  4036ac:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  4036b0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  4036b4:	6123      	str	r3, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4036b6:	7fab      	ldrb	r3, [r5, #30]
  4036b8:	7fe8      	ldrb	r0, [r5, #31]
  4036ba:	7f29      	ldrb	r1, [r5, #28]
  4036bc:	7f6a      	ldrb	r2, [r5, #29]
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4036be:	6026      	str	r6, [r4, #0]
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4036c0:	041b      	lsls	r3, r3, #16
  4036c2:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  4036c6:	430b      	orrs	r3, r1
		fp->fptr = 0;						/* File pointer */
  4036c8:	2000      	movs	r0, #0
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  4036ca:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  4036ce:	60e3      	str	r3, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  4036d0:	60a0      	str	r0, [r4, #8]
		fp->dsect = 0;
  4036d2:	61a0      	str	r0, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4036d4:	88f3      	ldrh	r3, [r6, #6]
  4036d6:	80a3      	strh	r3, [r4, #4]
	}

	LEAVE_FF(dj.fs, res);
}
  4036d8:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4036dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dir = dj.dir;

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
		if (!dir)	/* Current dir itself */
			res = FR_INVALID_NAME;
  4036e0:	2006      	movs	r0, #6
  4036e2:	e741      	b.n	403568 <f_open+0x2c>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
  4036e4:	4b3b      	ldr	r3, [pc, #236]	; (4037d4 <f_open+0x298>)
  4036e6:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  4036e8:	f895 c015 	ldrb.w	ip, [r5, #21]
  4036ec:	7eab      	ldrb	r3, [r5, #26]
  4036ee:	7d29      	ldrb	r1, [r5, #20]
  4036f0:	7eea      	ldrb	r2, [r5, #27]
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  4036f2:	9e05      	ldr	r6, [sp, #20]
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4036f4:	73a8      	strb	r0, [r5, #14]
  4036f6:	ea4f 4810 	mov.w	r8, r0, lsr #16
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  4036fa:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
  4036fe:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  403702:	f3c0 2907 	ubfx	r9, r0, #8, #8
			dir[DIR_Attr] = 0;					/* Reset attribute */
  403706:	2300      	movs	r3, #0
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  403708:	f885 8010 	strb.w	r8, [r5, #16]
  40370c:	0e00      	lsrs	r0, r0, #24
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  40370e:	f04f 0c01 	mov.w	ip, #1
			if (cl) {							/* Remove the cluster chain if exist */
  403712:	ea52 4801 	orrs.w	r8, r2, r1, lsl #16
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  403716:	f885 900f 	strb.w	r9, [r5, #15]
  40371a:	7468      	strb	r0, [r5, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  40371c:	72eb      	strb	r3, [r5, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  40371e:	772b      	strb	r3, [r5, #28]
  403720:	776b      	strb	r3, [r5, #29]
  403722:	77ab      	strb	r3, [r5, #30]
  403724:	77eb      	strb	r3, [r5, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  403726:	76ab      	strb	r3, [r5, #26]
  403728:	76eb      	strb	r3, [r5, #27]
  40372a:	752b      	strb	r3, [r5, #20]
  40372c:	756b      	strb	r3, [r5, #21]
			dj.fs->wflag = 1;
  40372e:	f886 c004 	strb.w	ip, [r6, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  403732:	f43f af5f 	beq.w	4035f4 <f_open+0xb8>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  403736:	45e0      	cmp	r8, ip
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  403738:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  40373c:	d002      	beq.n	403744 <f_open+0x208>
  40373e:	69b3      	ldr	r3, [r6, #24]
  403740:	4598      	cmp	r8, r3
  403742:	d327      	bcc.n	403794 <f_open+0x258>
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
		if (!fp->lockid) res = FR_INT_ERR;
  403744:	2002      	movs	r0, #2
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403746:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40374a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  40374e:	2800      	cmp	r0, #0
  403750:	f47f af72 	bne.w	403638 <f_open+0xfc>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  403754:	f44f 7080 	mov.w	r0, #256	; 0x100
  403758:	e799      	b.n	40368e <f_open+0x152>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  40375a:	2301      	movs	r3, #1
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
  40375c:	0059      	lsls	r1, r3, #1
  40375e:	eb01 0c03 	add.w	ip, r1, r3
  403762:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  403766:	eb02 000c 	add.w	r0, r2, ip
  40376a:	f842 600c 	str.w	r6, [r2, ip]
		Files[i].clu = dj->sclust;
  40376e:	f8dd b01c 	ldr.w	fp, [sp, #28]
		Files[i].idx = dj->index;
  403772:	f8bd a01a 	ldrh.w	sl, [sp, #26]

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
  403776:	f8c0 b004 	str.w	fp, [r0, #4]
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
  40377a:	f04f 0c00 	mov.w	ip, #0
	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
  40377e:	f8a0 a008 	strh.w	sl, [r0, #8]
		Files[i].ctr = 0;
  403782:	f8a0 c00a 	strh.w	ip, [r0, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403786:	f1b8 0f00 	cmp.w	r8, #0
  40378a:	d1e3      	bne.n	403754 <f_open+0x218>
  40378c:	4640      	mov	r0, r8
  40378e:	e77c      	b.n	40368a <f_open+0x14e>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403790:	2302      	movs	r3, #2
  403792:	e7e3      	b.n	40375c <f_open+0x220>
  403794:	4630      	mov	r0, r6
  403796:	4641      	mov	r1, r8
  403798:	4b0f      	ldr	r3, [pc, #60]	; (4037d8 <f_open+0x29c>)
  40379a:	4798      	blx	r3
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
  40379c:	2800      	cmp	r0, #0
  40379e:	f47f aee6 	bne.w	40356e <f_open+0x32>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4037a2:	9805      	ldr	r0, [sp, #20]
					res = move_window(dj.fs, dw);
  4037a4:	4b0d      	ldr	r3, [pc, #52]	; (4037dc <f_open+0x2a0>)
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4037a6:	f108 32ff 	add.w	r2, r8, #4294967295
					res = move_window(dj.fs, dw);
  4037aa:	4649      	mov	r1, r9
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  4037ac:	60c2      	str	r2, [r0, #12]
					res = move_window(dj.fs, dw);
  4037ae:	4798      	blx	r3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  4037b0:	2800      	cmp	r0, #0
  4037b2:	f47f aedc 	bne.w	40356e <f_open+0x32>
  4037b6:	9e05      	ldr	r6, [sp, #20]
  4037b8:	e71c      	b.n	4035f4 <f_open+0xb8>
  4037ba:	bf00      	nop
  4037bc:	00402585 	.word	0x00402585
  4037c0:	00403221 	.word	0x00403221
  4037c4:	00402305 	.word	0x00402305
  4037c8:	20000ed8 	.word	0x20000ed8
  4037cc:	00402ea9 	.word	0x00402ea9
  4037d0:	20000ee0 	.word	0x20000ee0
  4037d4:	004022ad 	.word	0x004022ad
  4037d8:	004031b5 	.word	0x004031b5
  4037dc:	00402375 	.word	0x00402375

004037e0 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4037e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4037e4:	469b      	mov	fp, r3
  4037e6:	4606      	mov	r6, r0
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  4037e8:	2300      	movs	r3, #0
  4037ea:	f8cb 3000 	str.w	r3, [fp]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4037ee:	b083      	sub	sp, #12
  4037f0:	460d      	mov	r5, r1
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  4037f2:	6800      	ldr	r0, [r0, #0]
  4037f4:	88b1      	ldrh	r1, [r6, #4]
  4037f6:	4b62      	ldr	r3, [pc, #392]	; (403980 <f_read+0x1a0>)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  4037f8:	4614      	mov	r4, r2
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  4037fa:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  4037fc:	b928      	cbnz	r0, 40380a <f_read+0x2a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  4037fe:	79b3      	ldrb	r3, [r6, #6]
  403800:	061f      	lsls	r7, r3, #24
  403802:	d405      	bmi.n	403810 <f_read+0x30>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403804:	07d8      	lsls	r0, r3, #31
  403806:	d407      	bmi.n	403818 <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
  403808:	2007      	movs	r0, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  40380a:	b003      	add	sp, #12
  40380c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  403810:	2002      	movs	r0, #2
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403812:	b003      	add	sp, #12
  403814:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403818:	68b1      	ldr	r1, [r6, #8]
  40381a:	68f7      	ldr	r7, [r6, #12]
  40381c:	1a7f      	subs	r7, r7, r1
  40381e:	42bc      	cmp	r4, r7
  403820:	bf38      	it	cc
  403822:	4627      	movcc	r7, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403824:	2f00      	cmp	r7, #0
  403826:	f000 80a8 	beq.w	40397a <f_read+0x19a>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  40382a:	f3c1 0308 	ubfx	r3, r1, #0, #9
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  40382e:	f8df 8158 	ldr.w	r8, [pc, #344]	; 403988 <f_read+0x1a8>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403832:	f8df 9158 	ldr.w	r9, [pc, #344]	; 40398c <f_read+0x1ac>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403836:	2b00      	cmp	r3, #0
  403838:	d13e      	bne.n	4038b8 <f_read+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  40383a:	6830      	ldr	r0, [r6, #0]
  40383c:	7883      	ldrb	r3, [r0, #2]
  40383e:	3b01      	subs	r3, #1
  403840:	ea03 2351 	and.w	r3, r3, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  403844:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  403848:	d04b      	beq.n	4038e2 <f_read+0x102>
  40384a:	6972      	ldr	r2, [r6, #20]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  40384c:	6981      	ldr	r1, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  40384e:	f1a2 0c02 	sub.w	ip, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403852:	3902      	subs	r1, #2
  403854:	458c      	cmp	ip, r1
  403856:	d271      	bcs.n	40393c <f_read+0x15c>
	return clst * fs->csize + fs->database;
  403858:	7882      	ldrb	r2, [r0, #2]
  40385a:	6a81      	ldr	r1, [r0, #40]	; 0x28
  40385c:	fb02 110c 	mla	r1, r2, ip, r1
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403860:	2900      	cmp	r1, #0
  403862:	d06b      	beq.n	40393c <f_read+0x15c>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403864:	0a7c      	lsrs	r4, r7, #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  403866:	eb01 0a03 	add.w	sl, r1, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  40386a:	d043      	beq.n	4038f4 <f_read+0x114>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  40386c:	1919      	adds	r1, r3, r4
  40386e:	4291      	cmp	r1, r2
					cc = fp->fs->csize - csect;
  403870:	bf88      	it	hi
  403872:	ebc3 0402 	rsbhi	r4, r3, r2
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403876:	b2e3      	uxtb	r3, r4
  403878:	7840      	ldrb	r0, [r0, #1]
  40387a:	4629      	mov	r1, r5
  40387c:	4652      	mov	r2, sl
  40387e:	47c0      	blx	r8
					ABORT(fp->fs, FR_DISK_ERR);
  403880:	79b3      	ldrb	r3, [r6, #6]
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403882:	2800      	cmp	r0, #0
  403884:	d161      	bne.n	40394a <f_read+0x16a>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  403886:	065a      	lsls	r2, r3, #25
  403888:	d504      	bpl.n	403894 <f_read+0xb4>
  40388a:	69b3      	ldr	r3, [r6, #24]
  40388c:	ebca 0303 	rsb	r3, sl, r3
  403890:	429c      	cmp	r4, r3
  403892:	d85f      	bhi.n	403954 <f_read+0x174>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403894:	0262      	lsls	r2, r4, #9
  403896:	68b1      	ldr	r1, [r6, #8]
  403898:	18ab      	adds	r3, r5, r2
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  40389a:	4411      	add	r1, r2
  40389c:	60b1      	str	r1, [r6, #8]
  40389e:	f8db 1000 	ldr.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4038a2:	1abf      	subs	r7, r7, r2
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  4038a4:	4411      	add	r1, r2
  4038a6:	461d      	mov	r5, r3
  4038a8:	f8cb 1000 	str.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  4038ac:	d065      	beq.n	40397a <f_read+0x19a>
  4038ae:	68b1      	ldr	r1, [r6, #8]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  4038b0:	f3c1 0308 	ubfx	r3, r1, #0, #9
  4038b4:	2b00      	cmp	r3, #0
  4038b6:	d0c0      	beq.n	40383a <f_read+0x5a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  4038b8:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  4038bc:	f103 0428 	add.w	r4, r3, #40	; 0x28
  4038c0:	42ba      	cmp	r2, r7
  4038c2:	bf28      	it	cs
  4038c4:	463a      	movcs	r2, r7
  4038c6:	4434      	add	r4, r6
  4038c8:	462b      	mov	r3, r5
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4038ca:	2a00      	cmp	r2, #0
  4038cc:	d0e5      	beq.n	40389a <f_read+0xba>
  4038ce:	18ab      	adds	r3, r5, r2
  4038d0:	4629      	mov	r1, r5
		*d++ = *s++;
  4038d2:	f814 5b01 	ldrb.w	r5, [r4], #1
  4038d6:	f801 5b01 	strb.w	r5, [r1], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  4038da:	4299      	cmp	r1, r3
  4038dc:	d1f9      	bne.n	4038d2 <f_read+0xf2>
  4038de:	68b1      	ldr	r1, [r6, #8]
  4038e0:	e7db      	b.n	40389a <f_read+0xba>
	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {						/* On the cluster boundary? */
				if (fp->fptr == 0) {			/* On the top of the file? */
  4038e2:	bb29      	cbnz	r1, 403930 <f_read+0x150>
					clst = fp->sclust;			/* Follow from the origin */
  4038e4:	6932      	ldr	r2, [r6, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  4038e6:	2a01      	cmp	r2, #1
  4038e8:	d928      	bls.n	40393c <f_read+0x15c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  4038ea:	1c51      	adds	r1, r2, #1
  4038ec:	d02c      	beq.n	403948 <f_read+0x168>
  4038ee:	6830      	ldr	r0, [r6, #0]
				fp->clust = clst;				/* Update current cluster */
  4038f0:	6172      	str	r2, [r6, #20]
  4038f2:	e7ab      	b.n	40384c <f_read+0x6c>
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  4038f4:	69b2      	ldr	r2, [r6, #24]
  4038f6:	4552      	cmp	r2, sl
  4038f8:	d014      	beq.n	403924 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  4038fa:	79b3      	ldrb	r3, [r6, #6]
  4038fc:	065b      	lsls	r3, r3, #25
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  4038fe:	f106 0428 	add.w	r4, r6, #40	; 0x28
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403902:	d509      	bpl.n	403918 <f_read+0x138>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403904:	2301      	movs	r3, #1
  403906:	7840      	ldrb	r0, [r0, #1]
  403908:	4621      	mov	r1, r4
  40390a:	47c8      	blx	r9
						ABORT(fp->fs, FR_DISK_ERR);
  40390c:	79b3      	ldrb	r3, [r6, #6]
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  40390e:	b9e0      	cbnz	r0, 40394a <f_read+0x16a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
  403910:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403914:	6830      	ldr	r0, [r6, #0]
  403916:	71b3      	strb	r3, [r6, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403918:	7840      	ldrb	r0, [r0, #1]
  40391a:	4621      	mov	r1, r4
  40391c:	4652      	mov	r2, sl
  40391e:	2301      	movs	r3, #1
  403920:	47c0      	blx	r8
  403922:	b988      	cbnz	r0, 403948 <f_read+0x168>
  403924:	68b1      	ldr	r1, [r6, #8]
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  403926:	f8c6 a018 	str.w	sl, [r6, #24]
  40392a:	f3c1 0308 	ubfx	r3, r1, #0, #9
  40392e:	e7c3      	b.n	4038b8 <f_read+0xd8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  403930:	6971      	ldr	r1, [r6, #20]
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  403932:	2901      	cmp	r1, #1
  403934:	d902      	bls.n	40393c <f_read+0x15c>
  403936:	6982      	ldr	r2, [r0, #24]
  403938:	4291      	cmp	r1, r2
  40393a:	d318      	bcc.n	40396e <f_read+0x18e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  40393c:	79b3      	ldrb	r3, [r6, #6]
  40393e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403942:	71b3      	strb	r3, [r6, #6]
  403944:	2002      	movs	r0, #2
  403946:	e760      	b.n	40380a <f_read+0x2a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
  403948:	79b3      	ldrb	r3, [r6, #6]
  40394a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  40394e:	71b3      	strb	r3, [r6, #6]
  403950:	2001      	movs	r0, #1
  403952:	e75a      	b.n	40380a <f_read+0x2a>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  403954:	eb05 2343 	add.w	r3, r5, r3, lsl #9
  403958:	f503 7000 	add.w	r0, r3, #512	; 0x200
  40395c:	f106 0228 	add.w	r2, r6, #40	; 0x28
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403960:	f812 1b01 	ldrb.w	r1, [r2], #1
  403964:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403968:	4283      	cmp	r3, r0
  40396a:	d1f9      	bne.n	403960 <f_read+0x180>
  40396c:	e792      	b.n	403894 <f_read+0xb4>
  40396e:	9301      	str	r3, [sp, #4]
  403970:	4a04      	ldr	r2, [pc, #16]	; (403984 <f_read+0x1a4>)
  403972:	4790      	blx	r2
  403974:	9b01      	ldr	r3, [sp, #4]
  403976:	4602      	mov	r2, r0
  403978:	e7b5      	b.n	4038e6 <f_read+0x106>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
  40397a:	2000      	movs	r0, #0
  40397c:	e745      	b.n	40380a <f_read+0x2a>
  40397e:	bf00      	nop
  403980:	004024d1 	.word	0x004024d1
  403984:	004028b5 	.word	0x004028b5
  403988:	00402155 	.word	0x00402155
  40398c:	004021c9 	.word	0x004021c9

00403990 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  403990:	b538      	push	{r3, r4, r5, lr}
  403992:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  403994:	4b27      	ldr	r3, [pc, #156]	; (403a34 <f_sync+0xa4>)
  403996:	6800      	ldr	r0, [r0, #0]
  403998:	88a1      	ldrh	r1, [r4, #4]
  40399a:	4798      	blx	r3
	if (res == FR_OK) {
  40399c:	b9d0      	cbnz	r0, 4039d4 <f_sync+0x44>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  40399e:	79a2      	ldrb	r2, [r4, #6]
  4039a0:	f002 0320 	and.w	r3, r2, #32
  4039a4:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  4039a8:	b1a3      	cbz	r3, 4039d4 <f_sync+0x44>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
  4039aa:	0653      	lsls	r3, r2, #25
  4039ac:	d50d      	bpl.n	4039ca <f_sync+0x3a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  4039ae:	4621      	mov	r1, r4
  4039b0:	69a2      	ldr	r2, [r4, #24]
  4039b2:	f851 3b28 	ldr.w	r3, [r1], #40
  4039b6:	4d20      	ldr	r5, [pc, #128]	; (403a38 <f_sync+0xa8>)
  4039b8:	7858      	ldrb	r0, [r3, #1]
  4039ba:	2301      	movs	r3, #1
  4039bc:	47a8      	blx	r5
  4039be:	2800      	cmp	r0, #0
  4039c0:	d136      	bne.n	403a30 <f_sync+0xa0>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  4039c2:	79a3      	ldrb	r3, [r4, #6]
  4039c4:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  4039c8:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  4039ca:	6820      	ldr	r0, [r4, #0]
  4039cc:	69e1      	ldr	r1, [r4, #28]
  4039ce:	4b1b      	ldr	r3, [pc, #108]	; (403a3c <f_sync+0xac>)
  4039d0:	4798      	blx	r3
			if (res == FR_OK) {
  4039d2:	b100      	cbz	r0, 4039d6 <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  4039d4:	bd38      	pop	{r3, r4, r5, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
  4039d6:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
  4039d8:	4a19      	ldr	r2, [pc, #100]	; (403a40 <f_sync+0xb0>)
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  4039da:	7aeb      	ldrb	r3, [r5, #11]
  4039dc:	f043 0320 	orr.w	r3, r3, #32
  4039e0:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  4039e2:	68e3      	ldr	r3, [r4, #12]
  4039e4:	772b      	strb	r3, [r5, #28]
  4039e6:	89a3      	ldrh	r3, [r4, #12]
  4039e8:	0a1b      	lsrs	r3, r3, #8
  4039ea:	776b      	strb	r3, [r5, #29]
  4039ec:	89e3      	ldrh	r3, [r4, #14]
  4039ee:	77ab      	strb	r3, [r5, #30]
  4039f0:	7be3      	ldrb	r3, [r4, #15]
  4039f2:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  4039f4:	6923      	ldr	r3, [r4, #16]
  4039f6:	76ab      	strb	r3, [r5, #26]
  4039f8:	8a23      	ldrh	r3, [r4, #16]
  4039fa:	0a1b      	lsrs	r3, r3, #8
  4039fc:	76eb      	strb	r3, [r5, #27]
  4039fe:	8a63      	ldrh	r3, [r4, #18]
  403a00:	752b      	strb	r3, [r5, #20]
  403a02:	8a63      	ldrh	r3, [r4, #18]
  403a04:	0a1b      	lsrs	r3, r3, #8
  403a06:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  403a08:	4790      	blx	r2
				ST_DWORD(dir+DIR_WrtTime, tim);
  403a0a:	f3c0 2107 	ubfx	r1, r0, #8, #8
  403a0e:	0c02      	lsrs	r2, r0, #16
  403a10:	0e03      	lsrs	r3, r0, #24
  403a12:	75e9      	strb	r1, [r5, #23]
  403a14:	762a      	strb	r2, [r5, #24]
  403a16:	75a8      	strb	r0, [r5, #22]
  403a18:	766b      	strb	r3, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  403a1a:	79a0      	ldrb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403a1c:	6823      	ldr	r3, [r4, #0]
				res = sync(fp->fs);
  403a1e:	4a09      	ldr	r2, [pc, #36]	; (403a44 <f_sync+0xb4>)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403a20:	f020 0020 	bic.w	r0, r0, #32
				fp->fs->wflag = 1;
  403a24:	2101      	movs	r1, #1
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403a26:	71a0      	strb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403a28:	7119      	strb	r1, [r3, #4]
				res = sync(fp->fs);
  403a2a:	6820      	ldr	r0, [r4, #0]
  403a2c:	4790      	blx	r2
  403a2e:	bd38      	pop	{r3, r4, r5, pc}
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
  403a30:	2001      	movs	r0, #1
  403a32:	e7cf      	b.n	4039d4 <f_sync+0x44>
  403a34:	004024d1 	.word	0x004024d1
  403a38:	004021c9 	.word	0x004021c9
  403a3c:	00402375 	.word	0x00402375
  403a40:	004022ad 	.word	0x004022ad
  403a44:	004023f9 	.word	0x004023f9

00403a48 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403a48:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403a4a:	4b10      	ldr	r3, [pc, #64]	; (403a8c <f_close+0x44>)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403a4c:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403a4e:	4798      	blx	r3
#if _FS_SHARE
	if (res == FR_OK) {		/* Decrement open counter */
  403a50:	b998      	cbnz	r0, 403a7a <f_close+0x32>
{
	WORD n;
	FRESULT res;


	if (--i < _FS_SHARE) {
  403a52:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403a54:	3b01      	subs	r3, #1
  403a56:	2b02      	cmp	r3, #2
  403a58:	d810      	bhi.n	403a7c <f_close+0x34>
		n = Files[i].ctr;
  403a5a:	005d      	lsls	r5, r3, #1
  403a5c:	490c      	ldr	r1, [pc, #48]	; (403a90 <f_close+0x48>)
  403a5e:	18ea      	adds	r2, r5, r3
  403a60:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  403a64:	3208      	adds	r2, #8
  403a66:	8856      	ldrh	r6, [r2, #2]
		if (n == 0x100) n = 0;
		if (n) n--;
  403a68:	f426 7780 	bic.w	r7, r6, #256	; 0x100
  403a6c:	b147      	cbz	r7, 403a80 <f_close+0x38>
  403a6e:	3e01      	subs	r6, #1
  403a70:	b2b6      	uxth	r6, r6
		Files[i].ctr = n;
  403a72:	8056      	strh	r6, [r2, #2]
		if (!n) Files[i].fs = 0;
  403a74:	b12e      	cbz	r6, 403a82 <f_close+0x3a>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  403a76:	2300      	movs	r3, #0
  403a78:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
  403a7a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (n) n--;
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;
		res = FR_OK;
	} else {
		res = FR_INT_ERR;
  403a7c:	2002      	movs	r0, #2
  403a7e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (--i < _FS_SHARE) {
		n = Files[i].ctr;
		if (n == 0x100) n = 0;
		if (n) n--;
		Files[i].ctr = n;
  403a80:	8050      	strh	r0, [r2, #2]
		if (!n) Files[i].fs = 0;
  403a82:	442b      	add	r3, r5
  403a84:	009b      	lsls	r3, r3, #2
  403a86:	2200      	movs	r2, #0
  403a88:	50ca      	str	r2, [r1, r3]
  403a8a:	e7f4      	b.n	403a76 <f_close+0x2e>
  403a8c:	00403991 	.word	0x00403991
  403a90:	20000ed8 	.word	0x20000ed8

00403a94 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403a94:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
  403a96:	b410      	push	{r4}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403a98:	d90e      	bls.n	403ab8 <ff_convert+0x24>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  403a9a:	b981      	cbnz	r1, 403abe <ff_convert+0x2a>
  403a9c:	4b0e      	ldr	r3, [pc, #56]	; (403ad8 <ff_convert+0x44>)
  403a9e:	e001      	b.n	403aa4 <ff_convert+0x10>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  403aa0:	2980      	cmp	r1, #128	; 0x80
  403aa2:	d015      	beq.n	403ad0 <ff_convert+0x3c>
				if (src == Tbl[c]) break;
  403aa4:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  403aa8:	4282      	cmp	r2, r0
  403aaa:	b28c      	uxth	r4, r1
  403aac:	f101 0101 	add.w	r1, r1, #1
  403ab0:	d1f6      	bne.n	403aa0 <ff_convert+0xc>
  403ab2:	f104 0080 	add.w	r0, r4, #128	; 0x80
  403ab6:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403ab8:	f85d 4b04 	ldr.w	r4, [sp], #4
  403abc:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403abe:	28ff      	cmp	r0, #255	; 0xff
  403ac0:	d806      	bhi.n	403ad0 <ff_convert+0x3c>
  403ac2:	3880      	subs	r0, #128	; 0x80
  403ac4:	4b05      	ldr	r3, [pc, #20]	; (403adc <ff_convert+0x48>)
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403ac6:	f85d 4b04 	ldr.w	r4, [sp], #4
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403aca:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403ace:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403ad0:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403ad2:	f85d 4b04 	ldr.w	r4, [sp], #4
  403ad6:	4770      	bx	lr
  403ad8:	00406aa2 	.word	0x00406aa2
  403adc:	00406aa4 	.word	0x00406aa4

00403ae0 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403ae0:	2861      	cmp	r0, #97	; 0x61
  403ae2:	d00a      	beq.n	403afa <ff_wtoupper+0x1a>
  403ae4:	4907      	ldr	r1, [pc, #28]	; (403b04 <ff_wtoupper+0x24>)
  403ae6:	2200      	movs	r2, #0
  403ae8:	e001      	b.n	403aee <ff_wtoupper+0xe>
  403aea:	4283      	cmp	r3, r0
  403aec:	d006      	beq.n	403afc <ff_wtoupper+0x1c>
  403aee:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403af2:	3201      	adds	r2, #1
  403af4:	2b00      	cmp	r3, #0
  403af6:	d1f8      	bne.n	403aea <ff_wtoupper+0xa>

	return tbl_lower[i] ? tbl_upper[i] : chr;
}
  403af8:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403afa:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403afc:	4b02      	ldr	r3, [pc, #8]	; (403b08 <ff_wtoupper+0x28>)
  403afe:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  403b02:	4770      	bx	lr
  403b04:	004068c4 	.word	0x004068c4
  403b08:	00406ba4 	.word	0x00406ba4

00403b0c <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  403b0c:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  403b0e:	685a      	ldr	r2, [r3, #4]
  403b10:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  403b12:	6842      	ldr	r2, [r0, #4]
  403b14:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403b16:	685a      	ldr	r2, [r3, #4]
  403b18:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  403b1a:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  403b1c:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403b1e:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403b20:	6803      	ldr	r3, [r0, #0]
  403b22:	3301      	adds	r3, #1
  403b24:	6003      	str	r3, [r0, #0]
  403b26:	4770      	bx	lr

00403b28 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  403b28:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  403b2a:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  403b2c:	1c63      	adds	r3, r4, #1
  403b2e:	d016      	beq.n	403b5e <vListInsert+0x36>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  403b30:	68c3      	ldr	r3, [r0, #12]
  403b32:	681a      	ldr	r2, [r3, #0]
  403b34:	4294      	cmp	r4, r2
  403b36:	f100 0308 	add.w	r3, r0, #8
  403b3a:	d304      	bcc.n	403b46 <vListInsert+0x1e>
  403b3c:	685b      	ldr	r3, [r3, #4]
  403b3e:	685a      	ldr	r2, [r3, #4]
  403b40:	6812      	ldr	r2, [r2, #0]
  403b42:	4294      	cmp	r4, r2
  403b44:	d2fa      	bcs.n	403b3c <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  403b46:	685a      	ldr	r2, [r3, #4]
  403b48:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403b4a:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  403b4c:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  403b4e:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403b50:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403b52:	6803      	ldr	r3, [r0, #0]
}
  403b54:	f85d 4b04 	ldr.w	r4, [sp], #4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
  403b58:	3301      	adds	r3, #1
  403b5a:	6003      	str	r3, [r0, #0]
}
  403b5c:	4770      	bx	lr
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  403b5e:	6903      	ldr	r3, [r0, #16]
  403b60:	e7f1      	b.n	403b46 <vListInsert+0x1e>
  403b62:	bf00      	nop

00403b64 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  403b64:	6843      	ldr	r3, [r0, #4]
  403b66:	6882      	ldr	r2, [r0, #8]
  403b68:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  403b6a:	6883      	ldr	r3, [r0, #8]
  403b6c:	6842      	ldr	r2, [r0, #4]
  403b6e:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  403b70:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  403b72:	685a      	ldr	r2, [r3, #4]
  403b74:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  403b76:	bf04      	itt	eq
  403b78:	6882      	ldreq	r2, [r0, #8]
  403b7a:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  403b7c:	2200      	movs	r2, #0
  403b7e:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  403b80:	681a      	ldr	r2, [r3, #0]
  403b82:	3a01      	subs	r2, #1
  403b84:	601a      	str	r2, [r3, #0]
  403b86:	4770      	bx	lr

00403b88 <SVC_Handler>:
/**
 * \brief Handler for Sytem supervisor call.
 */
void vPortSVCHandler(void)
{
	__asm volatile (" ldr r3, pxCurrentTCBConst2  \n"  /* Restore the context. */
  403b88:	4b06      	ldr	r3, [pc, #24]	; (403ba4 <pxCurrentTCBConst2>)
  403b8a:	6819      	ldr	r1, [r3, #0]
  403b8c:	6808      	ldr	r0, [r1, #0]
  403b8e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403b92:	f380 8809 	msr	PSP, r0
  403b96:	f04f 0000 	mov.w	r0, #0
  403b9a:	f380 8811 	msr	BASEPRI, r0
  403b9e:	f04e 0e0d 	orr.w	lr, lr, #13
  403ba2:	4770      	bx	lr

00403ba4 <pxCurrentTCBConst2>:
  403ba4:	20000fd4 	.word	0x20000fd4

00403ba8 <vPortYieldFromISR>:
 * \brief Yield PendSV to request a context switch.
 */
void vPortYieldFromISR(void)
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403ba8:	4b02      	ldr	r3, [pc, #8]	; (403bb4 <vPortYieldFromISR+0xc>)
  403baa:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403bae:	601a      	str	r2, [r3, #0]
  403bb0:	4770      	bx	lr
  403bb2:	bf00      	nop
  403bb4:	e000ed04 	.word	0xe000ed04

00403bb8 <vPortEnterCritical>:
/**
 * \brief Enter Critical code.
 */
void vPortEnterCritical(void)
{
	portDISABLE_INTERRUPTS();
  403bb8:	f04f 0000 	mov.w	r0, #0
  403bbc:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
  403bc0:	4b02      	ldr	r3, [pc, #8]	; (403bcc <vPortEnterCritical+0x14>)
  403bc2:	681a      	ldr	r2, [r3, #0]
  403bc4:	3201      	adds	r2, #1
  403bc6:	601a      	str	r2, [r3, #0]
  403bc8:	4770      	bx	lr
  403bca:	bf00      	nop
  403bcc:	200000b4 	.word	0x200000b4

00403bd0 <vPortExitCritical>:
/**
 * \brief Exit Critical code.
 */
void vPortExitCritical(void)
{
	uxCriticalNesting--;
  403bd0:	4a04      	ldr	r2, [pc, #16]	; (403be4 <vPortExitCritical+0x14>)
  403bd2:	6813      	ldr	r3, [r2, #0]
  403bd4:	3b01      	subs	r3, #1
  403bd6:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  403bd8:	b91b      	cbnz	r3, 403be2 <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  403bda:	f04f 0000 	mov.w	r0, #0
  403bde:	f380 8811 	msr	BASEPRI, r0
  403be2:	4770      	bx	lr
  403be4:	200000b4 	.word	0x200000b4

00403be8 <PendSV_Handler>:
 * \brief Handler for Sytem interrupt-driven request.
 */
void xPortPendSVHandler(void)
{
	/* This is a naked function. */
	__asm volatile (" mrs r0, psp      \n"
  403be8:	f3ef 8009 	mrs	r0, PSP
  403bec:	4b0c      	ldr	r3, [pc, #48]	; (403c20 <pxCurrentTCBConst>)
  403bee:	681a      	ldr	r2, [r3, #0]
  403bf0:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403bf4:	6010      	str	r0, [r2, #0]
  403bf6:	e92d 4008 	stmdb	sp!, {r3, lr}
  403bfa:	f04f 0000 	mov.w	r0, #0
  403bfe:	f380 8811 	msr	BASEPRI, r0
  403c02:	f000 fb35 	bl	404270 <vTaskSwitchContext>
  403c06:	f04f 0000 	mov.w	r0, #0
  403c0a:	f380 8811 	msr	BASEPRI, r0
  403c0e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  403c12:	6819      	ldr	r1, [r3, #0]
  403c14:	6808      	ldr	r0, [r1, #0]
  403c16:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403c1a:	f380 8809 	msr	PSP, r0
  403c1e:	4770      	bx	lr

00403c20 <pxCurrentTCBConst>:
  403c20:	20000fd4 	.word	0x20000fd4

00403c24 <xPortSysTickHandler>:

/**
 * \brief Handler for Sytem Tick interrupt.
 */
void xPortSysTickHandler(void)
{
  403c24:	b508      	push	{r3, lr}
	unsigned portLONG ulDummy;

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403c26:	4b07      	ldr	r3, [pc, #28]	; (403c44 <xPortSysTickHandler+0x20>)
  403c28:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403c2c:	601a      	str	r2, [r3, #0]
#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
  403c2e:	f04f 0000 	mov.w	r0, #0
  403c32:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
  403c36:	4b04      	ldr	r3, [pc, #16]	; (403c48 <xPortSysTickHandler+0x24>)
  403c38:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulDummy);
  403c3a:	f04f 0000 	mov.w	r0, #0
  403c3e:	f380 8811 	msr	BASEPRI, r0
  403c42:	bd08      	pop	{r3, pc}
  403c44:	e000ed04 	.word	0xe000ed04
  403c48:	00404051 	.word	0x00404051

00403c4c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403c4c:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403c4e:	6c03      	ldr	r3, [r0, #64]	; 0x40
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403c50:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403c52:	b933      	cbnz	r3, 403c62 <prvCopyDataToQueue+0x16>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403c54:	6805      	ldr	r5, [r0, #0]
  403c56:	2d00      	cmp	r5, #0
  403c58:	d028      	beq.n	403cac <prvCopyDataToQueue+0x60>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403c5a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403c5c:	3301      	adds	r3, #1
  403c5e:	63a3      	str	r3, [r4, #56]	; 0x38
  403c60:	bd38      	pop	{r3, r4, r5, pc}
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  403c62:	b982      	cbnz	r2, 403c86 <prvCopyDataToQueue+0x3a>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403c64:	461a      	mov	r2, r3
  403c66:	6880      	ldr	r0, [r0, #8]
  403c68:	4b13      	ldr	r3, [pc, #76]	; (403cb8 <prvCopyDataToQueue+0x6c>)
  403c6a:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403c6c:	68a1      	ldr	r1, [r4, #8]
  403c6e:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403c70:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403c72:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403c74:	4293      	cmp	r3, r2
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403c76:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403c78:	d3ef      	bcc.n	403c5a <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  403c7a:	6823      	ldr	r3, [r4, #0]
  403c7c:	60a3      	str	r3, [r4, #8]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403c7e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403c80:	3301      	adds	r3, #1
  403c82:	63a3      	str	r3, [r4, #56]	; 0x38
  403c84:	bd38      	pop	{r3, r4, r5, pc}
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403c86:	461a      	mov	r2, r3
  403c88:	68c0      	ldr	r0, [r0, #12]
  403c8a:	4b0b      	ldr	r3, [pc, #44]	; (403cb8 <prvCopyDataToQueue+0x6c>)
  403c8c:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403c8e:	6c22      	ldr	r2, [r4, #64]	; 0x40
  403c90:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403c92:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403c94:	4252      	negs	r2, r2
  403c96:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403c98:	428b      	cmp	r3, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403c9a:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403c9c:	d2dd      	bcs.n	403c5a <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403c9e:	6863      	ldr	r3, [r4, #4]
  403ca0:	441a      	add	r2, r3
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403ca2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403ca4:	60e2      	str	r2, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403ca6:	3301      	adds	r3, #1
  403ca8:	63a3      	str	r3, [r4, #56]	; 0x38
  403caa:	bd38      	pop	{r3, r4, r5, pc}
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  403cac:	6840      	ldr	r0, [r0, #4]
  403cae:	4b03      	ldr	r3, [pc, #12]	; (403cbc <prvCopyDataToQueue+0x70>)
  403cb0:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  403cb2:	6065      	str	r5, [r4, #4]
  403cb4:	e7d1      	b.n	403c5a <prvCopyDataToQueue+0xe>
  403cb6:	bf00      	nop
  403cb8:	0040611d 	.word	0x0040611d
  403cbc:	0040451d 	.word	0x0040451d

00403cc0 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  403cc0:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  403cc2:	6804      	ldr	r4, [r0, #0]
  403cc4:	b164      	cbz	r4, 403ce0 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403cc6:	68c3      	ldr	r3, [r0, #12]
  403cc8:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403cca:	6845      	ldr	r5, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403ccc:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403cce:	42ab      	cmp	r3, r5

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403cd0:	60c3      	str	r3, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  403cd2:	bf24      	itt	cs
  403cd4:	4623      	movcs	r3, r4
  403cd6:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  403cd8:	4608      	mov	r0, r1
  403cda:	4619      	mov	r1, r3
  403cdc:	4b01      	ldr	r3, [pc, #4]	; (403ce4 <prvCopyDataFromQueue+0x24>)
  403cde:	4798      	blx	r3
  403ce0:	bd38      	pop	{r3, r4, r5, pc}
  403ce2:	bf00      	nop
  403ce4:	0040611d 	.word	0x0040611d

00403ce8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  403ce8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403cec:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  403cee:	4f23      	ldr	r7, [pc, #140]	; (403d7c <prvUnlockQueue+0x94>)
  403cf0:	47b8      	blx	r7
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403cf2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403cf4:	2b00      	cmp	r3, #0
  403cf6:	dd18      	ble.n	403d2a <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403cf8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403cfa:	b1b3      	cbz	r3, 403d2a <prvUnlockQueue+0x42>
  403cfc:	f104 0624 	add.w	r6, r4, #36	; 0x24
  403d00:	4d1f      	ldr	r5, [pc, #124]	; (403d80 <prvUnlockQueue+0x98>)
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403d02:	f8df 8080 	ldr.w	r8, [pc, #128]	; 403d84 <prvUnlockQueue+0x9c>
  403d06:	e006      	b.n	403d16 <prvUnlockQueue+0x2e>
				}

				--( pxQueue->xTxLock );
  403d08:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403d0a:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403d0c:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403d0e:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403d10:	dd0b      	ble.n	403d2a <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403d12:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403d14:	b14b      	cbz	r3, 403d2a <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403d16:	4630      	mov	r0, r6
  403d18:	47a8      	blx	r5
  403d1a:	2800      	cmp	r0, #0
  403d1c:	d0f4      	beq.n	403d08 <prvUnlockQueue+0x20>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403d1e:	47c0      	blx	r8
				}

				--( pxQueue->xTxLock );
  403d20:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403d22:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403d24:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403d26:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403d28:	dcf3      	bgt.n	403d12 <prvUnlockQueue+0x2a>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  403d2a:	f04f 33ff 	mov.w	r3, #4294967295
  403d2e:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  403d30:	f8df 8054 	ldr.w	r8, [pc, #84]	; 403d88 <prvUnlockQueue+0xa0>
  403d34:	47c0      	blx	r8

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  403d36:	47b8      	blx	r7
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d38:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403d3a:	2b00      	cmp	r3, #0
  403d3c:	dd17      	ble.n	403d6e <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403d3e:	6923      	ldr	r3, [r4, #16]
  403d40:	b1ab      	cbz	r3, 403d6e <prvUnlockQueue+0x86>
  403d42:	f104 0610 	add.w	r6, r4, #16
  403d46:	4d0e      	ldr	r5, [pc, #56]	; (403d80 <prvUnlockQueue+0x98>)
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
  403d48:	4f0e      	ldr	r7, [pc, #56]	; (403d84 <prvUnlockQueue+0x9c>)
  403d4a:	e006      	b.n	403d5a <prvUnlockQueue+0x72>
				}

				--( pxQueue->xRxLock );
  403d4c:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403d4e:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d50:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  403d52:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d54:	dd0b      	ble.n	403d6e <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403d56:	6923      	ldr	r3, [r4, #16]
  403d58:	b14b      	cbz	r3, 403d6e <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  403d5a:	4630      	mov	r0, r6
  403d5c:	47a8      	blx	r5
  403d5e:	2800      	cmp	r0, #0
  403d60:	d0f4      	beq.n	403d4c <prvUnlockQueue+0x64>
				{
					vTaskMissedYield();
  403d62:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  403d64:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403d66:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d68:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  403d6a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  403d6c:	dcf3      	bgt.n	403d56 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  403d6e:	f04f 33ff 	mov.w	r3, #4294967295
  403d72:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  403d74:	47c0      	blx	r8
  403d76:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  403d7a:	bf00      	nop
  403d7c:	00403bb9 	.word	0x00403bb9
  403d80:	00404391 	.word	0x00404391
  403d84:	00404495 	.word	0x00404495
  403d88:	00403bd1 	.word	0x00403bd1

00403d8c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  403d8c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403d90:	4f37      	ldr	r7, [pc, #220]	; (403e70 <xQueueGenericSend+0xe4>)
  403d92:	4d38      	ldr	r5, [pc, #224]	; (403e74 <xQueueGenericSend+0xe8>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403d94:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 403e94 <xQueueGenericSend+0x108>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  403d98:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 403e98 <xQueueGenericSend+0x10c>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  403d9c:	b087      	sub	sp, #28
  403d9e:	4604      	mov	r4, r0
  403da0:	9203      	str	r2, [sp, #12]
  403da2:	9101      	str	r1, [sp, #4]
  403da4:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  403da6:	46b9      	mov	r9, r7
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  403da8:	2600      	movs	r6, #0
  403daa:	e021      	b.n	403df0 <xQueueGenericSend+0x64>
  403dac:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  403dae:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  403db0:	47c0      	blx	r8
		prvLockQueue( pxQueue );
  403db2:	47a8      	blx	r5
  403db4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403db6:	3301      	adds	r3, #1
  403db8:	bf04      	itt	eq
  403dba:	2300      	moveq	r3, #0
  403dbc:	6463      	streq	r3, [r4, #68]	; 0x44
  403dbe:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403dc0:	3301      	adds	r3, #1
  403dc2:	bf04      	itt	eq
  403dc4:	2300      	moveq	r3, #0
  403dc6:	64a3      	streq	r3, [r4, #72]	; 0x48
  403dc8:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  403dca:	4630      	mov	r0, r6
  403dcc:	a903      	add	r1, sp, #12
  403dce:	4b2a      	ldr	r3, [pc, #168]	; (403e78 <xQueueGenericSend+0xec>)
  403dd0:	4798      	blx	r3
  403dd2:	2800      	cmp	r0, #0
  403dd4:	d13a      	bne.n	403e4c <xQueueGenericSend+0xc0>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  403dd6:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  403dd8:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  403ddc:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  403dde:	47c8      	blx	r9
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
  403de0:	45b3      	cmp	fp, r6
  403de2:	d012      	beq.n	403e0a <xQueueGenericSend+0x7e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  403de4:	4b25      	ldr	r3, [pc, #148]	; (403e7c <xQueueGenericSend+0xf0>)
  403de6:	4620      	mov	r0, r4
  403de8:	4798      	blx	r3
				( void ) xTaskResumeAll();
  403dea:	4b25      	ldr	r3, [pc, #148]	; (403e80 <xQueueGenericSend+0xf4>)
  403dec:	4798      	blx	r3
  403dee:	2601      	movs	r6, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  403df0:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  403df2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  403df4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  403df6:	429a      	cmp	r2, r3
  403df8:	d316      	bcc.n	403e28 <xQueueGenericSend+0x9c>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  403dfa:	9803      	ldr	r0, [sp, #12]
  403dfc:	b300      	cbz	r0, 403e40 <xQueueGenericSend+0xb4>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
  403dfe:	2e00      	cmp	r6, #0
  403e00:	d1d4      	bne.n	403dac <xQueueGenericSend+0x20>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403e02:	ae04      	add	r6, sp, #16
  403e04:	4630      	mov	r0, r6
  403e06:	47d0      	blx	sl
  403e08:	e7d1      	b.n	403dae <xQueueGenericSend+0x22>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  403e0a:	f104 0010 	add.w	r0, r4, #16
  403e0e:	9903      	ldr	r1, [sp, #12]
  403e10:	4b1c      	ldr	r3, [pc, #112]	; (403e84 <xQueueGenericSend+0xf8>)
  403e12:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  403e14:	4b19      	ldr	r3, [pc, #100]	; (403e7c <xQueueGenericSend+0xf0>)
  403e16:	4620      	mov	r0, r4
  403e18:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
  403e1a:	4b19      	ldr	r3, [pc, #100]	; (403e80 <xQueueGenericSend+0xf4>)
  403e1c:	4798      	blx	r3
  403e1e:	2800      	cmp	r0, #0
  403e20:	d1e5      	bne.n	403dee <xQueueGenericSend+0x62>
				{
					portYIELD_WITHIN_API();
  403e22:	4b19      	ldr	r3, [pc, #100]	; (403e88 <xQueueGenericSend+0xfc>)
  403e24:	4798      	blx	r3
  403e26:	e7e2      	b.n	403dee <xQueueGenericSend+0x62>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  403e28:	4b18      	ldr	r3, [pc, #96]	; (403e8c <xQueueGenericSend+0x100>)
  403e2a:	9901      	ldr	r1, [sp, #4]
  403e2c:	9a02      	ldr	r2, [sp, #8]
  403e2e:	4620      	mov	r0, r4
  403e30:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403e32:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403e34:	b99b      	cbnz	r3, 403e5e <xQueueGenericSend+0xd2>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
  403e36:	47b8      	blx	r7

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  403e38:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  403e3a:	b007      	add	sp, #28
  403e3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  403e40:	9000      	str	r0, [sp, #0]
  403e42:	47b8      	blx	r7

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  403e44:	9800      	ldr	r0, [sp, #0]
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  403e46:	b007      	add	sp, #28
  403e48:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  403e4c:	4620      	mov	r0, r4
  403e4e:	4b0b      	ldr	r3, [pc, #44]	; (403e7c <xQueueGenericSend+0xf0>)
  403e50:	4798      	blx	r3
			( void ) xTaskResumeAll();
  403e52:	4b0b      	ldr	r3, [pc, #44]	; (403e80 <xQueueGenericSend+0xf4>)
  403e54:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  403e56:	2000      	movs	r0, #0
		}
	}
}
  403e58:	b007      	add	sp, #28
  403e5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  403e5e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  403e62:	4b0b      	ldr	r3, [pc, #44]	; (403e90 <xQueueGenericSend+0x104>)
  403e64:	4798      	blx	r3
  403e66:	2801      	cmp	r0, #1
  403e68:	d1e5      	bne.n	403e36 <xQueueGenericSend+0xaa>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  403e6a:	4b07      	ldr	r3, [pc, #28]	; (403e88 <xQueueGenericSend+0xfc>)
  403e6c:	4798      	blx	r3
  403e6e:	e7e2      	b.n	403e36 <xQueueGenericSend+0xaa>
  403e70:	00403bd1 	.word	0x00403bd1
  403e74:	00403bb9 	.word	0x00403bb9
  403e78:	00404419 	.word	0x00404419
  403e7c:	00403ce9 	.word	0x00403ce9
  403e80:	0040417d 	.word	0x0040417d
  403e84:	00404341 	.word	0x00404341
  403e88:	00403ba9 	.word	0x00403ba9
  403e8c:	00403c4d 	.word	0x00403c4d
  403e90:	00404391 	.word	0x00404391
  403e94:	00404401 	.word	0x00404401
  403e98:	00404041 	.word	0x00404041

00403e9c <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  403e9c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403ea0:	4f46      	ldr	r7, [pc, #280]	; (403fbc <xQueueGenericReceive+0x120>)
  403ea2:	4d47      	ldr	r5, [pc, #284]	; (403fc0 <xQueueGenericReceive+0x124>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403ea4:	f8df a140 	ldr.w	sl, [pc, #320]	; 403fe8 <xQueueGenericReceive+0x14c>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  403ea8:	f8df 9140 	ldr.w	r9, [pc, #320]	; 403fec <xQueueGenericReceive+0x150>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  403eac:	b087      	sub	sp, #28
  403eae:	4604      	mov	r4, r0
  403eb0:	9203      	str	r2, [sp, #12]
  403eb2:	9101      	str	r1, [sp, #4]
  403eb4:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  403eb6:	46b8      	mov	r8, r7
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  403eb8:	2600      	movs	r6, #0
  403eba:	e02a      	b.n	403f12 <xQueueGenericReceive+0x76>
  403ebc:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  403ebe:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  403ec0:	47c8      	blx	r9
		prvLockQueue( pxQueue );
  403ec2:	47a8      	blx	r5
  403ec4:	6c63      	ldr	r3, [r4, #68]	; 0x44
  403ec6:	3301      	adds	r3, #1
  403ec8:	bf04      	itt	eq
  403eca:	2300      	moveq	r3, #0
  403ecc:	6463      	streq	r3, [r4, #68]	; 0x44
  403ece:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403ed0:	3301      	adds	r3, #1
  403ed2:	bf04      	itt	eq
  403ed4:	2300      	moveq	r3, #0
  403ed6:	64a3      	streq	r3, [r4, #72]	; 0x48
  403ed8:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  403eda:	4630      	mov	r0, r6
  403edc:	a903      	add	r1, sp, #12
  403ede:	4b39      	ldr	r3, [pc, #228]	; (403fc4 <xQueueGenericReceive+0x128>)
  403ee0:	4798      	blx	r3
  403ee2:	2800      	cmp	r0, #0
  403ee4:	d14d      	bne.n	403f82 <xQueueGenericReceive+0xe6>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  403ee6:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  403ee8:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  403eec:	4e34      	ldr	r6, [pc, #208]	; (403fc0 <xQueueGenericReceive+0x124>)
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
	taskEXIT_CRITICAL();
  403eee:	47c0      	blx	r8
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
  403ef0:	f1bb 0f00 	cmp.w	fp, #0
  403ef4:	d119      	bne.n	403f2a <xQueueGenericReceive+0x8e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403ef6:	6823      	ldr	r3, [r4, #0]
  403ef8:	b303      	cbz	r3, 403f3c <xQueueGenericReceive+0xa0>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  403efa:	f104 0024 	add.w	r0, r4, #36	; 0x24
  403efe:	9903      	ldr	r1, [sp, #12]
  403f00:	4b31      	ldr	r3, [pc, #196]	; (403fc8 <xQueueGenericReceive+0x12c>)
  403f02:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  403f04:	4b31      	ldr	r3, [pc, #196]	; (403fcc <xQueueGenericReceive+0x130>)
  403f06:	4620      	mov	r0, r4
  403f08:	4798      	blx	r3
				if( !xTaskResumeAll() )
  403f0a:	4b31      	ldr	r3, [pc, #196]	; (403fd0 <xQueueGenericReceive+0x134>)
  403f0c:	4798      	blx	r3
  403f0e:	b190      	cbz	r0, 403f36 <xQueueGenericReceive+0x9a>
  403f10:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  403f12:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  403f14:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403f16:	b9bb      	cbnz	r3, 403f48 <xQueueGenericReceive+0xac>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  403f18:	9803      	ldr	r0, [sp, #12]
  403f1a:	2800      	cmp	r0, #0
  403f1c:	d02b      	beq.n	403f76 <xQueueGenericReceive+0xda>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
  403f1e:	2e00      	cmp	r6, #0
  403f20:	d1cc      	bne.n	403ebc <xQueueGenericReceive+0x20>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  403f22:	ae04      	add	r6, sp, #16
  403f24:	4630      	mov	r0, r6
  403f26:	47d0      	blx	sl
  403f28:	e7c9      	b.n	403ebe <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  403f2a:	4620      	mov	r0, r4
  403f2c:	4b27      	ldr	r3, [pc, #156]	; (403fcc <xQueueGenericReceive+0x130>)
  403f2e:	4798      	blx	r3
				( void ) xTaskResumeAll();
  403f30:	4b27      	ldr	r3, [pc, #156]	; (403fd0 <xQueueGenericReceive+0x134>)
  403f32:	4798      	blx	r3
  403f34:	e7ec      	b.n	403f10 <xQueueGenericReceive+0x74>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( !xTaskResumeAll() )
				{
					portYIELD_WITHIN_API();
  403f36:	4b27      	ldr	r3, [pc, #156]	; (403fd4 <xQueueGenericReceive+0x138>)
  403f38:	4798      	blx	r3
  403f3a:	e7e9      	b.n	403f10 <xQueueGenericReceive+0x74>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
  403f3c:	47b0      	blx	r6
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  403f3e:	6860      	ldr	r0, [r4, #4]
  403f40:	4b25      	ldr	r3, [pc, #148]	; (403fd8 <xQueueGenericReceive+0x13c>)
  403f42:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  403f44:	47c0      	blx	r8
  403f46:	e7d8      	b.n	403efa <xQueueGenericReceive+0x5e>
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  403f48:	4b24      	ldr	r3, [pc, #144]	; (403fdc <xQueueGenericReceive+0x140>)
  403f4a:	9901      	ldr	r1, [sp, #4]
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  403f4c:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  403f4e:	4620      	mov	r0, r4
  403f50:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  403f52:	9b02      	ldr	r3, [sp, #8]
  403f54:	b9f3      	cbnz	r3, 403f94 <xQueueGenericReceive+0xf8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  403f56:	6ba2      	ldr	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403f58:	6823      	ldr	r3, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  403f5a:	3a01      	subs	r2, #1
  403f5c:	63a2      	str	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403f5e:	b343      	cbz	r3, 403fb2 <xQueueGenericReceive+0x116>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  403f60:	6923      	ldr	r3, [r4, #16]
  403f62:	b1d3      	cbz	r3, 403f9a <xQueueGenericReceive+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  403f64:	f104 0010 	add.w	r0, r4, #16
  403f68:	4b1d      	ldr	r3, [pc, #116]	; (403fe0 <xQueueGenericReceive+0x144>)
  403f6a:	4798      	blx	r3
  403f6c:	2801      	cmp	r0, #1
  403f6e:	d114      	bne.n	403f9a <xQueueGenericReceive+0xfe>
						{
							portYIELD_WITHIN_API();
  403f70:	4b18      	ldr	r3, [pc, #96]	; (403fd4 <xQueueGenericReceive+0x138>)
  403f72:	4798      	blx	r3
  403f74:	e011      	b.n	403f9a <xQueueGenericReceive+0xfe>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  403f76:	9000      	str	r0, [sp, #0]
  403f78:	47b8      	blx	r7
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  403f7a:	9800      	ldr	r0, [sp, #0]
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  403f7c:	b007      	add	sp, #28
  403f7e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  403f82:	4620      	mov	r0, r4
  403f84:	4b11      	ldr	r3, [pc, #68]	; (403fcc <xQueueGenericReceive+0x130>)
  403f86:	4798      	blx	r3
			( void ) xTaskResumeAll();
  403f88:	4b11      	ldr	r3, [pc, #68]	; (403fd0 <xQueueGenericReceive+0x134>)
  403f8a:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  403f8c:	2000      	movs	r0, #0
		}
	}
}
  403f8e:	b007      	add	sp, #28
  403f90:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403f94:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  403f96:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403f98:	b923      	cbnz	r3, 403fa4 <xQueueGenericReceive+0x108>
						}
					}

				}

				taskEXIT_CRITICAL();
  403f9a:	47b8      	blx	r7
				return pdPASS;
  403f9c:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  403f9e:	b007      	add	sp, #28
  403fa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403fa4:	f104 0024 	add.w	r0, r4, #36	; 0x24
  403fa8:	4b0d      	ldr	r3, [pc, #52]	; (403fe0 <xQueueGenericReceive+0x144>)
  403faa:	4798      	blx	r3
  403fac:	2800      	cmp	r0, #0
  403fae:	d0f4      	beq.n	403f9a <xQueueGenericReceive+0xfe>
  403fb0:	e7de      	b.n	403f70 <xQueueGenericReceive+0xd4>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  403fb2:	4b0c      	ldr	r3, [pc, #48]	; (403fe4 <xQueueGenericReceive+0x148>)
  403fb4:	4798      	blx	r3
  403fb6:	6060      	str	r0, [r4, #4]
  403fb8:	e7d2      	b.n	403f60 <xQueueGenericReceive+0xc4>
  403fba:	bf00      	nop
  403fbc:	00403bd1 	.word	0x00403bd1
  403fc0:	00403bb9 	.word	0x00403bb9
  403fc4:	00404419 	.word	0x00404419
  403fc8:	00404341 	.word	0x00404341
  403fcc:	00403ce9 	.word	0x00403ce9
  403fd0:	0040417d 	.word	0x0040417d
  403fd4:	00403ba9 	.word	0x00403ba9
  403fd8:	004044ad 	.word	0x004044ad
  403fdc:	00403cc1 	.word	0x00403cc1
  403fe0:	00404391 	.word	0x00404391
  403fe4:	004044a1 	.word	0x004044a1
  403fe8:	00404401 	.word	0x00404401
  403fec:	00404041 	.word	0x00404041

00403ff0 <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  403ff0:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  403ff2:	4b0d      	ldr	r3, [pc, #52]	; (404028 <prvAddCurrentTaskToDelayedList+0x38>)

	if( xTimeToWake < xTickCount )
  403ff4:	4a0d      	ldr	r2, [pc, #52]	; (40402c <prvAddCurrentTaskToDelayedList+0x3c>)
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  403ff6:	6819      	ldr	r1, [r3, #0]

	if( xTimeToWake < xTickCount )
  403ff8:	6812      	ldr	r2, [r2, #0]
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  403ffa:	6048      	str	r0, [r1, #4]

	if( xTimeToWake < xTickCount )
  403ffc:	4290      	cmp	r0, r2
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  403ffe:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
  404000:	d30b      	bcc.n	40401a <prvAddCurrentTaskToDelayedList+0x2a>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404002:	490b      	ldr	r1, [pc, #44]	; (404030 <prvAddCurrentTaskToDelayedList+0x40>)
  404004:	4a0b      	ldr	r2, [pc, #44]	; (404034 <prvAddCurrentTaskToDelayedList+0x44>)
  404006:	6808      	ldr	r0, [r1, #0]
  404008:	6819      	ldr	r1, [r3, #0]
  40400a:	3104      	adds	r1, #4
  40400c:	4790      	blx	r2

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  40400e:	4b0a      	ldr	r3, [pc, #40]	; (404038 <prvAddCurrentTaskToDelayedList+0x48>)
  404010:	681a      	ldr	r2, [r3, #0]
  404012:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
  404014:	bf38      	it	cc
  404016:	601c      	strcc	r4, [r3, #0]
  404018:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40401a:	4908      	ldr	r1, [pc, #32]	; (40403c <prvAddCurrentTaskToDelayedList+0x4c>)
  40401c:	4a05      	ldr	r2, [pc, #20]	; (404034 <prvAddCurrentTaskToDelayedList+0x44>)
  40401e:	6808      	ldr	r0, [r1, #0]
  404020:	6819      	ldr	r1, [r3, #0]
  404022:	3104      	adds	r1, #4
  404024:	4790      	blx	r2
  404026:	bd10      	pop	{r4, pc}
  404028:	20000fd4 	.word	0x20000fd4
  40402c:	20000f04 	.word	0x20000f04
  404030:	20000fb0 	.word	0x20000fb0
  404034:	00403b29 	.word	0x00403b29
  404038:	200000bc 	.word	0x200000bc
  40403c:	20000fa8 	.word	0x20000fa8

00404040 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  404040:	4b02      	ldr	r3, [pc, #8]	; (40404c <vTaskSuspendAll+0xc>)
  404042:	681a      	ldr	r2, [r3, #0]
  404044:	3201      	adds	r2, #1
  404046:	601a      	str	r2, [r3, #0]
  404048:	4770      	bx	lr
  40404a:	bf00      	nop
  40404c:	20000fec 	.word	0x20000fec

00404050 <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  404050:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404054:	4b3e      	ldr	r3, [pc, #248]	; (404150 <vTaskIncrementTick+0x100>)
  404056:	681b      	ldr	r3, [r3, #0]
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  404058:	b083      	sub	sp, #12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40405a:	2b00      	cmp	r3, #0
  40405c:	d150      	bne.n	404100 <vTaskIncrementTick+0xb0>
	{
		++xTickCount;
  40405e:	4c3d      	ldr	r4, [pc, #244]	; (404154 <vTaskIncrementTick+0x104>)
  404060:	6823      	ldr	r3, [r4, #0]
  404062:	3301      	adds	r3, #1
  404064:	6023      	str	r3, [r4, #0]
		if( xTickCount == ( portTickType ) 0 )
  404066:	6823      	ldr	r3, [r4, #0]
  404068:	2b00      	cmp	r3, #0
  40406a:	d050      	beq.n	40410e <vTaskIncrementTick+0xbe>
  40406c:	4a3a      	ldr	r2, [pc, #232]	; (404158 <vTaskIncrementTick+0x108>)
  40406e:	9201      	str	r2, [sp, #4]
  404070:	6813      	ldr	r3, [r2, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  404072:	6822      	ldr	r2, [r4, #0]
  404074:	4937      	ldr	r1, [pc, #220]	; (404154 <vTaskIncrementTick+0x104>)
  404076:	429a      	cmp	r2, r3
  404078:	d346      	bcc.n	404108 <vTaskIncrementTick+0xb8>
  40407a:	4d38      	ldr	r5, [pc, #224]	; (40415c <vTaskIncrementTick+0x10c>)
  40407c:	682b      	ldr	r3, [r5, #0]
  40407e:	681b      	ldr	r3, [r3, #0]
  404080:	2b00      	cmp	r3, #0
  404082:	d036      	beq.n	4040f2 <vTaskIncrementTick+0xa2>
  404084:	682b      	ldr	r3, [r5, #0]
  404086:	68db      	ldr	r3, [r3, #12]
  404088:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  40408c:	6809      	ldr	r1, [r1, #0]
  40408e:	f8db 2004 	ldr.w	r2, [fp, #4]
  404092:	428a      	cmp	r2, r1
  404094:	d857      	bhi.n	404146 <vTaskIncrementTick+0xf6>
  404096:	4f32      	ldr	r7, [pc, #200]	; (404160 <vTaskIncrementTick+0x110>)
  404098:	4e32      	ldr	r6, [pc, #200]	; (404164 <vTaskIncrementTick+0x114>)
  40409a:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 404174 <vTaskIncrementTick+0x124>
  40409e:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 404178 <vTaskIncrementTick+0x128>
  4040a2:	e009      	b.n	4040b8 <vTaskIncrementTick+0x68>
  4040a4:	4a2d      	ldr	r2, [pc, #180]	; (40415c <vTaskIncrementTick+0x10c>)
  4040a6:	6813      	ldr	r3, [r2, #0]
  4040a8:	68db      	ldr	r3, [r3, #12]
  4040aa:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  4040ae:	6821      	ldr	r1, [r4, #0]
  4040b0:	f8db 2004 	ldr.w	r2, [fp, #4]
  4040b4:	428a      	cmp	r2, r1
  4040b6:	d846      	bhi.n	404146 <vTaskIncrementTick+0xf6>
  4040b8:	f10b 0a04 	add.w	sl, fp, #4
  4040bc:	4650      	mov	r0, sl
  4040be:	47b8      	blx	r7
  4040c0:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  4040c4:	f10b 0018 	add.w	r0, fp, #24
  4040c8:	b10a      	cbz	r2, 4040ce <vTaskIncrementTick+0x7e>
  4040ca:	4a25      	ldr	r2, [pc, #148]	; (404160 <vTaskIncrementTick+0x110>)
  4040cc:	4790      	blx	r2
  4040ce:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
  4040d2:	6832      	ldr	r2, [r6, #0]
  4040d4:	4293      	cmp	r3, r2
  4040d6:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4040da:	bf88      	it	hi
  4040dc:	4a21      	ldrhi	r2, [pc, #132]	; (404164 <vTaskIncrementTick+0x114>)
  4040de:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  4040e2:	4651      	mov	r1, sl
  4040e4:	bf88      	it	hi
  4040e6:	6013      	strhi	r3, [r2, #0]
  4040e8:	47c0      	blx	r8
  4040ea:	682b      	ldr	r3, [r5, #0]
  4040ec:	681b      	ldr	r3, [r3, #0]
  4040ee:	2b00      	cmp	r3, #0
  4040f0:	d1d8      	bne.n	4040a4 <vTaskIncrementTick+0x54>
  4040f2:	9a01      	ldr	r2, [sp, #4]
  4040f4:	f04f 33ff 	mov.w	r3, #4294967295
  4040f8:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  4040fa:	b003      	add	sp, #12
  4040fc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
  404100:	4b19      	ldr	r3, [pc, #100]	; (404168 <vTaskIncrementTick+0x118>)
  404102:	681a      	ldr	r2, [r3, #0]
  404104:	3201      	adds	r2, #1
  404106:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  404108:	b003      	add	sp, #12
  40410a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40410e:	4b13      	ldr	r3, [pc, #76]	; (40415c <vTaskIncrementTick+0x10c>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  404110:	4916      	ldr	r1, [pc, #88]	; (40416c <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  404112:	6818      	ldr	r0, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = pxTemp;
			xNumOfOverflows++;
  404114:	4a16      	ldr	r2, [pc, #88]	; (404170 <vTaskIncrementTick+0x120>)
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  404116:	680d      	ldr	r5, [r1, #0]
  404118:	601d      	str	r5, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  40411a:	6008      	str	r0, [r1, #0]
			xNumOfOverflows++;
  40411c:	6811      	ldr	r1, [r2, #0]
  40411e:	3101      	adds	r1, #1
  404120:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  404122:	681a      	ldr	r2, [r3, #0]
  404124:	6812      	ldr	r2, [r2, #0]
  404126:	b932      	cbnz	r2, 404136 <vTaskIncrementTick+0xe6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  404128:	4b0b      	ldr	r3, [pc, #44]	; (404158 <vTaskIncrementTick+0x108>)
  40412a:	4a0b      	ldr	r2, [pc, #44]	; (404158 <vTaskIncrementTick+0x108>)
  40412c:	9301      	str	r3, [sp, #4]
  40412e:	f04f 33ff 	mov.w	r3, #4294967295
  404132:	6013      	str	r3, [r2, #0]
  404134:	e79d      	b.n	404072 <vTaskIncrementTick+0x22>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  404136:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404138:	4a07      	ldr	r2, [pc, #28]	; (404158 <vTaskIncrementTick+0x108>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40413a:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40413c:	9201      	str	r2, [sp, #4]
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40413e:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404140:	685b      	ldr	r3, [r3, #4]
  404142:	6013      	str	r3, [r2, #0]
  404144:	e795      	b.n	404072 <vTaskIncrementTick+0x22>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  404146:	9b01      	ldr	r3, [sp, #4]
  404148:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  40414a:	b003      	add	sp, #12
  40414c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  404150:	20000fec 	.word	0x20000fec
  404154:	20000f04 	.word	0x20000f04
  404158:	200000bc 	.word	0x200000bc
  40415c:	20000fb0 	.word	0x20000fb0
  404160:	00403b65 	.word	0x00403b65
  404164:	20000f00 	.word	0x20000f00
  404168:	20000ff0 	.word	0x20000ff0
  40416c:	20000fa8 	.word	0x20000fa8
  404170:	20000ff8 	.word	0x20000ff8
  404174:	20000f08 	.word	0x20000f08
  404178:	00403b0d 	.word	0x00403b0d

0040417c <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  40417c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  404180:	4b2d      	ldr	r3, [pc, #180]	; (404238 <xTaskResumeAll+0xbc>)
  404182:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  404184:	4b2d      	ldr	r3, [pc, #180]	; (40423c <xTaskResumeAll+0xc0>)
  404186:	681a      	ldr	r2, [r3, #0]
  404188:	3a01      	subs	r2, #1
  40418a:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  40418c:	681e      	ldr	r6, [r3, #0]
  40418e:	2e00      	cmp	r6, #0
  404190:	d13c      	bne.n	40420c <xTaskResumeAll+0x90>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  404192:	4b2b      	ldr	r3, [pc, #172]	; (404240 <xTaskResumeAll+0xc4>)
  404194:	681b      	ldr	r3, [r3, #0]
  404196:	2b00      	cmp	r3, #0
  404198:	d038      	beq.n	40420c <xTaskResumeAll+0x90>
  40419a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 404268 <xTaskResumeAll+0xec>
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  40419e:	4f29      	ldr	r7, [pc, #164]	; (404244 <xTaskResumeAll+0xc8>)
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  4041a0:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 40426c <xTaskResumeAll+0xf0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4041a4:	46ca      	mov	sl, r9
  4041a6:	e01e      	b.n	4041e6 <xTaskResumeAll+0x6a>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  4041a8:	f8da 300c 	ldr.w	r3, [sl, #12]
  4041ac:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
  4041ae:	f104 0018 	add.w	r0, r4, #24
					vListRemove( &( pxTCB->xGenericListItem ) );
  4041b2:	1d25      	adds	r5, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  4041b4:	47b8      	blx	r7
					vListRemove( &( pxTCB->xGenericListItem ) );
  4041b6:	4628      	mov	r0, r5
  4041b8:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  4041ba:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4041bc:	f8d8 e000 	ldr.w	lr, [r8]
  4041c0:	4921      	ldr	r1, [pc, #132]	; (404248 <xTaskResumeAll+0xcc>)
  4041c2:	4a22      	ldr	r2, [pc, #136]	; (40424c <xTaskResumeAll+0xd0>)
  4041c4:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4041c8:	4573      	cmp	r3, lr
  4041ca:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  4041ce:	4629      	mov	r1, r5
  4041d0:	bf88      	it	hi
  4041d2:	f8c8 3000 	strhi.w	r3, [r8]
  4041d6:	4790      	blx	r2

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4041d8:	4b1d      	ldr	r3, [pc, #116]	; (404250 <xTaskResumeAll+0xd4>)
  4041da:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  4041dc:	681b      	ldr	r3, [r3, #0]
  4041de:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  4041e0:	429a      	cmp	r2, r3
  4041e2:	bf28      	it	cs
  4041e4:	2601      	movcs	r6, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4041e6:	f8d9 3000 	ldr.w	r3, [r9]
  4041ea:	2b00      	cmp	r3, #0
  4041ec:	d1dc      	bne.n	4041a8 <xTaskResumeAll+0x2c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  4041ee:	4c19      	ldr	r4, [pc, #100]	; (404254 <xTaskResumeAll+0xd8>)
  4041f0:	6823      	ldr	r3, [r4, #0]
  4041f2:	b18b      	cbz	r3, 404218 <xTaskResumeAll+0x9c>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  4041f4:	6823      	ldr	r3, [r4, #0]
  4041f6:	b13b      	cbz	r3, 404208 <xTaskResumeAll+0x8c>
  4041f8:	4d17      	ldr	r5, [pc, #92]	; (404258 <xTaskResumeAll+0xdc>)
					{
						vTaskIncrementTick();
  4041fa:	47a8      	blx	r5
						--uxMissedTicks;
  4041fc:	6823      	ldr	r3, [r4, #0]
  4041fe:	3b01      	subs	r3, #1
  404200:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  404202:	6823      	ldr	r3, [r4, #0]
  404204:	2b00      	cmp	r3, #0
  404206:	d1f8      	bne.n	4041fa <xTaskResumeAll+0x7e>
  404208:	4b14      	ldr	r3, [pc, #80]	; (40425c <xTaskResumeAll+0xe0>)
  40420a:	e00b      	b.n	404224 <xTaskResumeAll+0xa8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  40420c:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40420e:	4b14      	ldr	r3, [pc, #80]	; (404260 <xTaskResumeAll+0xe4>)
  404210:	4798      	blx	r3

	return xAlreadyYielded;
}
  404212:	4620      	mov	r0, r4
  404214:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  404218:	2e01      	cmp	r6, #1
  40421a:	d0f5      	beq.n	404208 <xTaskResumeAll+0x8c>
  40421c:	4b0f      	ldr	r3, [pc, #60]	; (40425c <xTaskResumeAll+0xe0>)
  40421e:	681a      	ldr	r2, [r3, #0]
  404220:	2a01      	cmp	r2, #1
  404222:	d1f3      	bne.n	40420c <xTaskResumeAll+0x90>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404224:	2100      	movs	r1, #0
					portYIELD_WITHIN_API();
  404226:	4a0f      	ldr	r2, [pc, #60]	; (404264 <xTaskResumeAll+0xe8>)
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404228:	6019      	str	r1, [r3, #0]
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  40422a:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
  40422c:	4790      	blx	r2
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40422e:	4b0c      	ldr	r3, [pc, #48]	; (404260 <xTaskResumeAll+0xe4>)
  404230:	4798      	blx	r3

	return xAlreadyYielded;
}
  404232:	4620      	mov	r0, r4
  404234:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404238:	00403bb9 	.word	0x00403bb9
  40423c:	20000fec 	.word	0x20000fec
  404240:	20000fb4 	.word	0x20000fb4
  404244:	00403b65 	.word	0x00403b65
  404248:	20000f08 	.word	0x20000f08
  40424c:	00403b0d 	.word	0x00403b0d
  404250:	20000fd4 	.word	0x20000fd4
  404254:	20000ff0 	.word	0x20000ff0
  404258:	00404051 	.word	0x00404051
  40425c:	20000fcc 	.word	0x20000fcc
  404260:	00403bd1 	.word	0x00403bd1
  404264:	00403ba9 	.word	0x00403ba9
  404268:	20000fb8 	.word	0x20000fb8
  40426c:	20000f00 	.word	0x20000f00

00404270 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  404270:	b430      	push	{r4, r5}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  404272:	4b29      	ldr	r3, [pc, #164]	; (404318 <vTaskSwitchContext+0xa8>)
  404274:	681b      	ldr	r3, [r3, #0]
  404276:	2b00      	cmp	r3, #0
  404278:	d134      	bne.n	4042e4 <vTaskSwitchContext+0x74>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  40427a:	4b28      	ldr	r3, [pc, #160]	; (40431c <vTaskSwitchContext+0xac>)
  40427c:	4928      	ldr	r1, [pc, #160]	; (404320 <vTaskSwitchContext+0xb0>)
  40427e:	681a      	ldr	r2, [r3, #0]
  404280:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  404284:	0092      	lsls	r2, r2, #2
  404286:	588a      	ldr	r2, [r1, r2]
  404288:	b94a      	cbnz	r2, 40429e <vTaskSwitchContext+0x2e>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
  40428a:	681a      	ldr	r2, [r3, #0]
  40428c:	3a01      	subs	r2, #1
  40428e:	601a      	str	r2, [r3, #0]

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  404290:	681a      	ldr	r2, [r3, #0]
  404292:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  404296:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  40429a:	2a00      	cmp	r2, #0
  40429c:	d0f5      	beq.n	40428a <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  40429e:	681b      	ldr	r3, [r3, #0]
  4042a0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4042a4:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  4042a8:	f101 0208 	add.w	r2, r1, #8
  4042ac:	684b      	ldr	r3, [r1, #4]
  4042ae:	685b      	ldr	r3, [r3, #4]
  4042b0:	604b      	str	r3, [r1, #4]
  4042b2:	4293      	cmp	r3, r2
  4042b4:	d02c      	beq.n	404310 <vTaskSwitchContext+0xa0>

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4042b6:	491b      	ldr	r1, [pc, #108]	; (404324 <vTaskSwitchContext+0xb4>)
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4042b8:	4a1b      	ldr	r2, [pc, #108]	; (404328 <vTaskSwitchContext+0xb8>)

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4042ba:	6808      	ldr	r0, [r1, #0]
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4042bc:	68db      	ldr	r3, [r3, #12]
  4042be:	6013      	str	r3, [r2, #0]

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4042c0:	b170      	cbz	r0, 4042e0 <vTaskSwitchContext+0x70>
  4042c2:	6813      	ldr	r3, [r2, #0]
  4042c4:	4819      	ldr	r0, [pc, #100]	; (40432c <vTaskSwitchContext+0xbc>)
  4042c6:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  4042c8:	6803      	ldr	r3, [r0, #0]
  4042ca:	429c      	cmp	r4, r3
  4042cc:	d008      	beq.n	4042e0 <vTaskSwitchContext+0x70>
  4042ce:	4b18      	ldr	r3, [pc, #96]	; (404330 <vTaskSwitchContext+0xc0>)
  4042d0:	4d18      	ldr	r5, [pc, #96]	; (404334 <vTaskSwitchContext+0xc4>)
  4042d2:	681c      	ldr	r4, [r3, #0]
  4042d4:	682d      	ldr	r5, [r5, #0]
  4042d6:	3408      	adds	r4, #8
  4042d8:	42a5      	cmp	r5, r4
  4042da:	d808      	bhi.n	4042ee <vTaskSwitchContext+0x7e>
  4042dc:	2300      	movs	r3, #0
  4042de:	600b      	str	r3, [r1, #0]
	}
}
  4042e0:	bc30      	pop	{r4, r5}
  4042e2:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  4042e4:	4b14      	ldr	r3, [pc, #80]	; (404338 <vTaskSwitchContext+0xc8>)
  4042e6:	2201      	movs	r2, #1
  4042e8:	601a      	str	r2, [r3, #0]
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
  4042ea:	bc30      	pop	{r4, r5}
  4042ec:	4770      	bx	lr
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4042ee:	4913      	ldr	r1, [pc, #76]	; (40433c <vTaskSwitchContext+0xcc>)
  4042f0:	6812      	ldr	r2, [r2, #0]
  4042f2:	681c      	ldr	r4, [r3, #0]
  4042f4:	680d      	ldr	r5, [r1, #0]
  4042f6:	6819      	ldr	r1, [r3, #0]
  4042f8:	6c52      	ldr	r2, [r2, #68]	; 0x44
  4042fa:	6002      	str	r2, [r0, #0]
  4042fc:	3104      	adds	r1, #4
  4042fe:	6019      	str	r1, [r3, #0]
  404300:	6818      	ldr	r0, [r3, #0]
  404302:	6819      	ldr	r1, [r3, #0]
  404304:	6025      	str	r5, [r4, #0]
  404306:	3104      	adds	r1, #4
  404308:	6002      	str	r2, [r0, #0]
  40430a:	6019      	str	r1, [r3, #0]
	}
}
  40430c:	bc30      	pop	{r4, r5}
  40430e:	4770      	bx	lr
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  404310:	685b      	ldr	r3, [r3, #4]
  404312:	604b      	str	r3, [r1, #4]
  404314:	e7cf      	b.n	4042b6 <vTaskSwitchContext+0x46>
  404316:	bf00      	nop
  404318:	20000fec 	.word	0x20000fec
  40431c:	20000f00 	.word	0x20000f00
  404320:	20000f08 	.word	0x20000f08
  404324:	20000fac 	.word	0x20000fac
  404328:	20000fd4 	.word	0x20000fd4
  40432c:	200000b8 	.word	0x200000b8
  404330:	20000fd0 	.word	0x20000fd0
  404334:	20000ff4 	.word	0x20000ff4
  404338:	20000fcc 	.word	0x20000fcc
  40433c:	20000f04 	.word	0x20000f04

00404340 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  404340:	b538      	push	{r3, r4, r5, lr}
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  404342:	4c0c      	ldr	r4, [pc, #48]	; (404374 <vTaskPlaceOnEventList+0x34>)
  404344:	4b0c      	ldr	r3, [pc, #48]	; (404378 <vTaskPlaceOnEventList+0x38>)
  404346:	6822      	ldr	r2, [r4, #0]
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  404348:	460d      	mov	r5, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40434a:	f102 0118 	add.w	r1, r2, #24
  40434e:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404350:	6820      	ldr	r0, [r4, #0]
  404352:	4b0a      	ldr	r3, [pc, #40]	; (40437c <vTaskPlaceOnEventList+0x3c>)
  404354:	3004      	adds	r0, #4
  404356:	4798      	blx	r3


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  404358:	1c6b      	adds	r3, r5, #1
  40435a:	d005      	beq.n	404368 <vTaskPlaceOnEventList+0x28>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  40435c:	4a08      	ldr	r2, [pc, #32]	; (404380 <vTaskPlaceOnEventList+0x40>)
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  40435e:	4b09      	ldr	r3, [pc, #36]	; (404384 <vTaskPlaceOnEventList+0x44>)
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  404360:	6810      	ldr	r0, [r2, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  404362:	4428      	add	r0, r5
  404364:	4798      	blx	r3
  404366:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404368:	6821      	ldr	r1, [r4, #0]
  40436a:	4807      	ldr	r0, [pc, #28]	; (404388 <vTaskPlaceOnEventList+0x48>)
  40436c:	4b07      	ldr	r3, [pc, #28]	; (40438c <vTaskPlaceOnEventList+0x4c>)
  40436e:	3104      	adds	r1, #4
  404370:	4798      	blx	r3
  404372:	bd38      	pop	{r3, r4, r5, pc}
  404374:	20000fd4 	.word	0x20000fd4
  404378:	00403b29 	.word	0x00403b29
  40437c:	00403b65 	.word	0x00403b65
  404380:	20000f04 	.word	0x20000f04
  404384:	00403ff1 	.word	0x00403ff1
  404388:	20000fd8 	.word	0x20000fd8
  40438c:	00403b0d 	.word	0x00403b0d

00404390 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  404390:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  404392:	68c3      	ldr	r3, [r0, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  404394:	4e13      	ldr	r6, [pc, #76]	; (4043e4 <xTaskRemoveFromEventList+0x54>)
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  404396:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  404398:	f104 0518 	add.w	r5, r4, #24
  40439c:	4628      	mov	r0, r5
  40439e:	47b0      	blx	r6

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4043a0:	4b11      	ldr	r3, [pc, #68]	; (4043e8 <xTaskRemoveFromEventList+0x58>)
  4043a2:	681b      	ldr	r3, [r3, #0]
  4043a4:	b9cb      	cbnz	r3, 4043da <xTaskRemoveFromEventList+0x4a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4043a6:	1d25      	adds	r5, r4, #4
  4043a8:	4628      	mov	r0, r5
  4043aa:	47b0      	blx	r6
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  4043ac:	4a0f      	ldr	r2, [pc, #60]	; (4043ec <xTaskRemoveFromEventList+0x5c>)
  4043ae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4043b0:	6811      	ldr	r1, [r2, #0]
  4043b2:	480f      	ldr	r0, [pc, #60]	; (4043f0 <xTaskRemoveFromEventList+0x60>)
  4043b4:	428b      	cmp	r3, r1
  4043b6:	bf88      	it	hi
  4043b8:	6013      	strhi	r3, [r2, #0]
  4043ba:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4043be:	4a0d      	ldr	r2, [pc, #52]	; (4043f4 <xTaskRemoveFromEventList+0x64>)
  4043c0:	4629      	mov	r1, r5
  4043c2:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  4043c6:	4790      	blx	r2
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4043c8:	4b0b      	ldr	r3, [pc, #44]	; (4043f8 <xTaskRemoveFromEventList+0x68>)
  4043ca:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4043cc:	681b      	ldr	r3, [r3, #0]
  4043ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4043d0:	4298      	cmp	r0, r3
  4043d2:	bf34      	ite	cc
  4043d4:	2000      	movcc	r0, #0
  4043d6:	2001      	movcs	r0, #1
  4043d8:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  4043da:	4629      	mov	r1, r5
  4043dc:	4807      	ldr	r0, [pc, #28]	; (4043fc <xTaskRemoveFromEventList+0x6c>)
  4043de:	4b05      	ldr	r3, [pc, #20]	; (4043f4 <xTaskRemoveFromEventList+0x64>)
  4043e0:	4798      	blx	r3
  4043e2:	e7f1      	b.n	4043c8 <xTaskRemoveFromEventList+0x38>
  4043e4:	00403b65 	.word	0x00403b65
  4043e8:	20000fec 	.word	0x20000fec
  4043ec:	20000f00 	.word	0x20000f00
  4043f0:	20000f08 	.word	0x20000f08
  4043f4:	00403b0d 	.word	0x00403b0d
  4043f8:	20000fd4 	.word	0x20000fd4
  4043fc:	20000fb8 	.word	0x20000fb8

00404400 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404400:	4a03      	ldr	r2, [pc, #12]	; (404410 <vTaskSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
  404402:	4b04      	ldr	r3, [pc, #16]	; (404414 <vTaskSetTimeOutState+0x14>)
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404404:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  404406:	681b      	ldr	r3, [r3, #0]
  404408:	e880 000c 	stmia.w	r0, {r2, r3}
  40440c:	4770      	bx	lr
  40440e:	bf00      	nop
  404410:	20000ff8 	.word	0x20000ff8
  404414:	20000f04 	.word	0x20000f04

00404418 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  404418:	b570      	push	{r4, r5, r6, lr}
  40441a:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  40441c:	4b19      	ldr	r3, [pc, #100]	; (404484 <xTaskCheckForTimeOut+0x6c>)
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  40441e:	4604      	mov	r4, r0
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  404420:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  404422:	682b      	ldr	r3, [r5, #0]
  404424:	1c5a      	adds	r2, r3, #1
  404426:	d028      	beq.n	40447a <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  404428:	4817      	ldr	r0, [pc, #92]	; (404488 <xTaskCheckForTimeOut+0x70>)
  40442a:	6822      	ldr	r2, [r4, #0]
  40442c:	6801      	ldr	r1, [r0, #0]
  40442e:	428a      	cmp	r2, r1
  404430:	d01b      	beq.n	40446a <xTaskCheckForTimeOut+0x52>
  404432:	4916      	ldr	r1, [pc, #88]	; (40448c <xTaskCheckForTimeOut+0x74>)
  404434:	6862      	ldr	r2, [r4, #4]
  404436:	680e      	ldr	r6, [r1, #0]
  404438:	42b2      	cmp	r2, r6
  40443a:	d911      	bls.n	404460 <xTaskCheckForTimeOut+0x48>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  40443c:	680e      	ldr	r6, [r1, #0]
  40443e:	4913      	ldr	r1, [pc, #76]	; (40448c <xTaskCheckForTimeOut+0x74>)
  404440:	1ab6      	subs	r6, r6, r2
  404442:	42b3      	cmp	r3, r6
  404444:	d90c      	bls.n	404460 <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  404446:	680e      	ldr	r6, [r1, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404448:	6800      	ldr	r0, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  40444a:	6809      	ldr	r1, [r1, #0]
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  40444c:	1b9b      	subs	r3, r3, r6
  40444e:	441a      	add	r2, r3
  404450:	602a      	str	r2, [r5, #0]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  404452:	4b0f      	ldr	r3, [pc, #60]	; (404490 <xTaskCheckForTimeOut+0x78>)

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
  404454:	e884 0003 	stmia.w	r4, {r0, r1}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
  404458:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40445a:	4798      	blx	r3

	return xReturn;
}
  40445c:	4628      	mov	r0, r5
  40445e:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  404460:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  404462:	4b0b      	ldr	r3, [pc, #44]	; (404490 <xTaskCheckForTimeOut+0x78>)
  404464:	4798      	blx	r3

	return xReturn;
}
  404466:	4628      	mov	r0, r5
  404468:	bd70      	pop	{r4, r5, r6, pc}
  40446a:	4908      	ldr	r1, [pc, #32]	; (40448c <xTaskCheckForTimeOut+0x74>)
  40446c:	6862      	ldr	r2, [r4, #4]
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  40446e:	680e      	ldr	r6, [r1, #0]
  404470:	4906      	ldr	r1, [pc, #24]	; (40448c <xTaskCheckForTimeOut+0x74>)
  404472:	1ab6      	subs	r6, r6, r2
  404474:	42b3      	cmp	r3, r6
  404476:	d8e6      	bhi.n	404446 <xTaskCheckForTimeOut+0x2e>
  404478:	e7f2      	b.n	404460 <xTaskCheckForTimeOut+0x48>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  40447a:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40447c:	4b04      	ldr	r3, [pc, #16]	; (404490 <xTaskCheckForTimeOut+0x78>)
  40447e:	4798      	blx	r3

	return xReturn;
}
  404480:	4628      	mov	r0, r5
  404482:	bd70      	pop	{r4, r5, r6, pc}
  404484:	00403bb9 	.word	0x00403bb9
  404488:	20000ff8 	.word	0x20000ff8
  40448c:	20000f04 	.word	0x20000f04
  404490:	00403bd1 	.word	0x00403bd1

00404494 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  404494:	4b01      	ldr	r3, [pc, #4]	; (40449c <vTaskMissedYield+0x8>)
  404496:	2201      	movs	r2, #1
  404498:	601a      	str	r2, [r3, #0]
  40449a:	4770      	bx	lr
  40449c:	20000fcc 	.word	0x20000fcc

004044a0 <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  4044a0:	4b01      	ldr	r3, [pc, #4]	; (4044a8 <xTaskGetCurrentTaskHandle+0x8>)
  4044a2:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  4044a4:	4770      	bx	lr
  4044a6:	bf00      	nop
  4044a8:	20000fd4 	.word	0x20000fd4

004044ac <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4044ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4044ae:	4d16      	ldr	r5, [pc, #88]	; (404508 <vTaskPriorityInherit+0x5c>)
  4044b0:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  4044b2:	682a      	ldr	r2, [r5, #0]
  4044b4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  4044b6:	4293      	cmp	r3, r2
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4044b8:	4604      	mov	r4, r0
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4044ba:	d20f      	bcs.n	4044dc <vTaskPriorityInherit+0x30>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4044bc:	682a      	ldr	r2, [r5, #0]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4044be:	4e13      	ldr	r6, [pc, #76]	; (40450c <vTaskPriorityInherit+0x60>)
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4044c0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4044c2:	6942      	ldr	r2, [r0, #20]
  4044c4:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4044c8:	eb06 0383 	add.w	r3, r6, r3, lsl #2
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4044cc:	f1c1 0108 	rsb	r1, r1, #8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4044d0:	429a      	cmp	r2, r3
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4044d2:	6181      	str	r1, [r0, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4044d4:	d003      	beq.n	4044de <vTaskPriorityInherit+0x32>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4044d6:	682b      	ldr	r3, [r5, #0]
  4044d8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  4044da:	62c3      	str	r3, [r0, #44]	; 0x2c
  4044dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  4044de:	1d07      	adds	r7, r0, #4
  4044e0:	4638      	mov	r0, r7
  4044e2:	4b0b      	ldr	r3, [pc, #44]	; (404510 <vTaskPriorityInherit+0x64>)
  4044e4:	4798      	blx	r3

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4044e6:	682b      	ldr	r3, [r5, #0]
				prvAddTaskToReadyQueue( pxTCB );
  4044e8:	4a0a      	ldr	r2, [pc, #40]	; (404514 <vTaskPriorityInherit+0x68>)
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4044ea:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4044ec:	6811      	ldr	r1, [r2, #0]
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  4044ee:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  4044f0:	428b      	cmp	r3, r1
  4044f2:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4044f6:	bf88      	it	hi
  4044f8:	6013      	strhi	r3, [r2, #0]
  4044fa:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  4044fe:	4639      	mov	r1, r7
  404500:	4b05      	ldr	r3, [pc, #20]	; (404518 <vTaskPriorityInherit+0x6c>)
  404502:	4798      	blx	r3
  404504:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404506:	bf00      	nop
  404508:	20000fd4 	.word	0x20000fd4
  40450c:	20000f08 	.word	0x20000f08
  404510:	00403b65 	.word	0x00403b65
  404514:	20000f00 	.word	0x20000f00
  404518:	00403b0d 	.word	0x00403b0d

0040451c <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  40451c:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  40451e:	4604      	mov	r4, r0
  404520:	b1c8      	cbz	r0, 404556 <vTaskPriorityDisinherit+0x3a>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  404522:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  404524:	6c83      	ldr	r3, [r0, #72]	; 0x48
  404526:	429a      	cmp	r2, r3
  404528:	d015      	beq.n	404556 <vTaskPriorityDisinherit+0x3a>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
  40452a:	1d05      	adds	r5, r0, #4
  40452c:	4628      	mov	r0, r5
  40452e:	4b0a      	ldr	r3, [pc, #40]	; (404558 <vTaskPriorityDisinherit+0x3c>)
  404530:	4798      	blx	r3

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  404532:	4a0a      	ldr	r2, [pc, #40]	; (40455c <vTaskPriorityDisinherit+0x40>)
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404534:	6ca3      	ldr	r3, [r4, #72]	; 0x48
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  404536:	6811      	ldr	r1, [r2, #0]
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404538:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  40453a:	f1c3 0008 	rsb	r0, r3, #8
				prvAddTaskToReadyQueue( pxTCB );
  40453e:	428b      	cmp	r3, r1
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  404540:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  404542:	4807      	ldr	r0, [pc, #28]	; (404560 <vTaskPriorityDisinherit+0x44>)
  404544:	bf88      	it	hi
  404546:	6013      	strhi	r3, [r2, #0]
  404548:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  40454c:	4a05      	ldr	r2, [pc, #20]	; (404564 <vTaskPriorityDisinherit+0x48>)
  40454e:	4629      	mov	r1, r5
  404550:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  404554:	4790      	blx	r2
  404556:	bd38      	pop	{r3, r4, r5, pc}
  404558:	00403b65 	.word	0x00403b65
  40455c:	20000f00 	.word	0x20000f00
  404560:	20000f08 	.word	0x20000f08
  404564:	00403b0d 	.word	0x00403b0d

00404568 <WDT_Handler>:

/**
 *  \brief Handler for watchdog interrupt.
 */
void WDT_Handler(void)
{
  404568:	b508      	push	{r3, lr}

	/* Clear status bit to acknowledge interrupt by dummy read. */
	wdt_get_status(WDT);
  40456a:	4803      	ldr	r0, [pc, #12]	; (404578 <WDT_Handler+0x10>)
  40456c:	4b03      	ldr	r3, [pc, #12]	; (40457c <WDT_Handler+0x14>)
  40456e:	4798      	blx	r3

	debugPrintString("Restarting system!!!\r");
  404570:	4803      	ldr	r0, [pc, #12]	; (404580 <WDT_Handler+0x18>)
  404572:	4b04      	ldr	r3, [pc, #16]	; (404584 <WDT_Handler+0x1c>)
  404574:	4798      	blx	r3
  404576:	bd08      	pop	{r3, pc}
  404578:	400e1450 	.word	0x400e1450
  40457c:	00405369 	.word	0x00405369
  404580:	00406d84 	.word	0x00406d84
  404584:	00400b79 	.word	0x00400b79

00404588 <itoa>:
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  404588:	b4f0      	push	{r4, r5, r6, r7}
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  40458a:	2a0a      	cmp	r2, #10
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  40458c:	b084      	sub	sp, #16
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  40458e:	d028      	beq.n	4045e2 <itoa+0x5a>
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;
  404590:	2700      	movs	r7, #0
	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  404592:	466e      	mov	r6, sp
  404594:	466b      	mov	r3, sp
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  404596:	b938      	cbnz	r0, 4045a8 <itoa+0x20>
  404598:	42b3      	cmp	r3, r6
  40459a:	d110      	bne.n	4045be <itoa+0x36>
	 {
		 i = v % radix;
  40459c:	4604      	mov	r4, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  40459e:	3430      	adds	r4, #48	; 0x30
  4045a0:	701c      	strb	r4, [r3, #0]
  4045a2:	3301      	adds	r3, #1
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  4045a4:	2800      	cmp	r0, #0
  4045a6:	d0f7      	beq.n	404598 <itoa+0x10>
	 {
		 i = v % radix;
  4045a8:	fbb0 f5f2 	udiv	r5, r0, r2
  4045ac:	fb02 0415 	mls	r4, r2, r5, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
  4045b0:	2c09      	cmp	r4, #9
		v = (unsigned)value;

	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
  4045b2:	4628      	mov	r0, r5
		 if (i < 10)
  4045b4:	ddf3      	ble.n	40459e <itoa+0x16>
			*tp++ = i+'0';
		 else
			*tp++ = i + 'a' - 10;
  4045b6:	3457      	adds	r4, #87	; 0x57
  4045b8:	701c      	strb	r4, [r3, #0]
  4045ba:	3301      	adds	r3, #1
  4045bc:	e7eb      	b.n	404596 <itoa+0xe>
	 }

	 int len = tp - tmp;
  4045be:	1b98      	subs	r0, r3, r6

	 if (sign)
  4045c0:	b11f      	cbz	r7, 4045ca <itoa+0x42>
	 {
		 *sp++ = '-';
  4045c2:	222d      	movs	r2, #45	; 0x2d
  4045c4:	700a      	strb	r2, [r1, #0]
		 len++;
  4045c6:	3001      	adds	r0, #1

	 int len = tp - tmp;

	 if (sign)
	 {
		 *sp++ = '-';
  4045c8:	3101      	adds	r1, #1
		 len++;
	 }

	 while (tp > tmp)
  4045ca:	42b3      	cmp	r3, r6
  4045cc:	d906      	bls.n	4045dc <itoa+0x54>
  4045ce:	3901      	subs	r1, #1
	 *sp++ = *--tp;
  4045d0:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  4045d4:	f801 2f01 	strb.w	r2, [r1, #1]!
	 {
		 *sp++ = '-';
		 len++;
	 }

	 while (tp > tmp)
  4045d8:	42b3      	cmp	r3, r6
  4045da:	d1f9      	bne.n	4045d0 <itoa+0x48>
	 *sp++ = *--tp;

	 return len;
  4045dc:	b004      	add	sp, #16
  4045de:	bcf0      	pop	{r4, r5, r6, r7}
  4045e0:	4770      	bx	lr
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4045e2:	2800      	cmp	r0, #0
  4045e4:	dad4      	bge.n	404590 <itoa+0x8>
	 if (sign)
		 v = -value;
  4045e6:	4240      	negs	r0, r0
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4045e8:	2701      	movs	r7, #1
  4045ea:	e7d2      	b.n	404592 <itoa+0xa>

004045ec <drv_gpio_int_cd>:
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4045ec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4045ee:	4e0b      	ldr	r6, [pc, #44]	; (40461c <drv_gpio_int_cd+0x30>)
  4045f0:	4b0b      	ldr	r3, [pc, #44]	; (404620 <drv_gpio_int_cd+0x34>)
  4045f2:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
	pio_disable_interrupt(PIOB, PinMask);
  4045f6:	4d0b      	ldr	r5, [pc, #44]	; (404624 <drv_gpio_int_cd+0x38>)
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  4045f8:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4045fa:	4798      	blx	r3
	pio_disable_interrupt(PIOB, PinMask);
  4045fc:	4b0a      	ldr	r3, [pc, #40]	; (404628 <drv_gpio_int_cd+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  4045fe:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOB, PinMask);
  404600:	4601      	mov	r1, r0
  404602:	4628      	mov	r0, r5
  404604:	4798      	blx	r3
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
  404606:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
  404608:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOB, PinMask);
  40460a:	4806      	ldr	r0, [pc, #24]	; (404624 <drv_gpio_int_cd+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
  40460c:	bf04      	itt	eq
  40460e:	2301      	moveq	r3, #1
  404610:	f886 310e 	strbeq.w	r3, [r6, #270]	; 0x10e
	}
	pio_enable_interrupt(PIOB, PinMask);
  404614:	4621      	mov	r1, r4
  404616:	4b05      	ldr	r3, [pc, #20]	; (40462c <drv_gpio_int_cd+0x40>)
  404618:	4798      	blx	r3
  40461a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40461c:	20000118 	.word	0x20000118
  404620:	00405145 	.word	0x00405145
  404624:	400e1000 	.word	0x400e1000
  404628:	00404f81 	.word	0x00404f81
  40462c:	00404f79 	.word	0x00404f79

00404630 <drv_gpio_int_lbo>:
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  404630:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  404632:	4e0b      	ldr	r6, [pc, #44]	; (404660 <drv_gpio_int_lbo+0x30>)
  404634:	4b0b      	ldr	r3, [pc, #44]	; (404664 <drv_gpio_int_lbo+0x34>)
  404636:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
	pio_disable_interrupt(PIOA, PinMask);
  40463a:	4d0b      	ldr	r5, [pc, #44]	; (404668 <drv_gpio_int_lbo+0x38>)
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  40463c:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40463e:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404640:	4b0a      	ldr	r3, [pc, #40]	; (40466c <drv_gpio_int_lbo+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  404642:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404644:	4601      	mov	r1, r0
  404646:	4628      	mov	r0, r5
  404648:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40464a:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40464c:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40464e:	4806      	ldr	r0, [pc, #24]	; (404668 <drv_gpio_int_lbo+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
  404650:	bf04      	itt	eq
  404652:	2301      	moveq	r3, #1
  404654:	f886 30fe 	strbeq.w	r3, [r6, #254]	; 0xfe
	}
	pio_enable_interrupt(PIOA, PinMask);
  404658:	4621      	mov	r1, r4
  40465a:	4b05      	ldr	r3, [pc, #20]	; (404670 <drv_gpio_int_lbo+0x40>)
  40465c:	4798      	blx	r3
  40465e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404660:	20000118 	.word	0x20000118
  404664:	00405145 	.word	0x00405145
  404668:	400e0e00 	.word	0x400e0e00
  40466c:	00404f81 	.word	0x00404f81
  404670:	00404f79 	.word	0x00404f79

00404674 <drv_gpio_int_dc2>:
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  404674:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404676:	4e0b      	ldr	r6, [pc, #44]	; (4046a4 <drv_gpio_int_dc2+0x30>)
  404678:	4b0b      	ldr	r3, [pc, #44]	; (4046a8 <drv_gpio_int_dc2+0x34>)
  40467a:	6e30      	ldr	r0, [r6, #96]	; 0x60
	pio_disable_interrupt(PIOA, PinMask);
  40467c:	4d0b      	ldr	r5, [pc, #44]	; (4046ac <drv_gpio_int_dc2+0x38>)
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  40467e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404680:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404682:	4b0b      	ldr	r3, [pc, #44]	; (4046b0 <drv_gpio_int_dc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  404684:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404686:	4601      	mov	r1, r0
  404688:	4628      	mov	r0, r5
  40468a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40468c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40468e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404690:	4806      	ldr	r0, [pc, #24]	; (4046ac <drv_gpio_int_dc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
  404692:	bf04      	itt	eq
  404694:	2301      	moveq	r3, #1
  404696:	f886 306e 	strbeq.w	r3, [r6, #110]	; 0x6e
	}
	pio_enable_interrupt(PIOA, PinMask);
  40469a:	4621      	mov	r1, r4
  40469c:	4b05      	ldr	r3, [pc, #20]	; (4046b4 <drv_gpio_int_dc2+0x40>)
  40469e:	4798      	blx	r3
  4046a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4046a2:	bf00      	nop
  4046a4:	20000118 	.word	0x20000118
  4046a8:	00405145 	.word	0x00405145
  4046ac:	400e0e00 	.word	0x400e0e00
  4046b0:	00404f81 	.word	0x00404f81
  4046b4:	00404f79 	.word	0x00404f79

004046b8 <drv_gpio_int_dc1>:
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4046b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4046ba:	4e0b      	ldr	r6, [pc, #44]	; (4046e8 <drv_gpio_int_dc1+0x30>)
  4046bc:	4b0b      	ldr	r3, [pc, #44]	; (4046ec <drv_gpio_int_dc1+0x34>)
  4046be:	6d30      	ldr	r0, [r6, #80]	; 0x50
	pio_disable_interrupt(PIOA, PinMask);
  4046c0:	4d0b      	ldr	r5, [pc, #44]	; (4046f0 <drv_gpio_int_dc1+0x38>)
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4046c2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4046c4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4046c6:	4b0b      	ldr	r3, [pc, #44]	; (4046f4 <drv_gpio_int_dc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4046c8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4046ca:	4601      	mov	r1, r0
  4046cc:	4628      	mov	r0, r5
  4046ce:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4046d0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4046d2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4046d4:	4806      	ldr	r0, [pc, #24]	; (4046f0 <drv_gpio_int_dc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
  4046d6:	bf04      	itt	eq
  4046d8:	2301      	moveq	r3, #1
  4046da:	f886 305e 	strbeq.w	r3, [r6, #94]	; 0x5e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4046de:	4621      	mov	r1, r4
  4046e0:	4b05      	ldr	r3, [pc, #20]	; (4046f8 <drv_gpio_int_dc1+0x40>)
  4046e2:	4798      	blx	r3
  4046e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4046e6:	bf00      	nop
  4046e8:	20000118 	.word	0x20000118
  4046ec:	00405145 	.word	0x00405145
  4046f0:	400e0e00 	.word	0x400e0e00
  4046f4:	00404f81 	.word	0x00404f81
  4046f8:	00404f79 	.word	0x00404f79

004046fc <drv_gpio_int_oc2>:
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  4046fc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  4046fe:	4e0b      	ldr	r6, [pc, #44]	; (40472c <drv_gpio_int_oc2+0x30>)
  404700:	4b0b      	ldr	r3, [pc, #44]	; (404730 <drv_gpio_int_oc2+0x34>)
  404702:	6c30      	ldr	r0, [r6, #64]	; 0x40
	pio_disable_interrupt(PIOA, PinMask);
  404704:	4d0b      	ldr	r5, [pc, #44]	; (404734 <drv_gpio_int_oc2+0x38>)
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  404706:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404708:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  40470a:	4b0b      	ldr	r3, [pc, #44]	; (404738 <drv_gpio_int_oc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  40470c:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  40470e:	4601      	mov	r1, r0
  404710:	4628      	mov	r0, r5
  404712:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404714:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404716:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404718:	4806      	ldr	r0, [pc, #24]	; (404734 <drv_gpio_int_oc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
  40471a:	bf04      	itt	eq
  40471c:	2301      	moveq	r3, #1
  40471e:	f886 304e 	strbeq.w	r3, [r6, #78]	; 0x4e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404722:	4621      	mov	r1, r4
  404724:	4b05      	ldr	r3, [pc, #20]	; (40473c <drv_gpio_int_oc2+0x40>)
  404726:	4798      	blx	r3
  404728:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40472a:	bf00      	nop
  40472c:	20000118 	.word	0x20000118
  404730:	00405145 	.word	0x00405145
  404734:	400e0e00 	.word	0x400e0e00
  404738:	00404f81 	.word	0x00404f81
  40473c:	00404f79 	.word	0x00404f79

00404740 <drv_gpio_int_oc1>:
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  404740:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404742:	4e0b      	ldr	r6, [pc, #44]	; (404770 <drv_gpio_int_oc1+0x30>)
  404744:	4b0b      	ldr	r3, [pc, #44]	; (404774 <drv_gpio_int_oc1+0x34>)
  404746:	6b30      	ldr	r0, [r6, #48]	; 0x30
	pio_disable_interrupt(PIOA, PinMask);
  404748:	4d0b      	ldr	r5, [pc, #44]	; (404778 <drv_gpio_int_oc1+0x38>)
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  40474a:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  40474c:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  40474e:	4b0b      	ldr	r3, [pc, #44]	; (40477c <drv_gpio_int_oc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404750:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404752:	4601      	mov	r1, r0
  404754:	4628      	mov	r0, r5
  404756:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404758:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40475a:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40475c:	4806      	ldr	r0, [pc, #24]	; (404778 <drv_gpio_int_oc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
  40475e:	bf04      	itt	eq
  404760:	2301      	moveq	r3, #1
  404762:	f886 303e 	strbeq.w	r3, [r6, #62]	; 0x3e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404766:	4621      	mov	r1, r4
  404768:	4b05      	ldr	r3, [pc, #20]	; (404780 <drv_gpio_int_oc1+0x40>)
  40476a:	4798      	blx	r3
  40476c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40476e:	bf00      	nop
  404770:	20000118 	.word	0x20000118
  404774:	00405145 	.word	0x00405145
  404778:	400e0e00 	.word	0x400e0e00
  40477c:	00404f81 	.word	0x00404f81
  404780:	00404f79 	.word	0x00404f79

00404784 <drv_gpio_int_sw2>:
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  404784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404786:	4e0b      	ldr	r6, [pc, #44]	; (4047b4 <drv_gpio_int_sw2+0x30>)
  404788:	4b0b      	ldr	r3, [pc, #44]	; (4047b8 <drv_gpio_int_sw2+0x34>)
  40478a:	6a30      	ldr	r0, [r6, #32]
	pio_disable_interrupt(PIOA, PinMask);
  40478c:	4d0b      	ldr	r5, [pc, #44]	; (4047bc <drv_gpio_int_sw2+0x38>)
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  40478e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404790:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404792:	4b0b      	ldr	r3, [pc, #44]	; (4047c0 <drv_gpio_int_sw2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404794:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404796:	4601      	mov	r1, r0
  404798:	4628      	mov	r0, r5
  40479a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  40479c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  40479e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4047a0:	4806      	ldr	r0, [pc, #24]	; (4047bc <drv_gpio_int_sw2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
  4047a2:	bf04      	itt	eq
  4047a4:	2301      	moveq	r3, #1
  4047a6:	f886 302e 	strbeq.w	r3, [r6, #46]	; 0x2e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4047aa:	4621      	mov	r1, r4
  4047ac:	4b05      	ldr	r3, [pc, #20]	; (4047c4 <drv_gpio_int_sw2+0x40>)
  4047ae:	4798      	blx	r3
  4047b0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4047b2:	bf00      	nop
  4047b4:	20000118 	.word	0x20000118
  4047b8:	00405145 	.word	0x00405145
  4047bc:	400e0e00 	.word	0x400e0e00
  4047c0:	00404f81 	.word	0x00404f81
  4047c4:	00404f79 	.word	0x00404f79

004047c8 <drv_gpio_int_sw1>:
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4047c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4047ca:	4e0a      	ldr	r6, [pc, #40]	; (4047f4 <drv_gpio_int_sw1+0x2c>)
  4047cc:	4b0a      	ldr	r3, [pc, #40]	; (4047f8 <drv_gpio_int_sw1+0x30>)
  4047ce:	6930      	ldr	r0, [r6, #16]
	pio_disable_interrupt(PIOA, PinMask);
  4047d0:	4d0a      	ldr	r5, [pc, #40]	; (4047fc <drv_gpio_int_sw1+0x34>)
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  4047d2:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4047d4:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4047d6:	4b0a      	ldr	r3, [pc, #40]	; (404800 <drv_gpio_int_sw1+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  4047d8:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4047da:	4601      	mov	r1, r0
  4047dc:	4628      	mov	r0, r5
  4047de:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4047e0:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4047e2:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4047e4:	4805      	ldr	r0, [pc, #20]	; (4047fc <drv_gpio_int_sw1+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
  4047e6:	bf04      	itt	eq
  4047e8:	2301      	moveq	r3, #1
  4047ea:	77b3      	strbeq	r3, [r6, #30]
	}
	pio_enable_interrupt(PIOA, PinMask);
  4047ec:	4621      	mov	r1, r4
  4047ee:	4b05      	ldr	r3, [pc, #20]	; (404804 <drv_gpio_int_sw1+0x3c>)
  4047f0:	4798      	blx	r3
  4047f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4047f4:	20000118 	.word	0x20000118
  4047f8:	00405145 	.word	0x00405145
  4047fc:	400e0e00 	.word	0x400e0e00
  404800:	00404f81 	.word	0x00404f81
  404804:	00404f79 	.word	0x00404f79

00404808 <drv_gpio_int_pw>:
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404808:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  40480a:	4e0a      	ldr	r6, [pc, #40]	; (404834 <drv_gpio_int_pw+0x2c>)
  40480c:	4b0a      	ldr	r3, [pc, #40]	; (404838 <drv_gpio_int_pw+0x30>)
  40480e:	6830      	ldr	r0, [r6, #0]
	pio_disable_interrupt(PIOA, PinMask);
  404810:	4d0a      	ldr	r5, [pc, #40]	; (40483c <drv_gpio_int_pw+0x34>)
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404812:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404814:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404816:	4b0a      	ldr	r3, [pc, #40]	; (404840 <drv_gpio_int_pw+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404818:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  40481a:	4601      	mov	r1, r0
  40481c:	4628      	mov	r0, r5
  40481e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404820:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404822:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404824:	4805      	ldr	r0, [pc, #20]	; (40483c <drv_gpio_int_pw+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
  404826:	bf04      	itt	eq
  404828:	2301      	moveq	r3, #1
  40482a:	73b3      	strbeq	r3, [r6, #14]
	}
	pio_enable_interrupt(PIOA, PinMask);
  40482c:	4621      	mov	r1, r4
  40482e:	4b05      	ldr	r3, [pc, #20]	; (404844 <drv_gpio_int_pw+0x3c>)
  404830:	4798      	blx	r3
  404832:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404834:	20000118 	.word	0x20000118
  404838:	00405145 	.word	0x00405145
  40483c:	400e0e00 	.word	0x400e0e00
  404840:	00404f81 	.word	0x00404f81
  404844:	00404f79 	.word	0x00404f79

00404848 <drv_gpio_config>:
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404848:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  40484c:	7903      	ldrb	r3, [r0, #4]
  40484e:	2b01      	cmp	r3, #1
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404850:	b082      	sub	sp, #8
  404852:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  404854:	d011      	beq.n	40487a <drv_gpio_config+0x32>
		p_pio->PIO_PPDDR |= PinMask; 
		
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
  404856:	7942      	ldrb	r2, [r0, #5]
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404858:	4b36      	ldr	r3, [pc, #216]	; (404934 <drv_gpio_config+0xec>)
  40485a:	6800      	ldr	r0, [r0, #0]
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_1;	//set default pin state
  40485c:	2a01      	cmp	r2, #1
  40485e:	bf14      	ite	ne
  404860:	f04f 5540 	movne.w	r5, #805306368	; 0x30000000
  404864:	f04f 5560 	moveq.w	r5, #939524096	; 0x38000000
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404868:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  40486a:	4629      	mov	r1, r5
  40486c:	6820      	ldr	r0, [r4, #0]
  40486e:	4b32      	ldr	r3, [pc, #200]	; (404938 <drv_gpio_config+0xf0>)
  404870:	4798      	blx	r3
	}
	
	return status;
}
  404872:	2000      	movs	r0, #0
  404874:	b002      	add	sp, #8
  404876:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
		if (gpioConfig->pullUpEnabled == TRUE)
  40487a:	7b02      	ldrb	r2, [r0, #12]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  40487c:	4f2f      	ldr	r7, [pc, #188]	; (40493c <drv_gpio_config+0xf4>)
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  40487e:	7b43      	ldrb	r3, [r0, #13]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  404880:	2a01      	cmp	r2, #1
  404882:	bf18      	it	ne
  404884:	f04f 5720 	movne.w	r7, #671088640	; 0x28000000
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  404888:	2b01      	cmp	r3, #1
  40488a:	d03c      	beq.n	404906 <drv_gpio_config+0xbe>
  40488c:	4d2c      	ldr	r5, [pc, #176]	; (404940 <drv_gpio_config+0xf8>)
  40488e:	4e2d      	ldr	r6, [pc, #180]	; (404944 <drv_gpio_config+0xfc>)
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);	
  404890:	4b28      	ldr	r3, [pc, #160]	; (404934 <drv_gpio_config+0xec>)
  404892:	6820      	ldr	r0, [r4, #0]
  404894:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  404896:	4b28      	ldr	r3, [pc, #160]	; (404938 <drv_gpio_config+0xf0>)
  404898:	6820      	ldr	r0, [r4, #0]
  40489a:	4639      	mov	r1, r7
  40489c:	4798      	blx	r3
		 
		PinFlag = 0;	//Reset the PinFlag to use it to configure interrupt
		switch(gpioConfig->interruptType)	//set interrupt configuration flag
  40489e:	79a3      	ldrb	r3, [r4, #6]
  4048a0:	2b03      	cmp	r3, #3
  4048a2:	d829      	bhi.n	4048f8 <drv_gpio_config+0xb0>
  4048a4:	4a28      	ldr	r2, [pc, #160]	; (404948 <drv_gpio_config+0x100>)
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  4048a6:	6820      	ldr	r0, [r4, #0]
  4048a8:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
  4048ac:	47a8      	blx	r5
  4048ae:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4048b0:	6820      	ldr	r0, [r4, #0]
  4048b2:	47b0      	blx	r6
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  4048b4:	f017 0f70 	tst.w	r7, #112	; 0x70
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4048b8:	4606      	mov	r6, r0
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  4048ba:	d014      	beq.n	4048e6 <drv_gpio_config+0x9e>
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  4048bc:	6820      	ldr	r0, [r4, #0]
  4048be:	4b23      	ldr	r3, [pc, #140]	; (40494c <drv_gpio_config+0x104>)
  4048c0:	4798      	blx	r3
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  4048c2:	68a3      	ldr	r3, [r4, #8]
  4048c4:	9300      	str	r3, [sp, #0]
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  4048c6:	4601      	mov	r1, r0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  4048c8:	463b      	mov	r3, r7
  4048ca:	4632      	mov	r2, r6
  4048cc:	4628      	mov	r0, r5
  4048ce:	4c20      	ldr	r4, [pc, #128]	; (404950 <drv_gpio_config+0x108>)
  4048d0:	47a0      	blx	r4
			pio_enable_interrupt(p_pio, PinMask);
  4048d2:	4b20      	ldr	r3, [pc, #128]	; (404954 <drv_gpio_config+0x10c>)
  4048d4:	4628      	mov	r0, r5
  4048d6:	4631      	mov	r1, r6
  4048d8:	4798      	blx	r3
			if (p_pio == PIOA)
  4048da:	4b1f      	ldr	r3, [pc, #124]	; (404958 <drv_gpio_config+0x110>)
  4048dc:	429d      	cmp	r5, r3
  4048de:	d024      	beq.n	40492a <drv_gpio_config+0xe2>
			{
				NVIC_EnableIRQ(PIOA_IRQn);
			}
			else if (p_pio == PIOB)
  4048e0:	4b1e      	ldr	r3, [pc, #120]	; (40495c <drv_gpio_config+0x114>)
  4048e2:	429d      	cmp	r5, r3
  4048e4:	d01c      	beq.n	404920 <drv_gpio_config+0xd8>
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  4048e6:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  4048ea:	2000      	movs	r0, #0
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  4048ec:	431e      	orrs	r6, r3
  4048ee:	f8c5 6090 	str.w	r6, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  4048f2:	b002      	add	sp, #8
  4048f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  4048f8:	6820      	ldr	r0, [r4, #0]
  4048fa:	47a8      	blx	r5
  4048fc:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  4048fe:	6820      	ldr	r0, [r4, #0]
  404900:	47b0      	blx	r6
  404902:	4606      	mov	r6, r0
  404904:	e7ef      	b.n	4048e6 <drv_gpio_config+0x9e>
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  404906:	4d0e      	ldr	r5, [pc, #56]	; (404940 <drv_gpio_config+0xf8>)
  404908:	6800      	ldr	r0, [r0, #0]
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  40490a:	4e0e      	ldr	r6, [pc, #56]	; (404944 <drv_gpio_config+0xfc>)
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  40490c:	47a8      	blx	r5
  40490e:	4680      	mov	r8, r0
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404910:	6820      	ldr	r0, [r4, #0]
  404912:	47b0      	blx	r6
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404914:	2205      	movs	r2, #5
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404916:	4601      	mov	r1, r0
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404918:	4b11      	ldr	r3, [pc, #68]	; (404960 <drv_gpio_config+0x118>)
  40491a:	4640      	mov	r0, r8
  40491c:	4798      	blx	r3
  40491e:	e7b7      	b.n	404890 <drv_gpio_config+0x48>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  404920:	4b10      	ldr	r3, [pc, #64]	; (404964 <drv_gpio_config+0x11c>)
  404922:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  404926:	601a      	str	r2, [r3, #0]
  404928:	e7dd      	b.n	4048e6 <drv_gpio_config+0x9e>
  40492a:	4b0e      	ldr	r3, [pc, #56]	; (404964 <drv_gpio_config+0x11c>)
  40492c:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404930:	601a      	str	r2, [r3, #0]
  404932:	e7d8      	b.n	4048e6 <drv_gpio_config+0x9e>
  404934:	0040531d 	.word	0x0040531d
  404938:	00404fe9 	.word	0x00404fe9
  40493c:	28000001 	.word	0x28000001
  404940:	0040512d 	.word	0x0040512d
  404944:	00405145 	.word	0x00405145
  404948:	00406d9c 	.word	0x00406d9c
  40494c:	0040513d 	.word	0x0040513d
  404950:	004051c9 	.word	0x004051c9
  404954:	00404f79 	.word	0x00404f79
  404958:	400e0e00 	.word	0x400e0e00
  40495c:	400e1000 	.word	0x400e1000
  404960:	00404e75 	.word	0x00404e75
  404964:	e000e100 	.word	0xe000e100

00404968 <drv_gpio_initializeAll>:
 * @brief initialize all GPIO
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
  404968:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
  40496a:	4b0b      	ldr	r3, [pc, #44]	; (404998 <drv_gpio_initializeAll+0x30>)
  40496c:	4c0b      	ldr	r4, [pc, #44]	; (40499c <drv_gpio_initializeAll+0x34>)
  40496e:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  404972:	4f0b      	ldr	r7, [pc, #44]	; (4049a0 <drv_gpio_initializeAll+0x38>)
  404974:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
  404978:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  40497c:	f504 7698 	add.w	r6, r4, #304	; 0x130
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
	status_t status = STATUS_PASS; 
  404980:	2500      	movs	r5, #0
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&gpioConfig[i]) != STATUS_PASS)
  404982:	4620      	mov	r0, r4
  404984:	47b8      	blx	r7
  404986:	3410      	adds	r4, #16
		{
			//printf("failed to initialize GPIO at index %d", i);
			status |= STATUS_FAIL;
  404988:	2800      	cmp	r0, #0
  40498a:	bf18      	it	ne
  40498c:	2501      	movne	r5, #1
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
  40498e:	42b4      	cmp	r4, r6
  404990:	d1f7      	bne.n	404982 <drv_gpio_initializeAll+0x1a>
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST2]);
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST3]);
	
	
	return status; 
}
  404992:	4628      	mov	r0, r5
  404994:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404996:	bf00      	nop
  404998:	400e0200 	.word	0x400e0200
  40499c:	20000118 	.word	0x20000118
  4049a0:	00404849 	.word	0x00404849

004049a4 <drv_gpio_setPinState>:
 * @brief Set a GPIO to HIGH or LOW
 * @param drv_gpio_pins_t pin, drv_gpio_pin_state_t state
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
  4049a4:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
  4049a6:	4c18      	ldr	r4, [pc, #96]	; (404a08 <drv_gpio_setPinState+0x64>)
  4049a8:	0105      	lsls	r5, r0, #4
  4049aa:	1963      	adds	r3, r4, r5
  4049ac:	791a      	ldrb	r2, [r3, #4]
  4049ae:	b972      	cbnz	r2, 4049ce <drv_gpio_setPinState+0x2a>
	{
		return STATUS_FAIL;
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
  4049b0:	7bdb      	ldrb	r3, [r3, #15]
  4049b2:	3b02      	subs	r3, #2
  4049b4:	2b01      	cmp	r3, #1
  4049b6:	d90c      	bls.n	4049d2 <drv_gpio_setPinState+0x2e>
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
		}
	}
	//the output should be in the right state. 
	
	switch(state)
  4049b8:	2901      	cmp	r1, #1
  4049ba:	d01f      	beq.n	4049fc <drv_gpio_setPinState+0x58>
  4049bc:	d312      	bcc.n	4049e4 <drv_gpio_setPinState+0x40>
  4049be:	2902      	cmp	r1, #2
  4049c0:	d115      	bne.n	4049ee <drv_gpio_setPinState+0x4a>
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  4049c2:	6820      	ldr	r0, [r4, #0]
  4049c4:	4911      	ldr	r1, [pc, #68]	; (404a0c <drv_gpio_setPinState+0x68>)
  4049c6:	4b12      	ldr	r3, [pc, #72]	; (404a10 <drv_gpio_setPinState+0x6c>)
  4049c8:	4798      	blx	r3
	}
	
	


	return status;
  4049ca:	2000      	movs	r0, #0
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		break;
  4049cc:	bd38      	pop	{r3, r4, r5, pc}
{
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
	{
		return STATUS_FAIL;
  4049ce:	2001      	movs	r0, #1
  4049d0:	bd38      	pop	{r3, r4, r5, pc}
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
  4049d2:	2901      	cmp	r1, #1
  4049d4:	d00d      	beq.n	4049f2 <drv_gpio_setPinState+0x4e>
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		}
		else if(state == DRV_GPIO_PIN_STATE_LOW)
  4049d6:	2900      	cmp	r1, #0
  4049d8:	d1ee      	bne.n	4049b8 <drv_gpio_setPinState+0x14>
		{
			pinFlag |= PIO_TYPE_PIO_OUTPUT_0;
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
  4049da:	6820      	ldr	r0, [r4, #0]
  4049dc:	4b0c      	ldr	r3, [pc, #48]	; (404a10 <drv_gpio_setPinState+0x6c>)
  4049de:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  4049e2:	4798      	blx	r3
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
  4049e4:	5960      	ldr	r0, [r4, r5]
  4049e6:	4b0b      	ldr	r3, [pc, #44]	; (404a14 <drv_gpio_setPinState+0x70>)
  4049e8:	4798      	blx	r3
	}
	
	


	return status;
  4049ea:	2000      	movs	r0, #0
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
  4049ec:	bd38      	pop	{r3, r4, r5, pc}
	}
	
	


	return status;
  4049ee:	2000      	movs	r0, #0
}
  4049f0:	bd38      	pop	{r3, r4, r5, pc}
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  4049f2:	6820      	ldr	r0, [r4, #0]
  4049f4:	4b06      	ldr	r3, [pc, #24]	; (404a10 <drv_gpio_setPinState+0x6c>)
  4049f6:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  4049fa:	4798      	blx	r3
	//the output should be in the right state. 
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
  4049fc:	5960      	ldr	r0, [r4, r5]
  4049fe:	4b06      	ldr	r3, [pc, #24]	; (404a18 <drv_gpio_setPinState+0x74>)
  404a00:	4798      	blx	r3
	}
	
	


	return status;
  404a02:	2000      	movs	r0, #0
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
  404a04:	bd38      	pop	{r3, r4, r5, pc}
  404a06:	bf00      	nop
  404a08:	20000118 	.word	0x20000118
  404a0c:	28000001 	.word	0x28000001
  404a10:	00404fe9 	.word	0x00404fe9
  404a14:	00404fa9 	.word	0x00404fa9
  404a18:	00404f8d 	.word	0x00404f8d

00404a1c <drv_gpio_getPinState>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_getPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t* state)
{
	status_t status = STATUS_PASS;
	bool value = ioport_get_pin_level(gpioConfig[pin].pinId);
  404a1c:	4b0a      	ldr	r3, [pc, #40]	; (404a48 <drv_gpio_getPinState+0x2c>)
  404a1e:	0100      	lsls	r0, r0, #4
  404a20:	5818      	ldr	r0, [r3, r0]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404a22:	0943      	lsrs	r3, r0, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404a24:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404a28:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404a2c:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404a2e:	f000 001f 	and.w	r0, r0, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  404a32:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404a34:	2301      	movs	r3, #1
  404a36:	fa03 f000 	lsl.w	r0, r3, r0
	if (value == false)
  404a3a:	4002      	ands	r2, r0
	{
		*state = DRV_GPIO_PIN_STATE_LOW;
  404a3c:	bf08      	it	eq
  404a3e:	4613      	moveq	r3, r2
  404a40:	700b      	strb	r3, [r1, #0]
	else
	{
		*state = DRV_GPIO_PIN_STATE_HIGH;
	}
	return status;
}
  404a42:	2000      	movs	r0, #0
  404a44:	4770      	bx	lr
  404a46:	bf00      	nop
  404a48:	20000118 	.word	0x20000118

00404a4c <drv_gpio_togglePin>:
 * @brief Toggle a GPIO level
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_togglePin(drv_gpio_pins_t pin)
{
  404a4c:	b508      	push	{r3, lr}
	status_t status = STATUS_PASS;
	pio_toggle_pin(gpioConfig[pin].pinId);
  404a4e:	4a03      	ldr	r2, [pc, #12]	; (404a5c <drv_gpio_togglePin+0x10>)
  404a50:	4b03      	ldr	r3, [pc, #12]	; (404a60 <drv_gpio_togglePin+0x14>)
  404a52:	0100      	lsls	r0, r0, #4
  404a54:	5810      	ldr	r0, [r2, r0]
  404a56:	4798      	blx	r3
	return status;
}
  404a58:	2000      	movs	r0, #0
  404a5a:	bd08      	pop	{r3, pc}
  404a5c:	20000118 	.word	0x20000118
  404a60:	00404fc5 	.word	0x00404fc5

00404a64 <uart_process_byte>:
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404a64:	b510      	push	{r4, lr}
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404a66:	f8b1 3204 	ldrh.w	r3, [r1, #516]	; 0x204
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404a6a:	b082      	sub	sp, #8
	uint32_t val = 0;
  404a6c:	2200      	movs	r2, #0
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404a6e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404a72:	460c      	mov	r4, r1
	uint32_t val = 0;
  404a74:	9201      	str	r2, [sp, #4]
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404a76:	d028      	beq.n	404aca <uart_process_byte+0x66>
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404a78:	d30c      	bcc.n	404a94 <uart_process_byte+0x30>
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
	}
	if(memBuf->rx_fifo.i_last == FIFO_BUFFER_SIZE)
  404a7a:	f8b4 3202 	ldrh.w	r3, [r4, #514]	; 0x202
  404a7e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_last = 0;                            // roll over the index counter
  404a82:	bf04      	itt	eq
  404a84:	2300      	moveq	r3, #0
  404a86:	f8a4 3202 	strheq.w	r3, [r4, #514]	; 0x202
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
  404a8a:	2301      	movs	r3, #1
  404a8c:	f884 3207 	strb.w	r3, [r4, #519]	; 0x207
}
  404a90:	b002      	add	sp, #8
  404a92:	bd10      	pop	{r4, pc}
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
  404a94:	a901      	add	r1, sp, #4
  404a96:	4b14      	ldr	r3, [pc, #80]	; (404ae8 <uart_process_byte+0x84>)
  404a98:	4798      	blx	r3
  404a9a:	b140      	cbz	r0, 404aae <uart_process_byte+0x4a>
  404a9c:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
		//if(p_usart == UART1)
		//{
			//usart_putchar(UART0, val);
		//}
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404aa0:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
  404aa4:	bf04      	itt	eq
  404aa6:	2301      	moveq	r3, #1
  404aa8:	f884 3208 	strbeq.w	r3, [r4, #520]	; 0x208
  404aac:	e7e5      	b.n	404a7a <uart_process_byte+0x16>
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
  404aae:	f8b4 2202 	ldrh.w	r2, [r4, #514]	; 0x202
  404ab2:	9b01      	ldr	r3, [sp, #4]
  404ab4:	54a3      	strb	r3, [r4, r2]
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404ab6:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404aba:	3301      	adds	r3, #1
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404abc:	3201      	adds	r2, #1
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404abe:	b29b      	uxth	r3, r3
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404ac0:	f8a4 2202 	strh.w	r2, [r4, #514]	; 0x202
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404ac4:	f8a4 3204 	strh.w	r3, [r4, #516]	; 0x204
  404ac8:	e7ea      	b.n	404aa0 <uart_process_byte+0x3c>
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404aca:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
		usart_getchar(p_usart,&val);		
  404ace:	4a06      	ldr	r2, [pc, #24]	; (404ae8 <uart_process_byte+0x84>)
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404ad0:	3301      	adds	r3, #1
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404ad2:	2101      	movs	r1, #1
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404ad4:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404ad8:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
  404adc:	a901      	add	r1, sp, #4
  404ade:	4790      	blx	r2
  404ae0:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404ae4:	e7dc      	b.n	404aa0 <uart_process_byte+0x3c>
  404ae6:	bf00      	nop
  404ae8:	004020e5 	.word	0x004020e5

00404aec <uart_process_tx_byte>:
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404aec:	b570      	push	{r4, r5, r6, lr}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404aee:	f8b1 3414 	ldrh.w	r3, [r1, #1044]	; 0x414
  404af2:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404af6:	460c      	mov	r4, r1
  404af8:	4602      	mov	r2, r0
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404afa:	d00f      	beq.n	404b1c <uart_process_tx_byte+0x30>
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->tx_fifo.num_bytes > 0)
  404afc:	b98b      	cbnz	r3, 404b22 <uart_process_tx_byte+0x36>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{   // tx sw buffer is empty
		memBuf->uart_tx_fifo_not_empty_flag = 0;          // clear the tx flag
  404afe:	f881 3416 	strb.w	r3, [r1, #1046]	; 0x416
		uart_disable_interrupt(p_usart,UART_IER_TXEMPTY); //the buffer is empty, stop the interrupt. 
  404b02:	f44f 7100 	mov.w	r1, #512	; 0x200
  404b06:	4b23      	ldr	r3, [pc, #140]	; (404b94 <uart_process_tx_byte+0xa8>)
  404b08:	4798      	blx	r3
  404b0a:	f8b4 2410 	ldrh.w	r2, [r4, #1040]	; 0x410
	}
	if(memBuf->tx_fifo.i_first == FIFO_BUFFER_SIZE)
  404b0e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_first = 0;                      // roll over the index counter
  404b12:	bf04      	itt	eq
  404b14:	2300      	moveq	r3, #0
  404b16:	f8a4 3410 	strheq.w	r3, [r4, #1040]	; 0x410
  404b1a:	bd70      	pop	{r4, r5, r6, pc}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  404b1c:	2100      	movs	r1, #0
  404b1e:	f884 1417 	strb.w	r1, [r4, #1047]	; 0x417
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
  404b22:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  404b26:	481c      	ldr	r0, [pc, #112]	; (404b98 <uart_process_tx_byte+0xac>)
  404b28:	1865      	adds	r5, r4, r1
  404b2a:	4282      	cmp	r2, r0
  404b2c:	f895 5210 	ldrb.w	r5, [r5, #528]	; 0x210
  404b30:	d010      	beq.n	404b54 <uart_process_tx_byte+0x68>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  404b32:	481a      	ldr	r0, [pc, #104]	; (404b9c <uart_process_tx_byte+0xb0>)
  404b34:	4282      	cmp	r2, r0
  404b36:	d01f      	beq.n	404b78 <uart_process_tx_byte+0x8c>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  404b38:	4819      	ldr	r0, [pc, #100]	; (404ba0 <uart_process_tx_byte+0xb4>)
  404b3a:	4282      	cmp	r2, r0
  404b3c:	d023      	beq.n	404b86 <uart_process_tx_byte+0x9a>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  404b3e:	4819      	ldr	r0, [pc, #100]	; (404ba4 <uart_process_tx_byte+0xb8>)
  404b40:	4282      	cmp	r2, r0
  404b42:	d012      	beq.n	404b6a <uart_process_tx_byte+0x7e>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404b44:	1c4a      	adds	r2, r1, #1
  404b46:	b292      	uxth	r2, r2
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404b48:	3b01      	subs	r3, #1
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404b4a:	f8a4 2410 	strh.w	r2, [r4, #1040]	; 0x410
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404b4e:	f8a4 3414 	strh.w	r3, [r4, #1044]	; 0x414
  404b52:	e7dc      	b.n	404b0e <uart_process_tx_byte+0x22>
  404b54:	4e14      	ldr	r6, [pc, #80]	; (404ba8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404b56:	4810      	ldr	r0, [pc, #64]	; (404b98 <uart_process_tx_byte+0xac>)
  404b58:	4629      	mov	r1, r5
  404b5a:	47b0      	blx	r6
  404b5c:	2800      	cmp	r0, #0
  404b5e:	d1fa      	bne.n	404b56 <uart_process_tx_byte+0x6a>
  404b60:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
  404b64:	f8b4 3414 	ldrh.w	r3, [r4, #1044]	; 0x414
  404b68:	e7ec      	b.n	404b44 <uart_process_tx_byte+0x58>
  404b6a:	4e10      	ldr	r6, [pc, #64]	; (404bac <uart_process_tx_byte+0xc0>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404b6c:	480d      	ldr	r0, [pc, #52]	; (404ba4 <uart_process_tx_byte+0xb8>)
  404b6e:	4629      	mov	r1, r5
  404b70:	47b0      	blx	r6
  404b72:	2800      	cmp	r0, #0
  404b74:	d1fa      	bne.n	404b6c <uart_process_tx_byte+0x80>
  404b76:	e7f3      	b.n	404b60 <uart_process_tx_byte+0x74>
  404b78:	4e0b      	ldr	r6, [pc, #44]	; (404ba8 <uart_process_tx_byte+0xbc>)
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404b7a:	4808      	ldr	r0, [pc, #32]	; (404b9c <uart_process_tx_byte+0xb0>)
  404b7c:	4629      	mov	r1, r5
  404b7e:	47b0      	blx	r6
  404b80:	2800      	cmp	r0, #0
  404b82:	d1fa      	bne.n	404b7a <uart_process_tx_byte+0x8e>
  404b84:	e7ec      	b.n	404b60 <uart_process_tx_byte+0x74>
  404b86:	4e09      	ldr	r6, [pc, #36]	; (404bac <uart_process_tx_byte+0xc0>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404b88:	4805      	ldr	r0, [pc, #20]	; (404ba0 <uart_process_tx_byte+0xb4>)
  404b8a:	4629      	mov	r1, r5
  404b8c:	47b0      	blx	r6
  404b8e:	2800      	cmp	r0, #0
  404b90:	d1fa      	bne.n	404b88 <uart_process_tx_byte+0x9c>
  404b92:	e7e5      	b.n	404b60 <uart_process_tx_byte+0x74>
  404b94:	004020b1 	.word	0x004020b1
  404b98:	400e0600 	.word	0x400e0600
  404b9c:	400e0800 	.word	0x400e0800
  404ba0:	40024000 	.word	0x40024000
  404ba4:	40028000 	.word	0x40028000
  404ba8:	004020b9 	.word	0x004020b9
  404bac:	004020d1 	.word	0x004020d1

00404bb0 <drv_uart_putChar>:
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404bb0:	b538      	push	{r3, r4, r5, lr}
  404bb2:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404bb4:	4b1f      	ldr	r3, [pc, #124]	; (404c34 <drv_uart_putChar+0x84>)
  404bb6:	6800      	ldr	r0, [r0, #0]
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404bb8:	460d      	mov	r5, r1
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404bba:	f44f 7100 	mov.w	r1, #512	; 0x200
  404bbe:	4798      	blx	r3
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
  404bc0:	6962      	ldr	r2, [r4, #20]
  404bc2:	481d      	ldr	r0, [pc, #116]	; (404c38 <drv_uart_putChar+0x88>)
  404bc4:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  404bc8:	eb00 1342 	add.w	r3, r0, r2, lsl #5
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404bcc:	f8b3 2414 	ldrh.w	r2, [r3, #1044]	; 0x414
  404bd0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  404bd4:	d021      	beq.n	404c1a <drv_uart_putChar+0x6a>
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404bd6:	d20e      	bcs.n	404bf6 <drv_uart_putChar+0x46>
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404bd8:	f8b3 1412 	ldrh.w	r1, [r3, #1042]	; 0x412
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404bdc:	3201      	adds	r2, #1
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404bde:	1858      	adds	r0, r3, r1
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404be0:	b292      	uxth	r2, r2
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404be2:	3101      	adds	r1, #1
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404be4:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404be8:	f880 5210 	strb.w	r5, [r0, #528]	; 0x210
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404bec:	f8a3 2414 	strh.w	r2, [r3, #1044]	; 0x414
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404bf0:	f8a3 1412 	strh.w	r1, [r3, #1042]	; 0x412
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404bf4:	d019      	beq.n	404c2a <drv_uart_putChar+0x7a>
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
	}
	if(memBuf->tx_fifo.i_last == FIFO_BUFFER_SIZE)
  404bf6:	f8b3 2412 	ldrh.w	r2, [r3, #1042]	; 0x412
  404bfa:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_last = 0;                            // roll over the index counter
  404bfe:	bf04      	itt	eq
  404c00:	2200      	moveq	r2, #0
  404c02:	f8a3 2412 	strheq.w	r2, [r3, #1042]	; 0x412
	}
	memBuf->uart_tx_fifo_not_empty_flag = 1;                 // set tx-data ready flag	
  404c06:	2201      	movs	r2, #1
  404c08:	f883 2416 	strb.w	r2, [r3, #1046]	; 0x416
	//re-enable the interrupts
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);		
  404c0c:	6820      	ldr	r0, [r4, #0]
  404c0e:	4b0b      	ldr	r3, [pc, #44]	; (404c3c <drv_uart_putChar+0x8c>)
  404c10:	f44f 7100 	mov.w	r1, #512	; 0x200
  404c14:	4798      	blx	r3
	return status;	
}
  404c16:	2000      	movs	r0, #0
  404c18:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404c1a:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404c1e:	2101      	movs	r1, #1
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404c20:	440a      	add	r2, r1
  404c22:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404c26:	f883 1418 	strb.w	r1, [r3, #1048]	; 0x418
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
  404c2a:	2201      	movs	r2, #1
  404c2c:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
  404c30:	e7e1      	b.n	404bf6 <drv_uart_putChar+0x46>
  404c32:	bf00      	nop
  404c34:	004020cd 	.word	0x004020cd
  404c38:	20001330 	.word	0x20001330
  404c3c:	004020c9 	.word	0x004020c9

00404c40 <drv_uart_putData>:
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404c40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	for (i=0;i<length;)
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404c44:	4f09      	ldr	r7, [pc, #36]	; (404c6c <drv_uart_putData+0x2c>)
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404c46:	4606      	mov	r6, r0
  404c48:	4688      	mov	r8, r1
  404c4a:	4615      	mov	r5, r2
	int i=0;
	for (i=0;i<length;)
  404c4c:	2400      	movs	r4, #0
  404c4e:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404c50:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404c52:	d208      	bcs.n	404c66 <drv_uart_putData+0x26>
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404c54:	f818 1004 	ldrb.w	r1, [r8, r4]
  404c58:	47b8      	blx	r7
  404c5a:	2800      	cmp	r0, #0
  404c5c:	d1f7      	bne.n	404c4e <drv_uart_putData+0xe>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  404c5e:	3401      	adds	r4, #1
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404c60:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404c62:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404c64:	d3f6      	bcc.n	404c54 <drv_uart_putData+0x14>
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
		}
	}
}
  404c66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404c6a:	bf00      	nop
  404c6c:	00404bb1 	.word	0x00404bb1

00404c70 <UART0_Handler>:
	}
}

// interrupt handlers
void UART0_Handler()
{	
  404c70:	b510      	push	{r4, lr}
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404c72:	480c      	ldr	r0, [pc, #48]	; (404ca4 <UART0_Handler+0x34>)
  404c74:	4b0c      	ldr	r3, [pc, #48]	; (404ca8 <UART0_Handler+0x38>)
  404c76:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404c78:	07c2      	lsls	r2, r0, #31
{	
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404c7a:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404c7c:	d503      	bpl.n	404c86 <UART0_Handler+0x16>
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404c7e:	490b      	ldr	r1, [pc, #44]	; (404cac <UART0_Handler+0x3c>)
  404c80:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404c84:	b953      	cbnz	r3, 404c9c <UART0_Handler+0x2c>
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404c86:	05a3      	lsls	r3, r4, #22
  404c88:	d503      	bpl.n	404c92 <UART0_Handler+0x22>
	{
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404c8a:	4908      	ldr	r1, [pc, #32]	; (404cac <UART0_Handler+0x3c>)
  404c8c:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404c90:	b903      	cbnz	r3, 404c94 <UART0_Handler+0x24>
  404c92:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART0, &(uartMemBuf[0])); 	
  404c94:	4803      	ldr	r0, [pc, #12]	; (404ca4 <UART0_Handler+0x34>)
  404c96:	4b06      	ldr	r3, [pc, #24]	; (404cb0 <UART0_Handler+0x40>)
  404c98:	4798      	blx	r3
  404c9a:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
  404c9c:	4801      	ldr	r0, [pc, #4]	; (404ca4 <UART0_Handler+0x34>)
  404c9e:	4b05      	ldr	r3, [pc, #20]	; (404cb4 <UART0_Handler+0x44>)
  404ca0:	4798      	blx	r3
  404ca2:	e7f0      	b.n	404c86 <UART0_Handler+0x16>
  404ca4:	400e0600 	.word	0x400e0600
  404ca8:	004020b5 	.word	0x004020b5
  404cac:	20001330 	.word	0x20001330
  404cb0:	00404aed 	.word	0x00404aed
  404cb4:	00404a65 	.word	0x00404a65

00404cb8 <UART1_Handler>:
		}
	}	
}

void UART1_Handler()
{
  404cb8:	b510      	push	{r4, lr}
	uint32_t status = uart_get_status(UART1); 
  404cba:	480e      	ldr	r0, [pc, #56]	; (404cf4 <UART1_Handler+0x3c>)
  404cbc:	4b0e      	ldr	r3, [pc, #56]	; (404cf8 <UART1_Handler+0x40>)
  404cbe:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404cc0:	07c2      	lsls	r2, r0, #31
	}	
}

void UART1_Handler()
{
	uint32_t status = uart_get_status(UART1); 
  404cc2:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404cc4:	d503      	bpl.n	404cce <UART1_Handler+0x16>
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404cc6:	490d      	ldr	r1, [pc, #52]	; (404cfc <UART1_Handler+0x44>)
  404cc8:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  404ccc:	b963      	cbnz	r3, 404ce8 <UART1_Handler+0x30>
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404cce:	05a3      	lsls	r3, r4, #22
  404cd0:	d503      	bpl.n	404cda <UART1_Handler+0x22>
	{
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404cd2:	490a      	ldr	r1, [pc, #40]	; (404cfc <UART1_Handler+0x44>)
  404cd4:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  404cd8:	b903      	cbnz	r3, 404cdc <UART1_Handler+0x24>
  404cda:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART1, &(uartMemBuf[1])); 	
  404cdc:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  404ce0:	4804      	ldr	r0, [pc, #16]	; (404cf4 <UART1_Handler+0x3c>)
  404ce2:	4b07      	ldr	r3, [pc, #28]	; (404d00 <UART1_Handler+0x48>)
  404ce4:	4798      	blx	r3
  404ce6:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
  404ce8:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  404cec:	4801      	ldr	r0, [pc, #4]	; (404cf4 <UART1_Handler+0x3c>)
  404cee:	4b05      	ldr	r3, [pc, #20]	; (404d04 <UART1_Handler+0x4c>)
  404cf0:	4798      	blx	r3
  404cf2:	e7ec      	b.n	404cce <UART1_Handler+0x16>
  404cf4:	400e0800 	.word	0x400e0800
  404cf8:	004020b5 	.word	0x004020b5
  404cfc:	20001330 	.word	0x20001330
  404d00:	00404aed 	.word	0x00404aed
  404d04:	00404a65 	.word	0x00404a65

00404d08 <USART0_Handler>:
		}
	}
}

void USART0_Handler()
{
  404d08:	b510      	push	{r4, lr}
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  404d0a:	480e      	ldr	r0, [pc, #56]	; (404d44 <USART0_Handler+0x3c>)
  404d0c:	4b0e      	ldr	r3, [pc, #56]	; (404d48 <USART0_Handler+0x40>)
  404d0e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404d10:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  404d12:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404d14:	d503      	bpl.n	404d1e <USART0_Handler+0x16>
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  404d16:	490d      	ldr	r1, [pc, #52]	; (404d4c <USART0_Handler+0x44>)
  404d18:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  404d1c:	b963      	cbnz	r3, 404d38 <USART0_Handler+0x30>
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404d1e:	05a3      	lsls	r3, r4, #22
  404d20:	d503      	bpl.n	404d2a <USART0_Handler+0x22>
	{
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  404d22:	490a      	ldr	r1, [pc, #40]	; (404d4c <USART0_Handler+0x44>)
  404d24:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  404d28:	b903      	cbnz	r3, 404d2c <USART0_Handler+0x24>
  404d2a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART0, &(uartMemBuf[2])); 	
  404d2c:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  404d30:	4804      	ldr	r0, [pc, #16]	; (404d44 <USART0_Handler+0x3c>)
  404d32:	4b07      	ldr	r3, [pc, #28]	; (404d50 <USART0_Handler+0x48>)
  404d34:	4798      	blx	r3
  404d36:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
  404d38:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  404d3c:	4801      	ldr	r0, [pc, #4]	; (404d44 <USART0_Handler+0x3c>)
  404d3e:	4b05      	ldr	r3, [pc, #20]	; (404d54 <USART0_Handler+0x4c>)
  404d40:	4798      	blx	r3
  404d42:	e7ec      	b.n	404d1e <USART0_Handler+0x16>
  404d44:	40024000 	.word	0x40024000
  404d48:	004020b5 	.word	0x004020b5
  404d4c:	20001330 	.word	0x20001330
  404d50:	00404aed 	.word	0x00404aed
  404d54:	00404a65 	.word	0x00404a65

00404d58 <USART1_Handler>:
		}
	}	
}

void USART1_Handler()
{
  404d58:	b510      	push	{r4, lr}
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  404d5a:	480e      	ldr	r0, [pc, #56]	; (404d94 <USART1_Handler+0x3c>)
  404d5c:	4b0e      	ldr	r3, [pc, #56]	; (404d98 <USART1_Handler+0x40>)
  404d5e:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404d60:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  404d62:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404d64:	d503      	bpl.n	404d6e <USART1_Handler+0x16>
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  404d66:	490d      	ldr	r1, [pc, #52]	; (404d9c <USART1_Handler+0x44>)
  404d68:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  404d6c:	b963      	cbnz	r3, 404d88 <USART1_Handler+0x30>
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404d6e:	05a3      	lsls	r3, r4, #22
  404d70:	d503      	bpl.n	404d7a <USART1_Handler+0x22>
	{
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  404d72:	490a      	ldr	r1, [pc, #40]	; (404d9c <USART1_Handler+0x44>)
  404d74:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  404d78:	b903      	cbnz	r3, 404d7c <USART1_Handler+0x24>
  404d7a:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART1, &(uartMemBuf[3])); 	
  404d7c:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  404d80:	4804      	ldr	r0, [pc, #16]	; (404d94 <USART1_Handler+0x3c>)
  404d82:	4b07      	ldr	r3, [pc, #28]	; (404da0 <USART1_Handler+0x48>)
  404d84:	4798      	blx	r3
  404d86:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
  404d88:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  404d8c:	4801      	ldr	r0, [pc, #4]	; (404d94 <USART1_Handler+0x3c>)
  404d8e:	4b05      	ldr	r3, [pc, #20]	; (404da4 <USART1_Handler+0x4c>)
  404d90:	4798      	blx	r3
  404d92:	e7ec      	b.n	404d6e <USART1_Handler+0x16>
  404d94:	40028000 	.word	0x40028000
  404d98:	004020b5 	.word	0x004020b5
  404d9c:	20001330 	.word	0x20001330
  404da0:	00404aed 	.word	0x00404aed
  404da4:	00404a65 	.word	0x00404a65

00404da8 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  404da8:	b538      	push	{r3, r4, r5, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  404daa:	480e      	ldr	r0, [pc, #56]	; (404de4 <sysclk_init+0x3c>)
  404dac:	4d0e      	ldr	r5, [pc, #56]	; (404de8 <sysclk_init+0x40>)
  404dae:	4c0f      	ldr	r4, [pc, #60]	; (404dec <sysclk_init+0x44>)
  404db0:	47a8      	blx	r5
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  404db2:	2000      	movs	r0, #0
  404db4:	213e      	movs	r1, #62	; 0x3e
  404db6:	4b0e      	ldr	r3, [pc, #56]	; (404df0 <sysclk_init+0x48>)
  404db8:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  404dba:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  404dbc:	2800      	cmp	r0, #0
  404dbe:	d0fc      	beq.n	404dba <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  404dc0:	4b0c      	ldr	r3, [pc, #48]	; (404df4 <sysclk_init+0x4c>)
  404dc2:	4c0d      	ldr	r4, [pc, #52]	; (404df8 <sysclk_init+0x50>)
  404dc4:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  404dc6:	4b0d      	ldr	r3, [pc, #52]	; (404dfc <sysclk_init+0x54>)
  404dc8:	4a0d      	ldr	r2, [pc, #52]	; (404e00 <sysclk_init+0x58>)
  404dca:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  404dcc:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  404dce:	2800      	cmp	r0, #0
  404dd0:	d0fc      	beq.n	404dcc <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  404dd2:	4b0c      	ldr	r3, [pc, #48]	; (404e04 <sysclk_init+0x5c>)
  404dd4:	2010      	movs	r0, #16
  404dd6:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  404dd8:	4b0b      	ldr	r3, [pc, #44]	; (404e08 <sysclk_init+0x60>)
  404dda:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  404ddc:	4801      	ldr	r0, [pc, #4]	; (404de4 <sysclk_init+0x3c>)
  404dde:	47a8      	blx	r5
  404de0:	bd38      	pop	{r3, r4, r5, pc}
  404de2:	bf00      	nop
  404de4:	07270e00 	.word	0x07270e00
  404de8:	004054f1 	.word	0x004054f1
  404dec:	004052ed 	.word	0x004052ed
  404df0:	00405299 	.word	0x00405299
  404df4:	004052fd 	.word	0x004052fd
  404df8:	0040530d 	.word	0x0040530d
  404dfc:	400e0400 	.word	0x400e0400
  404e00:	200e3f01 	.word	0x200e3f01
  404e04:	00405241 	.word	0x00405241
  404e08:	00405409 	.word	0x00405409

00404e0c <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  404e0c:	b538      	push	{r3, r4, r5, lr}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  404e0e:	200b      	movs	r0, #11
  404e10:	4d13      	ldr	r5, [pc, #76]	; (404e60 <board_init+0x54>)
// 	ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
// 	ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
	
	
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  404e12:	4c14      	ldr	r4, [pc, #80]	; (404e64 <board_init+0x58>)
  404e14:	47a8      	blx	r5
  404e16:	200c      	movs	r0, #12
  404e18:	47a8      	blx	r5
  404e1a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e1e:	201c      	movs	r0, #28
  404e20:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  404e22:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e26:	201d      	movs	r0, #29
  404e28:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  404e2a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e2e:	201e      	movs	r0, #30
  404e30:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  404e32:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e36:	201f      	movs	r0, #31
  404e38:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  404e3a:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e3e:	201a      	movs	r0, #26
  404e40:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  404e42:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  404e46:	201b      	movs	r0, #27
  404e48:	47a0      	blx	r4

	/* Configure SD/MMC card detect pin */
	gpio_configure_pin(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  404e4a:	4907      	ldr	r1, [pc, #28]	; (404e68 <board_init+0x5c>)
  404e4c:	202b      	movs	r0, #43	; 0x2b
  404e4e:	47a0      	blx	r4

//#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART1_PIO, PINS_UART1, PINS_UART1_FLAGS);
  404e50:	4b06      	ldr	r3, [pc, #24]	; (404e6c <board_init+0x60>)
  404e52:	4807      	ldr	r0, [pc, #28]	; (404e70 <board_init+0x64>)
  404e54:	210c      	movs	r1, #12
  404e56:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  404e5a:	4798      	blx	r3
  404e5c:	bd38      	pop	{r3, r4, r5, pc}
  404e5e:	bf00      	nop
  404e60:	0040531d 	.word	0x0040531d
  404e64:	00404fe9 	.word	0x00404fe9
  404e68:	28000001 	.word	0x28000001
  404e6c:	004050a1 	.word	0x004050a1
  404e70:	400e1000 	.word	0x400e1000

00404e74 <pio_set_debounce_filter>:
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  404e74:	0052      	lsls	r2, r2, #1
  404e76:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  404e7a:	fbb3 f2f2 	udiv	r2, r3, r2
  404e7e:	3a01      	subs	r2, #1
  404e80:	f3c2 020d 	ubfx	r2, r2, #0, #14
void pio_set_debounce_filter(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_cut_off)
{
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Set Debouncing, 0 bit field no effect */
	p_pio->PIO_IFSCER = ul_mask;
  404e84:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  404e88:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
  404e8c:	4770      	bx	lr
  404e8e:	bf00      	nop

00404e90 <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404e90:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  404e94:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  404e96:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404e98:	d030      	beq.n	404efc <pio_set_peripheral+0x6c>
  404e9a:	d812      	bhi.n	404ec2 <pio_set_peripheral+0x32>
  404e9c:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  404ea0:	d020      	beq.n	404ee4 <pio_set_peripheral+0x54>
  404ea2:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  404ea6:	d11a      	bne.n	404ede <pio_set_peripheral+0x4e>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404ea8:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  404eaa:	4313      	orrs	r3, r2
  404eac:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  404eae:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  404eb0:	6f41      	ldr	r1, [r0, #116]	; 0x74
  404eb2:	400b      	ands	r3, r1
  404eb4:	ea23 0302 	bic.w	r3, r3, r2
  404eb8:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  404eba:	6042      	str	r2, [r0, #4]
}
  404ebc:	f85d 4b04 	ldr.w	r4, [sp], #4
  404ec0:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404ec2:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  404ec6:	d0f9      	beq.n	404ebc <pio_set_peripheral+0x2c>
  404ec8:	d822      	bhi.n	404f10 <pio_set_peripheral+0x80>
  404eca:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  404ece:	d1f4      	bne.n	404eba <pio_set_peripheral+0x2a>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
		break;
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404ed0:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  404ed2:	4313      	orrs	r3, r2
  404ed4:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  404ed6:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  404ed8:	4313      	orrs	r3, r2
  404eda:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  404edc:	e7ed      	b.n	404eba <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404ede:	2900      	cmp	r1, #0
  404ee0:	d1eb      	bne.n	404eba <pio_set_peripheral+0x2a>
  404ee2:	e7eb      	b.n	404ebc <pio_set_peripheral+0x2c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404ee4:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  404ee6:	6f04      	ldr	r4, [r0, #112]	; 0x70
  404ee8:	43d3      	mvns	r3, r2
  404eea:	4021      	ands	r1, r4
  404eec:	4019      	ands	r1, r3
  404eee:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  404ef0:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  404ef2:	6f44      	ldr	r4, [r0, #116]	; 0x74
  404ef4:	4021      	ands	r1, r4
  404ef6:	400b      	ands	r3, r1
  404ef8:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  404efa:	e7de      	b.n	404eba <pio_set_peripheral+0x2a>
		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  404efc:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  404efe:	6f01      	ldr	r1, [r0, #112]	; 0x70
  404f00:	400b      	ands	r3, r1
  404f02:	ea23 0302 	bic.w	r3, r3, r2
  404f06:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  404f08:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  404f0a:	4313      	orrs	r3, r2
  404f0c:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  404f0e:	e7d4      	b.n	404eba <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  404f10:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  404f14:	d0d2      	beq.n	404ebc <pio_set_peripheral+0x2c>
  404f16:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  404f1a:	d0cf      	beq.n	404ebc <pio_set_peripheral+0x2c>
  404f1c:	e7cd      	b.n	404eba <pio_set_peripheral+0x2a>
  404f1e:	bf00      	nop

00404f20 <pio_set_input>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  404f20:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  404f22:	6441      	str	r1, [r0, #68]	; 0x44
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  404f24:	bf4c      	ite	mi
  404f26:	6641      	strmi	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  404f28:	6601      	strpl	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  404f2a:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  404f2e:	bf14      	ite	ne
  404f30:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  404f32:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  404f34:	0793      	lsls	r3, r2, #30
  404f36:	d406      	bmi.n	404f46 <pio_set_input+0x26>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  404f38:	0713      	lsls	r3, r2, #28
			p_pio->PIO_IFSCER = ul_mask;
  404f3a:	bf48      	it	mi
  404f3c:	f8c0 1084 	strmi.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  404f40:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  404f42:	6001      	str	r1, [r0, #0]
  404f44:	4770      	bx	lr
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
		p_pio->PIO_IFSCDR = ul_mask;
  404f46:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  404f4a:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  404f4c:	6001      	str	r1, [r0, #0]
  404f4e:	4770      	bx	lr

00404f50 <pio_configure_interrupt>:
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  404f50:	06d3      	lsls	r3, r2, #27
  404f52:	d50e      	bpl.n	404f72 <pio_configure_interrupt+0x22>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  404f54:	0693      	lsls	r3, r2, #26
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  404f56:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  404f5a:	bf4c      	ite	mi
  404f5c:	f8c0 10d4 	strmi.w	r1, [r0, #212]	; 0xd4
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  404f60:	f8c0 10d0 	strpl.w	r1, [r0, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  404f64:	0653      	lsls	r3, r2, #25
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  404f66:	bf4c      	ite	mi
  404f68:	f8c0 10c0 	strmi.w	r1, [r0, #192]	; 0xc0
		} else {
			/* Level select */
			p_pio->PIO_LSR = ul_mask;
  404f6c:	f8c0 10c4 	strpl.w	r1, [r0, #196]	; 0xc4
  404f70:	4770      	bx	lr
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
  404f72:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  404f76:	4770      	bx	lr

00404f78 <pio_enable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_ISR;
  404f78:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  404f7a:	6401      	str	r1, [r0, #64]	; 0x40
  404f7c:	4770      	bx	lr
  404f7e:	bf00      	nop

00404f80 <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  404f80:	6441      	str	r1, [r0, #68]	; 0x44
  404f82:	4770      	bx	lr

00404f84 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  404f84:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  404f86:	4770      	bx	lr

00404f88 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  404f88:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  404f8a:	4770      	bx	lr

00404f8c <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404f8c:	0943      	lsrs	r3, r0, #5
  404f8e:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404f92:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404f96:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  404f98:	f000 001f 	and.w	r0, r0, #31
  404f9c:	2201      	movs	r2, #1
  404f9e:	fa02 f000 	lsl.w	r0, r2, r0
  404fa2:	6318      	str	r0, [r3, #48]	; 0x30
  404fa4:	4770      	bx	lr
  404fa6:	bf00      	nop

00404fa8 <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404fa8:	0943      	lsrs	r3, r0, #5
  404faa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404fae:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404fb2:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  404fb4:	f000 001f 	and.w	r0, r0, #31
  404fb8:	2201      	movs	r2, #1
  404fba:	fa02 f000 	lsl.w	r0, r2, r0
  404fbe:	6358      	str	r0, [r3, #52]	; 0x34
  404fc0:	4770      	bx	lr
  404fc2:	bf00      	nop

00404fc4 <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404fc4:	0943      	lsrs	r3, r0, #5
  404fc6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404fca:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404fce:	025b      	lsls	r3, r3, #9
 */
void pio_toggle_pin(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  404fd0:	f000 001f 	and.w	r0, r0, #31
  404fd4:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  404fd6:	2101      	movs	r1, #1
  404fd8:	fa01 f000 	lsl.w	r0, r1, r0
  404fdc:	4210      	tst	r0, r2
		/* Value to be driven on the I/O line: 0. */
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  404fde:	bf14      	ite	ne
  404fe0:	6358      	strne	r0, [r3, #52]	; 0x34
	} else {
		/* Value to be driven on the I/O line: 1. */
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  404fe2:	6318      	streq	r0, [r3, #48]	; 0x30
  404fe4:	4770      	bx	lr
  404fe6:	bf00      	nop

00404fe8 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  404fe8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404fea:	0944      	lsrs	r4, r0, #5
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  404fec:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404fee:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  404ff2:	f001 41f0 	and.w	r1, r1, #2013265920	; 0x78000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404ff6:	f204 7407 	addw	r4, r4, #1799	; 0x707
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  404ffa:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  404ffe:	ea4f 2444 	mov.w	r4, r4, lsl #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  405002:	d00b      	beq.n	40501c <pio_configure_pin+0x34>
  405004:	d819      	bhi.n	40503a <pio_configure_pin+0x52>
  405006:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  40500a:	d007      	beq.n	40501c <pio_configure_pin+0x34>
  40500c:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  405010:	d004      	beq.n	40501c <pio_configure_pin+0x34>
  405012:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  405016:	d001      	beq.n	40501c <pio_configure_pin+0x34>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  405018:	2000      	movs	r0, #0
	}

	return 1;
}
  40501a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  40501c:	2601      	movs	r6, #1
  40501e:	f000 001f 	and.w	r0, r0, #31
  405022:	fa06 f700 	lsl.w	r7, r6, r0
  405026:	463a      	mov	r2, r7
  405028:	4620      	mov	r0, r4
  40502a:	4b1b      	ldr	r3, [pc, #108]	; (405098 <pio_configure_pin+0xb0>)
  40502c:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40502e:	07ed      	lsls	r5, r5, #31
		p_pio->PIO_PUER = ul_mask;
  405030:	bf4c      	ite	mi
  405032:	6667      	strmi	r7, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405034:	6627      	strpl	r7, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  405036:	4630      	mov	r0, r6
  405038:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40503a:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40503e:	d010      	beq.n	405062 <pio_configure_pin+0x7a>
  405040:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  405044:	d00d      	beq.n	405062 <pio_configure_pin+0x7a>
  405046:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  40504a:	d1e5      	bne.n	405018 <pio_configure_pin+0x30>
				(ul_flags & PIO_PULLUP));
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  40504c:	2601      	movs	r6, #1
  40504e:	f000 011f 	and.w	r1, r0, #31
  405052:	462a      	mov	r2, r5
  405054:	4620      	mov	r0, r4
  405056:	fa06 f101 	lsl.w	r1, r6, r1
  40505a:	4b10      	ldr	r3, [pc, #64]	; (40509c <pio_configure_pin+0xb4>)
  40505c:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40505e:	4630      	mov	r0, r6
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  405060:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  405062:	f000 001f 	and.w	r0, r0, #31
  405066:	2301      	movs	r3, #1
  405068:	4083      	lsls	r3, r0
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  40506a:	f005 0104 	and.w	r1, r5, #4
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40506e:	07e8      	lsls	r0, r5, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  405070:	6463      	str	r3, [r4, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  405072:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405076:	bf4c      	ite	mi
  405078:	6663      	strmi	r3, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  40507a:	6623      	strpl	r3, [r4, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40507c:	b149      	cbz	r1, 405092 <pio_configure_pin+0xaa>
		p_pio->PIO_MDER = ul_mask;
  40507e:	6523      	str	r3, [r4, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  405080:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  405084:	bf0c      	ite	eq
  405086:	6323      	streq	r3, [r4, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  405088:	6363      	strne	r3, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  40508a:	6123      	str	r3, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  40508c:	6023      	str	r3, [r4, #0]

	default:
		return 0;
	}

	return 1;
  40508e:	2001      	movs	r0, #1
  405090:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  405092:	6563      	str	r3, [r4, #84]	; 0x54
  405094:	e7f4      	b.n	405080 <pio_configure_pin+0x98>
  405096:	bf00      	nop
  405098:	00404e91 	.word	0x00404e91
  40509c:	00404f21 	.word	0x00404f21

004050a0 <pio_configure_pin_group>:
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4050a0:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
  4050a4:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  4050a8:	b570      	push	{r4, r5, r6, lr}
  4050aa:	4614      	mov	r4, r2
  4050ac:	4606      	mov	r6, r0
  4050ae:	460d      	mov	r5, r1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4050b0:	d00b      	beq.n	4050ca <pio_configure_pin_group+0x2a>
  4050b2:	d814      	bhi.n	4050de <pio_configure_pin_group+0x3e>
  4050b4:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4050b8:	d007      	beq.n	4050ca <pio_configure_pin_group+0x2a>
  4050ba:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4050be:	d004      	beq.n	4050ca <pio_configure_pin_group+0x2a>
  4050c0:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4050c4:	d001      	beq.n	4050ca <pio_configure_pin_group+0x2a>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  4050c6:	2000      	movs	r0, #0
	}

	return 1;
}
  4050c8:	bd70      	pop	{r4, r5, r6, pc}
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  4050ca:	4619      	mov	r1, r3
  4050cc:	462a      	mov	r2, r5
  4050ce:	4b15      	ldr	r3, [pc, #84]	; (405124 <pio_configure_pin_group+0x84>)
  4050d0:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4050d2:	07e0      	lsls	r0, r4, #31
		p_pio->PIO_PUER = ul_mask;
  4050d4:	bf4c      	ite	mi
  4050d6:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4050d8:	6635      	strpl	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  4050da:	2001      	movs	r0, #1
  4050dc:	bd70      	pop	{r4, r5, r6, pc}
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4050de:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  4050e2:	d009      	beq.n	4050f8 <pio_configure_pin_group+0x58>
  4050e4:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  4050e8:	d006      	beq.n	4050f8 <pio_configure_pin_group+0x58>
  4050ea:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  4050ee:	d1ea      	bne.n	4050c6 <pio_configure_pin_group+0x26>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  4050f0:	4b0d      	ldr	r3, [pc, #52]	; (405128 <pio_configure_pin_group+0x88>)
  4050f2:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  4050f4:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  4050f6:	bd70      	pop	{r4, r5, r6, pc}
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4050f8:	07e1      	lsls	r1, r4, #31
	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  4050fa:	f004 0204 	and.w	r2, r4, #4
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4050fe:	6475      	str	r5, [r6, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  405100:	f004 5360 	and.w	r3, r4, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405104:	bf4c      	ite	mi
  405106:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405108:	6635      	strpl	r5, [r6, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  40510a:	b14a      	cbz	r2, 405120 <pio_configure_pin_group+0x80>
		p_pio->PIO_MDER = ul_mask;
  40510c:	6535      	str	r5, [r6, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  40510e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  405112:	bf0c      	ite	eq
  405114:	6335      	streq	r5, [r6, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  405116:	6375      	strne	r5, [r6, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  405118:	6135      	str	r5, [r6, #16]
	p_pio->PIO_PER = ul_mask;
  40511a:	6035      	str	r5, [r6, #0]

	default:
		return 0;
	}

	return 1;
  40511c:	2001      	movs	r0, #1
  40511e:	bd70      	pop	{r4, r5, r6, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  405120:	6575      	str	r5, [r6, #84]	; 0x54
  405122:	e7f4      	b.n	40510e <pio_configure_pin_group+0x6e>
  405124:	00404e91 	.word	0x00404e91
  405128:	00404f21 	.word	0x00404f21

0040512c <pio_get_pin_group>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40512c:	0940      	lsrs	r0, r0, #5
  40512e:	f500 1000 	add.w	r0, r0, #2097152	; 0x200000
  405132:	f200 7007 	addw	r0, r0, #1799	; 0x707
#endif
	return p_pio;
}
  405136:	0240      	lsls	r0, r0, #9
  405138:	4770      	bx	lr
  40513a:	bf00      	nop

0040513c <pio_get_pin_group_id>:
		ul_id = ID_PIOC;
	} else {
		ul_id = ID_PIOA + (ul_pin >> 5);
	}
#else
	ul_id = ID_PIOA + (ul_pin >> 5);
  40513c:	0940      	lsrs	r0, r0, #5
#endif
	return ul_id;
}
  40513e:	300b      	adds	r0, #11
  405140:	4770      	bx	lr
  405142:	bf00      	nop

00405144 <pio_get_pin_group_mask>:
 *
 * \return GPIO port pin mask.
 */
uint32_t pio_get_pin_group_mask(uint32_t ul_pin)
{
	uint32_t ul_mask = 1 << (ul_pin & 0x1F);
  405144:	2301      	movs	r3, #1
  405146:	f000 001f 	and.w	r0, r0, #31
	return ul_mask;
}
  40514a:	fa03 f000 	lsl.w	r0, r3, r0
  40514e:	4770      	bx	lr

00405150 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405150:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  405154:	4b17      	ldr	r3, [pc, #92]	; (4051b4 <pio_handler_process+0x64>)
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405156:	4680      	mov	r8, r0
  405158:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40515a:	4798      	blx	r3
	status &= pio_get_interrupt_mask(p_pio);
  40515c:	4b16      	ldr	r3, [pc, #88]	; (4051b8 <pio_handler_process+0x68>)
{
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40515e:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  405160:	4640      	mov	r0, r8
  405162:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  405164:	4005      	ands	r5, r0
  405166:	d018      	beq.n	40519a <pio_handler_process+0x4a>
  405168:	4c14      	ldr	r4, [pc, #80]	; (4051bc <pio_handler_process+0x6c>)
  40516a:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
  40516e:	e003      	b.n	405178 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405170:	42bc      	cmp	r4, r7
  405172:	d012      	beq.n	40519a <pio_handler_process+0x4a>
  405174:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  405176:	b185      	cbz	r5, 40519a <pio_handler_process+0x4a>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  405178:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  40517c:	42b3      	cmp	r3, r6
  40517e:	d1f7      	bne.n	405170 <pio_handler_process+0x20>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  405180:	f854 1c08 	ldr.w	r1, [r4, #-8]
  405184:	4229      	tst	r1, r5
  405186:	d0f3      	beq.n	405170 <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  405188:	6823      	ldr	r3, [r4, #0]
  40518a:	4630      	mov	r0, r6
  40518c:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  40518e:	f854 3c08 	ldr.w	r3, [r4, #-8]
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405192:	42bc      	cmp	r4, r7
			if (gs_interrupt_sources[i].id == ul_id) {
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  405194:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  405198:	d1ec      	bne.n	405174 <pio_handler_process+0x24>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  40519a:	4b09      	ldr	r3, [pc, #36]	; (4051c0 <pio_handler_process+0x70>)
  40519c:	681b      	ldr	r3, [r3, #0]
  40519e:	b133      	cbz	r3, 4051ae <pio_handler_process+0x5e>
		if (pio_capture_handler) {
  4051a0:	4b08      	ldr	r3, [pc, #32]	; (4051c4 <pio_handler_process+0x74>)
  4051a2:	681b      	ldr	r3, [r3, #0]
  4051a4:	b10b      	cbz	r3, 4051aa <pio_handler_process+0x5a>
			pio_capture_handler(p_pio);
  4051a6:	4640      	mov	r0, r8
  4051a8:	4798      	blx	r3
  4051aa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4051ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4051b2:	bf00      	nop
  4051b4:	00404f85 	.word	0x00404f85
  4051b8:	00404f89 	.word	0x00404f89
  4051bc:	20001010 	.word	0x20001010
  4051c0:	200023b0 	.word	0x200023b0
  4051c4:	20001000 	.word	0x20001000

004051c8 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4051c8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4051cc:	4d0f      	ldr	r5, [pc, #60]	; (40520c <pio_handler_set+0x44>)
  4051ce:	682c      	ldr	r4, [r5, #0]
  4051d0:	2c0b      	cmp	r4, #11
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4051d2:	468c      	mov	ip, r1
  4051d4:	4616      	mov	r6, r2
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4051d6:	d902      	bls.n	4051de <pio_handler_set+0x16>
		return 1;
  4051d8:	2001      	movs	r0, #1

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);

	return 0;
}
  4051da:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4051de:	f8df 8030 	ldr.w	r8, [pc, #48]	; 405210 <pio_handler_set+0x48>
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4051e2:	f8df 9030 	ldr.w	r9, [pc, #48]	; 405214 <pio_handler_set+0x4c>

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  4051e6:	ea4f 1e04 	mov.w	lr, r4, lsl #4
  4051ea:	eb08 070e 	add.w	r7, r8, lr
	pSource->id = ul_id;
  4051ee:	f848 c00e 	str.w	ip, [r8, lr]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4051f2:	4611      	mov	r1, r2

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
  4051f4:	60bb      	str	r3, [r7, #8]
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  4051f6:	461a      	mov	r2, r3
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4051f8:	9b08      	ldr	r3, [sp, #32]
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
  4051fa:	607e      	str	r6, [r7, #4]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;
  4051fc:	3401      	adds	r4, #1
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  4051fe:	60fb      	str	r3, [r7, #12]
	gs_ul_nb_sources++;
  405200:	602c      	str	r4, [r5, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  405202:	47c8      	blx	r9

	return 0;
  405204:	2000      	movs	r0, #0
  405206:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  40520a:	bf00      	nop
  40520c:	20000ffc 	.word	0x20000ffc
  405210:	20001004 	.word	0x20001004
  405214:	00404f51 	.word	0x00404f51

00405218 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  405218:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  40521a:	4802      	ldr	r0, [pc, #8]	; (405224 <PIOA_Handler+0xc>)
  40521c:	4b02      	ldr	r3, [pc, #8]	; (405228 <PIOA_Handler+0x10>)
  40521e:	210b      	movs	r1, #11
  405220:	4798      	blx	r3
  405222:	bd08      	pop	{r3, pc}
  405224:	400e0e00 	.word	0x400e0e00
  405228:	00405151 	.word	0x00405151

0040522c <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  40522c:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40522e:	4802      	ldr	r0, [pc, #8]	; (405238 <PIOB_Handler+0xc>)
  405230:	4b02      	ldr	r3, [pc, #8]	; (40523c <PIOB_Handler+0x10>)
  405232:	210c      	movs	r1, #12
  405234:	4798      	blx	r3
  405236:	bd08      	pop	{r3, pc}
  405238:	400e1000 	.word	0x400e1000
  40523c:	00405151 	.word	0x00405151

00405240 <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  405240:	4914      	ldr	r1, [pc, #80]	; (405294 <pmc_switch_mck_to_pllack+0x54>)
  405242:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405244:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  405248:	4318      	orrs	r0, r3
  40524a:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40524c:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  40524e:	071b      	lsls	r3, r3, #28
  405250:	d407      	bmi.n	405262 <pmc_switch_mck_to_pllack+0x22>
  405252:	f44f 6300 	mov.w	r3, #2048	; 0x800
  405256:	e001      	b.n	40525c <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  405258:	3b01      	subs	r3, #1
  40525a:	d016      	beq.n	40528a <pmc_switch_mck_to_pllack+0x4a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40525c:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40525e:	0710      	lsls	r0, r2, #28
  405260:	d5fa      	bpl.n	405258 <pmc_switch_mck_to_pllack+0x18>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  405262:	490c      	ldr	r1, [pc, #48]	; (405294 <pmc_switch_mck_to_pllack+0x54>)
  405264:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405266:	f023 0303 	bic.w	r3, r3, #3
  40526a:	f043 0302 	orr.w	r3, r3, #2
  40526e:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405270:	6e88      	ldr	r0, [r1, #104]	; 0x68
  405272:	f010 0008 	ands.w	r0, r0, #8
  405276:	d10a      	bne.n	40528e <pmc_switch_mck_to_pllack+0x4e>
  405278:	f44f 6300 	mov.w	r3, #2048	; 0x800
  40527c:	e001      	b.n	405282 <pmc_switch_mck_to_pllack+0x42>
			--ul_timeout) {
		if (ul_timeout == 0) {
  40527e:	3b01      	subs	r3, #1
  405280:	d003      	beq.n	40528a <pmc_switch_mck_to_pllack+0x4a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405282:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  405284:	0712      	lsls	r2, r2, #28
  405286:	d5fa      	bpl.n	40527e <pmc_switch_mck_to_pllack+0x3e>
  405288:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  40528a:	2001      	movs	r0, #1
  40528c:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  40528e:	2000      	movs	r0, #0
}
  405290:	4770      	bx	lr
  405292:	bf00      	nop
  405294:	400e0400 	.word	0x400e0400

00405298 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  405298:	b9c8      	cbnz	r0, 4052ce <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  40529a:	4b11      	ldr	r3, [pc, #68]	; (4052e0 <pmc_switch_mainck_to_xtal+0x48>)
  40529c:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  40529e:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  4052a2:	f022 0203 	bic.w	r2, r2, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4052a6:	0209      	lsls	r1, r1, #8
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4052a8:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4052ac:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4052ae:	f042 0201 	orr.w	r2, r2, #1
  4052b2:	430a      	orrs	r2, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4052b4:	621a      	str	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4052b6:	4619      	mov	r1, r3
  4052b8:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  4052ba:	4a09      	ldr	r2, [pc, #36]	; (4052e0 <pmc_switch_mainck_to_xtal+0x48>)
  4052bc:	07db      	lsls	r3, r3, #31
  4052be:	d5fb      	bpl.n	4052b8 <pmc_switch_mainck_to_xtal+0x20>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4052c0:	6a13      	ldr	r3, [r2, #32]
  4052c2:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4052c6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4052ca:	6213      	str	r3, [r2, #32]
  4052cc:	4770      	bx	lr
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4052ce:	4904      	ldr	r1, [pc, #16]	; (4052e0 <pmc_switch_mainck_to_xtal+0x48>)
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4052d0:	4a04      	ldr	r2, [pc, #16]	; (4052e4 <pmc_switch_mainck_to_xtal+0x4c>)
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4052d2:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4052d4:	4b04      	ldr	r3, [pc, #16]	; (4052e8 <pmc_switch_mainck_to_xtal+0x50>)
  4052d6:	4002      	ands	r2, r0
  4052d8:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4052da:	620b      	str	r3, [r1, #32]
  4052dc:	4770      	bx	lr
  4052de:	bf00      	nop
  4052e0:	400e0400 	.word	0x400e0400
  4052e4:	fec8fffc 	.word	0xfec8fffc
  4052e8:	01370002 	.word	0x01370002

004052ec <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  4052ec:	4b02      	ldr	r3, [pc, #8]	; (4052f8 <pmc_osc_is_ready_mainck+0xc>)
  4052ee:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  4052f0:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  4052f4:	4770      	bx	lr
  4052f6:	bf00      	nop
  4052f8:	400e0400 	.word	0x400e0400

004052fc <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  4052fc:	4b02      	ldr	r3, [pc, #8]	; (405308 <pmc_disable_pllack+0xc>)
  4052fe:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  405302:	629a      	str	r2, [r3, #40]	; 0x28
  405304:	4770      	bx	lr
  405306:	bf00      	nop
  405308:	400e0400 	.word	0x400e0400

0040530c <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  40530c:	4b02      	ldr	r3, [pc, #8]	; (405318 <pmc_is_locked_pllack+0xc>)
  40530e:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  405310:	f000 0002 	and.w	r0, r0, #2
  405314:	4770      	bx	lr
  405316:	bf00      	nop
  405318:	400e0400 	.word	0x400e0400

0040531c <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  40531c:	2822      	cmp	r0, #34	; 0x22
  40531e:	d819      	bhi.n	405354 <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
  405320:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  405322:	4b0e      	ldr	r3, [pc, #56]	; (40535c <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
  405324:	d809      	bhi.n	40533a <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  405326:	2101      	movs	r1, #1
  405328:	699a      	ldr	r2, [r3, #24]
  40532a:	fa01 f000 	lsl.w	r0, r1, r0
  40532e:	4002      	ands	r2, r0
  405330:	4290      	cmp	r0, r2
  405332:	d011      	beq.n	405358 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
  405334:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405336:	2000      	movs	r0, #0
  405338:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  40533a:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  40533c:	2101      	movs	r1, #1
  40533e:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  405342:	fa01 f000 	lsl.w	r0, r1, r0
  405346:	4002      	ands	r2, r0
  405348:	4290      	cmp	r0, r2
  40534a:	d005      	beq.n	405358 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
  40534c:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  405350:	2000      	movs	r0, #0
  405352:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  405354:	2001      	movs	r0, #1
  405356:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405358:	2000      	movs	r0, #0
}
  40535a:	4770      	bx	lr
  40535c:	400e0400 	.word	0x400e0400

00405360 <wdt_disable>:
/**
 * \brief Disable the watchdog timer.
 */
void wdt_disable(Wdt *p_wdt)
{
	p_wdt->WDT_MR = WDT_MR_WDDIS;
  405360:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  405364:	6043      	str	r3, [r0, #4]
  405366:	4770      	bx	lr

00405368 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  405368:	6880      	ldr	r0, [r0, #8]
}
  40536a:	4770      	bx	lr

0040536c <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  40536c:	e7fe      	b.n	40536c <Dummy_Handler>
  40536e:	bf00      	nop

00405370 <Reset_Handler>:

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  405370:	481c      	ldr	r0, [pc, #112]	; (4053e4 <Reset_Handler+0x74>)
  405372:	4b1d      	ldr	r3, [pc, #116]	; (4053e8 <Reset_Handler+0x78>)
  405374:	4298      	cmp	r0, r3
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  405376:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  405378:	d925      	bls.n	4053c6 <Reset_Handler+0x56>
		for (; pDest < &_erelocate;) {
  40537a:	4a1c      	ldr	r2, [pc, #112]	; (4053ec <Reset_Handler+0x7c>)
  40537c:	4293      	cmp	r3, r2
  40537e:	d20a      	bcs.n	405396 <Reset_Handler+0x26>
  405380:	43d9      	mvns	r1, r3
  405382:	440a      	add	r2, r1
  405384:	f022 0403 	bic.w	r4, r2, #3
  405388:	3404      	adds	r4, #4
  40538a:	2200      	movs	r2, #0
			*pDest++ = *pSrc++;
  40538c:	5881      	ldr	r1, [r0, r2]
  40538e:	5099      	str	r1, [r3, r2]
  405390:	3204      	adds	r2, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  405392:	42a2      	cmp	r2, r4
  405394:	d1fa      	bne.n	40538c <Reset_Handler+0x1c>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  405396:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  405398:	4b15      	ldr	r3, [pc, #84]	; (4053f0 <Reset_Handler+0x80>)
  40539a:	4a16      	ldr	r2, [pc, #88]	; (4053f4 <Reset_Handler+0x84>)
  40539c:	4293      	cmp	r3, r2
  40539e:	d20a      	bcs.n	4053b6 <Reset_Handler+0x46>
  4053a0:	43d9      	mvns	r1, r3
  4053a2:	440a      	add	r2, r1
  4053a4:	f022 0103 	bic.w	r1, r2, #3
  4053a8:	4419      	add	r1, r3
		*pDest++ = 0;
  4053aa:	2200      	movs	r2, #0
  4053ac:	3b04      	subs	r3, #4
  4053ae:	f843 2f04 	str.w	r2, [r3, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4053b2:	428b      	cmp	r3, r1
  4053b4:	d1fb      	bne.n	4053ae <Reset_Handler+0x3e>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  4053b6:	4b10      	ldr	r3, [pc, #64]	; (4053f8 <Reset_Handler+0x88>)
  4053b8:	4a10      	ldr	r2, [pc, #64]	; (4053fc <Reset_Handler+0x8c>)
  4053ba:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  4053bc:	4b10      	ldr	r3, [pc, #64]	; (405400 <Reset_Handler+0x90>)
  4053be:	4798      	blx	r3

	/* Branch to main function */
	main();
  4053c0:	4b10      	ldr	r3, [pc, #64]	; (405404 <Reset_Handler+0x94>)
  4053c2:	4798      	blx	r3
  4053c4:	e7fe      	b.n	4053c4 <Reset_Handler+0x54>

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  4053c6:	d2e6      	bcs.n	405396 <Reset_Handler+0x26>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4053c8:	4908      	ldr	r1, [pc, #32]	; (4053ec <Reset_Handler+0x7c>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4053ca:	3804      	subs	r0, #4
	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4053cc:	1aca      	subs	r2, r1, r3
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4053ce:	4410      	add	r0, r2
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4053d0:	2a00      	cmp	r2, #0
  4053d2:	d0e0      	beq.n	405396 <Reset_Handler+0x26>
  4053d4:	460a      	mov	r2, r1
  4053d6:	1a54      	subs	r4, r2, r1
			*pDest-- = *pSrc--;
  4053d8:	5824      	ldr	r4, [r4, r0]
  4053da:	f842 4d04 	str.w	r4, [r2, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4053de:	4293      	cmp	r3, r2
  4053e0:	d1f9      	bne.n	4053d6 <Reset_Handler+0x66>
  4053e2:	e7d8      	b.n	405396 <Reset_Handler+0x26>
  4053e4:	00406de0 	.word	0x00406de0
  4053e8:	20000000 	.word	0x20000000
  4053ec:	20000a8c 	.word	0x20000a8c
  4053f0:	20000a8c 	.word	0x20000a8c
  4053f4:	200023b8 	.word	0x200023b8
  4053f8:	e000ed00 	.word	0xe000ed00
  4053fc:	00400000 	.word	0x00400000
  405400:	00405b85 	.word	0x00405b85
  405404:	004055a5 	.word	0x004055a5

00405408 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  405408:	4b32      	ldr	r3, [pc, #200]	; (4054d4 <SystemCoreClockUpdate+0xcc>)
  40540a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  40540c:	f002 0203 	and.w	r2, r2, #3
  405410:	2a01      	cmp	r2, #1
  405412:	d03a      	beq.n	40548a <SystemCoreClockUpdate+0x82>
  405414:	d323      	bcc.n	40545e <SystemCoreClockUpdate+0x56>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  405416:	6a1a      	ldr	r2, [r3, #32]
  405418:	01d2      	lsls	r2, r2, #7
  40541a:	d547      	bpl.n	4054ac <SystemCoreClockUpdate+0xa4>
				SystemCoreClock = CHIP_FREQ_XTAL;
  40541c:	4a2e      	ldr	r2, [pc, #184]	; (4054d8 <SystemCoreClockUpdate+0xd0>)
  40541e:	482f      	ldr	r0, [pc, #188]	; (4054dc <SystemCoreClockUpdate+0xd4>)
  405420:	6010      	str	r0, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  405422:	4b2c      	ldr	r3, [pc, #176]	; (4054d4 <SystemCoreClockUpdate+0xcc>)
  405424:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405426:	f001 0103 	and.w	r1, r1, #3
  40542a:	2902      	cmp	r1, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  40542c:	bf0b      	itete	eq
  40542e:	6a99      	ldreq	r1, [r3, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  405430:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  405432:	6a9b      	ldreq	r3, [r3, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405434:	6adb      	ldrne	r3, [r3, #44]	; 0x2c
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  405436:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40543a:	fb01 0000 	mla	r0, r1, r0, r0
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  40543e:	b2db      	uxtb	r3, r3
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405440:	fbb0 f0f3 	udiv	r0, r0, r3
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405444:	4b23      	ldr	r3, [pc, #140]	; (4054d4 <SystemCoreClockUpdate+0xcc>)
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405446:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405448:	6b19      	ldr	r1, [r3, #48]	; 0x30
  40544a:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40544e:	2970      	cmp	r1, #112	; 0x70
  405450:	d115      	bne.n	40547e <SystemCoreClockUpdate+0x76>
		SystemCoreClock /= 3U;
  405452:	4b23      	ldr	r3, [pc, #140]	; (4054e0 <SystemCoreClockUpdate+0xd8>)
  405454:	fba3 1000 	umull	r1, r0, r3, r0
  405458:	0840      	lsrs	r0, r0, #1
  40545a:	6010      	str	r0, [r2, #0]
  40545c:	4770      	bx	lr
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40545e:	4b21      	ldr	r3, [pc, #132]	; (4054e4 <SystemCoreClockUpdate+0xdc>)
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405460:	4a1d      	ldr	r2, [pc, #116]	; (4054d8 <SystemCoreClockUpdate+0xd0>)
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  405462:	695b      	ldr	r3, [r3, #20]
  405464:	061b      	lsls	r3, r3, #24
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405466:	bf4c      	ite	mi
  405468:	f44f 4000 	movmi.w	r0, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  40546c:	f44f 40fa 	movpl.w	r0, #32000	; 0x7d00
  405470:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405472:	4b18      	ldr	r3, [pc, #96]	; (4054d4 <SystemCoreClockUpdate+0xcc>)
  405474:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405476:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40547a:	2970      	cmp	r1, #112	; 0x70
  40547c:	d0e9      	beq.n	405452 <SystemCoreClockUpdate+0x4a>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  40547e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  405480:	f3c3 1302 	ubfx	r3, r3, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  405484:	40d8      	lsrs	r0, r3
  405486:	6010      	str	r0, [r2, #0]
  405488:	4770      	bx	lr
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  40548a:	6a1a      	ldr	r2, [r3, #32]
  40548c:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
			SystemCoreClock = CHIP_FREQ_XTAL;
  405490:	4a11      	ldr	r2, [pc, #68]	; (4054d8 <SystemCoreClockUpdate+0xd0>)
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  405492:	d108      	bne.n	4054a6 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  405494:	4814      	ldr	r0, [pc, #80]	; (4054e8 <SystemCoreClockUpdate+0xe0>)
  405496:	6010      	str	r0, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  405498:	6a1b      	ldr	r3, [r3, #32]
  40549a:	f003 0370 	and.w	r3, r3, #112	; 0x70
  40549e:	2b10      	cmp	r3, #16
  4054a0:	d014      	beq.n	4054cc <SystemCoreClockUpdate+0xc4>
  4054a2:	2b20      	cmp	r3, #32
  4054a4:	d1e5      	bne.n	405472 <SystemCoreClockUpdate+0x6a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4054a6:	480d      	ldr	r0, [pc, #52]	; (4054dc <SystemCoreClockUpdate+0xd4>)
  4054a8:	6010      	str	r0, [r2, #0]
			break;
  4054aa:	e7e2      	b.n	405472 <SystemCoreClockUpdate+0x6a>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
				SystemCoreClock = CHIP_FREQ_XTAL;
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4054ac:	4a0a      	ldr	r2, [pc, #40]	; (4054d8 <SystemCoreClockUpdate+0xd0>)
  4054ae:	480e      	ldr	r0, [pc, #56]	; (4054e8 <SystemCoreClockUpdate+0xe0>)
  4054b0:	6010      	str	r0, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4054b2:	6a1b      	ldr	r3, [r3, #32]
  4054b4:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4054b8:	2b10      	cmp	r3, #16
  4054ba:	d004      	beq.n	4054c6 <SystemCoreClockUpdate+0xbe>
  4054bc:	2b20      	cmp	r3, #32
  4054be:	d1b0      	bne.n	405422 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4054c0:	4806      	ldr	r0, [pc, #24]	; (4054dc <SystemCoreClockUpdate+0xd4>)
  4054c2:	6010      	str	r0, [r2, #0]
					break;
  4054c4:	e7ad      	b.n	405422 <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4054c6:	4809      	ldr	r0, [pc, #36]	; (4054ec <SystemCoreClockUpdate+0xe4>)
  4054c8:	6010      	str	r0, [r2, #0]
					break;
  4054ca:	e7aa      	b.n	405422 <SystemCoreClockUpdate+0x1a>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4054cc:	4807      	ldr	r0, [pc, #28]	; (4054ec <SystemCoreClockUpdate+0xe4>)
  4054ce:	6010      	str	r0, [r2, #0]
			break;
  4054d0:	e7cf      	b.n	405472 <SystemCoreClockUpdate+0x6a>
  4054d2:	bf00      	nop
  4054d4:	400e0400 	.word	0x400e0400
  4054d8:	2000024c 	.word	0x2000024c
  4054dc:	00b71b00 	.word	0x00b71b00
  4054e0:	aaaaaaab 	.word	0xaaaaaaab
  4054e4:	400e1410 	.word	0x400e1410
  4054e8:	003d0900 	.word	0x003d0900
  4054ec:	007a1200 	.word	0x007a1200

004054f0 <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  4054f0:	4b0f      	ldr	r3, [pc, #60]	; (405530 <system_init_flash+0x40>)
  4054f2:	4298      	cmp	r0, r3
  4054f4:	d912      	bls.n	40551c <system_init_flash+0x2c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  4054f6:	4b0f      	ldr	r3, [pc, #60]	; (405534 <system_init_flash+0x44>)
  4054f8:	4298      	cmp	r0, r3
  4054fa:	d90b      	bls.n	405514 <system_init_flash+0x24>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  4054fc:	4b0e      	ldr	r3, [pc, #56]	; (405538 <system_init_flash+0x48>)
  4054fe:	4298      	cmp	r0, r3
  405500:	d911      	bls.n	405526 <system_init_flash+0x36>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  405502:	4b0e      	ldr	r3, [pc, #56]	; (40553c <system_init_flash+0x4c>)
  405504:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  405506:	4b0e      	ldr	r3, [pc, #56]	; (405540 <system_init_flash+0x50>)
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  405508:	bf8c      	ite	hi
  40550a:	4a0e      	ldrhi	r2, [pc, #56]	; (405544 <system_init_flash+0x54>)
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  40550c:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  405510:	601a      	str	r2, [r3, #0]
  405512:	4770      	bx	lr
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  405514:	4b0a      	ldr	r3, [pc, #40]	; (405540 <system_init_flash+0x50>)
  405516:	4a0c      	ldr	r2, [pc, #48]	; (405548 <system_init_flash+0x58>)
  405518:	601a      	str	r2, [r3, #0]
  40551a:	4770      	bx	lr
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  40551c:	4b08      	ldr	r3, [pc, #32]	; (405540 <system_init_flash+0x50>)
  40551e:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  405522:	601a      	str	r2, [r3, #0]
  405524:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  405526:	4b06      	ldr	r3, [pc, #24]	; (405540 <system_init_flash+0x50>)
  405528:	4a08      	ldr	r2, [pc, #32]	; (40554c <system_init_flash+0x5c>)
  40552a:	601a      	str	r2, [r3, #0]
  40552c:	4770      	bx	lr
  40552e:	bf00      	nop
  405530:	01ba813f 	.word	0x01ba813f
  405534:	0375027f 	.word	0x0375027f
  405538:	053ec5ff 	.word	0x053ec5ff
  40553c:	07270dff 	.word	0x07270dff
  405540:	400e0a00 	.word	0x400e0a00
  405544:	04000500 	.word	0x04000500
  405548:	04000100 	.word	0x04000100
  40554c:	04000200 	.word	0x04000200

00405550 <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  405550:	4a07      	ldr	r2, [pc, #28]	; (405570 <_sbrk+0x20>)

extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  405552:	4908      	ldr	r1, [pc, #32]	; (405574 <_sbrk+0x24>)

	if (heap == NULL) {
  405554:	6813      	ldr	r3, [r2, #0]
  405556:	b13b      	cbz	r3, 405568 <_sbrk+0x18>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
  405558:	4418      	add	r0, r3
  40555a:	4281      	cmp	r1, r0
		return (caddr_t) -1;	
	}

	heap += incr;
  40555c:	bfa6      	itte	ge
  40555e:	6010      	strge	r0, [r2, #0]

	return (caddr_t) prev_heap;
  405560:	4618      	movge	r0, r3
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  405562:	f04f 30ff 	movlt.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  405566:	4770      	bx	lr
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
		heap = (unsigned char *)&_end;
  405568:	4b03      	ldr	r3, [pc, #12]	; (405578 <_sbrk+0x28>)
  40556a:	6013      	str	r3, [r2, #0]
  40556c:	e7f4      	b.n	405558 <_sbrk+0x8>
  40556e:	bf00      	nop
  405570:	200010c4 	.word	0x200010c4
  405574:	2000fffc 	.word	0x2000fffc
  405578:	200053b8 	.word	0x200053b8

0040557c <HardFault_Handler>:
extern drv_uart_config_t usart1Config;
extern brainSettings_t brainSettings; 
volatile unsigned long sgSysTickCount = 0;

void HardFault_Handler()
{
  40557c:	e7fe      	b.n	40557c <HardFault_Handler>
  40557e:	bf00      	nop

00405580 <MemManage_Handler>:
	while(1); 
}
void MemManage_Handler()
{
  405580:	e7fe      	b.n	405580 <MemManage_Handler>
  405582:	bf00      	nop

00405584 <BusFault_Handler>:
	while(1); 
}
void BusFault_Handler()
{
  405584:	e7fe      	b.n	405584 <BusFault_Handler>
  405586:	bf00      	nop

00405588 <UsageFault_Handler>:
	while(1); 
}
void UsageFault_Handler()
{
  405588:	e7fe      	b.n	405588 <UsageFault_Handler>
  40558a:	bf00      	nop

0040558c <SysTick_Handler>:

/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
  40558c:	b508      	push	{r3, lr}
	sgSysTickCount++;
  40558e:	4b03      	ldr	r3, [pc, #12]	; (40559c <SysTick_Handler+0x10>)
	xPortSysTickHandler();
  405590:	4a03      	ldr	r2, [pc, #12]	; (4055a0 <SysTick_Handler+0x14>)
/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
	sgSysTickCount++;
  405592:	6819      	ldr	r1, [r3, #0]
  405594:	3101      	adds	r1, #1
  405596:	6019      	str	r1, [r3, #0]
	xPortSysTickHandler();
  405598:	4790      	blx	r2
  40559a:	bd08      	pop	{r3, pc}
  40559c:	200010c8 	.word	0x200010c8
  4055a0:	00403c25 	.word	0x00403c25

004055a4 <main>:
}


int main (void)
{
  4055a4:	b508      	push	{r3, lr}
	irq_initialize_vectors();
	cpu_irq_enable();
  4055a6:	4b07      	ldr	r3, [pc, #28]	; (4055c4 <main+0x20>)
  4055a8:	2201      	movs	r2, #1
  4055aa:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4055ac:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4055b0:	b662      	cpsie	i
	//Initialize system clock and peripherals
	sysclk_init();
  4055b2:	4b05      	ldr	r3, [pc, #20]	; (4055c8 <main+0x24>)
  4055b4:	4c05      	ldr	r4, [pc, #20]	; (4055cc <main+0x28>)
  4055b6:	4798      	blx	r3
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
  4055b8:	4b05      	ldr	r3, [pc, #20]	; (4055d0 <main+0x2c>)
  4055ba:	4798      	blx	r3
	#endif
	//we should never get here. 
	/*	Debug code */
	while (1) 
	{		
		delay_ms(1000);
  4055bc:	4805      	ldr	r0, [pc, #20]	; (4055d4 <main+0x30>)
  4055be:	47a0      	blx	r4
  4055c0:	e7fc      	b.n	4055bc <main+0x18>
  4055c2:	bf00      	nop
  4055c4:	20000248 	.word	0x20000248
  4055c8:	00404da9 	.word	0x00404da9
  4055cc:	20000085 	.word	0x20000085
  4055d0:	00400961 	.word	0x00400961
  4055d4:	0082ca25 	.word	0x0082ca25

004055d8 <__aeabi_uldivmod>:
  4055d8:	b94b      	cbnz	r3, 4055ee <__aeabi_uldivmod+0x16>
  4055da:	b942      	cbnz	r2, 4055ee <__aeabi_uldivmod+0x16>
  4055dc:	2900      	cmp	r1, #0
  4055de:	bf08      	it	eq
  4055e0:	2800      	cmpeq	r0, #0
  4055e2:	d002      	beq.n	4055ea <__aeabi_uldivmod+0x12>
  4055e4:	f04f 31ff 	mov.w	r1, #4294967295
  4055e8:	4608      	mov	r0, r1
  4055ea:	f000 b83b 	b.w	405664 <__aeabi_idiv0>
  4055ee:	b082      	sub	sp, #8
  4055f0:	46ec      	mov	ip, sp
  4055f2:	e92d 5000 	stmdb	sp!, {ip, lr}
  4055f6:	f000 f81d 	bl	405634 <__gnu_uldivmod_helper>
  4055fa:	f8dd e004 	ldr.w	lr, [sp, #4]
  4055fe:	b002      	add	sp, #8
  405600:	bc0c      	pop	{r2, r3}
  405602:	4770      	bx	lr

00405604 <__gnu_ldivmod_helper>:
  405604:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405608:	9e06      	ldr	r6, [sp, #24]
  40560a:	4614      	mov	r4, r2
  40560c:	461d      	mov	r5, r3
  40560e:	4680      	mov	r8, r0
  405610:	4689      	mov	r9, r1
  405612:	f000 f829 	bl	405668 <__divdi3>
  405616:	fb04 f301 	mul.w	r3, r4, r1
  40561a:	fb00 3305 	mla	r3, r0, r5, r3
  40561e:	fba4 4500 	umull	r4, r5, r4, r0
  405622:	441d      	add	r5, r3
  405624:	ebb8 0404 	subs.w	r4, r8, r4
  405628:	eb69 0505 	sbc.w	r5, r9, r5
  40562c:	e9c6 4500 	strd	r4, r5, [r6]
  405630:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405634 <__gnu_uldivmod_helper>:
  405634:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405638:	9e06      	ldr	r6, [sp, #24]
  40563a:	4614      	mov	r4, r2
  40563c:	4680      	mov	r8, r0
  40563e:	4689      	mov	r9, r1
  405640:	461d      	mov	r5, r3
  405642:	f000 f95d 	bl	405900 <__udivdi3>
  405646:	fb00 f505 	mul.w	r5, r0, r5
  40564a:	fb04 5301 	mla	r3, r4, r1, r5
  40564e:	fba0 4504 	umull	r4, r5, r0, r4
  405652:	441d      	add	r5, r3
  405654:	ebb8 0404 	subs.w	r4, r8, r4
  405658:	eb69 0505 	sbc.w	r5, r9, r5
  40565c:	e9c6 4500 	strd	r4, r5, [r6]
  405660:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405664 <__aeabi_idiv0>:
  405664:	4770      	bx	lr
  405666:	bf00      	nop

00405668 <__divdi3>:
  405668:	2900      	cmp	r1, #0
  40566a:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40566e:	f2c0 809f 	blt.w	4057b0 <__divdi3+0x148>
  405672:	2400      	movs	r4, #0
  405674:	2b00      	cmp	r3, #0
  405676:	f2c0 8096 	blt.w	4057a6 <__divdi3+0x13e>
  40567a:	4615      	mov	r5, r2
  40567c:	4606      	mov	r6, r0
  40567e:	460f      	mov	r7, r1
  405680:	2b00      	cmp	r3, #0
  405682:	d13e      	bne.n	405702 <__divdi3+0x9a>
  405684:	428a      	cmp	r2, r1
  405686:	d957      	bls.n	405738 <__divdi3+0xd0>
  405688:	fab2 f382 	clz	r3, r2
  40568c:	b14b      	cbz	r3, 4056a2 <__divdi3+0x3a>
  40568e:	f1c3 0220 	rsb	r2, r3, #32
  405692:	fa01 f703 	lsl.w	r7, r1, r3
  405696:	fa20 f202 	lsr.w	r2, r0, r2
  40569a:	409d      	lsls	r5, r3
  40569c:	4317      	orrs	r7, r2
  40569e:	fa00 f603 	lsl.w	r6, r0, r3
  4056a2:	0c29      	lsrs	r1, r5, #16
  4056a4:	fbb7 f2f1 	udiv	r2, r7, r1
  4056a8:	0c33      	lsrs	r3, r6, #16
  4056aa:	fb01 7c12 	mls	ip, r1, r2, r7
  4056ae:	b2a8      	uxth	r0, r5
  4056b0:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
  4056b4:	fb00 f302 	mul.w	r3, r0, r2
  4056b8:	42bb      	cmp	r3, r7
  4056ba:	d909      	bls.n	4056d0 <__divdi3+0x68>
  4056bc:	197f      	adds	r7, r7, r5
  4056be:	f102 3cff 	add.w	ip, r2, #4294967295
  4056c2:	f080 8101 	bcs.w	4058c8 <__divdi3+0x260>
  4056c6:	42bb      	cmp	r3, r7
  4056c8:	f240 80fe 	bls.w	4058c8 <__divdi3+0x260>
  4056cc:	3a02      	subs	r2, #2
  4056ce:	442f      	add	r7, r5
  4056d0:	1aff      	subs	r7, r7, r3
  4056d2:	fbb7 f3f1 	udiv	r3, r7, r1
  4056d6:	b2b6      	uxth	r6, r6
  4056d8:	fb01 7113 	mls	r1, r1, r3, r7
  4056dc:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
  4056e0:	fb00 f003 	mul.w	r0, r0, r3
  4056e4:	4288      	cmp	r0, r1
  4056e6:	d908      	bls.n	4056fa <__divdi3+0x92>
  4056e8:	1949      	adds	r1, r1, r5
  4056ea:	f103 37ff 	add.w	r7, r3, #4294967295
  4056ee:	f080 80ed 	bcs.w	4058cc <__divdi3+0x264>
  4056f2:	4288      	cmp	r0, r1
  4056f4:	f240 80ea 	bls.w	4058cc <__divdi3+0x264>
  4056f8:	3b02      	subs	r3, #2
  4056fa:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  4056fe:	2300      	movs	r3, #0
  405700:	e003      	b.n	40570a <__divdi3+0xa2>
  405702:	428b      	cmp	r3, r1
  405704:	d90a      	bls.n	40571c <__divdi3+0xb4>
  405706:	2300      	movs	r3, #0
  405708:	461a      	mov	r2, r3
  40570a:	4610      	mov	r0, r2
  40570c:	4619      	mov	r1, r3
  40570e:	b114      	cbz	r4, 405716 <__divdi3+0xae>
  405710:	4240      	negs	r0, r0
  405712:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  405716:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40571a:	4770      	bx	lr
  40571c:	fab3 f883 	clz	r8, r3
  405720:	f1b8 0f00 	cmp.w	r8, #0
  405724:	f040 8084 	bne.w	405830 <__divdi3+0x1c8>
  405728:	428b      	cmp	r3, r1
  40572a:	d302      	bcc.n	405732 <__divdi3+0xca>
  40572c:	4282      	cmp	r2, r0
  40572e:	f200 80de 	bhi.w	4058ee <__divdi3+0x286>
  405732:	2300      	movs	r3, #0
  405734:	2201      	movs	r2, #1
  405736:	e7e8      	b.n	40570a <__divdi3+0xa2>
  405738:	b912      	cbnz	r2, 405740 <__divdi3+0xd8>
  40573a:	2301      	movs	r3, #1
  40573c:	fbb3 f5f2 	udiv	r5, r3, r2
  405740:	fab5 f285 	clz	r2, r5
  405744:	2a00      	cmp	r2, #0
  405746:	d139      	bne.n	4057bc <__divdi3+0x154>
  405748:	1b7f      	subs	r7, r7, r5
  40574a:	0c28      	lsrs	r0, r5, #16
  40574c:	fa1f fc85 	uxth.w	ip, r5
  405750:	2301      	movs	r3, #1
  405752:	fbb7 f1f0 	udiv	r1, r7, r0
  405756:	0c32      	lsrs	r2, r6, #16
  405758:	fb00 7711 	mls	r7, r0, r1, r7
  40575c:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  405760:	fb0c f201 	mul.w	r2, ip, r1
  405764:	42ba      	cmp	r2, r7
  405766:	d907      	bls.n	405778 <__divdi3+0x110>
  405768:	197f      	adds	r7, r7, r5
  40576a:	f101 38ff 	add.w	r8, r1, #4294967295
  40576e:	d202      	bcs.n	405776 <__divdi3+0x10e>
  405770:	42ba      	cmp	r2, r7
  405772:	f200 80c1 	bhi.w	4058f8 <__divdi3+0x290>
  405776:	4641      	mov	r1, r8
  405778:	1abf      	subs	r7, r7, r2
  40577a:	fbb7 f2f0 	udiv	r2, r7, r0
  40577e:	b2b6      	uxth	r6, r6
  405780:	fb00 7012 	mls	r0, r0, r2, r7
  405784:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
  405788:	fb0c fc02 	mul.w	ip, ip, r2
  40578c:	4584      	cmp	ip, r0
  40578e:	d907      	bls.n	4057a0 <__divdi3+0x138>
  405790:	1940      	adds	r0, r0, r5
  405792:	f102 37ff 	add.w	r7, r2, #4294967295
  405796:	d202      	bcs.n	40579e <__divdi3+0x136>
  405798:	4584      	cmp	ip, r0
  40579a:	f200 80ab 	bhi.w	4058f4 <__divdi3+0x28c>
  40579e:	463a      	mov	r2, r7
  4057a0:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  4057a4:	e7b1      	b.n	40570a <__divdi3+0xa2>
  4057a6:	43e4      	mvns	r4, r4
  4057a8:	4252      	negs	r2, r2
  4057aa:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  4057ae:	e764      	b.n	40567a <__divdi3+0x12>
  4057b0:	4240      	negs	r0, r0
  4057b2:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  4057b6:	f04f 34ff 	mov.w	r4, #4294967295
  4057ba:	e75b      	b.n	405674 <__divdi3+0xc>
  4057bc:	4095      	lsls	r5, r2
  4057be:	f1c2 0320 	rsb	r3, r2, #32
  4057c2:	fa27 f103 	lsr.w	r1, r7, r3
  4057c6:	0c28      	lsrs	r0, r5, #16
  4057c8:	fa26 f303 	lsr.w	r3, r6, r3
  4057cc:	4097      	lsls	r7, r2
  4057ce:	fbb1 f8f0 	udiv	r8, r1, r0
  4057d2:	431f      	orrs	r7, r3
  4057d4:	0c3b      	lsrs	r3, r7, #16
  4057d6:	fb00 1118 	mls	r1, r0, r8, r1
  4057da:	fa1f fc85 	uxth.w	ip, r5
  4057de:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  4057e2:	fb0c f308 	mul.w	r3, ip, r8
  4057e6:	428b      	cmp	r3, r1
  4057e8:	fa06 f602 	lsl.w	r6, r6, r2
  4057ec:	d908      	bls.n	405800 <__divdi3+0x198>
  4057ee:	1949      	adds	r1, r1, r5
  4057f0:	f108 32ff 	add.w	r2, r8, #4294967295
  4057f4:	d279      	bcs.n	4058ea <__divdi3+0x282>
  4057f6:	428b      	cmp	r3, r1
  4057f8:	d977      	bls.n	4058ea <__divdi3+0x282>
  4057fa:	f1a8 0802 	sub.w	r8, r8, #2
  4057fe:	4429      	add	r1, r5
  405800:	1ac9      	subs	r1, r1, r3
  405802:	fbb1 f3f0 	udiv	r3, r1, r0
  405806:	b2bf      	uxth	r7, r7
  405808:	fb00 1113 	mls	r1, r0, r3, r1
  40580c:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
  405810:	fb0c f203 	mul.w	r2, ip, r3
  405814:	42ba      	cmp	r2, r7
  405816:	d907      	bls.n	405828 <__divdi3+0x1c0>
  405818:	197f      	adds	r7, r7, r5
  40581a:	f103 31ff 	add.w	r1, r3, #4294967295
  40581e:	d260      	bcs.n	4058e2 <__divdi3+0x27a>
  405820:	42ba      	cmp	r2, r7
  405822:	d95e      	bls.n	4058e2 <__divdi3+0x27a>
  405824:	3b02      	subs	r3, #2
  405826:	442f      	add	r7, r5
  405828:	1abf      	subs	r7, r7, r2
  40582a:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  40582e:	e790      	b.n	405752 <__divdi3+0xea>
  405830:	f1c8 0220 	rsb	r2, r8, #32
  405834:	fa03 fc08 	lsl.w	ip, r3, r8
  405838:	fa25 f302 	lsr.w	r3, r5, r2
  40583c:	ea43 0c0c 	orr.w	ip, r3, ip
  405840:	ea4f 491c 	mov.w	r9, ip, lsr #16
  405844:	fa21 f302 	lsr.w	r3, r1, r2
  405848:	fa01 f708 	lsl.w	r7, r1, r8
  40584c:	fa20 f202 	lsr.w	r2, r0, r2
  405850:	fbb3 f1f9 	udiv	r1, r3, r9
  405854:	4317      	orrs	r7, r2
  405856:	fb09 3311 	mls	r3, r9, r1, r3
  40585a:	0c3a      	lsrs	r2, r7, #16
  40585c:	fa1f fb8c 	uxth.w	fp, ip
  405860:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  405864:	fb0b fa01 	mul.w	sl, fp, r1
  405868:	459a      	cmp	sl, r3
  40586a:	fa05 f008 	lsl.w	r0, r5, r8
  40586e:	d908      	bls.n	405882 <__divdi3+0x21a>
  405870:	eb13 030c 	adds.w	r3, r3, ip
  405874:	f101 32ff 	add.w	r2, r1, #4294967295
  405878:	d235      	bcs.n	4058e6 <__divdi3+0x27e>
  40587a:	459a      	cmp	sl, r3
  40587c:	d933      	bls.n	4058e6 <__divdi3+0x27e>
  40587e:	3902      	subs	r1, #2
  405880:	4463      	add	r3, ip
  405882:	ebca 0303 	rsb	r3, sl, r3
  405886:	fbb3 f2f9 	udiv	r2, r3, r9
  40588a:	fb09 3312 	mls	r3, r9, r2, r3
  40588e:	b2bf      	uxth	r7, r7
  405890:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405894:	fb0b f902 	mul.w	r9, fp, r2
  405898:	45b9      	cmp	r9, r7
  40589a:	d908      	bls.n	4058ae <__divdi3+0x246>
  40589c:	eb17 070c 	adds.w	r7, r7, ip
  4058a0:	f102 33ff 	add.w	r3, r2, #4294967295
  4058a4:	d21b      	bcs.n	4058de <__divdi3+0x276>
  4058a6:	45b9      	cmp	r9, r7
  4058a8:	d919      	bls.n	4058de <__divdi3+0x276>
  4058aa:	3a02      	subs	r2, #2
  4058ac:	4467      	add	r7, ip
  4058ae:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
  4058b2:	fba5 0100 	umull	r0, r1, r5, r0
  4058b6:	ebc9 0707 	rsb	r7, r9, r7
  4058ba:	428f      	cmp	r7, r1
  4058bc:	f04f 0300 	mov.w	r3, #0
  4058c0:	d30a      	bcc.n	4058d8 <__divdi3+0x270>
  4058c2:	d005      	beq.n	4058d0 <__divdi3+0x268>
  4058c4:	462a      	mov	r2, r5
  4058c6:	e720      	b.n	40570a <__divdi3+0xa2>
  4058c8:	4662      	mov	r2, ip
  4058ca:	e701      	b.n	4056d0 <__divdi3+0x68>
  4058cc:	463b      	mov	r3, r7
  4058ce:	e714      	b.n	4056fa <__divdi3+0x92>
  4058d0:	fa06 f608 	lsl.w	r6, r6, r8
  4058d4:	4286      	cmp	r6, r0
  4058d6:	d2f5      	bcs.n	4058c4 <__divdi3+0x25c>
  4058d8:	1e6a      	subs	r2, r5, #1
  4058da:	2300      	movs	r3, #0
  4058dc:	e715      	b.n	40570a <__divdi3+0xa2>
  4058de:	461a      	mov	r2, r3
  4058e0:	e7e5      	b.n	4058ae <__divdi3+0x246>
  4058e2:	460b      	mov	r3, r1
  4058e4:	e7a0      	b.n	405828 <__divdi3+0x1c0>
  4058e6:	4611      	mov	r1, r2
  4058e8:	e7cb      	b.n	405882 <__divdi3+0x21a>
  4058ea:	4690      	mov	r8, r2
  4058ec:	e788      	b.n	405800 <__divdi3+0x198>
  4058ee:	4643      	mov	r3, r8
  4058f0:	4642      	mov	r2, r8
  4058f2:	e70a      	b.n	40570a <__divdi3+0xa2>
  4058f4:	3a02      	subs	r2, #2
  4058f6:	e753      	b.n	4057a0 <__divdi3+0x138>
  4058f8:	3902      	subs	r1, #2
  4058fa:	442f      	add	r7, r5
  4058fc:	e73c      	b.n	405778 <__divdi3+0x110>
  4058fe:	bf00      	nop

00405900 <__udivdi3>:
  405900:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405904:	4614      	mov	r4, r2
  405906:	4605      	mov	r5, r0
  405908:	460e      	mov	r6, r1
  40590a:	2b00      	cmp	r3, #0
  40590c:	d143      	bne.n	405996 <__udivdi3+0x96>
  40590e:	428a      	cmp	r2, r1
  405910:	d953      	bls.n	4059ba <__udivdi3+0xba>
  405912:	fab2 f782 	clz	r7, r2
  405916:	b157      	cbz	r7, 40592e <__udivdi3+0x2e>
  405918:	f1c7 0620 	rsb	r6, r7, #32
  40591c:	fa20 f606 	lsr.w	r6, r0, r6
  405920:	fa01 f307 	lsl.w	r3, r1, r7
  405924:	fa02 f407 	lsl.w	r4, r2, r7
  405928:	431e      	orrs	r6, r3
  40592a:	fa00 f507 	lsl.w	r5, r0, r7
  40592e:	0c21      	lsrs	r1, r4, #16
  405930:	fbb6 f2f1 	udiv	r2, r6, r1
  405934:	0c2b      	lsrs	r3, r5, #16
  405936:	fb01 6712 	mls	r7, r1, r2, r6
  40593a:	b2a0      	uxth	r0, r4
  40593c:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
  405940:	fb00 f302 	mul.w	r3, r0, r2
  405944:	42b3      	cmp	r3, r6
  405946:	d909      	bls.n	40595c <__udivdi3+0x5c>
  405948:	1936      	adds	r6, r6, r4
  40594a:	f102 37ff 	add.w	r7, r2, #4294967295
  40594e:	f080 80f6 	bcs.w	405b3e <__udivdi3+0x23e>
  405952:	42b3      	cmp	r3, r6
  405954:	f240 80f3 	bls.w	405b3e <__udivdi3+0x23e>
  405958:	3a02      	subs	r2, #2
  40595a:	4426      	add	r6, r4
  40595c:	1af6      	subs	r6, r6, r3
  40595e:	fbb6 f3f1 	udiv	r3, r6, r1
  405962:	b2ad      	uxth	r5, r5
  405964:	fb01 6113 	mls	r1, r1, r3, r6
  405968:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
  40596c:	fb00 f003 	mul.w	r0, r0, r3
  405970:	4288      	cmp	r0, r1
  405972:	d908      	bls.n	405986 <__udivdi3+0x86>
  405974:	1909      	adds	r1, r1, r4
  405976:	f103 36ff 	add.w	r6, r3, #4294967295
  40597a:	f080 80e2 	bcs.w	405b42 <__udivdi3+0x242>
  40597e:	4288      	cmp	r0, r1
  405980:	f240 80df 	bls.w	405b42 <__udivdi3+0x242>
  405984:	3b02      	subs	r3, #2
  405986:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  40598a:	2300      	movs	r3, #0
  40598c:	4610      	mov	r0, r2
  40598e:	4619      	mov	r1, r3
  405990:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405994:	4770      	bx	lr
  405996:	428b      	cmp	r3, r1
  405998:	d84a      	bhi.n	405a30 <__udivdi3+0x130>
  40599a:	fab3 f683 	clz	r6, r3
  40599e:	2e00      	cmp	r6, #0
  4059a0:	d14d      	bne.n	405a3e <__udivdi3+0x13e>
  4059a2:	428b      	cmp	r3, r1
  4059a4:	d302      	bcc.n	4059ac <__udivdi3+0xac>
  4059a6:	4282      	cmp	r2, r0
  4059a8:	f200 80d6 	bhi.w	405b58 <__udivdi3+0x258>
  4059ac:	2300      	movs	r3, #0
  4059ae:	2201      	movs	r2, #1
  4059b0:	4610      	mov	r0, r2
  4059b2:	4619      	mov	r1, r3
  4059b4:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  4059b8:	4770      	bx	lr
  4059ba:	b912      	cbnz	r2, 4059c2 <__udivdi3+0xc2>
  4059bc:	2401      	movs	r4, #1
  4059be:	fbb4 f4f2 	udiv	r4, r4, r2
  4059c2:	fab4 f284 	clz	r2, r4
  4059c6:	2a00      	cmp	r2, #0
  4059c8:	d17c      	bne.n	405ac4 <__udivdi3+0x1c4>
  4059ca:	1b09      	subs	r1, r1, r4
  4059cc:	0c26      	lsrs	r6, r4, #16
  4059ce:	b2a7      	uxth	r7, r4
  4059d0:	2301      	movs	r3, #1
  4059d2:	fbb1 f0f6 	udiv	r0, r1, r6
  4059d6:	0c2a      	lsrs	r2, r5, #16
  4059d8:	fb06 1110 	mls	r1, r6, r0, r1
  4059dc:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
  4059e0:	fb07 f200 	mul.w	r2, r7, r0
  4059e4:	428a      	cmp	r2, r1
  4059e6:	d907      	bls.n	4059f8 <__udivdi3+0xf8>
  4059e8:	1909      	adds	r1, r1, r4
  4059ea:	f100 3cff 	add.w	ip, r0, #4294967295
  4059ee:	d202      	bcs.n	4059f6 <__udivdi3+0xf6>
  4059f0:	428a      	cmp	r2, r1
  4059f2:	f200 80c3 	bhi.w	405b7c <__udivdi3+0x27c>
  4059f6:	4660      	mov	r0, ip
  4059f8:	1a89      	subs	r1, r1, r2
  4059fa:	fbb1 f2f6 	udiv	r2, r1, r6
  4059fe:	b2ad      	uxth	r5, r5
  405a00:	fb06 1112 	mls	r1, r6, r2, r1
  405a04:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
  405a08:	fb07 f702 	mul.w	r7, r7, r2
  405a0c:	42af      	cmp	r7, r5
  405a0e:	d908      	bls.n	405a22 <__udivdi3+0x122>
  405a10:	192c      	adds	r4, r5, r4
  405a12:	f102 31ff 	add.w	r1, r2, #4294967295
  405a16:	f080 8096 	bcs.w	405b46 <__udivdi3+0x246>
  405a1a:	42a7      	cmp	r7, r4
  405a1c:	f240 8093 	bls.w	405b46 <__udivdi3+0x246>
  405a20:	3a02      	subs	r2, #2
  405a22:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  405a26:	4610      	mov	r0, r2
  405a28:	4619      	mov	r1, r3
  405a2a:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405a2e:	4770      	bx	lr
  405a30:	2300      	movs	r3, #0
  405a32:	461a      	mov	r2, r3
  405a34:	4610      	mov	r0, r2
  405a36:	4619      	mov	r1, r3
  405a38:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405a3c:	4770      	bx	lr
  405a3e:	f1c6 0520 	rsb	r5, r6, #32
  405a42:	fa22 f405 	lsr.w	r4, r2, r5
  405a46:	40b3      	lsls	r3, r6
  405a48:	431c      	orrs	r4, r3
  405a4a:	ea4f 4814 	mov.w	r8, r4, lsr #16
  405a4e:	fa21 f305 	lsr.w	r3, r1, r5
  405a52:	fa01 f706 	lsl.w	r7, r1, r6
  405a56:	fa20 f505 	lsr.w	r5, r0, r5
  405a5a:	fbb3 fcf8 	udiv	ip, r3, r8
  405a5e:	432f      	orrs	r7, r5
  405a60:	fb08 331c 	mls	r3, r8, ip, r3
  405a64:	0c3d      	lsrs	r5, r7, #16
  405a66:	fa1f fa84 	uxth.w	sl, r4
  405a6a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
  405a6e:	fb0a f90c 	mul.w	r9, sl, ip
  405a72:	4599      	cmp	r9, r3
  405a74:	fa02 fb06 	lsl.w	fp, r2, r6
  405a78:	d904      	bls.n	405a84 <__udivdi3+0x184>
  405a7a:	191b      	adds	r3, r3, r4
  405a7c:	f10c 32ff 	add.w	r2, ip, #4294967295
  405a80:	d36d      	bcc.n	405b5e <__udivdi3+0x25e>
  405a82:	4694      	mov	ip, r2
  405a84:	ebc9 0303 	rsb	r3, r9, r3
  405a88:	fbb3 f5f8 	udiv	r5, r3, r8
  405a8c:	fb08 3315 	mls	r3, r8, r5, r3
  405a90:	b2bf      	uxth	r7, r7
  405a92:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405a96:	fb0a f805 	mul.w	r8, sl, r5
  405a9a:	45b8      	cmp	r8, r7
  405a9c:	d904      	bls.n	405aa8 <__udivdi3+0x1a8>
  405a9e:	193f      	adds	r7, r7, r4
  405aa0:	f105 33ff 	add.w	r3, r5, #4294967295
  405aa4:	d361      	bcc.n	405b6a <__udivdi3+0x26a>
  405aa6:	461d      	mov	r5, r3
  405aa8:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
  405aac:	fbac 230b 	umull	r2, r3, ip, fp
  405ab0:	ebc8 0707 	rsb	r7, r8, r7
  405ab4:	429f      	cmp	r7, r3
  405ab6:	f04f 0500 	mov.w	r5, #0
  405aba:	d349      	bcc.n	405b50 <__udivdi3+0x250>
  405abc:	d045      	beq.n	405b4a <__udivdi3+0x24a>
  405abe:	4662      	mov	r2, ip
  405ac0:	462b      	mov	r3, r5
  405ac2:	e763      	b.n	40598c <__udivdi3+0x8c>
  405ac4:	4094      	lsls	r4, r2
  405ac6:	f1c2 0320 	rsb	r3, r2, #32
  405aca:	fa21 fc03 	lsr.w	ip, r1, r3
  405ace:	0c26      	lsrs	r6, r4, #16
  405ad0:	fa20 f303 	lsr.w	r3, r0, r3
  405ad4:	fa01 f502 	lsl.w	r5, r1, r2
  405ad8:	fbbc f8f6 	udiv	r8, ip, r6
  405adc:	ea43 0105 	orr.w	r1, r3, r5
  405ae0:	0c0b      	lsrs	r3, r1, #16
  405ae2:	fb06 cc18 	mls	ip, r6, r8, ip
  405ae6:	b2a7      	uxth	r7, r4
  405ae8:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
  405aec:	fb07 f308 	mul.w	r3, r7, r8
  405af0:	4563      	cmp	r3, ip
  405af2:	fa00 f502 	lsl.w	r5, r0, r2
  405af6:	d909      	bls.n	405b0c <__udivdi3+0x20c>
  405af8:	eb1c 0c04 	adds.w	ip, ip, r4
  405afc:	f108 32ff 	add.w	r2, r8, #4294967295
  405b00:	d23a      	bcs.n	405b78 <__udivdi3+0x278>
  405b02:	4563      	cmp	r3, ip
  405b04:	d938      	bls.n	405b78 <__udivdi3+0x278>
  405b06:	f1a8 0802 	sub.w	r8, r8, #2
  405b0a:	44a4      	add	ip, r4
  405b0c:	ebc3 0c0c 	rsb	ip, r3, ip
  405b10:	fbbc f3f6 	udiv	r3, ip, r6
  405b14:	b289      	uxth	r1, r1
  405b16:	fb06 cc13 	mls	ip, r6, r3, ip
  405b1a:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
  405b1e:	fb07 f203 	mul.w	r2, r7, r3
  405b22:	428a      	cmp	r2, r1
  405b24:	d907      	bls.n	405b36 <__udivdi3+0x236>
  405b26:	1909      	adds	r1, r1, r4
  405b28:	f103 30ff 	add.w	r0, r3, #4294967295
  405b2c:	d222      	bcs.n	405b74 <__udivdi3+0x274>
  405b2e:	428a      	cmp	r2, r1
  405b30:	d920      	bls.n	405b74 <__udivdi3+0x274>
  405b32:	3b02      	subs	r3, #2
  405b34:	4421      	add	r1, r4
  405b36:	1a89      	subs	r1, r1, r2
  405b38:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  405b3c:	e749      	b.n	4059d2 <__udivdi3+0xd2>
  405b3e:	463a      	mov	r2, r7
  405b40:	e70c      	b.n	40595c <__udivdi3+0x5c>
  405b42:	4633      	mov	r3, r6
  405b44:	e71f      	b.n	405986 <__udivdi3+0x86>
  405b46:	460a      	mov	r2, r1
  405b48:	e76b      	b.n	405a22 <__udivdi3+0x122>
  405b4a:	40b0      	lsls	r0, r6
  405b4c:	4290      	cmp	r0, r2
  405b4e:	d2b6      	bcs.n	405abe <__udivdi3+0x1be>
  405b50:	f10c 32ff 	add.w	r2, ip, #4294967295
  405b54:	2300      	movs	r3, #0
  405b56:	e719      	b.n	40598c <__udivdi3+0x8c>
  405b58:	4633      	mov	r3, r6
  405b5a:	4632      	mov	r2, r6
  405b5c:	e716      	b.n	40598c <__udivdi3+0x8c>
  405b5e:	4599      	cmp	r9, r3
  405b60:	d98f      	bls.n	405a82 <__udivdi3+0x182>
  405b62:	f1ac 0c02 	sub.w	ip, ip, #2
  405b66:	4423      	add	r3, r4
  405b68:	e78c      	b.n	405a84 <__udivdi3+0x184>
  405b6a:	45b8      	cmp	r8, r7
  405b6c:	d99b      	bls.n	405aa6 <__udivdi3+0x1a6>
  405b6e:	3d02      	subs	r5, #2
  405b70:	4427      	add	r7, r4
  405b72:	e799      	b.n	405aa8 <__udivdi3+0x1a8>
  405b74:	4603      	mov	r3, r0
  405b76:	e7de      	b.n	405b36 <__udivdi3+0x236>
  405b78:	4690      	mov	r8, r2
  405b7a:	e7c7      	b.n	405b0c <__udivdi3+0x20c>
  405b7c:	3802      	subs	r0, #2
  405b7e:	4421      	add	r1, r4
  405b80:	e73a      	b.n	4059f8 <__udivdi3+0xf8>
  405b82:	bf00      	nop

00405b84 <__libc_init_array>:
  405b84:	b570      	push	{r4, r5, r6, lr}
  405b86:	4e0f      	ldr	r6, [pc, #60]	; (405bc4 <__libc_init_array+0x40>)
  405b88:	4d0f      	ldr	r5, [pc, #60]	; (405bc8 <__libc_init_array+0x44>)
  405b8a:	1b76      	subs	r6, r6, r5
  405b8c:	10b6      	asrs	r6, r6, #2
  405b8e:	d007      	beq.n	405ba0 <__libc_init_array+0x1c>
  405b90:	3d04      	subs	r5, #4
  405b92:	2400      	movs	r4, #0
  405b94:	3401      	adds	r4, #1
  405b96:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405b9a:	4798      	blx	r3
  405b9c:	42a6      	cmp	r6, r4
  405b9e:	d1f9      	bne.n	405b94 <__libc_init_array+0x10>
  405ba0:	4e0a      	ldr	r6, [pc, #40]	; (405bcc <__libc_init_array+0x48>)
  405ba2:	4d0b      	ldr	r5, [pc, #44]	; (405bd0 <__libc_init_array+0x4c>)
  405ba4:	1b76      	subs	r6, r6, r5
  405ba6:	f001 f905 	bl	406db4 <_init>
  405baa:	10b6      	asrs	r6, r6, #2
  405bac:	d008      	beq.n	405bc0 <__libc_init_array+0x3c>
  405bae:	3d04      	subs	r5, #4
  405bb0:	2400      	movs	r4, #0
  405bb2:	3401      	adds	r4, #1
  405bb4:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405bb8:	4798      	blx	r3
  405bba:	42a6      	cmp	r6, r4
  405bbc:	d1f9      	bne.n	405bb2 <__libc_init_array+0x2e>
  405bbe:	bd70      	pop	{r4, r5, r6, pc}
  405bc0:	bd70      	pop	{r4, r5, r6, pc}
  405bc2:	bf00      	nop
  405bc4:	00406dc0 	.word	0x00406dc0
  405bc8:	00406dc0 	.word	0x00406dc0
  405bcc:	00406dc8 	.word	0x00406dc8
  405bd0:	00406dc0 	.word	0x00406dc0

00405bd4 <malloc>:
  405bd4:	4b02      	ldr	r3, [pc, #8]	; (405be0 <malloc+0xc>)
  405bd6:	4601      	mov	r1, r0
  405bd8:	6818      	ldr	r0, [r3, #0]
  405bda:	f000 b803 	b.w	405be4 <_malloc_r>
  405bde:	bf00      	nop
  405be0:	20000678 	.word	0x20000678

00405be4 <_malloc_r>:
  405be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405be8:	f101 050b 	add.w	r5, r1, #11
  405bec:	2d16      	cmp	r5, #22
  405bee:	b083      	sub	sp, #12
  405bf0:	4606      	mov	r6, r0
  405bf2:	d927      	bls.n	405c44 <_malloc_r+0x60>
  405bf4:	f035 0507 	bics.w	r5, r5, #7
  405bf8:	d427      	bmi.n	405c4a <_malloc_r+0x66>
  405bfa:	42a9      	cmp	r1, r5
  405bfc:	d825      	bhi.n	405c4a <_malloc_r+0x66>
  405bfe:	4630      	mov	r0, r6
  405c00:	f000 fb70 	bl	4062e4 <__malloc_lock>
  405c04:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  405c08:	d226      	bcs.n	405c58 <_malloc_r+0x74>
  405c0a:	4fc1      	ldr	r7, [pc, #772]	; (405f10 <_malloc_r+0x32c>)
  405c0c:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
  405c10:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
  405c14:	68dc      	ldr	r4, [r3, #12]
  405c16:	429c      	cmp	r4, r3
  405c18:	f000 81d2 	beq.w	405fc0 <_malloc_r+0x3dc>
  405c1c:	6863      	ldr	r3, [r4, #4]
  405c1e:	68e2      	ldr	r2, [r4, #12]
  405c20:	68a1      	ldr	r1, [r4, #8]
  405c22:	f023 0303 	bic.w	r3, r3, #3
  405c26:	4423      	add	r3, r4
  405c28:	4630      	mov	r0, r6
  405c2a:	685d      	ldr	r5, [r3, #4]
  405c2c:	60ca      	str	r2, [r1, #12]
  405c2e:	f045 0501 	orr.w	r5, r5, #1
  405c32:	6091      	str	r1, [r2, #8]
  405c34:	605d      	str	r5, [r3, #4]
  405c36:	f000 fb57 	bl	4062e8 <__malloc_unlock>
  405c3a:	3408      	adds	r4, #8
  405c3c:	4620      	mov	r0, r4
  405c3e:	b003      	add	sp, #12
  405c40:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405c44:	2510      	movs	r5, #16
  405c46:	42a9      	cmp	r1, r5
  405c48:	d9d9      	bls.n	405bfe <_malloc_r+0x1a>
  405c4a:	2400      	movs	r4, #0
  405c4c:	230c      	movs	r3, #12
  405c4e:	4620      	mov	r0, r4
  405c50:	6033      	str	r3, [r6, #0]
  405c52:	b003      	add	sp, #12
  405c54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405c58:	ea5f 2c55 	movs.w	ip, r5, lsr #9
  405c5c:	f000 808a 	beq.w	405d74 <_malloc_r+0x190>
  405c60:	f1bc 0f04 	cmp.w	ip, #4
  405c64:	f200 8160 	bhi.w	405f28 <_malloc_r+0x344>
  405c68:	ea4f 1c95 	mov.w	ip, r5, lsr #6
  405c6c:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
  405c70:	ea4f 014c 	mov.w	r1, ip, lsl #1
  405c74:	4fa6      	ldr	r7, [pc, #664]	; (405f10 <_malloc_r+0x32c>)
  405c76:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  405c7a:	68cc      	ldr	r4, [r1, #12]
  405c7c:	42a1      	cmp	r1, r4
  405c7e:	d105      	bne.n	405c8c <_malloc_r+0xa8>
  405c80:	e00c      	b.n	405c9c <_malloc_r+0xb8>
  405c82:	2b00      	cmp	r3, #0
  405c84:	da7a      	bge.n	405d7c <_malloc_r+0x198>
  405c86:	68e4      	ldr	r4, [r4, #12]
  405c88:	42a1      	cmp	r1, r4
  405c8a:	d007      	beq.n	405c9c <_malloc_r+0xb8>
  405c8c:	6862      	ldr	r2, [r4, #4]
  405c8e:	f022 0203 	bic.w	r2, r2, #3
  405c92:	1b53      	subs	r3, r2, r5
  405c94:	2b0f      	cmp	r3, #15
  405c96:	ddf4      	ble.n	405c82 <_malloc_r+0x9e>
  405c98:	f10c 3cff 	add.w	ip, ip, #4294967295
  405c9c:	f10c 0c01 	add.w	ip, ip, #1
  405ca0:	4b9b      	ldr	r3, [pc, #620]	; (405f10 <_malloc_r+0x32c>)
  405ca2:	693c      	ldr	r4, [r7, #16]
  405ca4:	f103 0e08 	add.w	lr, r3, #8
  405ca8:	4574      	cmp	r4, lr
  405caa:	f000 817e 	beq.w	405faa <_malloc_r+0x3c6>
  405cae:	6861      	ldr	r1, [r4, #4]
  405cb0:	f021 0103 	bic.w	r1, r1, #3
  405cb4:	1b4a      	subs	r2, r1, r5
  405cb6:	2a0f      	cmp	r2, #15
  405cb8:	f300 8164 	bgt.w	405f84 <_malloc_r+0x3a0>
  405cbc:	2a00      	cmp	r2, #0
  405cbe:	f8c3 e014 	str.w	lr, [r3, #20]
  405cc2:	f8c3 e010 	str.w	lr, [r3, #16]
  405cc6:	da6a      	bge.n	405d9e <_malloc_r+0x1ba>
  405cc8:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  405ccc:	f080 813a 	bcs.w	405f44 <_malloc_r+0x360>
  405cd0:	08c9      	lsrs	r1, r1, #3
  405cd2:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
  405cd6:	ea4f 08a1 	mov.w	r8, r1, asr #2
  405cda:	685a      	ldr	r2, [r3, #4]
  405cdc:	6881      	ldr	r1, [r0, #8]
  405cde:	60a1      	str	r1, [r4, #8]
  405ce0:	f04f 0901 	mov.w	r9, #1
  405ce4:	fa09 f808 	lsl.w	r8, r9, r8
  405ce8:	ea48 0202 	orr.w	r2, r8, r2
  405cec:	60e0      	str	r0, [r4, #12]
  405cee:	605a      	str	r2, [r3, #4]
  405cf0:	6084      	str	r4, [r0, #8]
  405cf2:	60cc      	str	r4, [r1, #12]
  405cf4:	ea4f 03ac 	mov.w	r3, ip, asr #2
  405cf8:	2001      	movs	r0, #1
  405cfa:	4098      	lsls	r0, r3
  405cfc:	4290      	cmp	r0, r2
  405cfe:	d85b      	bhi.n	405db8 <_malloc_r+0x1d4>
  405d00:	4202      	tst	r2, r0
  405d02:	d106      	bne.n	405d12 <_malloc_r+0x12e>
  405d04:	f02c 0c03 	bic.w	ip, ip, #3
  405d08:	0040      	lsls	r0, r0, #1
  405d0a:	4202      	tst	r2, r0
  405d0c:	f10c 0c04 	add.w	ip, ip, #4
  405d10:	d0fa      	beq.n	405d08 <_malloc_r+0x124>
  405d12:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
  405d16:	4644      	mov	r4, r8
  405d18:	46e1      	mov	r9, ip
  405d1a:	68e3      	ldr	r3, [r4, #12]
  405d1c:	429c      	cmp	r4, r3
  405d1e:	d107      	bne.n	405d30 <_malloc_r+0x14c>
  405d20:	e145      	b.n	405fae <_malloc_r+0x3ca>
  405d22:	2a00      	cmp	r2, #0
  405d24:	f280 8156 	bge.w	405fd4 <_malloc_r+0x3f0>
  405d28:	68db      	ldr	r3, [r3, #12]
  405d2a:	429c      	cmp	r4, r3
  405d2c:	f000 813f 	beq.w	405fae <_malloc_r+0x3ca>
  405d30:	6859      	ldr	r1, [r3, #4]
  405d32:	f021 0103 	bic.w	r1, r1, #3
  405d36:	1b4a      	subs	r2, r1, r5
  405d38:	2a0f      	cmp	r2, #15
  405d3a:	ddf2      	ble.n	405d22 <_malloc_r+0x13e>
  405d3c:	461c      	mov	r4, r3
  405d3e:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  405d42:	f854 8f08 	ldr.w	r8, [r4, #8]!
  405d46:	1959      	adds	r1, r3, r5
  405d48:	f045 0901 	orr.w	r9, r5, #1
  405d4c:	f042 0501 	orr.w	r5, r2, #1
  405d50:	f8c3 9004 	str.w	r9, [r3, #4]
  405d54:	4630      	mov	r0, r6
  405d56:	f8c8 c00c 	str.w	ip, [r8, #12]
  405d5a:	f8cc 8008 	str.w	r8, [ip, #8]
  405d5e:	6179      	str	r1, [r7, #20]
  405d60:	6139      	str	r1, [r7, #16]
  405d62:	f8c1 e00c 	str.w	lr, [r1, #12]
  405d66:	f8c1 e008 	str.w	lr, [r1, #8]
  405d6a:	604d      	str	r5, [r1, #4]
  405d6c:	508a      	str	r2, [r1, r2]
  405d6e:	f000 fabb 	bl	4062e8 <__malloc_unlock>
  405d72:	e763      	b.n	405c3c <_malloc_r+0x58>
  405d74:	217e      	movs	r1, #126	; 0x7e
  405d76:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  405d7a:	e77b      	b.n	405c74 <_malloc_r+0x90>
  405d7c:	4422      	add	r2, r4
  405d7e:	68e3      	ldr	r3, [r4, #12]
  405d80:	6850      	ldr	r0, [r2, #4]
  405d82:	68a1      	ldr	r1, [r4, #8]
  405d84:	f040 0501 	orr.w	r5, r0, #1
  405d88:	60cb      	str	r3, [r1, #12]
  405d8a:	4630      	mov	r0, r6
  405d8c:	6099      	str	r1, [r3, #8]
  405d8e:	6055      	str	r5, [r2, #4]
  405d90:	f000 faaa 	bl	4062e8 <__malloc_unlock>
  405d94:	3408      	adds	r4, #8
  405d96:	4620      	mov	r0, r4
  405d98:	b003      	add	sp, #12
  405d9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405d9e:	4421      	add	r1, r4
  405da0:	4630      	mov	r0, r6
  405da2:	684b      	ldr	r3, [r1, #4]
  405da4:	f043 0301 	orr.w	r3, r3, #1
  405da8:	604b      	str	r3, [r1, #4]
  405daa:	f000 fa9d 	bl	4062e8 <__malloc_unlock>
  405dae:	3408      	adds	r4, #8
  405db0:	4620      	mov	r0, r4
  405db2:	b003      	add	sp, #12
  405db4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405db8:	68bc      	ldr	r4, [r7, #8]
  405dba:	6863      	ldr	r3, [r4, #4]
  405dbc:	f023 0903 	bic.w	r9, r3, #3
  405dc0:	45a9      	cmp	r9, r5
  405dc2:	d304      	bcc.n	405dce <_malloc_r+0x1ea>
  405dc4:	ebc5 0309 	rsb	r3, r5, r9
  405dc8:	2b0f      	cmp	r3, #15
  405dca:	f300 8091 	bgt.w	405ef0 <_malloc_r+0x30c>
  405dce:	4b51      	ldr	r3, [pc, #324]	; (405f14 <_malloc_r+0x330>)
  405dd0:	4a51      	ldr	r2, [pc, #324]	; (405f18 <_malloc_r+0x334>)
  405dd2:	6819      	ldr	r1, [r3, #0]
  405dd4:	6813      	ldr	r3, [r2, #0]
  405dd6:	3301      	adds	r3, #1
  405dd8:	eb05 0a01 	add.w	sl, r5, r1
  405ddc:	eb04 0b09 	add.w	fp, r4, r9
  405de0:	f000 8161 	beq.w	4060a6 <_malloc_r+0x4c2>
  405de4:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
  405de8:	f10a 0a0f 	add.w	sl, sl, #15
  405dec:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
  405df0:	f02a 0a0f 	bic.w	sl, sl, #15
  405df4:	4630      	mov	r0, r6
  405df6:	4651      	mov	r1, sl
  405df8:	9201      	str	r2, [sp, #4]
  405dfa:	f000 fa77 	bl	4062ec <_sbrk_r>
  405dfe:	f1b0 3fff 	cmp.w	r0, #4294967295
  405e02:	4680      	mov	r8, r0
  405e04:	9a01      	ldr	r2, [sp, #4]
  405e06:	f000 8100 	beq.w	40600a <_malloc_r+0x426>
  405e0a:	4583      	cmp	fp, r0
  405e0c:	f200 80fa 	bhi.w	406004 <_malloc_r+0x420>
  405e10:	f8df c110 	ldr.w	ip, [pc, #272]	; 405f24 <_malloc_r+0x340>
  405e14:	f8dc 3000 	ldr.w	r3, [ip]
  405e18:	45c3      	cmp	fp, r8
  405e1a:	4453      	add	r3, sl
  405e1c:	f8cc 3000 	str.w	r3, [ip]
  405e20:	f000 814a 	beq.w	4060b8 <_malloc_r+0x4d4>
  405e24:	6812      	ldr	r2, [r2, #0]
  405e26:	493c      	ldr	r1, [pc, #240]	; (405f18 <_malloc_r+0x334>)
  405e28:	3201      	adds	r2, #1
  405e2a:	bf1b      	ittet	ne
  405e2c:	ebcb 0b08 	rsbne	fp, fp, r8
  405e30:	445b      	addne	r3, fp
  405e32:	f8c1 8000 	streq.w	r8, [r1]
  405e36:	f8cc 3000 	strne.w	r3, [ip]
  405e3a:	f018 0307 	ands.w	r3, r8, #7
  405e3e:	f000 8113 	beq.w	406068 <_malloc_r+0x484>
  405e42:	f1c3 0208 	rsb	r2, r3, #8
  405e46:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
  405e4a:	4490      	add	r8, r2
  405e4c:	3308      	adds	r3, #8
  405e4e:	44c2      	add	sl, r8
  405e50:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
  405e54:	ebca 0a03 	rsb	sl, sl, r3
  405e58:	4651      	mov	r1, sl
  405e5a:	4630      	mov	r0, r6
  405e5c:	f8cd c004 	str.w	ip, [sp, #4]
  405e60:	f000 fa44 	bl	4062ec <_sbrk_r>
  405e64:	1c43      	adds	r3, r0, #1
  405e66:	f8dd c004 	ldr.w	ip, [sp, #4]
  405e6a:	f000 8135 	beq.w	4060d8 <_malloc_r+0x4f4>
  405e6e:	ebc8 0200 	rsb	r2, r8, r0
  405e72:	4452      	add	r2, sl
  405e74:	f042 0201 	orr.w	r2, r2, #1
  405e78:	f8dc 3000 	ldr.w	r3, [ip]
  405e7c:	f8c7 8008 	str.w	r8, [r7, #8]
  405e80:	4453      	add	r3, sl
  405e82:	42bc      	cmp	r4, r7
  405e84:	f8c8 2004 	str.w	r2, [r8, #4]
  405e88:	f8cc 3000 	str.w	r3, [ip]
  405e8c:	f8df a094 	ldr.w	sl, [pc, #148]	; 405f24 <_malloc_r+0x340>
  405e90:	d015      	beq.n	405ebe <_malloc_r+0x2da>
  405e92:	f1b9 0f0f 	cmp.w	r9, #15
  405e96:	f240 80ea 	bls.w	40606e <_malloc_r+0x48a>
  405e9a:	6861      	ldr	r1, [r4, #4]
  405e9c:	f1a9 020c 	sub.w	r2, r9, #12
  405ea0:	f022 0207 	bic.w	r2, r2, #7
  405ea4:	f001 0e01 	and.w	lr, r1, #1
  405ea8:	18a1      	adds	r1, r4, r2
  405eaa:	2005      	movs	r0, #5
  405eac:	ea42 0e0e 	orr.w	lr, r2, lr
  405eb0:	2a0f      	cmp	r2, #15
  405eb2:	f8c4 e004 	str.w	lr, [r4, #4]
  405eb6:	6048      	str	r0, [r1, #4]
  405eb8:	6088      	str	r0, [r1, #8]
  405eba:	f200 8111 	bhi.w	4060e0 <_malloc_r+0x4fc>
  405ebe:	4a17      	ldr	r2, [pc, #92]	; (405f1c <_malloc_r+0x338>)
  405ec0:	68bc      	ldr	r4, [r7, #8]
  405ec2:	6811      	ldr	r1, [r2, #0]
  405ec4:	428b      	cmp	r3, r1
  405ec6:	bf88      	it	hi
  405ec8:	6013      	strhi	r3, [r2, #0]
  405eca:	4a15      	ldr	r2, [pc, #84]	; (405f20 <_malloc_r+0x33c>)
  405ecc:	6811      	ldr	r1, [r2, #0]
  405ece:	428b      	cmp	r3, r1
  405ed0:	bf88      	it	hi
  405ed2:	6013      	strhi	r3, [r2, #0]
  405ed4:	6862      	ldr	r2, [r4, #4]
  405ed6:	f022 0203 	bic.w	r2, r2, #3
  405eda:	4295      	cmp	r5, r2
  405edc:	ebc5 0302 	rsb	r3, r5, r2
  405ee0:	d801      	bhi.n	405ee6 <_malloc_r+0x302>
  405ee2:	2b0f      	cmp	r3, #15
  405ee4:	dc04      	bgt.n	405ef0 <_malloc_r+0x30c>
  405ee6:	4630      	mov	r0, r6
  405ee8:	f000 f9fe 	bl	4062e8 <__malloc_unlock>
  405eec:	2400      	movs	r4, #0
  405eee:	e6a5      	b.n	405c3c <_malloc_r+0x58>
  405ef0:	1962      	adds	r2, r4, r5
  405ef2:	f043 0301 	orr.w	r3, r3, #1
  405ef6:	f045 0501 	orr.w	r5, r5, #1
  405efa:	6065      	str	r5, [r4, #4]
  405efc:	4630      	mov	r0, r6
  405efe:	60ba      	str	r2, [r7, #8]
  405f00:	6053      	str	r3, [r2, #4]
  405f02:	f000 f9f1 	bl	4062e8 <__malloc_unlock>
  405f06:	3408      	adds	r4, #8
  405f08:	4620      	mov	r0, r4
  405f0a:	b003      	add	sp, #12
  405f0c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405f10:	2000067c 	.word	0x2000067c
  405f14:	200010d4 	.word	0x200010d4
  405f18:	20000a88 	.word	0x20000a88
  405f1c:	200010d0 	.word	0x200010d0
  405f20:	200010cc 	.word	0x200010cc
  405f24:	200010d8 	.word	0x200010d8
  405f28:	f1bc 0f14 	cmp.w	ip, #20
  405f2c:	d961      	bls.n	405ff2 <_malloc_r+0x40e>
  405f2e:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
  405f32:	f200 808f 	bhi.w	406054 <_malloc_r+0x470>
  405f36:	ea4f 3c15 	mov.w	ip, r5, lsr #12
  405f3a:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
  405f3e:	ea4f 014c 	mov.w	r1, ip, lsl #1
  405f42:	e697      	b.n	405c74 <_malloc_r+0x90>
  405f44:	0a4b      	lsrs	r3, r1, #9
  405f46:	2b04      	cmp	r3, #4
  405f48:	d958      	bls.n	405ffc <_malloc_r+0x418>
  405f4a:	2b14      	cmp	r3, #20
  405f4c:	f200 80ae 	bhi.w	4060ac <_malloc_r+0x4c8>
  405f50:	f103 025b 	add.w	r2, r3, #91	; 0x5b
  405f54:	0050      	lsls	r0, r2, #1
  405f56:	eb07 0080 	add.w	r0, r7, r0, lsl #2
  405f5a:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 406118 <_malloc_r+0x534>
  405f5e:	6883      	ldr	r3, [r0, #8]
  405f60:	4283      	cmp	r3, r0
  405f62:	f000 808a 	beq.w	40607a <_malloc_r+0x496>
  405f66:	685a      	ldr	r2, [r3, #4]
  405f68:	f022 0203 	bic.w	r2, r2, #3
  405f6c:	4291      	cmp	r1, r2
  405f6e:	d202      	bcs.n	405f76 <_malloc_r+0x392>
  405f70:	689b      	ldr	r3, [r3, #8]
  405f72:	4298      	cmp	r0, r3
  405f74:	d1f7      	bne.n	405f66 <_malloc_r+0x382>
  405f76:	68d9      	ldr	r1, [r3, #12]
  405f78:	687a      	ldr	r2, [r7, #4]
  405f7a:	60e1      	str	r1, [r4, #12]
  405f7c:	60a3      	str	r3, [r4, #8]
  405f7e:	608c      	str	r4, [r1, #8]
  405f80:	60dc      	str	r4, [r3, #12]
  405f82:	e6b7      	b.n	405cf4 <_malloc_r+0x110>
  405f84:	1961      	adds	r1, r4, r5
  405f86:	f042 0701 	orr.w	r7, r2, #1
  405f8a:	f045 0501 	orr.w	r5, r5, #1
  405f8e:	6065      	str	r5, [r4, #4]
  405f90:	4630      	mov	r0, r6
  405f92:	6159      	str	r1, [r3, #20]
  405f94:	6119      	str	r1, [r3, #16]
  405f96:	f8c1 e00c 	str.w	lr, [r1, #12]
  405f9a:	f8c1 e008 	str.w	lr, [r1, #8]
  405f9e:	604f      	str	r7, [r1, #4]
  405fa0:	508a      	str	r2, [r1, r2]
  405fa2:	3408      	adds	r4, #8
  405fa4:	f000 f9a0 	bl	4062e8 <__malloc_unlock>
  405fa8:	e648      	b.n	405c3c <_malloc_r+0x58>
  405faa:	685a      	ldr	r2, [r3, #4]
  405fac:	e6a2      	b.n	405cf4 <_malloc_r+0x110>
  405fae:	f109 0901 	add.w	r9, r9, #1
  405fb2:	f019 0f03 	tst.w	r9, #3
  405fb6:	f104 0408 	add.w	r4, r4, #8
  405fba:	f47f aeae 	bne.w	405d1a <_malloc_r+0x136>
  405fbe:	e02d      	b.n	40601c <_malloc_r+0x438>
  405fc0:	f104 0308 	add.w	r3, r4, #8
  405fc4:	6964      	ldr	r4, [r4, #20]
  405fc6:	42a3      	cmp	r3, r4
  405fc8:	bf08      	it	eq
  405fca:	f10c 0c02 	addeq.w	ip, ip, #2
  405fce:	f43f ae67 	beq.w	405ca0 <_malloc_r+0xbc>
  405fd2:	e623      	b.n	405c1c <_malloc_r+0x38>
  405fd4:	4419      	add	r1, r3
  405fd6:	461c      	mov	r4, r3
  405fd8:	6848      	ldr	r0, [r1, #4]
  405fda:	68db      	ldr	r3, [r3, #12]
  405fdc:	f854 2f08 	ldr.w	r2, [r4, #8]!
  405fe0:	f040 0501 	orr.w	r5, r0, #1
  405fe4:	604d      	str	r5, [r1, #4]
  405fe6:	4630      	mov	r0, r6
  405fe8:	60d3      	str	r3, [r2, #12]
  405fea:	609a      	str	r2, [r3, #8]
  405fec:	f000 f97c 	bl	4062e8 <__malloc_unlock>
  405ff0:	e624      	b.n	405c3c <_malloc_r+0x58>
  405ff2:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
  405ff6:	ea4f 014c 	mov.w	r1, ip, lsl #1
  405ffa:	e63b      	b.n	405c74 <_malloc_r+0x90>
  405ffc:	098a      	lsrs	r2, r1, #6
  405ffe:	3238      	adds	r2, #56	; 0x38
  406000:	0050      	lsls	r0, r2, #1
  406002:	e7a8      	b.n	405f56 <_malloc_r+0x372>
  406004:	42bc      	cmp	r4, r7
  406006:	f43f af03 	beq.w	405e10 <_malloc_r+0x22c>
  40600a:	68bc      	ldr	r4, [r7, #8]
  40600c:	6862      	ldr	r2, [r4, #4]
  40600e:	f022 0203 	bic.w	r2, r2, #3
  406012:	e762      	b.n	405eda <_malloc_r+0x2f6>
  406014:	f8d8 8000 	ldr.w	r8, [r8]
  406018:	4598      	cmp	r8, r3
  40601a:	d17b      	bne.n	406114 <_malloc_r+0x530>
  40601c:	f01c 0f03 	tst.w	ip, #3
  406020:	f1a8 0308 	sub.w	r3, r8, #8
  406024:	f10c 3cff 	add.w	ip, ip, #4294967295
  406028:	d1f4      	bne.n	406014 <_malloc_r+0x430>
  40602a:	687b      	ldr	r3, [r7, #4]
  40602c:	ea23 0300 	bic.w	r3, r3, r0
  406030:	607b      	str	r3, [r7, #4]
  406032:	0040      	lsls	r0, r0, #1
  406034:	4298      	cmp	r0, r3
  406036:	f63f aebf 	bhi.w	405db8 <_malloc_r+0x1d4>
  40603a:	2800      	cmp	r0, #0
  40603c:	f43f aebc 	beq.w	405db8 <_malloc_r+0x1d4>
  406040:	4203      	tst	r3, r0
  406042:	46cc      	mov	ip, r9
  406044:	f47f ae65 	bne.w	405d12 <_malloc_r+0x12e>
  406048:	0040      	lsls	r0, r0, #1
  40604a:	4203      	tst	r3, r0
  40604c:	f10c 0c04 	add.w	ip, ip, #4
  406050:	d0fa      	beq.n	406048 <_malloc_r+0x464>
  406052:	e65e      	b.n	405d12 <_malloc_r+0x12e>
  406054:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
  406058:	d81a      	bhi.n	406090 <_malloc_r+0x4ac>
  40605a:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
  40605e:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
  406062:	ea4f 014c 	mov.w	r1, ip, lsl #1
  406066:	e605      	b.n	405c74 <_malloc_r+0x90>
  406068:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  40606c:	e6ef      	b.n	405e4e <_malloc_r+0x26a>
  40606e:	2301      	movs	r3, #1
  406070:	f8c8 3004 	str.w	r3, [r8, #4]
  406074:	4644      	mov	r4, r8
  406076:	2200      	movs	r2, #0
  406078:	e72f      	b.n	405eda <_malloc_r+0x2f6>
  40607a:	1091      	asrs	r1, r2, #2
  40607c:	2001      	movs	r0, #1
  40607e:	f8d8 2004 	ldr.w	r2, [r8, #4]
  406082:	fa00 f101 	lsl.w	r1, r0, r1
  406086:	430a      	orrs	r2, r1
  406088:	f8c8 2004 	str.w	r2, [r8, #4]
  40608c:	4619      	mov	r1, r3
  40608e:	e774      	b.n	405f7a <_malloc_r+0x396>
  406090:	f240 5354 	movw	r3, #1364	; 0x554
  406094:	459c      	cmp	ip, r3
  406096:	d81b      	bhi.n	4060d0 <_malloc_r+0x4ec>
  406098:	ea4f 4c95 	mov.w	ip, r5, lsr #18
  40609c:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
  4060a0:	ea4f 014c 	mov.w	r1, ip, lsl #1
  4060a4:	e5e6      	b.n	405c74 <_malloc_r+0x90>
  4060a6:	f10a 0a10 	add.w	sl, sl, #16
  4060aa:	e6a3      	b.n	405df4 <_malloc_r+0x210>
  4060ac:	2b54      	cmp	r3, #84	; 0x54
  4060ae:	d81f      	bhi.n	4060f0 <_malloc_r+0x50c>
  4060b0:	0b0a      	lsrs	r2, r1, #12
  4060b2:	326e      	adds	r2, #110	; 0x6e
  4060b4:	0050      	lsls	r0, r2, #1
  4060b6:	e74e      	b.n	405f56 <_malloc_r+0x372>
  4060b8:	f3cb 010b 	ubfx	r1, fp, #0, #12
  4060bc:	2900      	cmp	r1, #0
  4060be:	f47f aeb1 	bne.w	405e24 <_malloc_r+0x240>
  4060c2:	eb0a 0109 	add.w	r1, sl, r9
  4060c6:	68ba      	ldr	r2, [r7, #8]
  4060c8:	f041 0101 	orr.w	r1, r1, #1
  4060cc:	6051      	str	r1, [r2, #4]
  4060ce:	e6f6      	b.n	405ebe <_malloc_r+0x2da>
  4060d0:	21fc      	movs	r1, #252	; 0xfc
  4060d2:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
  4060d6:	e5cd      	b.n	405c74 <_malloc_r+0x90>
  4060d8:	2201      	movs	r2, #1
  4060da:	f04f 0a00 	mov.w	sl, #0
  4060de:	e6cb      	b.n	405e78 <_malloc_r+0x294>
  4060e0:	f104 0108 	add.w	r1, r4, #8
  4060e4:	4630      	mov	r0, r6
  4060e6:	f000 f9eb 	bl	4064c0 <_free_r>
  4060ea:	f8da 3000 	ldr.w	r3, [sl]
  4060ee:	e6e6      	b.n	405ebe <_malloc_r+0x2da>
  4060f0:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  4060f4:	d803      	bhi.n	4060fe <_malloc_r+0x51a>
  4060f6:	0bca      	lsrs	r2, r1, #15
  4060f8:	3277      	adds	r2, #119	; 0x77
  4060fa:	0050      	lsls	r0, r2, #1
  4060fc:	e72b      	b.n	405f56 <_malloc_r+0x372>
  4060fe:	f240 5254 	movw	r2, #1364	; 0x554
  406102:	4293      	cmp	r3, r2
  406104:	d803      	bhi.n	40610e <_malloc_r+0x52a>
  406106:	0c8a      	lsrs	r2, r1, #18
  406108:	327c      	adds	r2, #124	; 0x7c
  40610a:	0050      	lsls	r0, r2, #1
  40610c:	e723      	b.n	405f56 <_malloc_r+0x372>
  40610e:	20fc      	movs	r0, #252	; 0xfc
  406110:	227e      	movs	r2, #126	; 0x7e
  406112:	e720      	b.n	405f56 <_malloc_r+0x372>
  406114:	687b      	ldr	r3, [r7, #4]
  406116:	e78c      	b.n	406032 <_malloc_r+0x44e>
  406118:	2000067c 	.word	0x2000067c

0040611c <memcpy>:
  40611c:	4684      	mov	ip, r0
  40611e:	ea41 0300 	orr.w	r3, r1, r0
  406122:	f013 0303 	ands.w	r3, r3, #3
  406126:	d16d      	bne.n	406204 <memcpy+0xe8>
  406128:	3a40      	subs	r2, #64	; 0x40
  40612a:	d341      	bcc.n	4061b0 <memcpy+0x94>
  40612c:	f851 3b04 	ldr.w	r3, [r1], #4
  406130:	f840 3b04 	str.w	r3, [r0], #4
  406134:	f851 3b04 	ldr.w	r3, [r1], #4
  406138:	f840 3b04 	str.w	r3, [r0], #4
  40613c:	f851 3b04 	ldr.w	r3, [r1], #4
  406140:	f840 3b04 	str.w	r3, [r0], #4
  406144:	f851 3b04 	ldr.w	r3, [r1], #4
  406148:	f840 3b04 	str.w	r3, [r0], #4
  40614c:	f851 3b04 	ldr.w	r3, [r1], #4
  406150:	f840 3b04 	str.w	r3, [r0], #4
  406154:	f851 3b04 	ldr.w	r3, [r1], #4
  406158:	f840 3b04 	str.w	r3, [r0], #4
  40615c:	f851 3b04 	ldr.w	r3, [r1], #4
  406160:	f840 3b04 	str.w	r3, [r0], #4
  406164:	f851 3b04 	ldr.w	r3, [r1], #4
  406168:	f840 3b04 	str.w	r3, [r0], #4
  40616c:	f851 3b04 	ldr.w	r3, [r1], #4
  406170:	f840 3b04 	str.w	r3, [r0], #4
  406174:	f851 3b04 	ldr.w	r3, [r1], #4
  406178:	f840 3b04 	str.w	r3, [r0], #4
  40617c:	f851 3b04 	ldr.w	r3, [r1], #4
  406180:	f840 3b04 	str.w	r3, [r0], #4
  406184:	f851 3b04 	ldr.w	r3, [r1], #4
  406188:	f840 3b04 	str.w	r3, [r0], #4
  40618c:	f851 3b04 	ldr.w	r3, [r1], #4
  406190:	f840 3b04 	str.w	r3, [r0], #4
  406194:	f851 3b04 	ldr.w	r3, [r1], #4
  406198:	f840 3b04 	str.w	r3, [r0], #4
  40619c:	f851 3b04 	ldr.w	r3, [r1], #4
  4061a0:	f840 3b04 	str.w	r3, [r0], #4
  4061a4:	f851 3b04 	ldr.w	r3, [r1], #4
  4061a8:	f840 3b04 	str.w	r3, [r0], #4
  4061ac:	3a40      	subs	r2, #64	; 0x40
  4061ae:	d2bd      	bcs.n	40612c <memcpy+0x10>
  4061b0:	3230      	adds	r2, #48	; 0x30
  4061b2:	d311      	bcc.n	4061d8 <memcpy+0xbc>
  4061b4:	f851 3b04 	ldr.w	r3, [r1], #4
  4061b8:	f840 3b04 	str.w	r3, [r0], #4
  4061bc:	f851 3b04 	ldr.w	r3, [r1], #4
  4061c0:	f840 3b04 	str.w	r3, [r0], #4
  4061c4:	f851 3b04 	ldr.w	r3, [r1], #4
  4061c8:	f840 3b04 	str.w	r3, [r0], #4
  4061cc:	f851 3b04 	ldr.w	r3, [r1], #4
  4061d0:	f840 3b04 	str.w	r3, [r0], #4
  4061d4:	3a10      	subs	r2, #16
  4061d6:	d2ed      	bcs.n	4061b4 <memcpy+0x98>
  4061d8:	320c      	adds	r2, #12
  4061da:	d305      	bcc.n	4061e8 <memcpy+0xcc>
  4061dc:	f851 3b04 	ldr.w	r3, [r1], #4
  4061e0:	f840 3b04 	str.w	r3, [r0], #4
  4061e4:	3a04      	subs	r2, #4
  4061e6:	d2f9      	bcs.n	4061dc <memcpy+0xc0>
  4061e8:	3204      	adds	r2, #4
  4061ea:	d008      	beq.n	4061fe <memcpy+0xe2>
  4061ec:	07d2      	lsls	r2, r2, #31
  4061ee:	bf1c      	itt	ne
  4061f0:	f811 3b01 	ldrbne.w	r3, [r1], #1
  4061f4:	f800 3b01 	strbne.w	r3, [r0], #1
  4061f8:	d301      	bcc.n	4061fe <memcpy+0xe2>
  4061fa:	880b      	ldrh	r3, [r1, #0]
  4061fc:	8003      	strh	r3, [r0, #0]
  4061fe:	4660      	mov	r0, ip
  406200:	4770      	bx	lr
  406202:	bf00      	nop
  406204:	2a08      	cmp	r2, #8
  406206:	d313      	bcc.n	406230 <memcpy+0x114>
  406208:	078b      	lsls	r3, r1, #30
  40620a:	d08d      	beq.n	406128 <memcpy+0xc>
  40620c:	f010 0303 	ands.w	r3, r0, #3
  406210:	d08a      	beq.n	406128 <memcpy+0xc>
  406212:	f1c3 0304 	rsb	r3, r3, #4
  406216:	1ad2      	subs	r2, r2, r3
  406218:	07db      	lsls	r3, r3, #31
  40621a:	bf1c      	itt	ne
  40621c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  406220:	f800 3b01 	strbne.w	r3, [r0], #1
  406224:	d380      	bcc.n	406128 <memcpy+0xc>
  406226:	f831 3b02 	ldrh.w	r3, [r1], #2
  40622a:	f820 3b02 	strh.w	r3, [r0], #2
  40622e:	e77b      	b.n	406128 <memcpy+0xc>
  406230:	3a04      	subs	r2, #4
  406232:	d3d9      	bcc.n	4061e8 <memcpy+0xcc>
  406234:	3a01      	subs	r2, #1
  406236:	f811 3b01 	ldrb.w	r3, [r1], #1
  40623a:	f800 3b01 	strb.w	r3, [r0], #1
  40623e:	d2f9      	bcs.n	406234 <memcpy+0x118>
  406240:	780b      	ldrb	r3, [r1, #0]
  406242:	7003      	strb	r3, [r0, #0]
  406244:	784b      	ldrb	r3, [r1, #1]
  406246:	7043      	strb	r3, [r0, #1]
  406248:	788b      	ldrb	r3, [r1, #2]
  40624a:	7083      	strb	r3, [r0, #2]
  40624c:	4660      	mov	r0, ip
  40624e:	4770      	bx	lr

00406250 <memset>:
  406250:	b4f0      	push	{r4, r5, r6, r7}
  406252:	0784      	lsls	r4, r0, #30
  406254:	d043      	beq.n	4062de <memset+0x8e>
  406256:	1e54      	subs	r4, r2, #1
  406258:	2a00      	cmp	r2, #0
  40625a:	d03e      	beq.n	4062da <memset+0x8a>
  40625c:	b2cd      	uxtb	r5, r1
  40625e:	4603      	mov	r3, r0
  406260:	e003      	b.n	40626a <memset+0x1a>
  406262:	1e62      	subs	r2, r4, #1
  406264:	2c00      	cmp	r4, #0
  406266:	d038      	beq.n	4062da <memset+0x8a>
  406268:	4614      	mov	r4, r2
  40626a:	f803 5b01 	strb.w	r5, [r3], #1
  40626e:	079a      	lsls	r2, r3, #30
  406270:	d1f7      	bne.n	406262 <memset+0x12>
  406272:	2c03      	cmp	r4, #3
  406274:	d92a      	bls.n	4062cc <memset+0x7c>
  406276:	b2cd      	uxtb	r5, r1
  406278:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  40627c:	2c0f      	cmp	r4, #15
  40627e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  406282:	d915      	bls.n	4062b0 <memset+0x60>
  406284:	f1a4 0710 	sub.w	r7, r4, #16
  406288:	093f      	lsrs	r7, r7, #4
  40628a:	f103 0610 	add.w	r6, r3, #16
  40628e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  406292:	461a      	mov	r2, r3
  406294:	6015      	str	r5, [r2, #0]
  406296:	6055      	str	r5, [r2, #4]
  406298:	6095      	str	r5, [r2, #8]
  40629a:	60d5      	str	r5, [r2, #12]
  40629c:	3210      	adds	r2, #16
  40629e:	42b2      	cmp	r2, r6
  4062a0:	d1f8      	bne.n	406294 <memset+0x44>
  4062a2:	f004 040f 	and.w	r4, r4, #15
  4062a6:	3701      	adds	r7, #1
  4062a8:	2c03      	cmp	r4, #3
  4062aa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4062ae:	d90d      	bls.n	4062cc <memset+0x7c>
  4062b0:	461e      	mov	r6, r3
  4062b2:	4622      	mov	r2, r4
  4062b4:	3a04      	subs	r2, #4
  4062b6:	2a03      	cmp	r2, #3
  4062b8:	f846 5b04 	str.w	r5, [r6], #4
  4062bc:	d8fa      	bhi.n	4062b4 <memset+0x64>
  4062be:	1f22      	subs	r2, r4, #4
  4062c0:	f022 0203 	bic.w	r2, r2, #3
  4062c4:	3204      	adds	r2, #4
  4062c6:	4413      	add	r3, r2
  4062c8:	f004 0403 	and.w	r4, r4, #3
  4062cc:	b12c      	cbz	r4, 4062da <memset+0x8a>
  4062ce:	b2c9      	uxtb	r1, r1
  4062d0:	441c      	add	r4, r3
  4062d2:	f803 1b01 	strb.w	r1, [r3], #1
  4062d6:	42a3      	cmp	r3, r4
  4062d8:	d1fb      	bne.n	4062d2 <memset+0x82>
  4062da:	bcf0      	pop	{r4, r5, r6, r7}
  4062dc:	4770      	bx	lr
  4062de:	4614      	mov	r4, r2
  4062e0:	4603      	mov	r3, r0
  4062e2:	e7c6      	b.n	406272 <memset+0x22>

004062e4 <__malloc_lock>:
  4062e4:	4770      	bx	lr
  4062e6:	bf00      	nop

004062e8 <__malloc_unlock>:
  4062e8:	4770      	bx	lr
  4062ea:	bf00      	nop

004062ec <_sbrk_r>:
  4062ec:	b538      	push	{r3, r4, r5, lr}
  4062ee:	4c07      	ldr	r4, [pc, #28]	; (40630c <_sbrk_r+0x20>)
  4062f0:	2300      	movs	r3, #0
  4062f2:	4605      	mov	r5, r0
  4062f4:	4608      	mov	r0, r1
  4062f6:	6023      	str	r3, [r4, #0]
  4062f8:	f7ff f92a 	bl	405550 <_sbrk>
  4062fc:	1c43      	adds	r3, r0, #1
  4062fe:	d000      	beq.n	406302 <_sbrk_r+0x16>
  406300:	bd38      	pop	{r3, r4, r5, pc}
  406302:	6823      	ldr	r3, [r4, #0]
  406304:	2b00      	cmp	r3, #0
  406306:	d0fb      	beq.n	406300 <_sbrk_r+0x14>
  406308:	602b      	str	r3, [r5, #0]
  40630a:	bd38      	pop	{r3, r4, r5, pc}
  40630c:	200023b4 	.word	0x200023b4

00406310 <strlen>:
  406310:	f020 0103 	bic.w	r1, r0, #3
  406314:	f010 0003 	ands.w	r0, r0, #3
  406318:	f1c0 0000 	rsb	r0, r0, #0
  40631c:	f851 3b04 	ldr.w	r3, [r1], #4
  406320:	f100 0c04 	add.w	ip, r0, #4
  406324:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  406328:	f06f 0200 	mvn.w	r2, #0
  40632c:	bf1c      	itt	ne
  40632e:	fa22 f20c 	lsrne.w	r2, r2, ip
  406332:	4313      	orrne	r3, r2
  406334:	f04f 0c01 	mov.w	ip, #1
  406338:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  40633c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  406340:	eba3 020c 	sub.w	r2, r3, ip
  406344:	ea22 0203 	bic.w	r2, r2, r3
  406348:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  40634c:	bf04      	itt	eq
  40634e:	f851 3b04 	ldreq.w	r3, [r1], #4
  406352:	3004      	addeq	r0, #4
  406354:	d0f4      	beq.n	406340 <strlen+0x30>
  406356:	f013 0fff 	tst.w	r3, #255	; 0xff
  40635a:	bf1f      	itttt	ne
  40635c:	3001      	addne	r0, #1
  40635e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
  406362:	3001      	addne	r0, #1
  406364:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
  406368:	bf18      	it	ne
  40636a:	3001      	addne	r0, #1
  40636c:	4770      	bx	lr
  40636e:	bf00      	nop

00406370 <strncpy>:
  406370:	ea40 0301 	orr.w	r3, r0, r1
  406374:	079b      	lsls	r3, r3, #30
  406376:	b470      	push	{r4, r5, r6}
  406378:	d12a      	bne.n	4063d0 <strncpy+0x60>
  40637a:	2a03      	cmp	r2, #3
  40637c:	d928      	bls.n	4063d0 <strncpy+0x60>
  40637e:	460c      	mov	r4, r1
  406380:	4603      	mov	r3, r0
  406382:	4621      	mov	r1, r4
  406384:	f854 5b04 	ldr.w	r5, [r4], #4
  406388:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
  40638c:	ea26 0605 	bic.w	r6, r6, r5
  406390:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
  406394:	d105      	bne.n	4063a2 <strncpy+0x32>
  406396:	3a04      	subs	r2, #4
  406398:	2a03      	cmp	r2, #3
  40639a:	f843 5b04 	str.w	r5, [r3], #4
  40639e:	4621      	mov	r1, r4
  4063a0:	d8ef      	bhi.n	406382 <strncpy+0x12>
  4063a2:	b19a      	cbz	r2, 4063cc <strncpy+0x5c>
  4063a4:	780c      	ldrb	r4, [r1, #0]
  4063a6:	701c      	strb	r4, [r3, #0]
  4063a8:	3a01      	subs	r2, #1
  4063aa:	3301      	adds	r3, #1
  4063ac:	b13c      	cbz	r4, 4063be <strncpy+0x4e>
  4063ae:	b16a      	cbz	r2, 4063cc <strncpy+0x5c>
  4063b0:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  4063b4:	f803 4b01 	strb.w	r4, [r3], #1
  4063b8:	3a01      	subs	r2, #1
  4063ba:	2c00      	cmp	r4, #0
  4063bc:	d1f7      	bne.n	4063ae <strncpy+0x3e>
  4063be:	b12a      	cbz	r2, 4063cc <strncpy+0x5c>
  4063c0:	441a      	add	r2, r3
  4063c2:	2100      	movs	r1, #0
  4063c4:	f803 1b01 	strb.w	r1, [r3], #1
  4063c8:	4293      	cmp	r3, r2
  4063ca:	d1fb      	bne.n	4063c4 <strncpy+0x54>
  4063cc:	bc70      	pop	{r4, r5, r6}
  4063ce:	4770      	bx	lr
  4063d0:	4603      	mov	r3, r0
  4063d2:	e7e6      	b.n	4063a2 <strncpy+0x32>

004063d4 <register_fini>:
  4063d4:	4b02      	ldr	r3, [pc, #8]	; (4063e0 <register_fini+0xc>)
  4063d6:	b113      	cbz	r3, 4063de <register_fini+0xa>
  4063d8:	4802      	ldr	r0, [pc, #8]	; (4063e4 <register_fini+0x10>)
  4063da:	f000 b805 	b.w	4063e8 <atexit>
  4063de:	4770      	bx	lr
  4063e0:	00000000 	.word	0x00000000
  4063e4:	004063f5 	.word	0x004063f5

004063e8 <atexit>:
  4063e8:	4601      	mov	r1, r0
  4063ea:	2000      	movs	r0, #0
  4063ec:	4602      	mov	r2, r0
  4063ee:	4603      	mov	r3, r0
  4063f0:	f000 b934 	b.w	40665c <__register_exitproc>

004063f4 <__libc_fini_array>:
  4063f4:	b538      	push	{r3, r4, r5, lr}
  4063f6:	4d09      	ldr	r5, [pc, #36]	; (40641c <__libc_fini_array+0x28>)
  4063f8:	4c09      	ldr	r4, [pc, #36]	; (406420 <__libc_fini_array+0x2c>)
  4063fa:	1b64      	subs	r4, r4, r5
  4063fc:	10a4      	asrs	r4, r4, #2
  4063fe:	bf18      	it	ne
  406400:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  406404:	d005      	beq.n	406412 <__libc_fini_array+0x1e>
  406406:	3c01      	subs	r4, #1
  406408:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  40640c:	4798      	blx	r3
  40640e:	2c00      	cmp	r4, #0
  406410:	d1f9      	bne.n	406406 <__libc_fini_array+0x12>
  406412:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  406416:	f000 bcd7 	b.w	406dc8 <_fini>
  40641a:	bf00      	nop
  40641c:	00406dd4 	.word	0x00406dd4
  406420:	00406dd8 	.word	0x00406dd8

00406424 <_malloc_trim_r>:
  406424:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406426:	4d23      	ldr	r5, [pc, #140]	; (4064b4 <_malloc_trim_r+0x90>)
  406428:	460f      	mov	r7, r1
  40642a:	4604      	mov	r4, r0
  40642c:	f7ff ff5a 	bl	4062e4 <__malloc_lock>
  406430:	68ab      	ldr	r3, [r5, #8]
  406432:	685e      	ldr	r6, [r3, #4]
  406434:	f026 0603 	bic.w	r6, r6, #3
  406438:	1bf1      	subs	r1, r6, r7
  40643a:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  40643e:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  406442:	f021 010f 	bic.w	r1, r1, #15
  406446:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
  40644a:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
  40644e:	db07      	blt.n	406460 <_malloc_trim_r+0x3c>
  406450:	4620      	mov	r0, r4
  406452:	2100      	movs	r1, #0
  406454:	f7ff ff4a 	bl	4062ec <_sbrk_r>
  406458:	68ab      	ldr	r3, [r5, #8]
  40645a:	4433      	add	r3, r6
  40645c:	4298      	cmp	r0, r3
  40645e:	d004      	beq.n	40646a <_malloc_trim_r+0x46>
  406460:	4620      	mov	r0, r4
  406462:	f7ff ff41 	bl	4062e8 <__malloc_unlock>
  406466:	2000      	movs	r0, #0
  406468:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40646a:	4620      	mov	r0, r4
  40646c:	4279      	negs	r1, r7
  40646e:	f7ff ff3d 	bl	4062ec <_sbrk_r>
  406472:	3001      	adds	r0, #1
  406474:	d00d      	beq.n	406492 <_malloc_trim_r+0x6e>
  406476:	4b10      	ldr	r3, [pc, #64]	; (4064b8 <_malloc_trim_r+0x94>)
  406478:	68aa      	ldr	r2, [r5, #8]
  40647a:	6819      	ldr	r1, [r3, #0]
  40647c:	1bf6      	subs	r6, r6, r7
  40647e:	f046 0601 	orr.w	r6, r6, #1
  406482:	4620      	mov	r0, r4
  406484:	1bc9      	subs	r1, r1, r7
  406486:	6056      	str	r6, [r2, #4]
  406488:	6019      	str	r1, [r3, #0]
  40648a:	f7ff ff2d 	bl	4062e8 <__malloc_unlock>
  40648e:	2001      	movs	r0, #1
  406490:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406492:	4620      	mov	r0, r4
  406494:	2100      	movs	r1, #0
  406496:	f7ff ff29 	bl	4062ec <_sbrk_r>
  40649a:	68ab      	ldr	r3, [r5, #8]
  40649c:	1ac2      	subs	r2, r0, r3
  40649e:	2a0f      	cmp	r2, #15
  4064a0:	ddde      	ble.n	406460 <_malloc_trim_r+0x3c>
  4064a2:	4d06      	ldr	r5, [pc, #24]	; (4064bc <_malloc_trim_r+0x98>)
  4064a4:	4904      	ldr	r1, [pc, #16]	; (4064b8 <_malloc_trim_r+0x94>)
  4064a6:	682d      	ldr	r5, [r5, #0]
  4064a8:	f042 0201 	orr.w	r2, r2, #1
  4064ac:	1b40      	subs	r0, r0, r5
  4064ae:	605a      	str	r2, [r3, #4]
  4064b0:	6008      	str	r0, [r1, #0]
  4064b2:	e7d5      	b.n	406460 <_malloc_trim_r+0x3c>
  4064b4:	2000067c 	.word	0x2000067c
  4064b8:	200010d8 	.word	0x200010d8
  4064bc:	20000a88 	.word	0x20000a88

004064c0 <_free_r>:
  4064c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4064c4:	460d      	mov	r5, r1
  4064c6:	4606      	mov	r6, r0
  4064c8:	2900      	cmp	r1, #0
  4064ca:	d055      	beq.n	406578 <_free_r+0xb8>
  4064cc:	f7ff ff0a 	bl	4062e4 <__malloc_lock>
  4064d0:	f855 1c04 	ldr.w	r1, [r5, #-4]
  4064d4:	f8df c174 	ldr.w	ip, [pc, #372]	; 40664c <_free_r+0x18c>
  4064d8:	f021 0301 	bic.w	r3, r1, #1
  4064dc:	f1a5 0408 	sub.w	r4, r5, #8
  4064e0:	18e2      	adds	r2, r4, r3
  4064e2:	f8dc 0008 	ldr.w	r0, [ip, #8]
  4064e6:	6857      	ldr	r7, [r2, #4]
  4064e8:	4290      	cmp	r0, r2
  4064ea:	f027 0703 	bic.w	r7, r7, #3
  4064ee:	d069      	beq.n	4065c4 <_free_r+0x104>
  4064f0:	f011 0101 	ands.w	r1, r1, #1
  4064f4:	6057      	str	r7, [r2, #4]
  4064f6:	d032      	beq.n	40655e <_free_r+0x9e>
  4064f8:	2100      	movs	r1, #0
  4064fa:	19d0      	adds	r0, r2, r7
  4064fc:	6840      	ldr	r0, [r0, #4]
  4064fe:	07c0      	lsls	r0, r0, #31
  406500:	d406      	bmi.n	406510 <_free_r+0x50>
  406502:	443b      	add	r3, r7
  406504:	6890      	ldr	r0, [r2, #8]
  406506:	2900      	cmp	r1, #0
  406508:	d04e      	beq.n	4065a8 <_free_r+0xe8>
  40650a:	68d2      	ldr	r2, [r2, #12]
  40650c:	60c2      	str	r2, [r0, #12]
  40650e:	6090      	str	r0, [r2, #8]
  406510:	f043 0201 	orr.w	r2, r3, #1
  406514:	6062      	str	r2, [r4, #4]
  406516:	50e3      	str	r3, [r4, r3]
  406518:	b9e1      	cbnz	r1, 406554 <_free_r+0x94>
  40651a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40651e:	d32d      	bcc.n	40657c <_free_r+0xbc>
  406520:	0a5a      	lsrs	r2, r3, #9
  406522:	2a04      	cmp	r2, #4
  406524:	d86a      	bhi.n	4065fc <_free_r+0x13c>
  406526:	0998      	lsrs	r0, r3, #6
  406528:	3038      	adds	r0, #56	; 0x38
  40652a:	0041      	lsls	r1, r0, #1
  40652c:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
  406530:	4946      	ldr	r1, [pc, #280]	; (40664c <_free_r+0x18c>)
  406532:	f8dc 2008 	ldr.w	r2, [ip, #8]
  406536:	4562      	cmp	r2, ip
  406538:	d066      	beq.n	406608 <_free_r+0x148>
  40653a:	6851      	ldr	r1, [r2, #4]
  40653c:	f021 0103 	bic.w	r1, r1, #3
  406540:	428b      	cmp	r3, r1
  406542:	d202      	bcs.n	40654a <_free_r+0x8a>
  406544:	6892      	ldr	r2, [r2, #8]
  406546:	4594      	cmp	ip, r2
  406548:	d1f7      	bne.n	40653a <_free_r+0x7a>
  40654a:	68d3      	ldr	r3, [r2, #12]
  40654c:	60e3      	str	r3, [r4, #12]
  40654e:	60a2      	str	r2, [r4, #8]
  406550:	609c      	str	r4, [r3, #8]
  406552:	60d4      	str	r4, [r2, #12]
  406554:	4630      	mov	r0, r6
  406556:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  40655a:	f7ff bec5 	b.w	4062e8 <__malloc_unlock>
  40655e:	f855 5c08 	ldr.w	r5, [r5, #-8]
  406562:	1b64      	subs	r4, r4, r5
  406564:	f10c 0808 	add.w	r8, ip, #8
  406568:	68a0      	ldr	r0, [r4, #8]
  40656a:	4540      	cmp	r0, r8
  40656c:	442b      	add	r3, r5
  40656e:	d043      	beq.n	4065f8 <_free_r+0x138>
  406570:	68e5      	ldr	r5, [r4, #12]
  406572:	60c5      	str	r5, [r0, #12]
  406574:	60a8      	str	r0, [r5, #8]
  406576:	e7c0      	b.n	4064fa <_free_r+0x3a>
  406578:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40657c:	08db      	lsrs	r3, r3, #3
  40657e:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
  406582:	2501      	movs	r5, #1
  406584:	f8dc 0004 	ldr.w	r0, [ip, #4]
  406588:	6891      	ldr	r1, [r2, #8]
  40658a:	60a1      	str	r1, [r4, #8]
  40658c:	109b      	asrs	r3, r3, #2
  40658e:	fa05 f303 	lsl.w	r3, r5, r3
  406592:	4318      	orrs	r0, r3
  406594:	60e2      	str	r2, [r4, #12]
  406596:	f8cc 0004 	str.w	r0, [ip, #4]
  40659a:	6094      	str	r4, [r2, #8]
  40659c:	4630      	mov	r0, r6
  40659e:	60cc      	str	r4, [r1, #12]
  4065a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4065a4:	f7ff bea0 	b.w	4062e8 <__malloc_unlock>
  4065a8:	4d29      	ldr	r5, [pc, #164]	; (406650 <_free_r+0x190>)
  4065aa:	42a8      	cmp	r0, r5
  4065ac:	d1ad      	bne.n	40650a <_free_r+0x4a>
  4065ae:	f043 0201 	orr.w	r2, r3, #1
  4065b2:	f8cc 4014 	str.w	r4, [ip, #20]
  4065b6:	f8cc 4010 	str.w	r4, [ip, #16]
  4065ba:	60e0      	str	r0, [r4, #12]
  4065bc:	60a0      	str	r0, [r4, #8]
  4065be:	6062      	str	r2, [r4, #4]
  4065c0:	50e3      	str	r3, [r4, r3]
  4065c2:	e7c7      	b.n	406554 <_free_r+0x94>
  4065c4:	441f      	add	r7, r3
  4065c6:	07cb      	lsls	r3, r1, #31
  4065c8:	d407      	bmi.n	4065da <_free_r+0x11a>
  4065ca:	f855 3c08 	ldr.w	r3, [r5, #-8]
  4065ce:	1ae4      	subs	r4, r4, r3
  4065d0:	441f      	add	r7, r3
  4065d2:	68a2      	ldr	r2, [r4, #8]
  4065d4:	68e3      	ldr	r3, [r4, #12]
  4065d6:	60d3      	str	r3, [r2, #12]
  4065d8:	609a      	str	r2, [r3, #8]
  4065da:	4b1e      	ldr	r3, [pc, #120]	; (406654 <_free_r+0x194>)
  4065dc:	681b      	ldr	r3, [r3, #0]
  4065de:	f047 0201 	orr.w	r2, r7, #1
  4065e2:	429f      	cmp	r7, r3
  4065e4:	6062      	str	r2, [r4, #4]
  4065e6:	f8cc 4008 	str.w	r4, [ip, #8]
  4065ea:	d3b3      	bcc.n	406554 <_free_r+0x94>
  4065ec:	4b1a      	ldr	r3, [pc, #104]	; (406658 <_free_r+0x198>)
  4065ee:	4630      	mov	r0, r6
  4065f0:	6819      	ldr	r1, [r3, #0]
  4065f2:	f7ff ff17 	bl	406424 <_malloc_trim_r>
  4065f6:	e7ad      	b.n	406554 <_free_r+0x94>
  4065f8:	2101      	movs	r1, #1
  4065fa:	e77e      	b.n	4064fa <_free_r+0x3a>
  4065fc:	2a14      	cmp	r2, #20
  4065fe:	d80c      	bhi.n	40661a <_free_r+0x15a>
  406600:	f102 005b 	add.w	r0, r2, #91	; 0x5b
  406604:	0041      	lsls	r1, r0, #1
  406606:	e791      	b.n	40652c <_free_r+0x6c>
  406608:	684b      	ldr	r3, [r1, #4]
  40660a:	1080      	asrs	r0, r0, #2
  40660c:	2501      	movs	r5, #1
  40660e:	fa05 f000 	lsl.w	r0, r5, r0
  406612:	4303      	orrs	r3, r0
  406614:	604b      	str	r3, [r1, #4]
  406616:	4613      	mov	r3, r2
  406618:	e798      	b.n	40654c <_free_r+0x8c>
  40661a:	2a54      	cmp	r2, #84	; 0x54
  40661c:	d803      	bhi.n	406626 <_free_r+0x166>
  40661e:	0b18      	lsrs	r0, r3, #12
  406620:	306e      	adds	r0, #110	; 0x6e
  406622:	0041      	lsls	r1, r0, #1
  406624:	e782      	b.n	40652c <_free_r+0x6c>
  406626:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  40662a:	d803      	bhi.n	406634 <_free_r+0x174>
  40662c:	0bd8      	lsrs	r0, r3, #15
  40662e:	3077      	adds	r0, #119	; 0x77
  406630:	0041      	lsls	r1, r0, #1
  406632:	e77b      	b.n	40652c <_free_r+0x6c>
  406634:	f240 5154 	movw	r1, #1364	; 0x554
  406638:	428a      	cmp	r2, r1
  40663a:	d803      	bhi.n	406644 <_free_r+0x184>
  40663c:	0c98      	lsrs	r0, r3, #18
  40663e:	307c      	adds	r0, #124	; 0x7c
  406640:	0041      	lsls	r1, r0, #1
  406642:	e773      	b.n	40652c <_free_r+0x6c>
  406644:	21fc      	movs	r1, #252	; 0xfc
  406646:	207e      	movs	r0, #126	; 0x7e
  406648:	e770      	b.n	40652c <_free_r+0x6c>
  40664a:	bf00      	nop
  40664c:	2000067c 	.word	0x2000067c
  406650:	20000684 	.word	0x20000684
  406654:	20000a84 	.word	0x20000a84
  406658:	200010d4 	.word	0x200010d4

0040665c <__register_exitproc>:
  40665c:	b5f0      	push	{r4, r5, r6, r7, lr}
  40665e:	4c27      	ldr	r4, [pc, #156]	; (4066fc <__register_exitproc+0xa0>)
  406660:	6826      	ldr	r6, [r4, #0]
  406662:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  406666:	b085      	sub	sp, #20
  406668:	4607      	mov	r7, r0
  40666a:	2c00      	cmp	r4, #0
  40666c:	d041      	beq.n	4066f2 <__register_exitproc+0x96>
  40666e:	6865      	ldr	r5, [r4, #4]
  406670:	2d1f      	cmp	r5, #31
  406672:	dd1e      	ble.n	4066b2 <__register_exitproc+0x56>
  406674:	4822      	ldr	r0, [pc, #136]	; (406700 <__register_exitproc+0xa4>)
  406676:	b918      	cbnz	r0, 406680 <__register_exitproc+0x24>
  406678:	f04f 30ff 	mov.w	r0, #4294967295
  40667c:	b005      	add	sp, #20
  40667e:	bdf0      	pop	{r4, r5, r6, r7, pc}
  406680:	f44f 70c8 	mov.w	r0, #400	; 0x190
  406684:	9103      	str	r1, [sp, #12]
  406686:	9202      	str	r2, [sp, #8]
  406688:	9301      	str	r3, [sp, #4]
  40668a:	f7ff faa3 	bl	405bd4 <malloc>
  40668e:	9903      	ldr	r1, [sp, #12]
  406690:	9a02      	ldr	r2, [sp, #8]
  406692:	9b01      	ldr	r3, [sp, #4]
  406694:	4604      	mov	r4, r0
  406696:	2800      	cmp	r0, #0
  406698:	d0ee      	beq.n	406678 <__register_exitproc+0x1c>
  40669a:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  40669e:	6025      	str	r5, [r4, #0]
  4066a0:	2000      	movs	r0, #0
  4066a2:	6060      	str	r0, [r4, #4]
  4066a4:	4605      	mov	r5, r0
  4066a6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4066aa:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  4066ae:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  4066b2:	b93f      	cbnz	r7, 4066c4 <__register_exitproc+0x68>
  4066b4:	1cab      	adds	r3, r5, #2
  4066b6:	2000      	movs	r0, #0
  4066b8:	3501      	adds	r5, #1
  4066ba:	6065      	str	r5, [r4, #4]
  4066bc:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  4066c0:	b005      	add	sp, #20
  4066c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4066c4:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  4066c8:	f04f 0c01 	mov.w	ip, #1
  4066cc:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  4066d0:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  4066d4:	fa0c f205 	lsl.w	r2, ip, r5
  4066d8:	4316      	orrs	r6, r2
  4066da:	2f02      	cmp	r7, #2
  4066dc:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  4066e0:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  4066e4:	d1e6      	bne.n	4066b4 <__register_exitproc+0x58>
  4066e6:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  4066ea:	431a      	orrs	r2, r3
  4066ec:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  4066f0:	e7e0      	b.n	4066b4 <__register_exitproc+0x58>
  4066f2:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  4066f6:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4066fa:	e7b8      	b.n	40666e <__register_exitproc+0x12>
  4066fc:	00406db0 	.word	0x00406db0
  406700:	00405bd5 	.word	0x00405bd5
  406704:	69663a30 	.word	0x69663a30
  406708:	61776d72 	.word	0x61776d72
  40670c:	622e6572 	.word	0x622e6572
  406710:	00006e69 	.word	0x00006e69

00406714 <sd_trans_multipliers>:
  406714:	00000000 0000000a 0000000c 0000000d     ................
  406724:	0000000f 00000014 00000019 0000001e     ................
  406734:	00000023 00000028 0000002d 00000032     #...(...-...2...
  406744:	00000037 0000003c 00000046 00000050     7...<...F...P...

00406754 <sd_mmc_trans_units>:
  406754:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00406770 <mmc_trans_multipliers>:
  406770:	00000000 0000000a 0000000c 0000000d     ................
  406780:	0000000f 00000014 0000001a 0000001e     ................
  406790:	00000023 00000028 0000002d 00000034     #...(...-...4...
  4067a0:	00000037 0000003c 00000046 00000050     7...<...F...P...

004067b0 <lun_desc>:
  4067b0:	00401835 00401875 00401895 004018ad     5.@.u.@...@...@.
  4067c0:	004018cd 00401911 00401975 004067f0     ..@...@.u.@..g@.
  4067d0:	00401845 00401885 004018a1 004018bd     E.@...@...@...@.
  4067e0:	004018d1 00401925 00401989 00406808     ..@.%.@...@..h@.
  4067f0:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  406800:	22302074 00000000 2f445322 20434d4d     t 0"...."SD/MMC 
  406810:	64726143 6f6c5320 22312074 00000000     Card Slot 1"....

00406820 <excvt.4554>:
  406820:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  406830:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  406840:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  406850:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  406860:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  406870:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  406880:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  406890:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
  4068a0:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
  4068b0:	00005d5b                                []..

004068b4 <LfnOfs>:
  4068b4:	07050301 12100e09 1c181614 0000001e     ................

004068c4 <tbl_lower.4258>:
  4068c4:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  4068d4:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  4068e4:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  4068f4:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  406904:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  406914:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  406924:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  406934:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  406944:	01050103 01090107 010d010b 0111010f     ................
  406954:	01150113 01190117 011d011b 0121011f     ..............!.
  406964:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  406974:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  406984:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  406994:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  4069a4:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  4069b4:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  4069c4:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  4069d4:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  4069e4:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  4069f4:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  406a04:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  406a14:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  406a24:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  406a34:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  406a44:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  406a54:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  406a64:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  406a74:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  406a84:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  406a94:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...

00406aa4 <Tbl>:
  406aa4:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  406ab4:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  406ac4:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  406ad4:	00d600ff 00f800dc 00d800a3 019200d7     ................
  406ae4:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  406af4:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  406b04:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  406b14:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  406b24:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  406b34:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  406b44:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  406b54:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  406b64:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  406b74:	00da00de 00d900db 00dd00fd 00b400af     ................
  406b84:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  406b94:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00406ba4 <tbl_upper.4259>:
  406ba4:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  406bb4:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  406bc4:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  406bd4:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  406be4:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  406bf4:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  406c04:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  406c14:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  406c24:	01040102 01080106 010c010a 0110010e     ................
  406c34:	01140112 01180116 011c011a 0120011e     .............. .
  406c44:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  406c54:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  406c64:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  406c74:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  406c84:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  406c94:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  406ca4:	03940393 03960395 03980397 039a0399     ................
  406cb4:	039c039b 039e039d 03a0039f 03a303a1     ................
  406cc4:	03a503a4 03a703a6 03a903a8 041003aa     ................
  406cd4:	04120411 04140413 04160415 04180417     ................
  406ce4:	041a0419 041c041b 041e041d 0420041f     .............. .
  406cf4:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  406d04:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  406d14:	04030402 04050404 04070406 04090408     ................
  406d24:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  406d34:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  406d44:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  406d54:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  406d64:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  406d74:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...
  406d84:	74736552 69747261 7320676e 65747379     Restarting syste
  406d94:	2121216d 0000000d                       m!!!....

00406d9c <CSWTCH.21>:
  406d9c:	00000070 00000050 00000030 00000010     p...P...0.......
  406dac:	00000043                                C...

00406db0 <_global_impure_ptr>:
  406db0:	20000250                                P.. 

00406db4 <_init>:
  406db4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406db6:	bf00      	nop
  406db8:	bcf8      	pop	{r3, r4, r5, r6, r7}
  406dba:	bc08      	pop	{r3}
  406dbc:	469e      	mov	lr, r3
  406dbe:	4770      	bx	lr

00406dc0 <__init_array_start>:
  406dc0:	004063d5 	.word	0x004063d5

00406dc4 <__frame_dummy_init_array_entry>:
  406dc4:	004000f1                                ..@.

00406dc8 <_fini>:
  406dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406dca:	bf00      	nop
  406dcc:	bcf8      	pop	{r3, r4, r5, r6, r7}
  406dce:	bc08      	pop	{r3}
  406dd0:	469e      	mov	lr, r3
  406dd2:	4770      	bx	lr

00406dd4 <__fini_array_start>:
  406dd4:	004000cd 	.word	0x004000cd

Disassembly of section .relocate:

20000000 <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
20000000:	b470      	push	{r4, r5, r6}
20000002:	b083      	sub	sp, #12
20000004:	9e06      	ldr	r6, [sp, #24]
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
20000006:	b343      	cbz	r3, 2000005a <efc_perform_read_sequence+0x5a>
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000008:	6804      	ldr	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
2000000a:	b2c9      	uxtb	r1, r1
2000000c:	f041 41b4 	orr.w	r1, r1, #1509949440	; 0x5a000000

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000010:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
20000014:	6004      	str	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
20000016:	6041      	str	r1, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000018:	6881      	ldr	r1, [r0, #8]
2000001a:	9101      	str	r1, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
2000001c:	9901      	ldr	r1, [sp, #4]
2000001e:	f011 0101 	ands.w	r1, r1, #1
20000022:	d1f9      	bne.n	20000018 <efc_perform_read_sequence+0x18>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000024:	b146      	cbz	r6, 20000038 <efc_perform_read_sequence+0x38>
20000026:	4c0f      	ldr	r4, [pc, #60]	; (20000064 <efc_perform_read_sequence+0x64>)
20000028:	eb03 0686 	add.w	r6, r3, r6, lsl #2
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
2000002c:	f854 5f04 	ldr.w	r5, [r4, #4]!
20000030:	f843 5b04 	str.w	r5, [r3], #4
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000034:	42b3      	cmp	r3, r6
20000036:	d1f9      	bne.n	2000002c <efc_perform_read_sequence+0x2c>

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000038:	b2d2      	uxtb	r2, r2
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000003a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
2000003e:	6042      	str	r2, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	6883      	ldr	r3, [r0, #8]
20000042:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000044:	9b01      	ldr	r3, [sp, #4]
20000046:	07db      	lsls	r3, r3, #31
20000048:	d5fa      	bpl.n	20000040 <efc_perform_read_sequence+0x40>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
2000004a:	6803      	ldr	r3, [r0, #0]
2000004c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20000050:	6003      	str	r3, [r0, #0]

	return EFC_RC_OK;
}
20000052:	4608      	mov	r0, r1
20000054:	b003      	add	sp, #12
20000056:	bc70      	pop	{r4, r5, r6}
20000058:	4770      	bx	lr
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
2000005a:	2102      	movs	r1, #2
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);

	p_efc->EEFC_FMR &= ~(0x1u << 16);

	return EFC_RC_OK;
}
2000005c:	4608      	mov	r0, r1
2000005e:	b003      	add	sp, #12
20000060:	bc70      	pop	{r4, r5, r6}
20000062:	4770      	bx	lr
20000064:	003ffffc 	.word	0x003ffffc

20000068 <efc_write_fmr>:
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
20000068:	6001      	str	r1, [r0, #0]
2000006a:	4770      	bx	lr

2000006c <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
2000006c:	b082      	sub	sp, #8
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
2000006e:	6041      	str	r1, [r0, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
20000070:	6883      	ldr	r3, [r0, #8]
20000072:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000074:	9b01      	ldr	r3, [sp, #4]
20000076:	07db      	lsls	r3, r3, #31
20000078:	d5fa      	bpl.n	20000070 <efc_perform_fcr+0x4>

	return (ul_status & EEFC_ERROR_FLAGS);
2000007a:	9801      	ldr	r0, [sp, #4]
}
2000007c:	f000 000e 	and.w	r0, r0, #14
20000080:	b002      	add	sp, #8
20000082:	4770      	bx	lr

20000084 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000084:	f3bf 8f5f 	dmb	sy
20000088:	3801      	subs	r0, #1
2000008a:	d1fb      	bne.n	20000084 <portable_delay_cycles>
2000008c:	4770      	bx	lr
2000008e:	bf00      	nop

20000090 <sd_mmc_cards>:
	...
20000098:	002b 0000 0000 0000 0000 0000 0000 0000     +...............
	...

200000b4 <uxCriticalNesting>:
200000b4:	aaaa aaaa                                   ....

200000b8 <uxPreviousTask>:
200000b8:	00ff 0000                                   ....

200000bc <xNextTaskUnblockTime>:
200000bc:	ffff ffff                                   ....

200000c0 <brainSettings>:
	...
200000f8:	0000 0100 0000 0000 0000 0000 0000 0000     ................
	...

20000118 <gpioConfig>:
20000118:	0000 0000 0001 0001 4809 0040 0101 0000     .........H@.....
20000128:	0001 0000 0001 0001 47c9 0040 0101 0000     .........G@.....
20000138:	0014 0000 0001 0001 4785 0040 0101 0000     .........G@.....
20000148:	0010 0000 0001 0001 4741 0040 0101 0000     ........AG@.....
20000158:	000f 0000 0001 0001 46fd 0040 0101 0000     .........F@.....
20000168:	0018 0000 0001 0001 46b9 0040 0100 0000     .........F@.....
20000178:	0019 0000 0001 0001 4675 0040 0100 0000     ........uF@.....
20000188:	0013 0000 0100 0004 0000 0000 0000 0100     ................
20000198:	0017 0000 0100 0004 0000 0000 0000 0100     ................
200001a8:	002a 0000 0100 0004 0000 0000 0100 0100     *...............
200001b8:	0011 0000 0100 0004 0000 0000 0100 0100     ................
200001c8:	0012 0000 0100 0004 0000 0000 0100 0100     ................
200001d8:	002d 0000 0100 0004 0000 0000 0000 0100     -...............
200001e8:	0020 0000 0100 0004 0000 0000 0000 0100      ...............
200001f8:	0021 0000 0100 0004 0000 0000 0000 0100     !...............
20000208:	000b 0000 0001 0001 4631 0040 0101 0000     ........1F@.....
20000218:	002b 0000 0001 0001 45ed 0040 0101 0000     +........E@.....
20000228:	000c 0000 0000 0004 0000 0000 0000 0000     ................
20000238:	0002 0000 0000 0004 0000 0000 0000 0100     ................

20000248 <g_interrupt_enabled>:
20000248:	0001 0000                                   ....

2000024c <SystemCoreClock>:
2000024c:	0900 003d                                   ..=.

20000250 <impure_data>:
20000250:	0000 0000 053c 2000 05a4 2000 060c 2000     ....<.. ... ... 
	...
20000284:	6dac 0040 0000 0000 0000 0000 0000 0000     .m@.............
	...
200002f8:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000308:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

20000678 <_impure_ptr>:
20000678:	0250 2000                                   P.. 

2000067c <__malloc_av_>:
	...
20000684:	067c 2000 067c 2000 0684 2000 0684 2000     |.. |.. ... ... 
20000694:	068c 2000 068c 2000 0694 2000 0694 2000     ... ... ... ... 
200006a4:	069c 2000 069c 2000 06a4 2000 06a4 2000     ... ... ... ... 
200006b4:	06ac 2000 06ac 2000 06b4 2000 06b4 2000     ... ... ... ... 
200006c4:	06bc 2000 06bc 2000 06c4 2000 06c4 2000     ... ... ... ... 
200006d4:	06cc 2000 06cc 2000 06d4 2000 06d4 2000     ... ... ... ... 
200006e4:	06dc 2000 06dc 2000 06e4 2000 06e4 2000     ... ... ... ... 
200006f4:	06ec 2000 06ec 2000 06f4 2000 06f4 2000     ... ... ... ... 
20000704:	06fc 2000 06fc 2000 0704 2000 0704 2000     ... ... ... ... 
20000714:	070c 2000 070c 2000 0714 2000 0714 2000     ... ... ... ... 
20000724:	071c 2000 071c 2000 0724 2000 0724 2000     ... ... $.. $.. 
20000734:	072c 2000 072c 2000 0734 2000 0734 2000     ,.. ,.. 4.. 4.. 
20000744:	073c 2000 073c 2000 0744 2000 0744 2000     <.. <.. D.. D.. 
20000754:	074c 2000 074c 2000 0754 2000 0754 2000     L.. L.. T.. T.. 
20000764:	075c 2000 075c 2000 0764 2000 0764 2000     \.. \.. d.. d.. 
20000774:	076c 2000 076c 2000 0774 2000 0774 2000     l.. l.. t.. t.. 
20000784:	077c 2000 077c 2000 0784 2000 0784 2000     |.. |.. ... ... 
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 
20000a24:	0a1c 2000 0a1c 2000 0a24 2000 0a24 2000     ... ... $.. $.. 
20000a34:	0a2c 2000 0a2c 2000 0a34 2000 0a34 2000     ,.. ,.. 4.. 4.. 
20000a44:	0a3c 2000 0a3c 2000 0a44 2000 0a44 2000     <.. <.. D.. D.. 
20000a54:	0a4c 2000 0a4c 2000 0a54 2000 0a54 2000     L.. L.. T.. T.. 
20000a64:	0a5c 2000 0a5c 2000 0a64 2000 0a64 2000     \.. \.. d.. d.. 
20000a74:	0a6c 2000 0a6c 2000 0a74 2000 0a74 2000     l.. l.. t.. t.. 

20000a84 <__malloc_trim_threshold>:
20000a84:	0000 0002                                   ....

20000a88 <__malloc_sbrk_base>:
20000a88:	ffff ffff                                   ....
