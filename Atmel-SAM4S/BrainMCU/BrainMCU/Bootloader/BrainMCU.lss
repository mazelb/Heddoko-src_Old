
BrainMCU.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00007124  00400000  00400000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .ARM.exidx    00000008  00407124  00407124  0000f124  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .relocate     00000aec  20000000  0040712c  00010000  2**3
                  CONTENTS, ALLOC, LOAD, CODE
  3 .bss          0000195c  20000aec  00407c18  00010aec  2**2
                  ALLOC
  4 .stack        00003000  20002448  00409574  00010aec  2**0
                  ALLOC
  5 .ARM.attributes 0000002a  00000000  00000000  00010aec  2**0
                  CONTENTS, READONLY
  6 .comment      0000005b  00000000  00000000  00010b16  2**0
                  CONTENTS, READONLY
  7 .debug_info   00028f08  00000000  00000000  00010b71  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00006555  00000000  00000000  00039a79  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00015fa9  00000000  00000000  0003ffce  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_aranges 00001718  00000000  00000000  00055f77  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000029c0  00000000  00000000  0005768f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  0000fd0c  00000000  00000000  0005a04f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_line   00023ff8  00000000  00000000  00069d5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_str    0005d95a  00000000  00000000  0008dd53  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  00003c3c  00000000  00000000  000eb6b0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00400000 <_sfixed>:
  400000:	20005448 	.word	0x20005448
  400004:	0040569d 	.word	0x0040569d
  400008:	00405699 	.word	0x00405699
  40000c:	004058a9 	.word	0x004058a9
  400010:	004058ad 	.word	0x004058ad
  400014:	004058b1 	.word	0x004058b1
  400018:	004058b5 	.word	0x004058b5
	...
  40002c:	00403e59 	.word	0x00403e59
  400030:	00405699 	.word	0x00405699
  400034:	00000000 	.word	0x00000000
  400038:	00403eb9 	.word	0x00403eb9
  40003c:	004058b9 	.word	0x004058b9
  400040:	00405699 	.word	0x00405699
  400044:	00405699 	.word	0x00405699
  400048:	00405699 	.word	0x00405699
  40004c:	00405699 	.word	0x00405699
  400050:	00404895 	.word	0x00404895
  400054:	00405699 	.word	0x00405699
  400058:	00405699 	.word	0x00405699
  40005c:	00000000 	.word	0x00000000
  400060:	00404f9d 	.word	0x00404f9d
  400064:	00404fe5 	.word	0x00404fe5
  400068:	00000000 	.word	0x00000000
  40006c:	00405545 	.word	0x00405545
  400070:	00405559 	.word	0x00405559
  400074:	00000000 	.word	0x00000000
  400078:	00405035 	.word	0x00405035
  40007c:	00405085 	.word	0x00405085
	...
  400088:	00405699 	.word	0x00405699
  40008c:	00400301 	.word	0x00400301
  400090:	00400311 	.word	0x00400311
  400094:	00405699 	.word	0x00405699
  400098:	00405699 	.word	0x00405699
  40009c:	00405699 	.word	0x00405699
  4000a0:	00405699 	.word	0x00405699
  4000a4:	00405699 	.word	0x00405699
	...
  4000b4:	00405699 	.word	0x00405699
  4000b8:	00405699 	.word	0x00405699
  4000bc:	00405699 	.word	0x00405699
  4000c0:	00405699 	.word	0x00405699
  4000c4:	00405699 	.word	0x00405699
  4000c8:	00405699 	.word	0x00405699

004000cc <__do_global_dtors_aux>:
  4000cc:	b510      	push	{r4, lr}
  4000ce:	4c05      	ldr	r4, [pc, #20]	; (4000e4 <__do_global_dtors_aux+0x18>)
  4000d0:	7823      	ldrb	r3, [r4, #0]
  4000d2:	b933      	cbnz	r3, 4000e2 <__do_global_dtors_aux+0x16>
  4000d4:	4b04      	ldr	r3, [pc, #16]	; (4000e8 <__do_global_dtors_aux+0x1c>)
  4000d6:	b113      	cbz	r3, 4000de <__do_global_dtors_aux+0x12>
  4000d8:	4804      	ldr	r0, [pc, #16]	; (4000ec <__do_global_dtors_aux+0x20>)
  4000da:	f3af 8000 	nop.w
  4000de:	2301      	movs	r3, #1
  4000e0:	7023      	strb	r3, [r4, #0]
  4000e2:	bd10      	pop	{r4, pc}
  4000e4:	20000aec 	.word	0x20000aec
  4000e8:	00000000 	.word	0x00000000
  4000ec:	0040712c 	.word	0x0040712c

004000f0 <frame_dummy>:
  4000f0:	b508      	push	{r3, lr}
  4000f2:	4b06      	ldr	r3, [pc, #24]	; (40010c <frame_dummy+0x1c>)
  4000f4:	b11b      	cbz	r3, 4000fe <frame_dummy+0xe>
  4000f6:	4806      	ldr	r0, [pc, #24]	; (400110 <frame_dummy+0x20>)
  4000f8:	4906      	ldr	r1, [pc, #24]	; (400114 <frame_dummy+0x24>)
  4000fa:	f3af 8000 	nop.w
  4000fe:	4806      	ldr	r0, [pc, #24]	; (400118 <frame_dummy+0x28>)
  400100:	6803      	ldr	r3, [r0, #0]
  400102:	b113      	cbz	r3, 40010a <frame_dummy+0x1a>
  400104:	4b05      	ldr	r3, [pc, #20]	; (40011c <frame_dummy+0x2c>)
  400106:	b103      	cbz	r3, 40010a <frame_dummy+0x1a>
  400108:	4798      	blx	r3
  40010a:	bd08      	pop	{r3, pc}
  40010c:	00000000 	.word	0x00000000
  400110:	0040712c 	.word	0x0040712c
  400114:	20000af0 	.word	0x20000af0
  400118:	0040712c 	.word	0x0040712c
  40011c:	00000000 	.word	0x00000000

00400120 <local_twi_handler>:
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400120:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  400124:	0107      	lsls	r7, r0, #4
  400126:	f8df 81d4 	ldr.w	r8, [pc, #468]	; 4002fc <local_twi_handler+0x1dc>

	twi_status = twi_get_interrupt_status(twi_port);
  40012a:	4b6b      	ldr	r3, [pc, #428]	; (4002d8 <local_twi_handler+0x1b8>)
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40012c:	f858 5007 	ldr.w	r5, [r8, r7]
/*
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
  400130:	b083      	sub	sp, #12
  400132:	4606      	mov	r6, r0
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400134:	2400      	movs	r4, #0
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  400136:	4628      	mov	r0, r5
 * For internal use only.
 * A common TWI interrupt handler that is called for all TWI peripherals.
 */
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
  400138:	9401      	str	r4, [sp, #4]
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013a:	4798      	blx	r3
	twi_status &= twi_get_interrupt_mask(twi_port);
  40013c:	4b67      	ldr	r3, [pc, #412]	; (4002dc <local_twi_handler+0x1bc>)
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;

	twi_status = twi_get_interrupt_status(twi_port);
  40013e:	4682      	mov	sl, r0
	twi_status &= twi_get_interrupt_mask(twi_port);
  400140:	4628      	mov	r0, r5
  400142:	4798      	blx	r3
  400144:	ea00 0a0a 	and.w	sl, r0, sl

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400148:	f41a 5900 	ands.w	r9, sl, #8192	; 0x2000
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;

	twi_port = all_twi_definitions[twi_index].peripheral_base_address;
  40014c:	eb08 0307 	add.w	r3, r8, r7

	twi_status = twi_get_interrupt_status(twi_port);
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
  400150:	d179      	bne.n	400246 <local_twi_handler+0x126>
			}
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
  400152:	f41a 5f80 	tst.w	sl, #4096	; 0x1000
  400156:	d12c      	bne.n	4001b2 <local_twi_handler+0x92>
						&higher_priority_task_woken);
			}
		}
	}

	if (((twi_status & SR_ERROR_INTERRUPTS) != 0) || (transfer_timeout == true)) {
  400158:	f41a 7f50 	tst.w	sl, #832	; 0x340
  40015c:	d109      	bne.n	400172 <local_twi_handler+0x52>
  40015e:	f1b9 0f00 	cmp.w	r9, #0
  400162:	d106      	bne.n	400172 <local_twi_handler+0x52>
	has a priority equal to or higher than the currently running task (the task
	this ISR interrupted), then higher_priority_task_woken will have
	automatically been set to pdTRUE within the semaphore function.
	portEND_SWITCHING_ISR() will then ensure that this ISR returns directly to
	the higher priority unblocked task. */
	portEND_SWITCHING_ISR(higher_priority_task_woken);
  400164:	9b01      	ldr	r3, [sp, #4]
  400166:	b10b      	cbz	r3, 40016c <local_twi_handler+0x4c>
  400168:	4b5d      	ldr	r3, [pc, #372]	; (4002e0 <local_twi_handler+0x1c0>)
  40016a:	4798      	blx	r3
}
  40016c:	b003      	add	sp, #12
  40016e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  400172:	4447      	add	r7, r8
  400174:	4b5b      	ldr	r3, [pc, #364]	; (4002e4 <local_twi_handler+0x1c4>)
  400176:	6878      	ldr	r0, [r7, #4]

		if (!(twi_status & TWI_SR_NACK)) {
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400178:	4c5b      	ldr	r4, [pc, #364]	; (4002e8 <local_twi_handler+0x1c8>)
		Stop the transmission, disable interrupts used by the peripheral, and
		ensure the peripheral access mutex is made available to tasks.  As this
		peripheral is half duplex, only the Tx peripheral access mutex exits.*/

		/* Stop the PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS | PERIPH_PTCR_RXTDIS);
  40017a:	f240 2102 	movw	r1, #514	; 0x202
  40017e:	4798      	blx	r3

		if (!(twi_status & TWI_SR_NACK)) {
  400180:	f41a 7f80 	tst.w	sl, #256	; 0x100
			/* Do not send stop if NACK received. Handled by hardware */
			twi_port->TWI_CR = TWI_CR_STOP;
  400184:	bf04      	itt	eq
  400186:	2302      	moveq	r3, #2
  400188:	602b      	streq	r3, [r5, #0]
		}
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  40018a:	4628      	mov	r0, r5
  40018c:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400190:	47a0      	blx	r4
		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  400192:	4628      	mov	r0, r5
  400194:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  400198:	47a0      	blx	r4

		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  40019a:	4b54      	ldr	r3, [pc, #336]	; (4002ec <local_twi_handler+0x1cc>)
  40019c:	eb03 06c6 	add.w	r6, r3, r6, lsl #3
  4001a0:	6870      	ldr	r0, [r6, #4]
  4001a2:	2800      	cmp	r0, #0
  4001a4:	d0de      	beq.n	400164 <local_twi_handler+0x44>
			xSemaphoreGiveFromISR(
  4001a6:	2100      	movs	r1, #0
  4001a8:	460b      	mov	r3, r1
  4001aa:	aa01      	add	r2, sp, #4
  4001ac:	4c50      	ldr	r4, [pc, #320]	; (4002f0 <local_twi_handler+0x1d0>)
  4001ae:	47a0      	blx	r4
  4001b0:	e7d8      	b.n	400164 <local_twi_handler+0x44>
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
		uint32_t status;
		/* Must handle the two last bytes */
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_RXTDIS);
  4001b2:	eb08 0307 	add.w	r3, r8, r7
  4001b6:	2102      	movs	r1, #2
  4001b8:	6858      	ldr	r0, [r3, #4]
  4001ba:	4b4a      	ldr	r3, [pc, #296]	; (4002e4 <local_twi_handler+0x1c4>)
  4001bc:	4798      	blx	r3

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);
  4001be:	4628      	mov	r0, r5
  4001c0:	f44f 5180 	mov.w	r1, #4096	; 0x1000
  4001c4:	4b48      	ldr	r3, [pc, #288]	; (4002e8 <local_twi_handler+0x1c8>)
  4001c6:	4798      	blx	r3
		}
	}

	/* Has the PDC completed a reception? */
	if ((twi_status & TWI_SR_ENDRX) != 0UL) {
		uint32_t timeout_counter = 0;
  4001c8:	2400      	movs	r4, #0
  4001ca:	e002      	b.n	4001d2 <local_twi_handler+0xb2>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001cc:	3401      	adds	r4, #1
  4001ce:	1c63      	adds	r3, r4, #1
  4001d0:	d002      	beq.n	4001d8 <local_twi_handler+0xb8>

		twi_disable_interrupt(twi_port, TWI_IDR_ENDRX);

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001d2:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001d4:	079a      	lsls	r2, r3, #30
  4001d6:	d5f9      	bpl.n	4001cc <local_twi_handler+0xac>
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001d8:	4b46      	ldr	r3, [pc, #280]	; (4002f4 <local_twi_handler+0x1d4>)
  4001da:	00f2      	lsls	r2, r6, #3
  4001dc:	1899      	adds	r1, r3, r2
  4001de:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  4001e2:	6849      	ldr	r1, [r1, #4]
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}
		/* Complete the transfer. */
		twi_port->TWI_CR = TWI_CR_STOP;
  4001e4:	2302      	movs	r3, #2
  4001e6:	602b      	str	r3, [r5, #0]
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;
  4001e8:	4401      	add	r1, r0
  4001ea:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  4001ec:	f801 3c02 	strb.w	r3, [r1, #-2]
  4001f0:	e002      	b.n	4001f8 <local_twi_handler+0xd8>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_RXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  4001f2:	3401      	adds	r4, #1
  4001f4:	1c63      	adds	r3, r4, #1
  4001f6:	d00f      	beq.n	400218 <local_twi_handler+0xf8>
		/* Read second last data */
		twis[twi_index].buffer[(twis[twi_index].length)-2] = twi_port->TWI_RHR;

		/* Wait for RX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  4001f8:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_RXRDY) {
  4001fa:	0798      	lsls	r0, r3, #30
  4001fc:	d5f9      	bpl.n	4001f2 <local_twi_handler+0xd2>
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				break;
			}
		}

		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4001fe:	1c60      	adds	r0, r4, #1
  400200:	d00a      	beq.n	400218 <local_twi_handler+0xf8>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
  400202:	6b2b      	ldr	r3, [r5, #48]	; 0x30
  400204:	f801 3c01 	strb.w	r3, [r1, #-1]
			timeout_counter = 0;
  400208:	2400      	movs	r4, #0
  40020a:	e002      	b.n	400212 <local_twi_handler+0xf2>
				status = twi_port->TWI_SR;
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40020c:	3401      	adds	r4, #1
  40020e:	1c63      	adds	r3, r4, #1
  400210:	d05e      	beq.n	4002d0 <local_twi_handler+0x1b0>
			/* Read last data */
			twis[twi_index].buffer[(twis[twi_index].length)-1] = twi_port->TWI_RHR;
			timeout_counter = 0;
			/* Wait for TX complete flag before releasing semaphore */
			while (1) {
				status = twi_port->TWI_SR;
  400212:	6a2b      	ldr	r3, [r5, #32]
				if (status & TWI_SR_TXCOMP) {
  400214:	07d9      	lsls	r1, r3, #31
  400216:	d5f9      	bpl.n	40020c <local_twi_handler+0xec>
		}

		/* If the driver is supporting multi-threading, then return the access
		mutex.  NOTE: As the peripheral is half duplex there is only one
		access mutex, and the reception uses the tx access muted. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400218:	4b34      	ldr	r3, [pc, #208]	; (4002ec <local_twi_handler+0x1cc>)
  40021a:	441a      	add	r2, r3
  40021c:	6850      	ldr	r0, [r2, #4]
  40021e:	b128      	cbz	r0, 40022c <local_twi_handler+0x10c>
			xSemaphoreGiveFromISR(
  400220:	2100      	movs	r1, #0
  400222:	460b      	mov	r3, r1
  400224:	aa01      	add	r2, sp, #4
  400226:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 4002f0 <local_twi_handler+0x1d0>
  40022a:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the receiving task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if  (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  40022c:	3401      	adds	r4, #1
  40022e:	d093      	beq.n	400158 <local_twi_handler+0x38>
			if (rx_dma_control[twi_index].transaction_complete_notification_semaphore != NULL) {
  400230:	4b31      	ldr	r3, [pc, #196]	; (4002f8 <local_twi_handler+0x1d8>)
  400232:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400236:	2800      	cmp	r0, #0
  400238:	d08e      	beq.n	400158 <local_twi_handler+0x38>
				xSemaphoreGiveFromISR(
  40023a:	2100      	movs	r1, #0
  40023c:	460b      	mov	r3, r1
  40023e:	aa01      	add	r2, sp, #4
  400240:	4c2b      	ldr	r4, [pc, #172]	; (4002f0 <local_twi_handler+0x1d0>)
  400242:	47a0      	blx	r4
  400244:	e788      	b.n	400158 <local_twi_handler+0x38>
	twi_status &= twi_get_interrupt_mask(twi_port);

	/* Has the PDC completed a transmission? */
	if ((twi_status & TWI_SR_ENDTX) != 0UL) {
		/* Disable PDC */
		pdc_disable_transfer(all_twi_definitions[twi_index].pdc_base_address, PERIPH_PTCR_TXTDIS);
  400246:	6858      	ldr	r0, [r3, #4]
  400248:	4b26      	ldr	r3, [pc, #152]	; (4002e4 <local_twi_handler+0x1c4>)
  40024a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40024e:	4798      	blx	r3
		twi_disable_interrupt(twi_port, TWI_IDR_ENDTX);
  400250:	4628      	mov	r0, r5
  400252:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  400256:	4b24      	ldr	r3, [pc, #144]	; (4002e8 <local_twi_handler+0x1c8>)
  400258:	4798      	blx	r3
  40025a:	e002      	b.n	400262 <local_twi_handler+0x142>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  40025c:	3401      	adds	r4, #1
  40025e:	1c63      	adds	r3, r4, #1
  400260:	d033      	beq.n	4002ca <local_twi_handler+0x1aa>
		uint8_t status;
		uint32_t timeout_counter = 0;

		/* Wait for TX ready flag */
		while (1) {
			status = twi_port->TWI_SR;
  400262:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXRDY) {
  400264:	075a      	lsls	r2, r3, #29
  400266:	d5f9      	bpl.n	40025c <local_twi_handler+0x13c>
static void local_twi_handler(const portBASE_TYPE twi_index)
{
	portBASE_TYPE higher_priority_task_woken = pdFALSE;
	uint32_t twi_status;
	Twi *twi_port;
	bool transfer_timeout = false;
  400268:	f04f 0900 	mov.w	r9, #0
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40026c:	4b21      	ldr	r3, [pc, #132]	; (4002f4 <local_twi_handler+0x1d4>)
  40026e:	00f2      	lsls	r2, r6, #3
  400270:	1899      	adds	r1, r3, r2
  400272:	f853 0036 	ldr.w	r0, [r3, r6, lsl #3]
  400276:	684b      	ldr	r3, [r1, #4]
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  400278:	2102      	movs	r1, #2
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027a:	4403      	add	r3, r0
				transfer_timeout = true;
				break;
			}
		}
		/* Complete the transfer - stop and last byte */
		twi_port->TWI_CR = TWI_CR_STOP;
  40027c:	6029      	str	r1, [r5, #0]
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];
  40027e:	f813 3c01 	ldrb.w	r3, [r3, #-1]
  400282:	636b      	str	r3, [r5, #52]	; 0x34
  400284:	e002      	b.n	40028c <local_twi_handler+0x16c>
			status = twi_port->TWI_SR;
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
  400286:	3401      	adds	r4, #1
  400288:	1c61      	adds	r1, r4, #1
  40028a:	d01b      	beq.n	4002c4 <local_twi_handler+0x1a4>
		twi_port->TWI_CR = TWI_CR_STOP;
		twi_port->TWI_THR = twis[twi_index].buffer[twis[twi_index].length-1];

		/* Wait for TX complete flag */
		while (1) {
			status = twi_port->TWI_SR;
  40028c:	6a2b      	ldr	r3, [r5, #32]
			if (status & TWI_SR_TXCOMP) {
  40028e:	07d8      	lsls	r0, r3, #31
  400290:	d5f9      	bpl.n	400286 <local_twi_handler+0x166>
				break;
			}
		}
		/* If the driver is supporting multi-threading, then return the access
		mutex. */
		if (tx_dma_control[twi_index].peripheral_access_mutex != NULL) {
  400292:	f8df b058 	ldr.w	fp, [pc, #88]	; 4002ec <local_twi_handler+0x1cc>
  400296:	445a      	add	r2, fp
  400298:	6850      	ldr	r0, [r2, #4]
  40029a:	b128      	cbz	r0, 4002a8 <local_twi_handler+0x188>
			xSemaphoreGiveFromISR(
  40029c:	2100      	movs	r1, #0
  40029e:	460b      	mov	r3, r1
  4002a0:	aa01      	add	r2, sp, #4
  4002a2:	f8df c04c 	ldr.w	ip, [pc, #76]	; 4002f0 <local_twi_handler+0x1d0>
  4002a6:	47e0      	blx	ip
					&higher_priority_task_woken);
		}

		/* if the sending task supplied a notification semaphore, then
		notify the task that the transmission has completed. */
		if (!(timeout_counter >= TWI_TIMEOUT_COUNTER)) {
  4002a8:	3401      	adds	r4, #1
  4002aa:	f43f af52 	beq.w	400152 <local_twi_handler+0x32>
			if (tx_dma_control[twi_index]. transaction_complete_notification_semaphore != NULL) {
  4002ae:	f85b 0036 	ldr.w	r0, [fp, r6, lsl #3]
  4002b2:	2800      	cmp	r0, #0
  4002b4:	f43f af4d 	beq.w	400152 <local_twi_handler+0x32>
				xSemaphoreGiveFromISR(
  4002b8:	2100      	movs	r1, #0
  4002ba:	460b      	mov	r3, r1
  4002bc:	aa01      	add	r2, sp, #4
  4002be:	4c0c      	ldr	r4, [pc, #48]	; (4002f0 <local_twi_handler+0x1d0>)
  4002c0:	47a0      	blx	r4
  4002c2:	e746      	b.n	400152 <local_twi_handler+0x32>
			if (status & TWI_SR_TXCOMP) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002c4:	f04f 0901 	mov.w	r9, #1
  4002c8:	e7e3      	b.n	400292 <local_twi_handler+0x172>
			if (status & TWI_SR_TXRDY) {
				break;
			}
			/* Check timeout condition. */
			if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
				transfer_timeout = true;
  4002ca:	f04f 0901 	mov.w	r9, #1
  4002ce:	e7cd      	b.n	40026c <local_twi_handler+0x14c>
				if (status & TWI_SR_TXCOMP) {
					break;
				}
				/* Check timeout condition. */
				if (++timeout_counter >= TWI_TIMEOUT_COUNTER) {
					transfer_timeout = true;
  4002d0:	f04f 0901 	mov.w	r9, #1
  4002d4:	e7a0      	b.n	400218 <local_twi_handler+0xf8>
  4002d6:	bf00      	nop
  4002d8:	004005ed 	.word	0x004005ed
  4002dc:	004005f1 	.word	0x004005f1
  4002e0:	00403e79 	.word	0x00403e79
  4002e4:	0040228d 	.word	0x0040228d
  4002e8:	004005e5 	.word	0x004005e5
  4002ec:	20000b28 	.word	0x20000b28
  4002f0:	0040416d 	.word	0x0040416d
  4002f4:	20000b18 	.word	0x20000b18
  4002f8:	20000b08 	.word	0x20000b08
  4002fc:	00406a30 	.word	0x00406a30

00400300 <TWI0_Handler>:
#endif /* TWI */

#ifdef TWI0

void TWI0_Handler(void)
{
  400300:	b508      	push	{r3, lr}
	local_twi_handler(0);
  400302:	2000      	movs	r0, #0
  400304:	4b01      	ldr	r3, [pc, #4]	; (40030c <TWI0_Handler+0xc>)
  400306:	4798      	blx	r3
  400308:	bd08      	pop	{r3, pc}
  40030a:	bf00      	nop
  40030c:	00400121 	.word	0x00400121

00400310 <TWI1_Handler>:
#endif

#ifdef TWI1

void TWI1_Handler(void)
{
  400310:	b508      	push	{r3, lr}
	local_twi_handler(1);
  400312:	2001      	movs	r0, #1
  400314:	4b01      	ldr	r3, [pc, #4]	; (40031c <TWI1_Handler+0xc>)
  400316:	4798      	blx	r3
  400318:	bd08      	pop	{r3, pc}
  40031a:	bf00      	nop
  40031c:	00400121 	.word	0x00400121

00400320 <efc_get_wait_state>:
 *
 * \return The number of wait states in cycle (no shift).
 */
uint32_t efc_get_wait_state(Efc *p_efc)
{
	return ((p_efc->EEFC_FMR & EEFC_FMR_FWS_Msk) >> EEFC_FMR_FWS_Pos);
  400320:	6800      	ldr	r0, [r0, #0]
}
  400322:	f3c0 2003 	ubfx	r0, r0, #8, #4
  400326:	4770      	bx	lr

00400328 <efc_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful.
 */
uint32_t efc_init(Efc *p_efc, uint32_t ul_access_mode, uint32_t ul_fws)
{
  400328:	b508      	push	{r3, lr}
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws) | EEFC_FMR_CLOE);
  40032a:	0212      	lsls	r2, r2, #8
  40032c:	f402 6270 	and.w	r2, r2, #3840	; 0xf00
  400330:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
  400334:	4311      	orrs	r1, r2
  400336:	4b02      	ldr	r3, [pc, #8]	; (400340 <efc_init+0x18>)
  400338:	4798      	blx	r3
#else
	efc_write_fmr(p_efc, ul_access_mode | EEFC_FMR_FWS(ul_fws));
#endif	
	return EFC_RC_OK;
}
  40033a:	2000      	movs	r0, #0
  40033c:	bd08      	pop	{r3, pc}
  40033e:	bf00      	nop
  400340:	20000069 	.word	0x20000069

00400344 <efc_set_wait_state>:
 *
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
  400344:	b508      	push	{r3, lr}
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  400346:	6802      	ldr	r2, [r0, #0]

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400348:	4b04      	ldr	r3, [pc, #16]	; (40035c <efc_set_wait_state+0x18>)
  40034a:	0209      	lsls	r1, r1, #8
 * \param p_efc Pointer to an EFC instance.
 * \param ul_fws The number of wait states in cycle (no shift).
 */
void efc_set_wait_state(Efc *p_efc, uint32_t ul_fws)
{
	uint32_t ul_fmr = p_efc->EEFC_FMR & (~EEFC_FMR_FWS_Msk);
  40034c:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

	efc_write_fmr(p_efc, ul_fmr | EEFC_FMR_FWS(ul_fws));
  400350:	f401 6170 	and.w	r1, r1, #3840	; 0xf00
  400354:	4311      	orrs	r1, r2
  400356:	4798      	blx	r3
  400358:	bd08      	pop	{r3, pc}
  40035a:	bf00      	nop
  40035c:	20000069 	.word	0x20000069

00400360 <efc_perform_command>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t efc_perform_command(Efc *p_efc, uint32_t ul_command,
		uint32_t ul_argument)
{
  400360:	b508      	push	{r3, lr}
	/* Unique ID commands are not supported. */
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
  400362:	f1a1 030e 	sub.w	r3, r1, #14
  400366:	2b01      	cmp	r3, #1
  400368:	d802      	bhi.n	400370 <efc_perform_command+0x10>
		return EFC_RC_NOT_SUPPORT;
  40036a:	f04f 30ff 	mov.w	r0, #4294967295

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
			EEFC_FCR_FCMD(ul_command));
}
  40036e:	bd08      	pop	{r3, pc}
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(ul_argument) |
  400370:	0212      	lsls	r2, r2, #8
  400372:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  400376:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
  40037a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
			EEFC_FCR_FCMD(ul_command));
  40037e:	b2c9      	uxtb	r1, r1
	if (ul_command == EFC_FCMD_STUI || ul_command == EFC_FCMD_SPUI) {
		return EFC_RC_NOT_SUPPORT;
	}

	/* Use RAM Function. */
	return efc_perform_fcr(p_efc,
  400380:	4311      	orrs	r1, r2
  400382:	4b01      	ldr	r3, [pc, #4]	; (400388 <efc_perform_command+0x28>)
  400384:	4798      	blx	r3
  400386:	bd08      	pop	{r3, pc}
  400388:	2000006d 	.word	0x2000006d

0040038c <flash_init>:
 * \param ul_fws The number of wait states in cycle (no shift).
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_init(uint32_t ul_mode, uint32_t ul_fws)
{
  40038c:	b508      	push	{r3, lr}
  40038e:	460a      	mov	r2, r1
	efc_init(EFC, ul_mode, ul_fws);
  400390:	4b02      	ldr	r3, [pc, #8]	; (40039c <flash_init+0x10>)
  400392:	4601      	mov	r1, r0
  400394:	4802      	ldr	r0, [pc, #8]	; (4003a0 <flash_init+0x14>)
  400396:	4798      	blx	r3
#ifdef EFC1
	efc_init(EFC1, ul_mode, ul_fws);
#endif

	return FLASH_RC_OK;
}
  400398:	2000      	movs	r0, #0
  40039a:	bd08      	pop	{r3, pc}
  40039c:	00400329 	.word	0x00400329
  4003a0:	400e0a00 	.word	0x400e0a00

004003a4 <flash_erase_page>:
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4003a4:	2903      	cmp	r1, #3
 * \param ul_address Flash bank start address.
 *
 * \return 0 if successful; otherwise returns an error code.
 */
uint32_t flash_erase_page(uint32_t ul_address, uint8_t uc_page_num)
{
  4003a6:	b508      	push	{r3, lr}
	Efc *p_efc;
	uint16_t us_page;

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
  4003a8:	d901      	bls.n	4003ae <flash_erase_page+0xa>
		return FLASH_RC_INVALID;
  4003aa:	2011      	movs	r0, #17
	{
		return retVal;
	}

	return FLASH_RC_OK;
}
  4003ac:	bd08      	pop	{r3, pc}

	if (uc_page_num >= IFLASH_ERASE_PAGES_INVALID) {
		return FLASH_RC_INVALID;
	}

	if (ul_address & (IFLASH_PAGE_SIZE - 1)) {
  4003ae:	f3c0 0308 	ubfx	r3, r0, #0, #9
  4003b2:	2b00      	cmp	r3, #0
  4003b4:	d1f9      	bne.n	4003aa <flash_erase_page+0x6>
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4003b6:	f5a0 0280 	sub.w	r2, r0, #4194304	; 0x400000
  4003ba:	f3c2 224f 	ubfx	r2, r2, #9, #16
	if (ul_address & (IFLASH_PAGE_SIZE - 1)) {
		return FLASH_RC_INVALID;
	}

	translate_address(&p_efc, ul_address, &us_page, NULL);
	uint32_t retVal = efc_perform_command(p_efc, EFC_FCMD_EPA,
  4003be:	430a      	orrs	r2, r1
  4003c0:	4b02      	ldr	r3, [pc, #8]	; (4003cc <flash_erase_page+0x28>)
  4003c2:	4803      	ldr	r0, [pc, #12]	; (4003d0 <flash_erase_page+0x2c>)
  4003c4:	2107      	movs	r1, #7
  4003c6:	4798      	blx	r3
  4003c8:	bd08      	pop	{r3, pc}
  4003ca:	bf00      	nop
  4003cc:	00400361 	.word	0x00400361
  4003d0:	400e0a00 	.word	0x400e0a00

004003d4 <flash_write>:
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t __attribute__((optimize("O0"))) flash_write(uint32_t ul_address, const void *p_buffer,
		uint32_t ul_size, uint32_t ul_erase_flag)
{
  4003d4:	b580      	push	{r7, lr}
  4003d6:	b096      	sub	sp, #88	; 0x58
  4003d8:	af00      	add	r7, sp, #0
  4003da:	60f8      	str	r0, [r7, #12]
  4003dc:	60b9      	str	r1, [r7, #8]
  4003de:	607a      	str	r2, [r7, #4]
  4003e0:	603b      	str	r3, [r7, #0]
	uint32_t ul_page_addr;
	uint16_t us_padding;
	uint32_t ul_error;
	uint32_t ul_idx;
	uint32_t *p_aligned_dest;
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;
  4003e2:	4b62      	ldr	r3, [pc, #392]	; (40056c <flash_write+0x198>)
  4003e4:	64bb      	str	r3, [r7, #72]	; 0x48
  4003e6:	f107 0318 	add.w	r3, r7, #24
  4003ea:	63bb      	str	r3, [r7, #56]	; 0x38
  4003ec:	68fb      	ldr	r3, [r7, #12]
  4003ee:	637b      	str	r3, [r7, #52]	; 0x34
  4003f0:	f107 0316 	add.w	r3, r7, #22
  4003f4:	633b      	str	r3, [r7, #48]	; 0x30
  4003f6:	f107 0314 	add.w	r3, r7, #20
  4003fa:	62fb      	str	r3, [r7, #44]	; 0x2c
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4003fc:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  4003fe:	f5a3 0380 	sub.w	r3, r3, #4194304	; 0x400000
  400402:	0a5b      	lsrs	r3, r3, #9
  400404:	857b      	strh	r3, [r7, #42]	; 0x2a
	us_offset = (ul_addr - IFLASH_ADDR) % IFLASH_PAGE_SIZE;
  400406:	6b7b      	ldr	r3, [r7, #52]	; 0x34
  400408:	b29b      	uxth	r3, r3
  40040a:	f3c3 0308 	ubfx	r3, r3, #0, #9
  40040e:	853b      	strh	r3, [r7, #40]	; 0x28
#endif

	/* Store values */
	if (pp_efc) {
  400410:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  400412:	2b00      	cmp	r3, #0
  400414:	d002      	beq.n	40041c <flash_write+0x48>
		*pp_efc = p_efc;
  400416:	6bbb      	ldr	r3, [r7, #56]	; 0x38
  400418:	4a55      	ldr	r2, [pc, #340]	; (400570 <flash_write+0x19c>)
  40041a:	601a      	str	r2, [r3, #0]
	}

	if (pus_page) {
  40041c:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  40041e:	2b00      	cmp	r3, #0
  400420:	d002      	beq.n	400428 <flash_write+0x54>
		*pus_page = us_page;
  400422:	6b3b      	ldr	r3, [r7, #48]	; 0x30
  400424:	8d7a      	ldrh	r2, [r7, #42]	; 0x2a
  400426:	801a      	strh	r2, [r3, #0]
	}

	if (pus_offset) {
  400428:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  40042a:	2b00      	cmp	r3, #0
  40042c:	d002      	beq.n	400434 <flash_write+0x60>
		*pus_offset = us_offset;
  40042e:	6afb      	ldr	r3, [r7, #44]	; 0x2c
  400430:	8d3a      	ldrh	r2, [r7, #40]	; 0x28
  400432:	801a      	strh	r2, [r3, #0]
	uint8_t *puc_page_buffer = (uint8_t *) gs_ul_page_buffer;

	translate_address(&p_efc, ul_address, &us_page, &us_offset);

	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
  400434:	69bb      	ldr	r3, [r7, #24]
  400436:	4618      	mov	r0, r3
  400438:	4b4e      	ldr	r3, [pc, #312]	; (400574 <flash_write+0x1a0>)
  40043a:	4798      	blx	r3
  40043c:	6478      	str	r0, [r7, #68]	; 0x44
	efc_set_wait_state(p_efc, 6);
  40043e:	69bb      	ldr	r3, [r7, #24]
  400440:	4618      	mov	r0, r3
  400442:	2106      	movs	r1, #6
  400444:	4b4c      	ldr	r3, [pc, #304]	; (400578 <flash_write+0x1a4>)
  400446:	4798      	blx	r3

	/* Write all pages */
	while (ul_size > 0) {
  400448:	e082      	b.n	400550 <flash_write+0x17c>
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
  40044a:	8abb      	ldrh	r3, [r7, #20]
  40044c:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
  400450:	687b      	ldr	r3, [r7, #4]
  400452:	429a      	cmp	r2, r3
  400454:	bf38      	it	cc
  400456:	4613      	movcc	r3, r2
  400458:	643b      	str	r3, [r7, #64]	; 0x40
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
  40045a:	8afb      	ldrh	r3, [r7, #22]
  40045c:	84fb      	strh	r3, [r7, #38]	; 0x26
  40045e:	2300      	movs	r3, #0
  400460:	84bb      	strh	r3, [r7, #36]	; 0x24
  400462:	f107 0310 	add.w	r3, r7, #16
  400466:	623b      	str	r3, [r7, #32]
/* One bank flash */
#else
	/* avoid Cppcheck Warning */
	UNUSED(p_efc);
	/* Compute address */
	ul_addr = IFLASH_ADDR + us_page * IFLASH_PAGE_SIZE + us_offset;
  400468:	8cfb      	ldrh	r3, [r7, #38]	; 0x26
  40046a:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  40046e:	025a      	lsls	r2, r3, #9
  400470:	8cbb      	ldrh	r3, [r7, #36]	; 0x24
  400472:	4413      	add	r3, r2
  400474:	61fb      	str	r3, [r7, #28]
#endif

	/* Store result */
	if (pul_addr != NULL) {
  400476:	6a3b      	ldr	r3, [r7, #32]
  400478:	2b00      	cmp	r3, #0
  40047a:	d002      	beq.n	400482 <flash_write+0xae>
		*pul_addr = ul_addr;
  40047c:	6a3b      	ldr	r3, [r7, #32]
  40047e:	69fa      	ldr	r2, [r7, #28]
  400480:	601a      	str	r2, [r3, #0]
	while (ul_size > 0) {
		/* Copy data in temporary buffer to avoid alignment problems. */
		writeSize = Min((uint32_t) IFLASH_PAGE_SIZE - us_offset,
				ul_size);
		compute_address(p_efc, us_page, 0, &ul_page_addr);
		us_padding = IFLASH_PAGE_SIZE - us_offset - writeSize;
  400482:	8abb      	ldrh	r3, [r7, #20]
  400484:	425b      	negs	r3, r3
  400486:	b29a      	uxth	r2, r3
  400488:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  40048a:	b29b      	uxth	r3, r3
  40048c:	1ad3      	subs	r3, r2, r3
  40048e:	b29b      	uxth	r3, r3
  400490:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400494:	87fb      	strh	r3, [r7, #62]	; 0x3e

		/* Pre-buffer data */
		memcpy(puc_page_buffer, (void *)ul_page_addr, us_offset);
  400496:	693b      	ldr	r3, [r7, #16]
  400498:	461a      	mov	r2, r3
  40049a:	8abb      	ldrh	r3, [r7, #20]
  40049c:	6cb8      	ldr	r0, [r7, #72]	; 0x48
  40049e:	4611      	mov	r1, r2
  4004a0:	461a      	mov	r2, r3
  4004a2:	4b36      	ldr	r3, [pc, #216]	; (40057c <flash_write+0x1a8>)
  4004a4:	4798      	blx	r3

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);
  4004a6:	8abb      	ldrh	r3, [r7, #20]
  4004a8:	6cba      	ldr	r2, [r7, #72]	; 0x48
  4004aa:	4413      	add	r3, r2
  4004ac:	4618      	mov	r0, r3
  4004ae:	68b9      	ldr	r1, [r7, #8]
  4004b0:	6c3a      	ldr	r2, [r7, #64]	; 0x40
  4004b2:	4b32      	ldr	r3, [pc, #200]	; (40057c <flash_write+0x1a8>)
  4004b4:	4798      	blx	r3

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  4004b6:	8abb      	ldrh	r3, [r7, #20]
  4004b8:	461a      	mov	r2, r3
  4004ba:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4004bc:	4413      	add	r3, r2
  4004be:	6cba      	ldr	r2, [r7, #72]	; 0x48
  4004c0:	18d1      	adds	r1, r2, r3
				(void *)(ul_page_addr + us_offset + writeSize),
  4004c2:	8abb      	ldrh	r3, [r7, #20]
  4004c4:	461a      	mov	r2, r3
  4004c6:	693b      	ldr	r3, [r7, #16]
  4004c8:	441a      	add	r2, r3
  4004ca:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  4004cc:	4413      	add	r3, r2

		/* Buffer data */
		memcpy(puc_page_buffer + us_offset, p_buffer, writeSize);

		/* Post-buffer data */
		memcpy(puc_page_buffer + us_offset + writeSize,
  4004ce:	461a      	mov	r2, r3
  4004d0:	8ffb      	ldrh	r3, [r7, #62]	; 0x3e
  4004d2:	4608      	mov	r0, r1
  4004d4:	4611      	mov	r1, r2
  4004d6:	461a      	mov	r2, r3
  4004d8:	4b28      	ldr	r3, [pc, #160]	; (40057c <flash_write+0x1a8>)
  4004da:	4798      	blx	r3

		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
  4004dc:	693b      	ldr	r3, [r7, #16]
  4004de:	64fb      	str	r3, [r7, #76]	; 0x4c
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  4004e0:	2300      	movs	r3, #0
  4004e2:	653b      	str	r3, [r7, #80]	; 0x50
  4004e4:	e00a      	b.n	4004fc <flash_write+0x128>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
  4004e6:	6cfb      	ldr	r3, [r7, #76]	; 0x4c
  4004e8:	1d1a      	adds	r2, r3, #4
  4004ea:	64fa      	str	r2, [r7, #76]	; 0x4c
  4004ec:	4a1f      	ldr	r2, [pc, #124]	; (40056c <flash_write+0x198>)
  4004ee:	6d39      	ldr	r1, [r7, #80]	; 0x50
  4004f0:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
  4004f4:	601a      	str	r2, [r3, #0]
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
				++ul_idx) {
  4004f6:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4004f8:	3301      	adds	r3, #1
  4004fa:	653b      	str	r3, [r7, #80]	; 0x50
		/* Write page.
		 * Writing 8-bit and 16-bit data is not allowed and may lead to
		 * unpredictable data corruption.
		 */
		p_aligned_dest = (uint32_t *) ul_page_addr;
		for (ul_idx = 0; ul_idx < (IFLASH_PAGE_SIZE / sizeof(uint32_t));
  4004fc:	6d3b      	ldr	r3, [r7, #80]	; 0x50
  4004fe:	2b7f      	cmp	r3, #127	; 0x7f
  400500:	d9f1      	bls.n	4004e6 <flash_write+0x112>
				++ul_idx) {
			*p_aligned_dest++ = gs_ul_page_buffer[ul_idx];
		}

		if (ul_erase_flag) {
  400502:	683b      	ldr	r3, [r7, #0]
  400504:	2b00      	cmp	r3, #0
  400506:	d008      	beq.n	40051a <flash_write+0x146>
			ul_error = efc_perform_command(p_efc, EFC_FCMD_EWP,
  400508:	69ba      	ldr	r2, [r7, #24]
  40050a:	8afb      	ldrh	r3, [r7, #22]
  40050c:	4610      	mov	r0, r2
  40050e:	2103      	movs	r1, #3
  400510:	461a      	mov	r2, r3
  400512:	4b1b      	ldr	r3, [pc, #108]	; (400580 <flash_write+0x1ac>)
  400514:	4798      	blx	r3
  400516:	6578      	str	r0, [r7, #84]	; 0x54
  400518:	e007      	b.n	40052a <flash_write+0x156>
					us_page);
		} else {
			ul_error = efc_perform_command(p_efc, EFC_FCMD_WP,
  40051a:	69ba      	ldr	r2, [r7, #24]
  40051c:	8afb      	ldrh	r3, [r7, #22]
  40051e:	4610      	mov	r0, r2
  400520:	2101      	movs	r1, #1
  400522:	461a      	mov	r2, r3
  400524:	4b16      	ldr	r3, [pc, #88]	; (400580 <flash_write+0x1ac>)
  400526:	4798      	blx	r3
  400528:	6578      	str	r0, [r7, #84]	; 0x54
					us_page);
		}

		if (ul_error) {
  40052a:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  40052c:	2b00      	cmp	r3, #0
  40052e:	d001      	beq.n	400534 <flash_write+0x160>
			return ul_error;
  400530:	6d7b      	ldr	r3, [r7, #84]	; 0x54
  400532:	e017      	b.n	400564 <flash_write+0x190>
		}

		/* Progression */
		p_buffer = (void *)((uint32_t) p_buffer + writeSize);
  400534:	68ba      	ldr	r2, [r7, #8]
  400536:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  400538:	4413      	add	r3, r2
  40053a:	60bb      	str	r3, [r7, #8]
		ul_size -= writeSize;
  40053c:	687a      	ldr	r2, [r7, #4]
  40053e:	6c3b      	ldr	r3, [r7, #64]	; 0x40
  400540:	1ad3      	subs	r3, r2, r3
  400542:	607b      	str	r3, [r7, #4]
		us_page++;
  400544:	8afb      	ldrh	r3, [r7, #22]
  400546:	3301      	adds	r3, #1
  400548:	b29b      	uxth	r3, r3
  40054a:	82fb      	strh	r3, [r7, #22]
		us_offset = 0;
  40054c:	2300      	movs	r3, #0
  40054e:	82bb      	strh	r3, [r7, #20]
	/* According to the errata, set the wait state value to 6. */
	ul_fws_temp = efc_get_wait_state(p_efc);
	efc_set_wait_state(p_efc, 6);

	/* Write all pages */
	while (ul_size > 0) {
  400550:	687b      	ldr	r3, [r7, #4]
  400552:	2b00      	cmp	r3, #0
  400554:	f47f af79 	bne.w	40044a <flash_write+0x76>
		us_page++;
		us_offset = 0;
	}

	/* According to the errata, restore the wait state value. */
	efc_set_wait_state(p_efc, ul_fws_temp);
  400558:	69bb      	ldr	r3, [r7, #24]
  40055a:	4618      	mov	r0, r3
  40055c:	6c79      	ldr	r1, [r7, #68]	; 0x44
  40055e:	4b06      	ldr	r3, [pc, #24]	; (400578 <flash_write+0x1a4>)
  400560:	4798      	blx	r3

	return FLASH_RC_OK;
  400562:	2300      	movs	r3, #0
}
  400564:	4618      	mov	r0, r3
  400566:	3758      	adds	r7, #88	; 0x58
  400568:	46bd      	mov	sp, r7
  40056a:	bd80      	pop	{r7, pc}
  40056c:	20000b38 	.word	0x20000b38
  400570:	400e0a00 	.word	0x400e0a00
  400574:	00400321 	.word	0x00400321
  400578:	00400345 	.word	0x00400345
  40057c:	00406449 	.word	0x00406449
  400580:	00400361 	.word	0x00400361

00400584 <flash_unlock>:
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  400584:	f421 51ff 	bic.w	r1, r1, #8160	; 0x1fe0
  400588:	f021 011f 	bic.w	r1, r1, #31
 *
 * \return 0 if successful, otherwise returns an error code.
 */
uint32_t flash_unlock(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
  40058c:	b570      	push	{r4, r5, r6, lr}
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  40058e:	f420 50ff 	bic.w	r0, r0, #8160	; 0x1fe0
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  400592:	f501 54ff 	add.w	r4, r1, #8160	; 0x1fe0
static void compute_lock_range(uint32_t ul_start, uint32_t ul_end,
		uint32_t *pul_actual_start, uint32_t *pul_actual_end)
{
	uint32_t ul_actual_start, ul_actual_end;

	ul_actual_start = ul_start - (ul_start % IFLASH_LOCK_REGION_SIZE);
  400596:	f020 001f 	bic.w	r0, r0, #31
	ul_actual_end = ul_end - (ul_end % IFLASH_LOCK_REGION_SIZE) +
  40059a:	341f      	adds	r4, #31
	uint16_t us_num_pages_in_region =
			IFLASH_LOCK_REGION_SIZE / IFLASH_PAGE_SIZE;

	/* Compute actual unlock range and store it */
	compute_lock_range(ul_start, ul_end, &ul_actual_start, &ul_actual_end);
	if (pul_actual_start != NULL) {
  40059c:	b102      	cbz	r2, 4005a0 <flash_unlock+0x1c>
		*pul_actual_start = ul_actual_start;
  40059e:	6010      	str	r0, [r2, #0]
	}
	if (pul_actual_end != NULL) {
  4005a0:	b103      	cbz	r3, 4005a4 <flash_unlock+0x20>
		*pul_actual_end = ul_actual_end;
  4005a2:	601c      	str	r4, [r3, #0]
#else
	Assert(ul_addr >= IFLASH_ADDR);
	Assert(ul_addr <= (IFLASH_ADDR + IFLASH_SIZE));

	p_efc = EFC;
	us_page = (ul_addr - IFLASH_ADDR) / IFLASH_PAGE_SIZE;
  4005a4:	4d0c      	ldr	r5, [pc, #48]	; (4005d8 <flash_unlock+0x54>)
  4005a6:	f5a0 0480 	sub.w	r4, r0, #4194304	; 0x400000
  4005aa:	0a64      	lsrs	r4, r4, #9
  4005ac:	440d      	add	r5, r1
  4005ae:	b2a4      	uxth	r4, r4
  4005b0:	f3c5 254f 	ubfx	r5, r5, #9, #16
	/* Compute page numbers */
	translate_address(&p_efc, ul_actual_start, &us_start_page, 0);
	translate_address(0, ul_actual_end, &us_end_page, 0);

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
  4005b4:	42ac      	cmp	r4, r5
  4005b6:	d20c      	bcs.n	4005d2 <flash_unlock+0x4e>
  4005b8:	4e08      	ldr	r6, [pc, #32]	; (4005dc <flash_unlock+0x58>)
  4005ba:	e001      	b.n	4005c0 <flash_unlock+0x3c>
  4005bc:	42ac      	cmp	r4, r5
  4005be:	d208      	bcs.n	4005d2 <flash_unlock+0x4e>
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
  4005c0:	4622      	mov	r2, r4
  4005c2:	4807      	ldr	r0, [pc, #28]	; (4005e0 <flash_unlock+0x5c>)
  4005c4:	2109      	movs	r1, #9
  4005c6:	47b0      	blx	r6
				us_start_page);
		if (ul_error) {
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
  4005c8:	3410      	adds	r4, #16
  4005ca:	b2a4      	uxth	r4, r4

	/* Unlock all pages */
	while (us_start_page < us_end_page) {
		ul_error = efc_perform_command(p_efc, EFC_FCMD_CLB,
				us_start_page);
		if (ul_error) {
  4005cc:	2800      	cmp	r0, #0
  4005ce:	d0f5      	beq.n	4005bc <flash_unlock+0x38>
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
}
  4005d0:	bd70      	pop	{r4, r5, r6, pc}
			return ul_error;
		}
		us_start_page += us_num_pages_in_region;
	}

	return FLASH_RC_OK;
  4005d2:	2000      	movs	r0, #0
  4005d4:	bd70      	pop	{r4, r5, r6, pc}
  4005d6:	bf00      	nop
  4005d8:	ffc01fff 	.word	0xffc01fff
  4005dc:	00400361 	.word	0x00400361
  4005e0:	400e0a00 	.word	0x400e0a00

004005e4 <twi_disable_interrupt>:
 * \param ul_sources Interrupts to be disabled.
 */
void twi_disable_interrupt(Twi *p_twi, uint32_t ul_sources)
{
	/* Disable the specified interrupts */
	p_twi->TWI_IDR = ul_sources;
  4005e4:	6281      	str	r1, [r0, #40]	; 0x28
	/* Dummy read */
	p_twi->TWI_SR;
  4005e6:	6a03      	ldr	r3, [r0, #32]
  4005e8:	4770      	bx	lr
  4005ea:	bf00      	nop

004005ec <twi_get_interrupt_status>:
 *
 * \retval TWI interrupt status.
 */
uint32_t twi_get_interrupt_status(Twi *p_twi)
{
	return p_twi->TWI_SR;
  4005ec:	6a00      	ldr	r0, [r0, #32]
}
  4005ee:	4770      	bx	lr

004005f0 <twi_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t twi_get_interrupt_mask(Twi *p_twi)
{
	return p_twi->TWI_IMR;
  4005f0:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
}
  4005f2:	4770      	bx	lr

004005f4 <loadNewFirmware>:
 * loadNewFirmware(char* filename)
 * @brief Load new firmware function. 
 * @return status_t returns STATUS_PASS if successful and STATUS_FAIL if there is a failure. 
 */
status_t __attribute__((optimize("O0"))) loadNewFirmware(char* filename)
{	
  4005f4:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
  4005f8:	f5ad 6dd1 	sub.w	sp, sp, #1672	; 0x688
  4005fc:	af00      	add	r7, sp, #0
  4005fe:	f107 0324 	add.w	r3, r7, #36	; 0x24
  400602:	6018      	str	r0, [r3, #0]
	status_t result = STATUS_PASS;
  400604:	2300      	movs	r3, #0
  400606:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
	FIL firmwareFileObj = {0};
  40060a:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  40060e:	f44f 720a 	mov.w	r2, #552	; 0x228
  400612:	4618      	mov	r0, r3
  400614:	2100      	movs	r1, #0
  400616:	4b76      	ldr	r3, [pc, #472]	; (4007f0 <loadNewFirmware+0x1fc>)
  400618:	4798      	blx	r3
	//initialize the suitNumber

	filename[0] = LUN_ID_SD_MMC_0_MEM + '0'; //is this necessary? 
  40061a:	f107 0324 	add.w	r3, r7, #36	; 0x24
  40061e:	681b      	ldr	r3, [r3, #0]
  400620:	2230      	movs	r2, #48	; 0x30
  400622:	701a      	strb	r2, [r3, #0]
	wdt_disable(WDT);
  400624:	4873      	ldr	r0, [pc, #460]	; (4007f4 <loadNewFirmware+0x200>)
  400626:	4b74      	ldr	r3, [pc, #464]	; (4007f8 <loadNewFirmware+0x204>)
  400628:	4798      	blx	r3
	
	FRESULT res = f_open(&firmwareFileObj, (char const *)filename, FA_OPEN_EXISTING | FA_READ);
  40062a:	f207 423c 	addw	r2, r7, #1084	; 0x43c
  40062e:	f107 0324 	add.w	r3, r7, #36	; 0x24
  400632:	4610      	mov	r0, r2
  400634:	6819      	ldr	r1, [r3, #0]
  400636:	2201      	movs	r2, #1
  400638:	4b70      	ldr	r3, [pc, #448]	; (4007fc <loadNewFirmware+0x208>)
  40063a:	4798      	blx	r3
  40063c:	4603      	mov	r3, r0
  40063e:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  400642:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  400646:	2b00      	cmp	r3, #0
  400648:	d001      	beq.n	40064e <loadNewFirmware+0x5a>
	{
		return STATUS_FAIL;
  40064a:	2301      	movs	r3, #1
  40064c:	e2d6      	b.n	400bfc <loadNewFirmware+0x608>
	}
	//read the header from the file. 
	firmwareHeader_t header = {0}; 
  40064e:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  400652:	2200      	movs	r2, #0
  400654:	601a      	str	r2, [r3, #0]
  400656:	3304      	adds	r3, #4
  400658:	2200      	movs	r2, #0
  40065a:	601a      	str	r2, [r3, #0]
  40065c:	3304      	adds	r3, #4
  40065e:	2200      	movs	r2, #0
  400660:	601a      	str	r2, [r3, #0]
  400662:	3304      	adds	r3, #4
	uint32_t bytes_read = 0, total_bytes_read = 0;	
  400664:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  400668:	2200      	movs	r2, #0
  40066a:	601a      	str	r2, [r3, #0]
  40066c:	2300      	movs	r3, #0
  40066e:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
	res = f_read(&firmwareFileObj, (void*)&header, sizeof(firmwareHeader_t), &bytes_read);
  400672:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400676:	f507 6286 	add.w	r2, r7, #1072	; 0x430
  40067a:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  40067e:	4618      	mov	r0, r3
  400680:	4611      	mov	r1, r2
  400682:	220c      	movs	r2, #12
  400684:	4623      	mov	r3, r4
  400686:	4c5e      	ldr	r4, [pc, #376]	; (400800 <loadNewFirmware+0x20c>)
  400688:	47a0      	blx	r4
  40068a:	4603      	mov	r3, r0
  40068c:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	//confirm that the file has a valid header, with the CRC bytes matching. 
	if(header.fileHeaderBytes != FIRMWARE_FILE_HEADER_BYTES ) //|| header.crc1 != header.crc2
  400690:	f507 6386 	add.w	r3, r7, #1072	; 0x430
  400694:	681a      	ldr	r2, [r3, #0]
  400696:	4b5b      	ldr	r3, [pc, #364]	; (400804 <loadNewFirmware+0x210>)
  400698:	429a      	cmp	r2, r3
  40069a:	d006      	beq.n	4006aa <loadNewFirmware+0xb6>
	{
		//bad header, don't even try to load this crap!
		f_close(&firmwareFileObj); 
  40069c:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4006a0:	4618      	mov	r0, r3
  4006a2:	4b59      	ldr	r3, [pc, #356]	; (400808 <loadNewFirmware+0x214>)
  4006a4:	4798      	blx	r3
		return STATUS_FAIL; 
  4006a6:	2301      	movs	r3, #1
  4006a8:	e2a8      	b.n	400bfc <loadNewFirmware+0x608>
	}	
	uint32_t destAddress = FIRMWARE_TEMPORARY_LOCATION; //that where we are writing
  4006aa:	4b58      	ldr	r3, [pc, #352]	; (40080c <loadNewFirmware+0x218>)
  4006ac:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
	uint32_t retVal = 0;
  4006b0:	2300      	movs	r3, #0
  4006b2:	f8c7 366c 	str.w	r3, [r7, #1644]	; 0x66c
	//initialize the memory
	retVal = flash_init(FLASH_ACCESS_MODE_128, 6); //	| EEFC_FMR_CLOE | EEFC_FMR_SCOD 
  4006b6:	2000      	movs	r0, #0
  4006b8:	2106      	movs	r1, #6
  4006ba:	4b55      	ldr	r3, [pc, #340]	; (400810 <loadNewFirmware+0x21c>)
  4006bc:	4798      	blx	r3
  4006be:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	int resultTest = 	efc_perform_fcr(EFC0,
  4006c2:	4854      	ldr	r0, [pc, #336]	; (400814 <loadNewFirmware+0x220>)
  4006c4:	4954      	ldr	r1, [pc, #336]	; (400818 <loadNewFirmware+0x224>)
  4006c6:	4b55      	ldr	r3, [pc, #340]	; (40081c <loadNewFirmware+0x228>)
  4006c8:	4798      	blx	r3
  4006ca:	4603      	mov	r3, r0
  4006cc:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
	EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0x0123) |
	0x07u);
	
	retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);			
  4006d0:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4006d4:	68da      	ldr	r2, [r3, #12]
  4006d6:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  4006da:	4413      	add	r3, r2
  4006dc:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  4006e0:	4619      	mov	r1, r3
  4006e2:	2200      	movs	r2, #0
  4006e4:	2300      	movs	r3, #0
  4006e6:	4c4e      	ldr	r4, [pc, #312]	; (400820 <loadNewFirmware+0x22c>)
  4006e8:	47a0      	blx	r4
  4006ea:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
  4006ee:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  4006f2:	f44f 7200 	mov.w	r2, #512	; 0x200
  4006f6:	4618      	mov	r0, r3
  4006f8:	2100      	movs	r1, #0
  4006fa:	4b3d      	ldr	r3, [pc, #244]	; (4007f0 <loadNewFirmware+0x1fc>)
  4006fc:	4798      	blx	r3
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
  4006fe:	f107 032c 	add.w	r3, r7, #44	; 0x2c
  400702:	f44f 7200 	mov.w	r2, #512	; 0x200
  400706:	4618      	mov	r0, r3
  400708:	2100      	movs	r1, #0
  40070a:	4b39      	ldr	r3, [pc, #228]	; (4007f0 <loadNewFirmware+0x1fc>)
  40070c:	4798      	blx	r3
		
	uint32_t i = 0, error = 0;
  40070e:	2300      	movs	r3, #0
  400710:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400714:	2300      	movs	r3, #0
  400716:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  40071a:	4b3c      	ldr	r3, [pc, #240]	; (40080c <loadNewFirmware+0x218>)
  40071c:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400720:	e016      	b.n	400750 <loadNewFirmware+0x15c>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_32);
  400722:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  400726:	2103      	movs	r1, #3
  400728:	4b3e      	ldr	r3, [pc, #248]	; (400824 <loadNewFirmware+0x230>)
  40072a:	4798      	blx	r3
  40072c:	4603      	mov	r3, r0
  40072e:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  400732:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  400736:	2b00      	cmp	r3, #0
  400738:	d004      	beq.n	400744 <loadNewFirmware+0x150>
		{
			error++;
  40073a:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  40073e:	3301      	adds	r3, #1
  400740:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	char buf[FIRMWARE_BUFFER_SIZE] = {0}; 	 
	char nullBuf[FIRMWARE_BUFFER_SIZE] = {0}; 		
		
	uint32_t i = 0, error = 0;
	//erase the program space first
	for(i=0x424000ul;i< 0x440000ul;i+=0x4000)
  400744:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400748:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  40074c:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  400750:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  400754:	f5b3 0f88 	cmp.w	r3, #4456448	; 0x440000
  400758:	d3e3      	bcc.n	400722 <loadNewFirmware+0x12e>
		if(resultTest != 0)
		{
			error++;
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  40075a:	200e      	movs	r0, #14
  40075c:	2101      	movs	r1, #1
  40075e:	4b32      	ldr	r3, [pc, #200]	; (400828 <loadNewFirmware+0x234>)
  400760:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400762:	200c      	movs	r0, #12
  400764:	2101      	movs	r1, #1
  400766:	4b30      	ldr	r3, [pc, #192]	; (400828 <loadNewFirmware+0x234>)
  400768:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
  40076a:	200d      	movs	r0, #13
  40076c:	2101      	movs	r1, #1
  40076e:	4b2e      	ldr	r3, [pc, #184]	; (400828 <loadNewFirmware+0x234>)
  400770:	4798      	blx	r3
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  400772:	e093      	b.n	40089c <loadNewFirmware+0x2a8>
	{
		res = f_read(&firmwareFileObj, buf, FIRMWARE_BUFFER_SIZE, &bytes_read);
  400774:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400778:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  40077c:	f207 442c 	addw	r4, r7, #1068	; 0x42c
  400780:	4618      	mov	r0, r3
  400782:	4611      	mov	r1, r2
  400784:	f44f 7200 	mov.w	r2, #512	; 0x200
  400788:	4623      	mov	r3, r4
  40078a:	4c1d      	ldr	r4, [pc, #116]	; (400800 <loadNewFirmware+0x20c>)
  40078c:	47a0      	blx	r4
  40078e:	4603      	mov	r3, r0
  400790:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
		if(bytes_read != 0)
  400794:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  400798:	681b      	ldr	r3, [r3, #0]
  40079a:	2b00      	cmp	r3, #0
  40079c:	d016      	beq.n	4007cc <loadNewFirmware+0x1d8>
		{		
			if(flash_write(destAddress+total_bytes_read, (void*)buf,bytes_read,0) != 0)
  40079e:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  4007a2:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4007a6:	441a      	add	r2, r3
  4007a8:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4007ac:	681c      	ldr	r4, [r3, #0]
  4007ae:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  4007b2:	4610      	mov	r0, r2
  4007b4:	4619      	mov	r1, r3
  4007b6:	4622      	mov	r2, r4
  4007b8:	2300      	movs	r3, #0
  4007ba:	4c1c      	ldr	r4, [pc, #112]	; (40082c <loadNewFirmware+0x238>)
  4007bc:	47a0      	blx	r4
  4007be:	4603      	mov	r3, r0
  4007c0:	2b00      	cmp	r3, #0
  4007c2:	d003      	beq.n	4007cc <loadNewFirmware+0x1d8>
			{
				result = STATUS_FAIL;
  4007c4:	2301      	movs	r3, #1
  4007c6:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  4007ca:	e075      	b.n	4008b8 <loadNewFirmware+0x2c4>
			}
		}
		total_bytes_read += bytes_read; 
  4007cc:	f207 432c 	addw	r3, r7, #1068	; 0x42c
  4007d0:	681b      	ldr	r3, [r3, #0]
  4007d2:	f8d7 2680 	ldr.w	r2, [r7, #1664]	; 0x680
  4007d6:	4413      	add	r3, r2
  4007d8:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		if(total_bytes_read ==  firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  4007dc:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4007e0:	68db      	ldr	r3, [r3, #12]
  4007e2:	f1a3 020c 	sub.w	r2, r3, #12
  4007e6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4007ea:	429a      	cmp	r2, r3
  4007ec:	d120      	bne.n	400830 <loadNewFirmware+0x23c>
		{
			break; //this is redundant
  4007ee:	e063      	b.n	4008b8 <loadNewFirmware+0x2c4>
  4007f0:	0040657d 	.word	0x0040657d
  4007f4:	400e1450 	.word	0x400e1450
  4007f8:	0040568d 	.word	0x0040568d
  4007fc:	0040380d 	.word	0x0040380d
  400800:	00403ab1 	.word	0x00403ab1
  400804:	aa55aa55 	.word	0xaa55aa55
  400808:	00403d19 	.word	0x00403d19
  40080c:	00424000 	.word	0x00424000
  400810:	0040038d 	.word	0x0040038d
  400814:	400e0a00 	.word	0x400e0a00
  400818:	5a012307 	.word	0x5a012307
  40081c:	2000006d 	.word	0x2000006d
  400820:	00400585 	.word	0x00400585
  400824:	004003a5 	.word	0x004003a5
  400828:	00404cd1 	.word	0x00404cd1
  40082c:	004003d5 	.word	0x004003d5
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
  400830:	200c      	movs	r0, #12
  400832:	4bac      	ldr	r3, [pc, #688]	; (400ae4 <loadNewFirmware+0x4f0>)
  400834:	4798      	blx	r3
  400836:	4bac      	ldr	r3, [pc, #688]	; (400ae8 <loadNewFirmware+0x4f4>)
		delay_ms(100);
  400838:	4618      	mov	r0, r3
  40083a:	f04f 0100 	mov.w	r1, #0
  40083e:	4602      	mov	r2, r0
  400840:	460b      	mov	r3, r1
  400842:	1892      	adds	r2, r2, r2
  400844:	eb43 0303 	adc.w	r3, r3, r3
  400848:	1812      	adds	r2, r2, r0
  40084a:	eb43 0301 	adc.w	r3, r3, r1
  40084e:	015c      	lsls	r4, r3, #5
  400850:	61fc      	str	r4, [r7, #28]
  400852:	69fd      	ldr	r5, [r7, #28]
  400854:	ea45 65d2 	orr.w	r5, r5, r2, lsr #27
  400858:	61fd      	str	r5, [r7, #28]
  40085a:	ea4f 1c42 	mov.w	ip, r2, lsl #5
  40085e:	f8c7 c018 	str.w	ip, [r7, #24]
  400862:	e9d7 4506 	ldrd	r4, r5, [r7, #24]
  400866:	1912      	adds	r2, r2, r4
  400868:	eb43 0305 	adc.w	r3, r3, r5
  40086c:	1880      	adds	r0, r0, r2
  40086e:	eb41 0103 	adc.w	r1, r1, r3
  400872:	f243 62af 	movw	r2, #13999	; 0x36af
  400876:	f04f 0300 	mov.w	r3, #0
  40087a:	1812      	adds	r2, r2, r0
  40087c:	eb43 0301 	adc.w	r3, r3, r1
  400880:	4c9a      	ldr	r4, [pc, #616]	; (400aec <loadNewFirmware+0x4f8>)
  400882:	4610      	mov	r0, r2
  400884:	4619      	mov	r1, r3
  400886:	f243 62b0 	movw	r2, #14000	; 0x36b0
  40088a:	f04f 0300 	mov.w	r3, #0
  40088e:	47a0      	blx	r4
  400890:	4602      	mov	r2, r0
  400892:	460b      	mov	r3, r1
  400894:	4613      	mov	r3, r2
  400896:	4618      	mov	r0, r3
  400898:	4b95      	ldr	r3, [pc, #596]	; (400af0 <loadNewFirmware+0x4fc>)
  40089a:	4798      	blx	r3
		}	
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);			
	while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t) && res == FR_OK)
  40089c:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  4008a0:	68db      	ldr	r3, [r3, #12]
  4008a2:	f1a3 020c 	sub.w	r2, r3, #12
  4008a6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  4008aa:	429a      	cmp	r2, r3
  4008ac:	d904      	bls.n	4008b8 <loadNewFirmware+0x2c4>
  4008ae:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  4008b2:	2b00      	cmp	r3, #0
  4008b4:	f43f af5e 	beq.w	400774 <loadNewFirmware+0x180>
			break; //this is redundant
		}
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 
		delay_ms(100);
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
  4008b8:	200d      	movs	r0, #13
  4008ba:	2100      	movs	r1, #0
  4008bc:	4b8d      	ldr	r3, [pc, #564]	; (400af4 <loadNewFirmware+0x500>)
  4008be:	4798      	blx	r3
  4008c0:	4b89      	ldr	r3, [pc, #548]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  4008c2:	4618      	mov	r0, r3
  4008c4:	f04f 0100 	mov.w	r1, #0
  4008c8:	4602      	mov	r2, r0
  4008ca:	460b      	mov	r3, r1
  4008cc:	1892      	adds	r2, r2, r2
  4008ce:	eb43 0303 	adc.w	r3, r3, r3
  4008d2:	1812      	adds	r2, r2, r0
  4008d4:	eb43 0301 	adc.w	r3, r3, r1
  4008d8:	015d      	lsls	r5, r3, #5
  4008da:	617d      	str	r5, [r7, #20]
  4008dc:	f8d7 c014 	ldr.w	ip, [r7, #20]
  4008e0:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  4008e4:	f8c7 c014 	str.w	ip, [r7, #20]
  4008e8:	0154      	lsls	r4, r2, #5
  4008ea:	613c      	str	r4, [r7, #16]
  4008ec:	e9d7 4504 	ldrd	r4, r5, [r7, #16]
  4008f0:	1912      	adds	r2, r2, r4
  4008f2:	eb43 0305 	adc.w	r3, r3, r5
  4008f6:	1880      	adds	r0, r0, r2
  4008f8:	eb41 0103 	adc.w	r1, r1, r3
  4008fc:	f243 62af 	movw	r2, #13999	; 0x36af
  400900:	f04f 0300 	mov.w	r3, #0
  400904:	1812      	adds	r2, r2, r0
  400906:	eb43 0301 	adc.w	r3, r3, r1
  40090a:	4c78      	ldr	r4, [pc, #480]	; (400aec <loadNewFirmware+0x4f8>)
  40090c:	4610      	mov	r0, r2
  40090e:	4619      	mov	r1, r3
  400910:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400914:	f04f 0300 	mov.w	r3, #0
  400918:	47a0      	blx	r4
  40091a:	4602      	mov	r2, r0
  40091c:	460b      	mov	r3, r1
  40091e:	4613      	mov	r3, r2
  400920:	4618      	mov	r0, r3
  400922:	4b73      	ldr	r3, [pc, #460]	; (400af0 <loadNewFirmware+0x4fc>)
  400924:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
  400926:	200d      	movs	r0, #13
  400928:	2101      	movs	r1, #1
  40092a:	4b72      	ldr	r3, [pc, #456]	; (400af4 <loadNewFirmware+0x500>)
  40092c:	4798      	blx	r3
  40092e:	4b6e      	ldr	r3, [pc, #440]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);	
  400930:	4618      	mov	r0, r3
  400932:	f04f 0100 	mov.w	r1, #0
  400936:	4602      	mov	r2, r0
  400938:	460b      	mov	r3, r1
  40093a:	1892      	adds	r2, r2, r2
  40093c:	eb43 0303 	adc.w	r3, r3, r3
  400940:	1812      	adds	r2, r2, r0
  400942:	eb43 0301 	adc.w	r3, r3, r1
  400946:	015d      	lsls	r5, r3, #5
  400948:	60fd      	str	r5, [r7, #12]
  40094a:	f8d7 c00c 	ldr.w	ip, [r7, #12]
  40094e:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  400952:	f8c7 c00c 	str.w	ip, [r7, #12]
  400956:	0154      	lsls	r4, r2, #5
  400958:	60bc      	str	r4, [r7, #8]
  40095a:	e9d7 4502 	ldrd	r4, r5, [r7, #8]
  40095e:	1912      	adds	r2, r2, r4
  400960:	eb43 0305 	adc.w	r3, r3, r5
  400964:	1880      	adds	r0, r0, r2
  400966:	eb41 0103 	adc.w	r1, r1, r3
  40096a:	f243 62af 	movw	r2, #13999	; 0x36af
  40096e:	f04f 0300 	mov.w	r3, #0
  400972:	1812      	adds	r2, r2, r0
  400974:	eb43 0301 	adc.w	r3, r3, r1
  400978:	4c5c      	ldr	r4, [pc, #368]	; (400aec <loadNewFirmware+0x4f8>)
  40097a:	4610      	mov	r0, r2
  40097c:	4619      	mov	r1, r3
  40097e:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400982:	f04f 0300 	mov.w	r3, #0
  400986:	47a0      	blx	r4
  400988:	4602      	mov	r2, r0
  40098a:	460b      	mov	r3, r1
  40098c:	4613      	mov	r3, r2
  40098e:	4618      	mov	r0, r3
  400990:	4b57      	ldr	r3, [pc, #348]	; (400af0 <loadNewFirmware+0x4fc>)
  400992:	4798      	blx	r3
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  400994:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  400998:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  40099c:	e016      	b.n	4009cc <loadNewFirmware+0x3d8>
	{
		resultTest = flash_erase_page(i,IFLASH_ERASE_PAGES_16);
  40099e:	f8d7 067c 	ldr.w	r0, [r7, #1660]	; 0x67c
  4009a2:	2102      	movs	r1, #2
  4009a4:	4b54      	ldr	r3, [pc, #336]	; (400af8 <loadNewFirmware+0x504>)
  4009a6:	4798      	blx	r3
  4009a8:	4603      	mov	r3, r0
  4009aa:	f8c7 3668 	str.w	r3, [r7, #1640]	; 0x668
		if(resultTest != 0)
  4009ae:	f8d7 3668 	ldr.w	r3, [r7, #1640]	; 0x668
  4009b2:	2b00      	cmp	r3, #0
  4009b4:	d004      	beq.n	4009c0 <loadNewFirmware+0x3cc>
		{
			error++;
  4009b6:	f8d7 3678 	ldr.w	r3, [r7, #1656]	; 0x678
  4009ba:	3301      	adds	r3, #1
  4009bc:	f8c7 3678 	str.w	r3, [r7, #1656]	; 0x678
	}
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW);
	delay_ms(100);
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH);
	delay_ms(100);	
	for(i=0x408000ul;i< 0x424000ul;i+=0x2000)
  4009c0:	f8d7 367c 	ldr.w	r3, [r7, #1660]	; 0x67c
  4009c4:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
  4009c8:	f8c7 367c 	str.w	r3, [r7, #1660]	; 0x67c
  4009cc:	f8d7 267c 	ldr.w	r2, [r7, #1660]	; 0x67c
  4009d0:	4b4a      	ldr	r3, [pc, #296]	; (400afc <loadNewFirmware+0x508>)
  4009d2:	429a      	cmp	r2, r3
  4009d4:	d9e3      	bls.n	40099e <loadNewFirmware+0x3aa>
		{
			error++;
		}
	}	
	//verify firmware
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  4009d6:	200c      	movs	r0, #12
  4009d8:	2101      	movs	r1, #1
  4009da:	4b46      	ldr	r3, [pc, #280]	; (400af4 <loadNewFirmware+0x500>)
  4009dc:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW);
  4009de:	200e      	movs	r0, #14
  4009e0:	2100      	movs	r1, #0
  4009e2:	4b44      	ldr	r3, [pc, #272]	; (400af4 <loadNewFirmware+0x500>)
  4009e4:	4798      	blx	r3
  4009e6:	4b40      	ldr	r3, [pc, #256]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  4009e8:	4618      	mov	r0, r3
  4009ea:	f04f 0100 	mov.w	r1, #0
  4009ee:	4602      	mov	r2, r0
  4009f0:	460b      	mov	r3, r1
  4009f2:	1892      	adds	r2, r2, r2
  4009f4:	eb43 0303 	adc.w	r3, r3, r3
  4009f8:	1812      	adds	r2, r2, r0
  4009fa:	eb43 0301 	adc.w	r3, r3, r1
  4009fe:	ea4f 1b43 	mov.w	fp, r3, lsl #5
  400a02:	ea4b 6bd2 	orr.w	fp, fp, r2, lsr #27
  400a06:	ea4f 1a42 	mov.w	sl, r2, lsl #5
  400a0a:	eb12 020a 	adds.w	r2, r2, sl
  400a0e:	eb43 030b 	adc.w	r3, r3, fp
  400a12:	1880      	adds	r0, r0, r2
  400a14:	eb41 0103 	adc.w	r1, r1, r3
  400a18:	f243 62af 	movw	r2, #13999	; 0x36af
  400a1c:	f04f 0300 	mov.w	r3, #0
  400a20:	1812      	adds	r2, r2, r0
  400a22:	eb43 0301 	adc.w	r3, r3, r1
  400a26:	4c31      	ldr	r4, [pc, #196]	; (400aec <loadNewFirmware+0x4f8>)
  400a28:	4610      	mov	r0, r2
  400a2a:	4619      	mov	r1, r3
  400a2c:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400a30:	f04f 0300 	mov.w	r3, #0
  400a34:	47a0      	blx	r4
  400a36:	4602      	mov	r2, r0
  400a38:	460b      	mov	r3, r1
  400a3a:	4613      	mov	r3, r2
  400a3c:	4618      	mov	r0, r3
  400a3e:	4b2c      	ldr	r3, [pc, #176]	; (400af0 <loadNewFirmware+0x4fc>)
  400a40:	4798      	blx	r3
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH);
  400a42:	200e      	movs	r0, #14
  400a44:	2101      	movs	r1, #1
  400a46:	4b2b      	ldr	r3, [pc, #172]	; (400af4 <loadNewFirmware+0x500>)
  400a48:	4798      	blx	r3
  400a4a:	4b27      	ldr	r3, [pc, #156]	; (400ae8 <loadNewFirmware+0x4f4>)
	delay_ms(100);
  400a4c:	4618      	mov	r0, r3
  400a4e:	f04f 0100 	mov.w	r1, #0
  400a52:	4602      	mov	r2, r0
  400a54:	460b      	mov	r3, r1
  400a56:	1892      	adds	r2, r2, r2
  400a58:	eb43 0303 	adc.w	r3, r3, r3
  400a5c:	1812      	adds	r2, r2, r0
  400a5e:	eb43 0301 	adc.w	r3, r3, r1
  400a62:	ea4f 1943 	mov.w	r9, r3, lsl #5
  400a66:	ea49 69d2 	orr.w	r9, r9, r2, lsr #27
  400a6a:	ea4f 1842 	mov.w	r8, r2, lsl #5
  400a6e:	eb12 0208 	adds.w	r2, r2, r8
  400a72:	eb43 0309 	adc.w	r3, r3, r9
  400a76:	1880      	adds	r0, r0, r2
  400a78:	eb41 0103 	adc.w	r1, r1, r3
  400a7c:	f243 62af 	movw	r2, #13999	; 0x36af
  400a80:	f04f 0300 	mov.w	r3, #0
  400a84:	1812      	adds	r2, r2, r0
  400a86:	eb43 0301 	adc.w	r3, r3, r1
  400a8a:	4c18      	ldr	r4, [pc, #96]	; (400aec <loadNewFirmware+0x4f8>)
  400a8c:	4610      	mov	r0, r2
  400a8e:	4619      	mov	r1, r3
  400a90:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400a94:	f04f 0300 	mov.w	r3, #0
  400a98:	47a0      	blx	r4
  400a9a:	4602      	mov	r2, r0
  400a9c:	460b      	mov	r3, r1
  400a9e:	4613      	mov	r3, r2
  400aa0:	4618      	mov	r0, r3
  400aa2:	4b13      	ldr	r3, [pc, #76]	; (400af0 <loadNewFirmware+0x4fc>)
  400aa4:	4798      	blx	r3
	//TODO fix CRC problem. 
	//uint32_t ul_crc = compute_crc((uint8_t *)FIRMWARE_TEMPORARY_LOCATION, firmwareFileObj.fsize - sizeof(firmwareHeader_t),
	//CRCCU_MR_PTYPE_CASTAGNOLI);
	uint32_t ul_crc =0;
  400aa6:	2300      	movs	r3, #0
  400aa8:	f8c7 3664 	str.w	r3, [r7, #1636]	; 0x664
	fileCRC = ul_crc; 
  400aac:	4b14      	ldr	r3, [pc, #80]	; (400b00 <loadNewFirmware+0x50c>)
  400aae:	f8d7 2664 	ldr.w	r2, [r7, #1636]	; 0x664
  400ab2:	601a      	str	r2, [r3, #0]
	//if(header.crc == fileCRC)
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
  400ab4:	2300      	movs	r3, #0
  400ab6:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
		destAddress = APP_START_ADDRESS;
  400aba:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
  400abe:	f8c7 3670 	str.w	r3, [r7, #1648]	; 0x670
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
  400ac2:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400ac6:	68da      	ldr	r2, [r3, #12]
  400ac8:	f8d7 3670 	ldr.w	r3, [r7, #1648]	; 0x670
  400acc:	4413      	add	r3, r2
  400ace:	f8d7 0670 	ldr.w	r0, [r7, #1648]	; 0x670
  400ad2:	4619      	mov	r1, r3
  400ad4:	2200      	movs	r2, #0
  400ad6:	2300      	movs	r3, #0
  400ad8:	4c0a      	ldr	r4, [pc, #40]	; (400b04 <loadNewFirmware+0x510>)
  400ada:	47a0      	blx	r4
  400adc:	f8c7 066c 	str.w	r0, [r7, #1644]	; 0x66c
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400ae0:	e074      	b.n	400bcc <loadNewFirmware+0x5d8>
  400ae2:	bf00      	nop
  400ae4:	00404d79 	.word	0x00404d79
  400ae8:	07270e00 	.word	0x07270e00
  400aec:	00405905 	.word	0x00405905
  400af0:	20000085 	.word	0x20000085
  400af4:	00404cd1 	.word	0x00404cd1
  400af8:	004003a5 	.word	0x004003a5
  400afc:	00423fff 	.word	0x00423fff
  400b00:	20000d38 	.word	0x20000d38
  400b04:	00400585 	.word	0x00400585
		{			
			memcpy(buf,FIRMWARE_TEMPORARY_LOCATION+total_bytes_read,FIRMWARE_BUFFER_SIZE); 			
  400b08:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b0c:	f503 0384 	add.w	r3, r3, #4325376	; 0x420000
  400b10:	f503 4380 	add.w	r3, r3, #16384	; 0x4000
  400b14:	f507 720b 	add.w	r2, r7, #556	; 0x22c
  400b18:	4611      	mov	r1, r2
  400b1a:	461a      	mov	r2, r3
  400b1c:	f44f 7300 	mov.w	r3, #512	; 0x200
  400b20:	4608      	mov	r0, r1
  400b22:	4611      	mov	r1, r2
  400b24:	461a      	mov	r2, r3
  400b26:	4b38      	ldr	r3, [pc, #224]	; (400c08 <loadNewFirmware+0x614>)
  400b28:	4798      	blx	r3
			if(flash_write(destAddress+total_bytes_read, (void*)buf,FIRMWARE_BUFFER_SIZE,0) != 0)
  400b2a:	f8d7 2670 	ldr.w	r2, [r7, #1648]	; 0x670
  400b2e:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b32:	441a      	add	r2, r3
  400b34:	f507 730b 	add.w	r3, r7, #556	; 0x22c
  400b38:	4610      	mov	r0, r2
  400b3a:	4619      	mov	r1, r3
  400b3c:	f44f 7200 	mov.w	r2, #512	; 0x200
  400b40:	2300      	movs	r3, #0
  400b42:	4c32      	ldr	r4, [pc, #200]	; (400c0c <loadNewFirmware+0x618>)
  400b44:	47a0      	blx	r4
  400b46:	4603      	mov	r3, r0
  400b48:	2b00      	cmp	r3, #0
  400b4a:	d003      	beq.n	400b54 <loadNewFirmware+0x560>
			{
				result = STATUS_FAIL;
  400b4c:	2301      	movs	r3, #1
  400b4e:	f887 3677 	strb.w	r3, [r7, #1655]	; 0x677
				break;
  400b52:	e044      	b.n	400bde <loadNewFirmware+0x5ea>
			}
			total_bytes_read += FIRMWARE_BUFFER_SIZE; 
  400b54:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400b58:	f503 7300 	add.w	r3, r3, #512	; 0x200
  400b5c:	f8c7 3680 	str.w	r3, [r7, #1664]	; 0x680
			drv_gpio_togglePin(DRV_GPIO_PIN_BLUE_LED);
  400b60:	200d      	movs	r0, #13
  400b62:	4b2b      	ldr	r3, [pc, #172]	; (400c10 <loadNewFirmware+0x61c>)
  400b64:	4798      	blx	r3
  400b66:	4b2b      	ldr	r3, [pc, #172]	; (400c14 <loadNewFirmware+0x620>)
			delay_ms(100);
  400b68:	4618      	mov	r0, r3
  400b6a:	f04f 0100 	mov.w	r1, #0
  400b6e:	4602      	mov	r2, r0
  400b70:	460b      	mov	r3, r1
  400b72:	1892      	adds	r2, r2, r2
  400b74:	eb43 0303 	adc.w	r3, r3, r3
  400b78:	1812      	adds	r2, r2, r0
  400b7a:	eb43 0301 	adc.w	r3, r3, r1
  400b7e:	015d      	lsls	r5, r3, #5
  400b80:	607d      	str	r5, [r7, #4]
  400b82:	f8d7 c004 	ldr.w	ip, [r7, #4]
  400b86:	ea4c 6cd2 	orr.w	ip, ip, r2, lsr #27
  400b8a:	f8c7 c004 	str.w	ip, [r7, #4]
  400b8e:	0154      	lsls	r4, r2, #5
  400b90:	603c      	str	r4, [r7, #0]
  400b92:	e9d7 4500 	ldrd	r4, r5, [r7]
  400b96:	1912      	adds	r2, r2, r4
  400b98:	eb43 0305 	adc.w	r3, r3, r5
  400b9c:	1880      	adds	r0, r0, r2
  400b9e:	eb41 0103 	adc.w	r1, r1, r3
  400ba2:	f243 62af 	movw	r2, #13999	; 0x36af
  400ba6:	f04f 0300 	mov.w	r3, #0
  400baa:	1812      	adds	r2, r2, r0
  400bac:	eb43 0301 	adc.w	r3, r3, r1
  400bb0:	4c19      	ldr	r4, [pc, #100]	; (400c18 <loadNewFirmware+0x624>)
  400bb2:	4610      	mov	r0, r2
  400bb4:	4619      	mov	r1, r3
  400bb6:	f243 62b0 	movw	r2, #14000	; 0x36b0
  400bba:	f04f 0300 	mov.w	r3, #0
  400bbe:	47a0      	blx	r4
  400bc0:	4602      	mov	r2, r0
  400bc2:	460b      	mov	r3, r1
  400bc4:	4613      	mov	r3, r2
  400bc6:	4618      	mov	r0, r3
  400bc8:	4b14      	ldr	r3, [pc, #80]	; (400c1c <loadNewFirmware+0x628>)
  400bca:	4798      	blx	r3
	//{
		//CRC checks out, let copy the firmware to the final location
		total_bytes_read =0;
		destAddress = APP_START_ADDRESS;
		retVal = flash_unlock(destAddress,destAddress + firmwareFileObj.fsize ,NULL,NULL);
		while(total_bytes_read < firmwareFileObj.fsize - sizeof(firmwareHeader_t))
  400bcc:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400bd0:	68db      	ldr	r3, [r3, #12]
  400bd2:	f1a3 020c 	sub.w	r2, r3, #12
  400bd6:	f8d7 3680 	ldr.w	r3, [r7, #1664]	; 0x680
  400bda:	429a      	cmp	r2, r3
  400bdc:	d894      	bhi.n	400b08 <loadNewFirmware+0x514>
	//else
	//{
		//result = STATUS_FAIL; 
	//}
		//
	res = f_close(&firmwareFileObj);
  400bde:	f207 433c 	addw	r3, r7, #1084	; 0x43c
  400be2:	4618      	mov	r0, r3
  400be4:	4b0e      	ldr	r3, [pc, #56]	; (400c20 <loadNewFirmware+0x62c>)
  400be6:	4798      	blx	r3
  400be8:	4603      	mov	r3, r0
  400bea:	f887 3687 	strb.w	r3, [r7, #1671]	; 0x687
	if (res != FR_OK)
  400bee:	f897 3687 	ldrb.w	r3, [r7, #1671]	; 0x687
  400bf2:	2b00      	cmp	r3, #0
  400bf4:	d001      	beq.n	400bfa <loadNewFirmware+0x606>
	{
		return STATUS_FAIL;
  400bf6:	2301      	movs	r3, #1
  400bf8:	e000      	b.n	400bfc <loadNewFirmware+0x608>
	}
	return STATUS_PASS; 	
  400bfa:	2300      	movs	r3, #0
}
  400bfc:	4618      	mov	r0, r3
  400bfe:	f507 67d1 	add.w	r7, r7, #1672	; 0x688
  400c02:	46bd      	mov	sp, r7
  400c04:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
  400c08:	00406449 	.word	0x00406449
  400c0c:	004003d5 	.word	0x004003d5
  400c10:	00404d79 	.word	0x00404d79
  400c14:	07270e00 	.word	0x07270e00
  400c18:	00405905 	.word	0x00405905
  400c1c:	20000085 	.word	0x20000085
  400c20:	00403d19 	.word	0x00403d19

00400c24 <runBootloader>:
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  400c24:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  400c28:	4b6e      	ldr	r3, [pc, #440]	; (400de4 <runBootloader+0x1c0>)
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c2a:	4c6f      	ldr	r4, [pc, #444]	; (400de8 <runBootloader+0x1c4>)
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
	drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//Check for Low Battery
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  400c2c:	4f6f      	ldr	r7, [pc, #444]	; (400dec <runBootloader+0x1c8>)
 * It will copy a executable to a temporary location, then load it into the main program space. 
 * The bootloader program is always loaded onto a release board at location 0x00000000 and executes the main
 * program. 
 */
void runBootloader()
{
  400c2e:	b085      	sub	sp, #20
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
  400c30:	4798      	blx	r3
	pmc_enable_periph_clk(ID_CRCCU);   		    
  400c32:	4b6f      	ldr	r3, [pc, #444]	; (400df0 <runBootloader+0x1cc>)
  400c34:	2020      	movs	r0, #32
  400c36:	4798      	blx	r3
	board_init();	
  400c38:	4b6e      	ldr	r3, [pc, #440]	; (400df4 <runBootloader+0x1d0>)
  400c3a:	4798      	blx	r3
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  400c3c:	2301      	movs	r3, #1
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c3e:	4618      	mov	r0, r3
  400c40:	a903      	add	r1, sp, #12
{
	status_t status = STATUS_PASS; 
	drv_gpio_initializeAll();
	pmc_enable_periph_clk(ID_CRCCU);   		    
	board_init();	
	drv_gpio_pin_state_t sw1State = DRV_GPIO_PIN_STATE_HIGH, sw2State = DRV_GPIO_PIN_STATE_HIGH, lboState = DRV_GPIO_PIN_STATE_HIGH; 	
  400c42:	f88d 300c 	strb.w	r3, [sp, #12]
  400c46:	f88d 300d 	strb.w	r3, [sp, #13]
  400c4a:	f88d 300e 	strb.w	r3, [sp, #14]
	//check pins for seeing if the bootloader should be entered. 
	uint32_t enterBootloader = 0;
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400c4e:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  400c50:	f10d 010d 	add.w	r1, sp, #13
  400c54:	2002      	movs	r0, #2
  400c56:	47a0      	blx	r4
	drv_gpio_getPinState(DRV_GPIO_PIN_LBO, &lboState);	//Check for Low Battery
  400c58:	f10d 010e 	add.w	r1, sp, #14
  400c5c:	200f      	movs	r0, #15
  400c5e:	47a0      	blx	r4
	int i = 0; 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_LOW);
  400c60:	2100      	movs	r1, #0
  400c62:	200c      	movs	r0, #12
  400c64:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400c66:	200d      	movs	r0, #13
  400c68:	2100      	movs	r1, #0
  400c6a:	47b8      	blx	r7
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
  400c6c:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400c70:	2b00      	cmp	r3, #0
  400c72:	d143      	bne.n	400cfc <runBootloader+0xd8>
  400c74:	f89d 300d 	ldrb.w	r3, [sp, #13]
  400c78:	2b00      	cmp	r3, #0
  400c7a:	d13f      	bne.n	400cfc <runBootloader+0xd8>
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
  400c7c:	f89d 300e 	ldrb.w	r3, [sp, #14]
  400c80:	2b00      	cmp	r3, #0
  400c82:	d048      	beq.n	400d16 <runBootloader+0xf2>
  400c84:	4e5c      	ldr	r6, [pc, #368]	; (400df8 <runBootloader+0x1d4>)
  400c86:	250a      	movs	r5, #10
  400c88:	e00a      	b.n	400ca0 <runBootloader+0x7c>
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400c8a:	f89d 800d 	ldrb.w	r8, [sp, #13]
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400c8e:	485b      	ldr	r0, [pc, #364]	; (400dfc <runBootloader+0x1d8>)
			for(i=0;i<10;i++)
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400c90:	f1d8 0801 	rsbs	r8, r8, #1
  400c94:	bf38      	it	cc
  400c96:	f04f 0800 	movcc.w	r8, #0
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400c9a:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400c9c:	3d01      	subs	r5, #1
  400c9e:	d010      	beq.n	400cc2 <runBootloader+0x9e>
			{		
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
  400ca0:	a903      	add	r1, sp, #12
  400ca2:	2001      	movs	r0, #1
  400ca4:	47a0      	blx	r4
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
  400ca6:	2002      	movs	r0, #2
  400ca8:	f10d 010d 	add.w	r1, sp, #13
  400cac:	47a0      	blx	r4
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
  400cae:	f89d 300c 	ldrb.w	r3, [sp, #12]
  400cb2:	2b00      	cmp	r3, #0
  400cb4:	d0e9      	beq.n	400c8a <runBootloader+0x66>
				{
					enterBootloader = 0; 
				}
				delay_ms(100); 			
  400cb6:	4851      	ldr	r0, [pc, #324]	; (400dfc <runBootloader+0x1d8>)
  400cb8:	47b0      	blx	r6
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400cba:	3d01      	subs	r5, #1
				enterBootloader = 1; //set the enter bootloader flag
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW1,&sw1State);
				drv_gpio_getPinState(DRV_GPIO_PIN_AC_SW2,&sw2State);
				if(sw1State != DRV_GPIO_PIN_STATE_LOW || sw2State != DRV_GPIO_PIN_STATE_LOW)
				{
					enterBootloader = 0; 
  400cbc:	f04f 0800 	mov.w	r8, #0
			enterBootloader = 0;
		}
		else
		{
			//make sure that both IO stay low for 1 second
			for(i=0;i<10;i++)
  400cc0:	d1ee      	bne.n	400ca0 <runBootloader+0x7c>
				}
				delay_ms(100); 			
			}		
		}
	}	
	if(enterBootloader == 1)
  400cc2:	f1b8 0f00 	cmp.w	r8, #0
  400cc6:	d019      	beq.n	400cfc <runBootloader+0xd8>
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400cc8:	a904      	add	r1, sp, #16
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400cca:	2010      	movs	r0, #16
		}
	}	
	if(enterBootloader == 1)
	{
		//if bootloader conditions met initialize SD card and load firmware	
		drv_gpio_pin_state_t sdCardCD = DRV_GPIO_PIN_STATE_LOW; 
  400ccc:	f801 5d01 	strb.w	r5, [r1, #-1]!
		//Check if SD card is installed
		drv_gpio_getPinState(DRV_GPIO_PIN_SD_CD,&sdCardCD);
  400cd0:	47a0      	blx	r4
		if(sdCardCD != DRV_GPIO_PIN_STATE_HIGH)
  400cd2:	f89d 300f 	ldrb.w	r3, [sp, #15]
  400cd6:	2b01      	cmp	r3, #1
  400cd8:	d020      	beq.n	400d1c <runBootloader+0xf8>
 * errorBlink()
 * @brief blink led red 5 times to indicate error
 */
static void errorBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400cda:	2101      	movs	r1, #1
  400cdc:	200e      	movs	r0, #14
  400cde:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ce0:	2101      	movs	r1, #1
  400ce2:	200c      	movs	r0, #12
  400ce4:	47b8      	blx	r7
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400ce6:	200d      	movs	r0, #13
  400ce8:	2101      	movs	r1, #1
  400cea:	47b8      	blx	r7
  400cec:	4d44      	ldr	r5, [pc, #272]	; (400e00 <runBootloader+0x1dc>)
  400cee:	240a      	movs	r4, #10
	
	int i = 0;
	for(i=0; i<10; i++)
	{
		delay_ms(200); 
  400cf0:	4844      	ldr	r0, [pc, #272]	; (400e04 <runBootloader+0x1e0>)
  400cf2:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_RED_LED); 	
  400cf4:	200e      	movs	r0, #14
  400cf6:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<10; i++)
  400cf8:	3c01      	subs	r4, #1
  400cfa:	d1f9      	bne.n	400cf0 <runBootloader+0xcc>
 */
static void start_application(void)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
  400cfc:	f44f 0381 	mov.w	r3, #4227072	; 0x408000

    \param [in]    topOfMainStack  Main Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
{
  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) : "sp");
  400d00:	681a      	ldr	r2, [r3, #0]
  400d02:	f382 8808 	msr	MSP, r2
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400d06:	4940      	ldr	r1, [pc, #256]	; (400e08 <runBootloader+0x1e4>)
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
  400d08:	4a40      	ldr	r2, [pc, #256]	; (400e0c <runBootloader+0x1e8>)
{
	uint32_t app_start_address;
	/* Rebase the Stack Pointer */
	__set_MSP(*(uint32_t *) APP_START_ADDRESS);
	/* Rebase the vector table base address */
	SCB->VTOR = ((uint32_t) APP_START_ADDRESS & SCB_VTOR_TBLOFF_Msk);
  400d0a:	608b      	str	r3, [r1, #8]
	/* Load the Reset Handler address of the application */
	app_start_address = *(uint32_t *)(APP_START_ADDRESS+4); 
	/* Jump to application Reset Handler in the application */
	asm("bx %0"::"r"(app_start_address));
  400d0c:	6813      	ldr	r3, [r2, #0]
  400d0e:	4718      	bx	r3
		//unmount the drive
		//f_mount(LUN_ID_SD_MMC_0_MEM, NULL);		
	} 	   
	start_application();
	
}
  400d10:	b005      	add	sp, #20
  400d12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if(sw1State == DRV_GPIO_PIN_STATE_LOW && sw2State == DRV_GPIO_PIN_STATE_LOW)
	{
		if (lboState == DRV_GPIO_PIN_STATE_LOW)
		{
			//battery is low, don't run bootloader
			lowBatteryBlink();
  400d16:	4b3e      	ldr	r3, [pc, #248]	; (400e10 <runBootloader+0x1ec>)
  400d18:	4798      	blx	r3
  400d1a:	e7ef      	b.n	400cfc <runBootloader+0xd8>
static status_t initializeSDCard()
{
	static FRESULT res;
	status_t status = STATUS_PASS; 
	////Initialize SD card
	sd_mmc_init();
  400d1c:	4b3d      	ldr	r3, [pc, #244]	; (400e14 <runBootloader+0x1f0>)
  400d1e:	f8df a110 	ldr.w	sl, [pc, #272]	; 400e30 <runBootloader+0x20c>
  400d22:	f8df 9110 	ldr.w	r9, [pc, #272]	; 400e34 <runBootloader+0x210>
  400d26:	f8df 8110 	ldr.w	r8, [pc, #272]	; 400e38 <runBootloader+0x214>
  400d2a:	4798      	blx	r3
	//
	///* Wait card present and ready */
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
  400d2c:	f44f 74fa 	mov.w	r4, #500	; 0x1f4
  400d30:	e008      	b.n	400d44 <runBootloader+0x120>
					break; 
				}
			}
		}
		maxAttemptCount--;
		if(maxAttemptCount == 0)
  400d32:	3c01      	subs	r4, #1
  400d34:	d049      	beq.n	400dca <runBootloader+0x1a6>
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400d36:	4838      	ldr	r0, [pc, #224]	; (400e18 <runBootloader+0x1f4>)
		
		
	} while (CTRL_GOOD != res);
  400d38:	f8df b0f8 	ldr.w	fp, [pc, #248]	; 400e34 <runBootloader+0x210>
		if(maxAttemptCount == 0)
		{
			status = STATUS_FAIL;
			break;
		}
		delay_ms(10);
  400d3c:	47b0      	blx	r6
		
		
	} while (CTRL_GOOD != res);
  400d3e:	f899 3000 	ldrb.w	r3, [r9]
  400d42:	b17b      	cbz	r3, 400d64 <runBootloader+0x140>
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400d44:	2000      	movs	r0, #0
  400d46:	47d0      	blx	sl
		if (res == CTRL_FAIL)
  400d48:	2801      	cmp	r0, #1
	//
	////we don't want the firmware to freeze if we don't have an SD card.
	int maxAttemptCount = 500; 
	do
	{
		res = sd_mmc_test_unit_ready(0);
  400d4a:	f889 0000 	strb.w	r0, [r9]
		if (res == CTRL_FAIL)
  400d4e:	d1f0      	bne.n	400d32 <runBootloader+0x10e>
		{
			while (CTRL_NO_PRESENT != sd_mmc_check(0))
  400d50:	2000      	movs	r0, #0
  400d52:	47c0      	blx	r8
  400d54:	2802      	cmp	r0, #2
  400d56:	d0ec      	beq.n	400d32 <runBootloader+0x10e>
			{
				maxAttemptCount--; 
				if(maxAttemptCount == 0)
  400d58:	3c01      	subs	r4, #1
  400d5a:	d1f9      	bne.n	400d50 <runBootloader+0x12c>
				{
					status = STATUS_FAIL;
  400d5c:	2501      	movs	r5, #1
					break; 
				}
			}
		}
		maxAttemptCount--;
  400d5e:	f04f 34ff 	mov.w	r4, #4294967295
  400d62:	e7e8      	b.n	400d36 <runBootloader+0x112>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400d64:	4619      	mov	r1, r3
  400d66:	f44f 720c 	mov.w	r2, #560	; 0x230
  400d6a:	9301      	str	r3, [sp, #4]
  400d6c:	482b      	ldr	r0, [pc, #172]	; (400e1c <runBootloader+0x1f8>)
  400d6e:	4c2c      	ldr	r4, [pc, #176]	; (400e20 <runBootloader+0x1fc>)
  400d70:	47a0      	blx	r4
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400d72:	9b01      	ldr	r3, [sp, #4]
  400d74:	4929      	ldr	r1, [pc, #164]	; (400e1c <runBootloader+0x1f8>)
  400d76:	4618      	mov	r0, r3
  400d78:	4b2a      	ldr	r3, [pc, #168]	; (400e24 <runBootloader+0x200>)
  400d7a:	4798      	blx	r3
	if (res == FR_INVALID_DRIVE)
  400d7c:	280b      	cmp	r0, #11
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400d7e:	f88b 0000 	strb.w	r0, [fp]
	if (res == FR_INVALID_DRIVE)
  400d82:	d0aa      	beq.n	400cda <runBootloader+0xb6>
		if(status == STATUS_PASS)
		{
			status = initializeSDCard(); 	
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
  400d84:	2d00      	cmp	r5, #0
  400d86:	d1a8      	bne.n	400cda <runBootloader+0xb6>
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400d88:	2101      	movs	r1, #1
  400d8a:	200c      	movs	r0, #12
  400d8c:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
  400d8e:	4629      	mov	r1, r5
  400d90:	200d      	movs	r0, #13
  400d92:	47b8      	blx	r7
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
  400d94:	4629      	mov	r1, r5
  400d96:	200e      	movs	r0, #14
  400d98:	47b8      	blx	r7
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400d9a:	4823      	ldr	r0, [pc, #140]	; (400e28 <runBootloader+0x204>)
  400d9c:	4b23      	ldr	r3, [pc, #140]	; (400e2c <runBootloader+0x208>)
		}
		//load the new firmware only if the card was initialized. 		
		if(status == STATUS_PASS)
		{		
			//set the LED to purple during the firmware load
			drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH);
  400d9e:	4c13      	ldr	r4, [pc, #76]	; (400dec <runBootloader+0x1c8>)
			drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_LOW); 
			drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_LOW); 
			status = loadNewFirmware(FIRMWARE_IMAGE_NAME);						
  400da0:	4798      	blx	r3
		}
		if(status != STATUS_PASS)
  400da2:	2800      	cmp	r0, #0
  400da4:	d199      	bne.n	400cda <runBootloader+0xb6>
 * successBlink()
 * @brief blink led green 3 times if successful
 */
static void successBlink()
{
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400da6:	2101      	movs	r1, #1
  400da8:	200e      	movs	r0, #14
  400daa:	47a0      	blx	r4
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400dac:	2101      	movs	r1, #1
  400dae:	200c      	movs	r0, #12
  400db0:	47a0      	blx	r4
  400db2:	4d13      	ldr	r5, [pc, #76]	; (400e00 <runBootloader+0x1dc>)
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
  400db4:	200d      	movs	r0, #13
  400db6:	2101      	movs	r1, #1
  400db8:	47a0      	blx	r4
  400dba:	2406      	movs	r4, #6
	
	int i = 0;
	for(i=0; i<6; i++)
	{
		delay_ms(200); 
  400dbc:	4811      	ldr	r0, [pc, #68]	; (400e04 <runBootloader+0x1e0>)
  400dbe:	47b0      	blx	r6
		drv_gpio_togglePin(DRV_GPIO_PIN_GREEN_LED); 	
  400dc0:	200c      	movs	r0, #12
  400dc2:	47a8      	blx	r5
	drv_gpio_setPinState(DRV_GPIO_PIN_RED_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_GREEN_LED, DRV_GPIO_PIN_STATE_HIGH); 
	drv_gpio_setPinState(DRV_GPIO_PIN_BLUE_LED, DRV_GPIO_PIN_STATE_HIGH); 
	
	int i = 0;
	for(i=0; i<6; i++)
  400dc4:	3c01      	subs	r4, #1
  400dc6:	d1f9      	bne.n	400dbc <runBootloader+0x198>
  400dc8:	e798      	b.n	400cfc <runBootloader+0xd8>
		
	} while (CTRL_GOOD != res);
		
		
	/*	Mount the SD card	*/
	memset(&fs, 0, sizeof(FATFS));
  400dca:	4b15      	ldr	r3, [pc, #84]	; (400e20 <runBootloader+0x1fc>)
  400dcc:	4813      	ldr	r0, [pc, #76]	; (400e1c <runBootloader+0x1f8>)
  400dce:	4621      	mov	r1, r4
  400dd0:	f44f 720c 	mov.w	r2, #560	; 0x230
  400dd4:	4798      	blx	r3
	res = f_mount(LUN_ID_SD_MMC_0_MEM, &fs);
  400dd6:	4620      	mov	r0, r4
  400dd8:	4910      	ldr	r1, [pc, #64]	; (400e1c <runBootloader+0x1f8>)
  400dda:	4b12      	ldr	r3, [pc, #72]	; (400e24 <runBootloader+0x200>)
  400ddc:	4798      	blx	r3
  400dde:	f889 0000 	strb.w	r0, [r9]
  400de2:	e77a      	b.n	400cda <runBootloader+0xb6>
  400de4:	00404c95 	.word	0x00404c95
  400de8:	00404d49 	.word	0x00404d49
  400dec:	00404cd1 	.word	0x00404cd1
  400df0:	00405649 	.word	0x00405649
  400df4:	00405139 	.word	0x00405139
  400df8:	20000085 	.word	0x20000085
  400dfc:	000d1437 	.word	0x000d1437
  400e00:	00404d79 	.word	0x00404d79
  400e04:	001a286e 	.word	0x001a286e
  400e08:	e000ed00 	.word	0xe000ed00
  400e0c:	00408004 	.word	0x00408004
  400e10:	00400f79 	.word	0x00400f79
  400e14:	00401105 	.word	0x00401105
  400e18:	00014ed3 	.word	0x00014ed3
  400e1c:	20001190 	.word	0x20001190
  400e20:	0040657d 	.word	0x0040657d
  400e24:	004037cd 	.word	0x004037cd
  400e28:	00406a50 	.word	0x00406a50
  400e2c:	004005f5 	.word	0x004005f5
  400e30:	00401aad 	.word	0x00401aad
  400e34:	20000d3c 	.word	0x20000d3c
  400e38:	00401125 	.word	0x00401125

00400e3c <debugPrintString>:
		task_debugLogWriteEntry(timeStampedStr, length);
	}
}

void __attribute__((optimize("O0"))) debugPrintString(char* str)
{
  400e3c:	b580      	push	{r7, lr}
  400e3e:	b0b6      	sub	sp, #216	; 0xd8
  400e40:	af00      	add	r7, sp, #0
  400e42:	6078      	str	r0, [r7, #4]
	size_t length = 0;
  400e44:	2300      	movs	r3, #0
  400e46:	f8c7 30d4 	str.w	r3, [r7, #212]	; 0xd4
	char timeStampedStr[MAX_DEBUG_STRING_LENGTH];
	int len = itoa(sgSysTickCount, timeStampedStr, 10);
  400e4a:	4b27      	ldr	r3, [pc, #156]	; (400ee8 <debugPrintString+0xac>)
  400e4c:	681b      	ldr	r3, [r3, #0]
  400e4e:	461a      	mov	r2, r3
  400e50:	f107 0308 	add.w	r3, r7, #8
  400e54:	4610      	mov	r0, r2
  400e56:	4619      	mov	r1, r3
  400e58:	220a      	movs	r2, #10
  400e5a:	4b24      	ldr	r3, [pc, #144]	; (400eec <debugPrintString+0xb0>)
  400e5c:	4798      	blx	r3
  400e5e:	f8c7 00d0 	str.w	r0, [r7, #208]	; 0xd0
	timeStampedStr[len++] = ',';
  400e62:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e66:	1c5a      	adds	r2, r3, #1
  400e68:	f8c7 20d0 	str.w	r2, [r7, #208]	; 0xd0
  400e6c:	f107 02d8 	add.w	r2, r7, #216	; 0xd8
  400e70:	4413      	add	r3, r2
  400e72:	222c      	movs	r2, #44	; 0x2c
  400e74:	f803 2cd0 	strb.w	r2, [r3, #-208]
	strncpy(timeStampedStr+len, str, MAX_DEBUG_STRING_LENGTH-len);
  400e78:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e7c:	f107 0208 	add.w	r2, r7, #8
  400e80:	441a      	add	r2, r3
  400e82:	f8d7 30d0 	ldr.w	r3, [r7, #208]	; 0xd0
  400e86:	f1c3 03c8 	rsb	r3, r3, #200	; 0xc8
  400e8a:	4610      	mov	r0, r2
  400e8c:	6879      	ldr	r1, [r7, #4]
  400e8e:	461a      	mov	r2, r3
  400e90:	4b17      	ldr	r3, [pc, #92]	; (400ef0 <debugPrintString+0xb4>)
  400e92:	4798      	blx	r3
	
	length = strlen(timeStampedStr); 
  400e94:	f107 0308 	add.w	r3, r7, #8
  400e98:	4618      	mov	r0, r3
  400e9a:	4b16      	ldr	r3, [pc, #88]	; (400ef4 <debugPrintString+0xb8>)
  400e9c:	4798      	blx	r3
  400e9e:	f8c7 00d4 	str.w	r0, [r7, #212]	; 0xd4
	if(length > 0)
  400ea2:	f8d7 30d4 	ldr.w	r3, [r7, #212]	; 0xd4
  400ea6:	2b00      	cmp	r3, #0
  400ea8:	d01a      	beq.n	400ee0 <debugPrintString+0xa4>
	{
		if(brainSettings.debugPrintsEnabled)
  400eaa:	4b13      	ldr	r3, [pc, #76]	; (400ef8 <debugPrintString+0xbc>)
  400eac:	f893 309f 	ldrb.w	r3, [r3, #159]	; 0x9f
  400eb0:	2b00      	cmp	r3, #0
  400eb2:	d00e      	beq.n	400ed2 <debugPrintString+0x96>
		{
			if(config != NULL)
  400eb4:	4b11      	ldr	r3, [pc, #68]	; (400efc <debugPrintString+0xc0>)
  400eb6:	681b      	ldr	r3, [r3, #0]
  400eb8:	2b00      	cmp	r3, #0
  400eba:	d00a      	beq.n	400ed2 <debugPrintString+0x96>
			{
				drv_uart_putData((config->uart), timeStampedStr, length);
  400ebc:	4b0f      	ldr	r3, [pc, #60]	; (400efc <debugPrintString+0xc0>)
  400ebe:	681b      	ldr	r3, [r3, #0]
  400ec0:	681a      	ldr	r2, [r3, #0]
  400ec2:	f107 0308 	add.w	r3, r7, #8
  400ec6:	4610      	mov	r0, r2
  400ec8:	4619      	mov	r1, r3
  400eca:	f8d7 20d4 	ldr.w	r2, [r7, #212]	; 0xd4
  400ece:	4b0c      	ldr	r3, [pc, #48]	; (400f00 <debugPrintString+0xc4>)
  400ed0:	4798      	blx	r3
			}
		}
		task_debugLogWriteEntry(timeStampedStr, length);
  400ed2:	f107 0308 	add.w	r3, r7, #8
  400ed6:	4618      	mov	r0, r3
  400ed8:	f8d7 10d4 	ldr.w	r1, [r7, #212]	; 0xd4
  400edc:	4b09      	ldr	r3, [pc, #36]	; (400f04 <debugPrintString+0xc8>)
  400ede:	4798      	blx	r3
	}
}
  400ee0:	37d8      	adds	r7, #216	; 0xd8
  400ee2:	46bd      	mov	sp, r7
  400ee4:	bd80      	pop	{r7, pc}
  400ee6:	bf00      	nop
  400ee8:	20001158 	.word	0x20001158
  400eec:	004048b5 	.word	0x004048b5
  400ef0:	0040669d 	.word	0x0040669d
  400ef4:	0040663d 	.word	0x0040663d
  400ef8:	200000c0 	.word	0x200000c0
  400efc:	20000d40 	.word	0x20000d40
  400f00:	00404f6d 	.word	0x00404f6d
  400f04:	00400f09 	.word	0x00400f09

00400f08 <task_debugLogWriteEntry>:

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400f08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400f0a:	4c15      	ldr	r4, [pc, #84]	; (400f60 <task_debugLogWriteEntry+0x58>)
  400f0c:	6823      	ldr	r3, [r4, #0]

	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
  400f0e:	4607      	mov	r7, r0
  400f10:	460e      	mov	r6, r1
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
  400f12:	b13b      	cbz	r3, 400f24 <task_debugLogWriteEntry+0x1c>
	{
		return STATUS_FAIL; 
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
  400f14:	2100      	movs	r1, #0
  400f16:	4618      	mov	r0, r3
  400f18:	2205      	movs	r2, #5
  400f1a:	460b      	mov	r3, r1
  400f1c:	4d11      	ldr	r5, [pc, #68]	; (400f64 <task_debugLogWriteEntry+0x5c>)
  400f1e:	47a8      	blx	r5
  400f20:	2801      	cmp	r0, #1
  400f22:	d001      	beq.n	400f28 <task_debugLogWriteEntry+0x20>
{
	status_t status = STATUS_PASS;
	//take the semaphore
	if(semaphore_sdCardWrite == NULL)
	{
		return STATUS_FAIL; 
  400f24:	2001      	movs	r0, #1
  400f26:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}	
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
  400f28:	4d0f      	ldr	r5, [pc, #60]	; (400f68 <task_debugLogWriteEntry+0x60>)
  400f2a:	682a      	ldr	r2, [r5, #0]
  400f2c:	4432      	add	r2, r6
  400f2e:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  400f32:	d308      	bcc.n	400f46 <task_debugLogWriteEntry+0x3e>
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
			debugLogBufferPointer += length;
		}
		else
		{
			status = STATUS_FAIL;
  400f34:	4605      	mov	r5, r0
		}
		xSemaphoreGive(semaphore_sdCardWrite);
  400f36:	2100      	movs	r1, #0
  400f38:	6820      	ldr	r0, [r4, #0]
  400f3a:	4c0c      	ldr	r4, [pc, #48]	; (400f6c <task_debugLogWriteEntry+0x64>)
  400f3c:	460a      	mov	r2, r1
  400f3e:	460b      	mov	r3, r1
  400f40:	47a0      	blx	r4
  400f42:	4628      	mov	r0, r5
	{
		status = STATUS_FAIL;
	}	
	return status;
	
}
  400f44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if(xSemaphoreTake(semaphore_sdCardWrite,5) == true)
	{
		//copy data to sdCard buffer, make sure we have room first
		if(debugLogBufferPointer + length < DEBUG_LOG_BUFFER_SIZE)
		{
			memcpy(debugLogBuffer+debugLogBufferPointer,entry,length);
  400f46:	682a      	ldr	r2, [r5, #0]
  400f48:	4809      	ldr	r0, [pc, #36]	; (400f70 <task_debugLogWriteEntry+0x68>)
  400f4a:	4b0a      	ldr	r3, [pc, #40]	; (400f74 <task_debugLogWriteEntry+0x6c>)
  400f4c:	4410      	add	r0, r2
  400f4e:	4639      	mov	r1, r7
  400f50:	4632      	mov	r2, r6
  400f52:	4798      	blx	r3
			debugLogBufferPointer += length;
  400f54:	682b      	ldr	r3, [r5, #0]
  400f56:	441e      	add	r6, r3
  400f58:	602e      	str	r6, [r5, #0]
	return status; 
}

status_t task_debugLogWriteEntry(char* entry, size_t length)
{
	status_t status = STATUS_PASS;
  400f5a:	2500      	movs	r5, #0
  400f5c:	e7eb      	b.n	400f36 <task_debugLogWriteEntry+0x2e>
  400f5e:	bf00      	nop
  400f60:	20000d44 	.word	0x20000d44
  400f64:	004041c9 	.word	0x004041c9
  400f68:	20000f48 	.word	0x20000f48
  400f6c:	0040405d 	.word	0x0040405d
  400f70:	20000d48 	.word	0x20000d48
  400f74:	00406449 	.word	0x00406449

00400f78 <lowBatteryBlink>:
 * @brief Blink the LED to indicate low battery 
 * @param void
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
  400f78:	b570      	push	{r4, r5, r6, lr}
  400f7a:	4e08      	ldr	r6, [pc, #32]	; (400f9c <lowBatteryBlink+0x24>)
  400f7c:	4d08      	ldr	r5, [pc, #32]	; (400fa0 <lowBatteryBlink+0x28>)
  400f7e:	2403      	movs	r4, #3
	//Blink the LED connected to STAT pin to indicate battery low
	for (int i = 0; i < 3; i++)
	{
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_HIGH);
  400f80:	2101      	movs	r1, #1
  400f82:	2012      	movs	r0, #18
  400f84:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  400f86:	4807      	ldr	r0, [pc, #28]	; (400fa4 <lowBatteryBlink+0x2c>)
  400f88:	47a8      	blx	r5
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_LOW);
  400f8a:	2100      	movs	r1, #0
  400f8c:	2012      	movs	r0, #18
  400f8e:	47b0      	blx	r6
		delay_ms(LED_BLINK_RATE);
  400f90:	4804      	ldr	r0, [pc, #16]	; (400fa4 <lowBatteryBlink+0x2c>)
  400f92:	47a8      	blx	r5
 * @return void
 ***********************************************************************************************/
void lowBatteryBlink()
{
	//Blink the LED connected to STAT pin to indicate battery low
	for (int i = 0; i < 3; i++)
  400f94:	3c01      	subs	r4, #1
  400f96:	d1f3      	bne.n	400f80 <lowBatteryBlink+0x8>
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_HIGH);
		delay_ms(LED_BLINK_RATE);
		drv_gpio_setPinState(DRV_GPIO_PIN_STAT, DRV_GPIO_PIN_STATE_LOW);
		delay_ms(LED_BLINK_RATE);
	}
  400f98:	bd70      	pop	{r4, r5, r6, pc}
  400f9a:	bf00      	nop
  400f9c:	00404cd1 	.word	0x00404cd1
  400fa0:	20000085 	.word	0x20000085
  400fa4:	0020b28a 	.word	0x0020b28a

00400fa8 <sd_mmc_configure_slot>:

/**
 * \brief Configures the driver with the selected card configuration
 */
static void sd_mmc_configure_slot(void)
{
  400fa8:	b510      	push	{r4, lr}
	driver_select_device(sd_mmc_slot_sel, sd_mmc_card->clock,
  400faa:	4a07      	ldr	r2, [pc, #28]	; (400fc8 <sd_mmc_configure_slot+0x20>)
  400fac:	4b07      	ldr	r3, [pc, #28]	; (400fcc <sd_mmc_configure_slot+0x24>)
  400fae:	6812      	ldr	r2, [r2, #0]
  400fb0:	7818      	ldrb	r0, [r3, #0]
  400fb2:	f892 3022 	ldrb.w	r3, [r2, #34]	; 0x22
  400fb6:	6811      	ldr	r1, [r2, #0]
  400fb8:	4c05      	ldr	r4, [pc, #20]	; (400fd0 <sd_mmc_configure_slot+0x28>)
  400fba:	7c52      	ldrb	r2, [r2, #17]
  400fbc:	3300      	adds	r3, #0
  400fbe:	bf18      	it	ne
  400fc0:	2301      	movne	r3, #1
  400fc2:	47a0      	blx	r4
  400fc4:	bd10      	pop	{r4, pc}
  400fc6:	bf00      	nop
  400fc8:	20000f50 	.word	0x20000f50
  400fcc:	20000f56 	.word	0x20000f56
  400fd0:	00401e1d 	.word	0x00401e1d

00400fd4 <sd_mmc_select_slot.part.0>:
 * \retval SD_MMC_ERR_NO_CARD  No card present on slot
 * \retval SD_MMC_ERR_UNUSABLE Unusable card
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
  400fd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	}
	Assert(sd_mmc_nb_block_remaining == 0);

#if (defined SD_MMC_0_CD_GPIO)
	//! Card Detect pins
	if (ioport_get_pin_level(sd_mmc_cards[slot].cd_gpio)
  400fd6:	00c5      	lsls	r5, r0, #3
  400fd8:	4c34      	ldr	r4, [pc, #208]	; (4010ac <sd_mmc_select_slot.part.0+0xd8>)
  400fda:	1829      	adds	r1, r5, r0
  400fdc:	eb04 0181 	add.w	r1, r4, r1, lsl #2
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400fe0:	2601      	movs	r6, #1
  400fe2:	688a      	ldr	r2, [r1, #8]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  400fe4:	0953      	lsrs	r3, r2, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  400fe6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  400fea:	f203 7307 	addw	r3, r3, #1799	; 0x707
  400fee:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400ff0:	f002 021f 	and.w	r2, r2, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  400ff4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  400ff6:	fa06 f202 	lsl.w	r2, r6, r2
  400ffa:	4013      	ands	r3, r2
  400ffc:	f101 0108 	add.w	r1, r1, #8
  401000:	d110      	bne.n	401024 <sd_mmc_select_slot.part.0+0x50>
			!= SD_MMC_0_CD_DETECT_VALUE) {
		if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  401002:	7989      	ldrb	r1, [r1, #6]
  401004:	42b1      	cmp	r1, r6
  401006:	d006      	beq.n	401016 <sd_mmc_select_slot.part.0+0x42>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  401008:	4428      	add	r0, r5
  40100a:	eb04 0480 	add.w	r4, r4, r0, lsl #2
  40100e:	2304      	movs	r3, #4
  401010:	73a3      	strb	r3, [r4, #14]
		return SD_MMC_ERR_NO_CARD;
  401012:	2002      	movs	r0, #2
  401014:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
}

static inline void SD_MMC_STOP_TIMEOUT(void)
{
	if (sd_mmc_sam_systick_used) {
  401016:	4a26      	ldr	r2, [pc, #152]	; (4010b0 <sd_mmc_select_slot.part.0+0xdc>)
  401018:	7812      	ldrb	r2, [r2, #0]
  40101a:	2a00      	cmp	r2, #0
  40101c:	d0f4      	beq.n	401008 <sd_mmc_select_slot.part.0+0x34>
		SysTick->CTRL = 0;
  40101e:	4a25      	ldr	r2, [pc, #148]	; (4010b4 <sd_mmc_select_slot.part.0+0xe0>)
  401020:	6013      	str	r3, [r2, #0]
  401022:	e7f1      	b.n	401008 <sd_mmc_select_slot.part.0+0x34>
			SD_MMC_STOP_TIMEOUT();
		}
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
  401024:	798b      	ldrb	r3, [r1, #6]
  401026:	2b04      	cmp	r3, #4
  401028:	d02a      	beq.n	401080 <sd_mmc_select_slot.part.0+0xac>
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
  40102a:	2b01      	cmp	r3, #1
  40102c:	d003      	beq.n	401036 <sd_mmc_select_slot.part.0+0x62>
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
		sd_mmc_cards[slot].high_speed = 0;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_UNUSABLE) {
  40102e:	2b03      	cmp	r3, #3
  401030:	d118      	bne.n	401064 <sd_mmc_select_slot.part.0+0x90>
		return SD_MMC_ERR_UNUSABLE;
  401032:	4618      	mov	r0, r3
  401034:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
}

static inline bool SD_MMC_IS_TIMEOUT(void)
{
	if (!sd_mmc_sam_systick_used) {
  401036:	4b1e      	ldr	r3, [pc, #120]	; (4010b0 <sd_mmc_select_slot.part.0+0xdc>)
  401038:	781b      	ldrb	r3, [r3, #0]
  40103a:	b12b      	cbz	r3, 401048 <sd_mmc_select_slot.part.0+0x74>
		return (xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdTRUE);
#else
		return true;
#endif
	}
	if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) {
  40103c:	4b1d      	ldr	r3, [pc, #116]	; (4010b4 <sd_mmc_select_slot.part.0+0xe0>)
  40103e:	681a      	ldr	r2, [r3, #0]
  401040:	03d2      	lsls	r2, r2, #15
  401042:	d530      	bpl.n	4010a6 <sd_mmc_select_slot.part.0+0xd2>
		SysTick->CTRL = 0;
  401044:	2200      	movs	r2, #0
  401046:	601a      	str	r2, [r3, #0]
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  401048:	1829      	adds	r1, r5, r0
  40104a:	0089      	lsls	r1, r1, #2
  40104c:	1863      	adds	r3, r4, r1
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  40104e:	4f1a      	ldr	r7, [pc, #104]	; (4010b8 <sd_mmc_select_slot.part.0+0xe4>)
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
  401050:	2602      	movs	r6, #2
  401052:	739e      	strb	r6, [r3, #14]
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
  401054:	5067      	str	r7, [r4, r1]
		sd_mmc_cards[slot].bus_width = 1;
  401056:	2701      	movs	r7, #1
		sd_mmc_cards[slot].high_speed = 0;
  401058:	2100      	movs	r1, #0
		}
		// Card is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_INIT;
		// Set 1-bit bus width and low clock for initialization
		sd_mmc_cards[slot].clock = SDMMC_CLOCK_INIT;
		sd_mmc_cards[slot].bus_width = 1;
  40105a:	745f      	strb	r7, [r3, #17]
		sd_mmc_cards[slot].high_speed = 0;
  40105c:	f883 1022 	strb.w	r1, [r3, #34]	; 0x22
  401060:	7b9b      	ldrb	r3, [r3, #14]
  401062:	e7e4      	b.n	40102e <sd_mmc_select_slot.part.0+0x5a>
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
  401064:	4405      	add	r5, r0
  401066:	eb04 0485 	add.w	r4, r4, r5, lsl #2
  40106a:	4914      	ldr	r1, [pc, #80]	; (4010bc <sd_mmc_select_slot.part.0+0xe8>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  40106c:	4a14      	ldr	r2, [pc, #80]	; (4010c0 <sd_mmc_select_slot.part.0+0xec>)
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
  40106e:	4b15      	ldr	r3, [pc, #84]	; (4010c4 <sd_mmc_select_slot.part.0+0xf0>)
		sd_mmc_cards[slot].high_speed = 0;
	}
#endif

	// Initialize interface
	sd_mmc_slot_sel = slot;
  401070:	7010      	strb	r0, [r2, #0]
	sd_mmc_card = &sd_mmc_cards[slot];
  401072:	600c      	str	r4, [r1, #0]
	sd_mmc_configure_slot();
  401074:	4798      	blx	r3
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
			SD_MMC_INIT_ONGOING : SD_MMC_OK;
  401076:	7ba0      	ldrb	r0, [r4, #14]

	// Initialize interface
	sd_mmc_slot_sel = slot;
	sd_mmc_card = &sd_mmc_cards[slot];
	sd_mmc_configure_slot();
	return (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_INIT) ?
  401078:	1e83      	subs	r3, r0, #2
  40107a:	4258      	negs	r0, r3
  40107c:	4158      	adcs	r0, r3
  40107e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  401080:	4b0c      	ldr	r3, [pc, #48]	; (4010b4 <sd_mmc_select_slot.part.0+0xe0>)
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
		return SD_MMC_ERR_NO_CARD;
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
  401082:	718e      	strb	r6, [r1, #6]
		static xTimeOutType xTimeOut;
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
  401084:	681a      	ldr	r2, [r3, #0]
  401086:	b932      	cbnz	r2, 401096 <sd_mmc_select_slot.part.0+0xc2>
		sd_mmc_sam_systick_used = true;
  401088:	4909      	ldr	r1, [pc, #36]	; (4010b0 <sd_mmc_select_slot.part.0+0xdc>)
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  40108a:	4a0f      	ldr	r2, [pc, #60]	; (4010c8 <sd_mmc_select_slot.part.0+0xf4>)
#endif

static inline void SD_MMC_START_TIMEOUT(void)
{
	if (!SysTick->CTRL) {
		sd_mmc_sam_systick_used = true;
  40108c:	700e      	strb	r6, [r1, #0]
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
  40108e:	605a      	str	r2, [r3, #4]
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
  401090:	601e      	str	r6, [r3, #0]
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  401092:	2002      	movs	r0, #2
  401094:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  401096:	4a06      	ldr	r2, [pc, #24]	; (4010b0 <sd_mmc_select_slot.part.0+0xdc>)
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  401098:	480c      	ldr	r0, [pc, #48]	; (4010cc <sd_mmc_select_slot.part.0+0xf8>)
  40109a:	4b0d      	ldr	r3, [pc, #52]	; (4010d0 <sd_mmc_select_slot.part.0+0xfc>)
		sd_mmc_sam_systick_used = true;
		SysTick->LOAD = (sysclk_get_cpu_hz() / (8 * 1000))
				* SD_MMC_DEBOUNCE_TIMEOUT;
		SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	} else {
		sd_mmc_sam_systick_used = false;
  40109c:	2100      	movs	r1, #0
  40109e:	7011      	strb	r1, [r2, #0]
#ifdef FREERTOS_USED
		// Note: the define INCLUDE_vTaskDelay must be set to one
		// in FreeRTOSConfig.h file.
		vTaskSetTimeOutState(&xTimeOut);
#else
		delay_ms(SD_MMC_DEBOUNCE_TIMEOUT);
  4010a0:	4798      	blx	r3
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_NO_CARD) {
		// A card plug on going, but this is not initialized
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_DEBOUNCE;
		// Debounce + Power On Setup
		SD_MMC_START_TIMEOUT();
		return SD_MMC_ERR_NO_CARD;
  4010a2:	2002      	movs	r0, #2
  4010a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}
	if (sd_mmc_cards[slot].state == SD_MMC_CARD_STATE_DEBOUNCE) {
		if (!SD_MMC_IS_TIMEOUT()) {
			// Debounce on going
			return SD_MMC_ERR_NO_CARD;
  4010a6:	2002      	movs	r0, #2
  4010a8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4010aa:	bf00      	nop
  4010ac:	20000090 	.word	0x20000090
  4010b0:	20000f4e 	.word	0x20000f4e
  4010b4:	e000e010 	.word	0xe000e010
  4010b8:	00061a80 	.word	0x00061a80
  4010bc:	20000f50 	.word	0x20000f50
  4010c0:	20000f56 	.word	0x20000f56
  4010c4:	00400fa9 	.word	0x00400fa9
  4010c8:	00e4e1c0 	.word	0x00e4e1c0
  4010cc:	0082ca25 	.word	0x0082ca25
  4010d0:	20000085 	.word	0x20000085

004010d4 <sd_mmc_cmd9_mci>:
 * data (CSD) on the CMD line mci.
 *
 * \return true if success, otherwise false
 */
static bool sd_mmc_cmd9_mci(void)
{
  4010d4:	b538      	push	{r3, r4, r5, lr}
	if (!driver_send_cmd(SDMMC_MCI_CMD9_SEND_CSD, (uint32_t)sd_mmc_card->rca << 16)) {
  4010d6:	4d08      	ldr	r5, [pc, #32]	; (4010f8 <sd_mmc_cmd9_mci+0x24>)
  4010d8:	4a08      	ldr	r2, [pc, #32]	; (4010fc <sd_mmc_cmd9_mci+0x28>)
  4010da:	682b      	ldr	r3, [r5, #0]
  4010dc:	8999      	ldrh	r1, [r3, #12]
  4010de:	f641 3009 	movw	r0, #6921	; 0x1b09
  4010e2:	0409      	lsls	r1, r1, #16
  4010e4:	4790      	blx	r2
  4010e6:	4604      	mov	r4, r0
  4010e8:	b118      	cbz	r0, 4010f2 <sd_mmc_cmd9_mci+0x1e>
		return false;
	}
	driver_get_response_128(sd_mmc_card->csd);
  4010ea:	6828      	ldr	r0, [r5, #0]
  4010ec:	4b04      	ldr	r3, [pc, #16]	; (401100 <sd_mmc_cmd9_mci+0x2c>)
  4010ee:	3012      	adds	r0, #18
  4010f0:	4798      	blx	r3
	return true;
}
  4010f2:	4620      	mov	r0, r4
  4010f4:	bd38      	pop	{r3, r4, r5, pc}
  4010f6:	bf00      	nop
  4010f8:	20000f50 	.word	0x20000f50
  4010fc:	00401ec1 	.word	0x00401ec1
  401100:	00401ef5 	.word	0x00401ef5

00401104 <sd_mmc_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void sd_mmc_init(void)
{
  401104:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  401106:	4804      	ldr	r0, [pc, #16]	; (401118 <sd_mmc_init+0x14>)
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  401108:	4a04      	ldr	r2, [pc, #16]	; (40111c <sd_mmc_init+0x18>)
	driver_init();
  40110a:	4b05      	ldr	r3, [pc, #20]	; (401120 <sd_mmc_init+0x1c>)
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  40110c:	2404      	movs	r4, #4
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  40110e:	21ff      	movs	r1, #255	; 0xff
	pmc_enable_periph_clk(SD_MMC_##slot##_WP_PIO_ID);
	MREPEAT(SD_MMC_MEM_CNT, SD_MMC_ENABLE_WP_PIN, ~)
# undef SD_MMC_ENABLE_WP_PIN
#endif
	for (uint8_t slot = 0; slot < SD_MMC_MEM_CNT; slot++) {
		sd_mmc_cards[slot].state = SD_MMC_CARD_STATE_NO_CARD;
  401110:	7384      	strb	r4, [r0, #14]
	}
	sd_mmc_slot_sel = 0xFF; // No slot configurated
  401112:	7011      	strb	r1, [r2, #0]
	driver_init();
  401114:	4798      	blx	r3
  401116:	bd10      	pop	{r4, pc}
  401118:	20000090 	.word	0x20000090
  40111c:	20000f56 	.word	0x20000f56
  401120:	00401de5 	.word	0x00401de5

00401124 <sd_mmc_check>:
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  401124:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  401128:	4605      	mov	r5, r0
{
	return SD_MMC_MEM_CNT;
}

sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
  40112a:	b095      	sub	sp, #84	; 0x54
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40112c:	2800      	cmp	r0, #0
  40112e:	f000 80ea 	beq.w	401306 <sd_mmc_check+0x1e2>
		return SD_MMC_ERR_SLOT;
  401132:	2404      	movs	r4, #4
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401134:	4b9e      	ldr	r3, [pc, #632]	; (4013b0 <sd_mmc_check+0x28c>)
  401136:	7818      	ldrb	r0, [r3, #0]
  401138:	2800      	cmp	r0, #0
  40113a:	f000 80de 	beq.w	4012fa <sd_mmc_check+0x1d6>
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  40113e:	4620      	mov	r0, r4
  401140:	b015      	add	sp, #84	; 0x54
  401142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	uint32_t resp;

	*v2 = 0;
	// Test for SD version 2
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
  401146:	f245 5008 	movw	r0, #21768	; 0x5508
  40114a:	f44f 71d5 	mov.w	r1, #426	; 0x1aa
  40114e:	47b0      	blx	r6
  401150:	2800      	cmp	r0, #0
  401152:	f040 80f7 	bne.w	401344 <sd_mmc_check+0x220>
 */
static bool sd_cmd8(uint8_t * v2)
{
	uint32_t resp;

	*v2 = 0;
  401156:	f04f 0900 	mov.w	r9, #0
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40115a:	683b      	ldr	r3, [r7, #0]
  40115c:	7bdb      	ldrb	r3, [r3, #15]
  40115e:	07da      	lsls	r2, r3, #31
  401160:	f100 80fc 	bmi.w	40135c <sd_mmc_check+0x238>
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
			return false;
		}
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
  401164:	f245 1003 	movw	r0, #20739	; 0x5103
  401168:	2100      	movs	r1, #0
  40116a:	47b0      	blx	r6
  40116c:	2800      	cmp	r0, #0
  40116e:	f000 80e0 	beq.w	401332 <sd_mmc_check+0x20e>
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  401172:	f8df 9274 	ldr.w	r9, [pc, #628]	; 4013e8 <sd_mmc_check+0x2c4>
  401176:	683d      	ldr	r5, [r7, #0]
  401178:	f8df a268 	ldr.w	sl, [pc, #616]	; 4013e4 <sd_mmc_check+0x2c0>
  40117c:	47c8      	blx	r9

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40117e:	683b      	ldr	r3, [r7, #0]
	}
	// Ask the card to publish a new relative address (RCA).
	if (!driver_send_cmd(SD_CMD3_SEND_RELATIVE_ADDR, 0)) {
		return false;
	}
	sd_mmc_card->rca = (driver_get_response() >> 16) & 0xFFFF;
  401180:	0c00      	lsrs	r0, r0, #16
  401182:	81a8      	strh	r0, [r5, #12]

	// SD MEMORY, Get the Card-Specific Data
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401184:	7bda      	ldrb	r2, [r3, #15]
  401186:	07d5      	lsls	r5, r2, #31
  401188:	d53a      	bpl.n	401200 <sd_mmc_check+0xdc>
		if (!sd_mmc_cmd9_mci()) {
  40118a:	4b8a      	ldr	r3, [pc, #552]	; (4013b4 <sd_mmc_check+0x290>)
  40118c:	4798      	blx	r3
  40118e:	2800      	cmp	r0, #0
  401190:	f000 80cf 	beq.w	401332 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
  401194:	f8da 3000 	ldr.w	r3, [sl]
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401198:	4d87      	ldr	r5, [pc, #540]	; (4013b8 <sd_mmc_check+0x294>)
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40119a:	7d5a      	ldrb	r2, [r3, #21]
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  40119c:	4887      	ldr	r0, [pc, #540]	; (4013bc <sd_mmc_check+0x298>)
  40119e:	7c99      	ldrb	r1, [r3, #18]
	uint32_t mul;
	uint32_t tran_speed;

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  4011a0:	f002 0e07 	and.w	lr, r2, #7
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
  4011a4:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  4011a8:	f855 502e 	ldr.w	r5, [r5, lr, lsl #2]
  4011ac:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
  4011b0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
  4011b4:	fb02 f205 	mul.w	r2, r2, r5
  4011b8:	fb00 f202 	mul.w	r2, r0, r2
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  4011bc:	0989      	lsrs	r1, r1, #6

	// Get SD memory maximum transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = sd_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  4011be:	601a      	str	r2, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
  4011c0:	f040 8179 	bne.w	4014b6 <sd_mmc_check+0x392>
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011c4:	7e58      	ldrb	r0, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011c6:	f893 c018 	ldrb.w	ip, [r3, #24]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011ca:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4011cc:	f893 e01a 	ldrb.w	lr, [r3, #26]
  4011d0:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4011d2:	7dda      	ldrb	r2, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011d4:	0080      	lsls	r0, r0, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011d6:	ea40 208c 	orr.w	r0, r0, ip, lsl #10
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011da:	0049      	lsls	r1, r1, #1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4011dc:	ea40 109e 	orr.w	r0, r0, lr, lsr #6
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4011e0:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  4011e4:	f3c0 000b 	ubfx	r0, r0, #0, #12
  4011e8:	f001 0107 	and.w	r1, r1, #7
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4011ec:	3001      	adds	r0, #1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  4011ee:	3102      	adds	r1, #2
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
  4011f0:	fa00 f101 	lsl.w	r1, r0, r1
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4011f4:	f002 020f 	and.w	r2, r2, #15
  4011f8:	fa01 f202 	lsl.w	r2, r1, r2
				(1 << SD_CSD_1_0_READ_BL_LEN(sd_mmc_card->csd))
				/ 1024;
  4011fc:	0a92      	lsrs	r2, r2, #10
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
	} else {
		uint32_t blocknr = ((SD_CSD_1_0_C_SIZE(sd_mmc_card->csd) + 1) *
				(1 << (SD_CSD_1_0_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4011fe:	605a      	str	r2, [r3, #4]
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  401200:	8999      	ldrh	r1, [r3, #12]
			return false;
		}
		sd_decode_csd();
	}
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  401202:	4d6f      	ldr	r5, [pc, #444]	; (4013c0 <sd_mmc_check+0x29c>)
  401204:	0409      	lsls	r1, r1, #16
  401206:	f243 1007 	movw	r0, #12551	; 0x3107
  40120a:	47b0      	blx	r6
  40120c:	2800      	cmp	r0, #0
  40120e:	f000 8090 	beq.w	401332 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// SD MEMORY, Read the SCR to get card version
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401212:	683b      	ldr	r3, [r7, #0]
  401214:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 4013e4 <sd_mmc_check+0x2c0>
  401218:	7bda      	ldrb	r2, [r3, #15]
  40121a:	07d0      	lsls	r0, r2, #31
  40121c:	d530      	bpl.n	401280 <sd_mmc_check+0x15c>
{
	uint8_t scr[SD_SCR_REG_BSIZE];

	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  40121e:	8999      	ldrh	r1, [r3, #12]
  401220:	f241 1037 	movw	r0, #4407	; 0x1137
  401224:	0409      	lsls	r1, r1, #16
  401226:	47a8      	blx	r5
  401228:	2800      	cmp	r0, #0
  40122a:	f000 8082 	beq.w	401332 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_adtc_start(SD_ACMD51_SEND_SCR, 0,
  40122e:	2501      	movs	r5, #1
  401230:	9500      	str	r5, [sp, #0]
  401232:	462b      	mov	r3, r5
  401234:	4863      	ldr	r0, [pc, #396]	; (4013c4 <sd_mmc_check+0x2a0>)
  401236:	f8df c1b8 	ldr.w	ip, [pc, #440]	; 4013f0 <sd_mmc_check+0x2cc>
  40123a:	2100      	movs	r1, #0
  40123c:	2208      	movs	r2, #8
  40123e:	47e0      	blx	ip
  401240:	2800      	cmp	r0, #0
  401242:	d076      	beq.n	401332 <sd_mmc_check+0x20e>
			SD_SCR_REG_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(scr, 1)) {
  401244:	4629      	mov	r1, r5
  401246:	a804      	add	r0, sp, #16
  401248:	4b5f      	ldr	r3, [pc, #380]	; (4013c8 <sd_mmc_check+0x2a4>)
  40124a:	4798      	blx	r3
  40124c:	2800      	cmp	r0, #0
  40124e:	d070      	beq.n	401332 <sd_mmc_check+0x20e>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  401250:	4b5e      	ldr	r3, [pc, #376]	; (4013cc <sd_mmc_check+0x2a8>)
  401252:	4798      	blx	r3
  401254:	2800      	cmp	r0, #0
  401256:	d06c      	beq.n	401332 <sd_mmc_check+0x20e>
  401258:	f89d 3010 	ldrb.w	r3, [sp, #16]
		return false;
	}

	// Get SD Memory Card - Spec. Version
	switch (SD_SCR_SD_SPEC(scr)) {
  40125c:	f003 030f 	and.w	r3, r3, #15
  401260:	2b01      	cmp	r3, #1
  401262:	f000 8223 	beq.w	4016ac <sd_mmc_check+0x588>
  401266:	f0c0 821c 	bcc.w	4016a2 <sd_mmc_check+0x57e>
  40126a:	2b02      	cmp	r3, #2
  40126c:	f040 8219 	bne.w	4016a2 <sd_mmc_check+0x57e>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401270:	f89d 3012 	ldrb.w	r3, [sp, #18]
	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
		break;

	case SD_SCR_SD_SPEC_2_00:
		if (SD_SCR_SD_SPEC3(scr) == SD_SCR_SD_SPEC_3_00) {
  401274:	09db      	lsrs	r3, r3, #7
			sd_mmc_card->version = CARD_VER_SD_3_0;
  401276:	683b      	ldr	r3, [r7, #0]
  401278:	bf14      	ite	ne
  40127a:	2230      	movne	r2, #48	; 0x30
		} else {
			sd_mmc_card->version = CARD_VER_SD_2_0;
  40127c:	2220      	moveq	r2, #32
  40127e:	741a      	strb	r2, [r3, #16]
	if (IS_SDIO()) {
		if (!sdio_get_max_speed()) {
			return false;
		}
	}
	if ((4 <= driver_get_bus_width(sd_mmc_slot_sel))) {
  401280:	4d4b      	ldr	r5, [pc, #300]	; (4013b0 <sd_mmc_check+0x28c>)
  401282:	4b53      	ldr	r3, [pc, #332]	; (4013d0 <sd_mmc_check+0x2ac>)
  401284:	7828      	ldrb	r0, [r5, #0]
  401286:	4798      	blx	r3
  401288:	2803      	cmp	r0, #3
  40128a:	d91a      	bls.n	4012c2 <sd_mmc_check+0x19e>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_bus_width()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  40128c:	683b      	ldr	r3, [r7, #0]
  40128e:	f8df a154 	ldr.w	sl, [pc, #340]	; 4013e4 <sd_mmc_check+0x2c0>
  401292:	7bda      	ldrb	r2, [r3, #15]
  401294:	07d1      	lsls	r1, r2, #31
  401296:	d512      	bpl.n	4012be <sd_mmc_check+0x19a>
 */
static bool sd_acmd6(void)
{
	// CMD55 - Indicate to the card that the next command is an
	// application specific command rather than a standard command.
	if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, (uint32_t)sd_mmc_card->rca << 16)) {
  401298:	8999      	ldrh	r1, [r3, #12]
  40129a:	f8df b124 	ldr.w	fp, [pc, #292]	; 4013c0 <sd_mmc_check+0x29c>
  40129e:	0409      	lsls	r1, r1, #16
  4012a0:	f241 1037 	movw	r0, #4407	; 0x1137
  4012a4:	47b0      	blx	r6
  4012a6:	2800      	cmp	r0, #0
  4012a8:	d044      	beq.n	401334 <sd_mmc_check+0x210>
		return false;
	}
	// 10b = 4 bits bus
	if (!driver_send_cmd(SD_ACMD6_SET_BUS_WIDTH, 0x2)) {
  4012aa:	f241 1006 	movw	r0, #4358	; 0x1106
  4012ae:	2102      	movs	r1, #2
  4012b0:	47d8      	blx	fp
  4012b2:	2800      	cmp	r0, #0
  4012b4:	d03e      	beq.n	401334 <sd_mmc_check+0x210>
		return false;
	}
	sd_mmc_card->bus_width = 4;
  4012b6:	f8da 3000 	ldr.w	r3, [sl]
  4012ba:	2204      	movs	r2, #4
  4012bc:	745a      	strb	r2, [r3, #17]
			if (!sd_acmd6()) {
				return false;
			}
		}
		// Switch to selected bus mode
		sd_mmc_configure_slot();
  4012be:	4b45      	ldr	r3, [pc, #276]	; (4013d4 <sd_mmc_check+0x2b0>)
  4012c0:	4798      	blx	r3
	}
	if (driver_is_high_speed_capable()) {
  4012c2:	4b45      	ldr	r3, [pc, #276]	; (4013d8 <sd_mmc_check+0x2b4>)
  4012c4:	4798      	blx	r3
  4012c6:	b158      	cbz	r0, 4012e0 <sd_mmc_check+0x1bc>
		if (IS_SDIO()) {
			if (!sdio_cmd52_set_high_speed()) {
				return false;
			}
		}
		if (sd_mmc_card->type & CARD_TYPE_SD) {
  4012c8:	683b      	ldr	r3, [r7, #0]
  4012ca:	f8df b118 	ldr.w	fp, [pc, #280]	; 4013e4 <sd_mmc_check+0x2c0>
  4012ce:	7bda      	ldrb	r2, [r3, #15]
  4012d0:	07d2      	lsls	r2, r2, #31
  4012d2:	d503      	bpl.n	4012dc <sd_mmc_check+0x1b8>
			if (sd_mmc_card->version > CARD_VER_SD_1_0) {
  4012d4:	7c1b      	ldrb	r3, [r3, #16]
  4012d6:	2b10      	cmp	r3, #16
  4012d8:	f200 80fa 	bhi.w	4014d0 <sd_mmc_check+0x3ac>
					return false;
				}
			}
		}
		// Valid new configuration
		sd_mmc_configure_slot();
  4012dc:	4b3d      	ldr	r3, [pc, #244]	; (4013d4 <sd_mmc_check+0x2b0>)
  4012de:	4798      	blx	r3
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
  4012e0:	683a      	ldr	r2, [r7, #0]
  4012e2:	f8df 8100 	ldr.w	r8, [pc, #256]	; 4013e4 <sd_mmc_check+0x2c0>
  4012e6:	7bd3      	ldrb	r3, [r2, #15]
  4012e8:	07d9      	lsls	r1, r3, #31
  4012ea:	f100 80d9 	bmi.w	4014a0 <sd_mmc_check+0x37c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4012ee:	7828      	ldrb	r0, [r5, #0]
	//if (sd_mmc_is_spi()? sd_mmc_spi_card_init()
			//: sd_mmc_mci_card_init())
	if(sd_mmc_mci_card_init()) 
	{
		sd_mmc_debug("SD/MMC card ready\n\r");
		sd_mmc_card->state = SD_MMC_CARD_STATE_READY;
  4012f0:	2300      	movs	r3, #0
  4012f2:	7393      	strb	r3, [r2, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4012f4:	2800      	cmp	r0, #0
  4012f6:	f47f af22 	bne.w	40113e <sd_mmc_check+0x1a>
		driver_deselect_device(sd_mmc_slot_sel);
  4012fa:	4b38      	ldr	r3, [pc, #224]	; (4013dc <sd_mmc_check+0x2b8>)
  4012fc:	4798      	blx	r3
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}
  4012fe:	4620      	mov	r0, r4
  401300:	b015      	add	sp, #84	; 0x54
  401302:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  401306:	4b36      	ldr	r3, [pc, #216]	; (4013e0 <sd_mmc_check+0x2bc>)
  401308:	4798      	blx	r3
sd_mmc_err_t sd_mmc_check(uint8_t slot)
{
	sd_mmc_err_t sd_mmc_err;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_INIT_ONGOING) {
  40130a:	2801      	cmp	r0, #1
  40130c:	4604      	mov	r4, r0
  40130e:	f47f af11 	bne.w	401134 <sd_mmc_check+0x10>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  401312:	4f34      	ldr	r7, [pc, #208]	; (4013e4 <sd_mmc_check+0x2c0>)
	sd_mmc_card->version = CARD_VER_UNKNOWN;
	sd_mmc_card->rca = 0;
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  401314:	f8df 80dc 	ldr.w	r8, [pc, #220]	; 4013f4 <sd_mmc_check+0x2d0>
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  401318:	683b      	ldr	r3, [r7, #0]

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40131a:	4e29      	ldr	r6, [pc, #164]	; (4013c0 <sd_mmc_check+0x29c>)
static bool sd_mmc_mci_card_init(void)
{
	uint8_t v2 = 0;

	// In first, try to install SD/SDIO card
	sd_mmc_card->type = CARD_TYPE_SD;
  40131c:	73d8      	strb	r0, [r3, #15]
	sd_mmc_card->version = CARD_VER_UNKNOWN;
  40131e:	741d      	strb	r5, [r3, #16]
	sd_mmc_card->rca = 0;
  401320:	819d      	strh	r5, [r3, #12]
	sd_mmc_debug("Start SD card install\n\r");

	// Card need of 74 cycles clock minimum to start
	driver_send_clock();
  401322:	47c0      	blx	r8

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  401324:	4629      	mov	r1, r5
  401326:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  40132a:	47b0      	blx	r6
  40132c:	2800      	cmp	r0, #0
  40132e:	f47f af0a 	bne.w	401146 <sd_mmc_check+0x22>
  401332:	4d1f      	ldr	r5, [pc, #124]	; (4013b0 <sd_mmc_check+0x28c>)
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401334:	683b      	ldr	r3, [r7, #0]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401336:	7828      	ldrb	r0, [r5, #0]
		// To notify that the card has been just initialized
		// It is necessary for USB Device MSC
		return SD_MMC_INIT_ONGOING;
	}
	sd_mmc_debug("SD/MMC card initialization failed\n\r");
	sd_mmc_card->state = SD_MMC_CARD_STATE_UNUSABLE;
  401338:	2403      	movs	r4, #3
  40133a:	739c      	strb	r4, [r3, #14]
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40133c:	2800      	cmp	r0, #0
  40133e:	f47f aefe 	bne.w	40113e <sd_mmc_check+0x1a>
  401342:	e7da      	b.n	4012fa <sd_mmc_check+0x1d6>
	if (!driver_send_cmd(SD_CMD8_SEND_IF_COND,
			SD_CMD8_PATTERN | SD_CMD8_HIGH_VOLTAGE)) {
		return true; // It is not a V2
	}
	// Check R7 response
	resp = driver_get_response();
  401344:	4b28      	ldr	r3, [pc, #160]	; (4013e8 <sd_mmc_check+0x2c4>)
  401346:	4798      	blx	r3
	if (resp == 0xFFFFFFFF) {
  401348:	1c45      	adds	r5, r0, #1
  40134a:	f43f af04 	beq.w	401156 <sd_mmc_check+0x32>
		// No compliance R7 value
		return true; // It is not a V2
	}
	if ((resp & (SD_CMD8_MASK_PATTERN | SD_CMD8_MASK_VOLTAGE))
  40134e:	f3c0 000b 	ubfx	r0, r0, #0, #12
  401352:	f5b0 7fd5 	cmp.w	r0, #426	; 0x1aa
  401356:	d1ec      	bne.n	401332 <sd_mmc_check+0x20e>
		sd_mmc_debug("%s: CMD8 resp32 0x%08x UNUSABLE CARD\n\r",
				__func__, resp);
		return false;
	}
	sd_mmc_debug("SD card V2\n\r");
	*v2 = 1;
  401358:	46a1      	mov	r9, r4
  40135a:	e6fe      	b.n	40115a <sd_mmc_check+0x36>
	// Try to get the SDIO card's operating condition
	if (!sdio_op_cond()) {
		return false;
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  40135c:	f640 0535 	movw	r5, #2101	; 0x835
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  401360:	f8df a088 	ldr.w	sl, [pc, #136]	; 4013ec <sd_mmc_check+0x2c8>
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  401364:	f8df b080 	ldr.w	fp, [pc, #128]	; 4013e8 <sd_mmc_check+0x2c4>
  401368:	e00e      	b.n	401388 <sd_mmc_check+0x264>
			sd_mmc_debug("%s: CMD55 Fail\n\r", __func__);
			return false;
		}

		// (ACMD41) Sends host OCR register
		arg = SD_MMC_VOLTAGE_SUPPORT;
  40136a:	f1b9 0f00 	cmp.w	r9, #0
		if (v2) {
			arg |= SD_ACMD41_HCS;
		}
		// Check response
		if (!driver_send_cmd(SD_MCI_ACMD41_SD_SEND_OP_COND, arg)) {
  40136e:	bf14      	ite	ne
  401370:	4651      	movne	r1, sl
  401372:	f44f 11fc 	moveq.w	r1, #2064384	; 0x1f8000
  401376:	f244 5029 	movw	r0, #17705	; 0x4529
  40137a:	47b0      	blx	r6
  40137c:	b150      	cbz	r0, 401394 <sd_mmc_check+0x270>
			sd_mmc_debug("%s: ACMD41 Fail\n\r", __func__);
			return false;
		}
		resp = driver_get_response();
  40137e:	47d8      	blx	fp
		if (resp & OCR_POWER_UP_BUSY) {
  401380:	2800      	cmp	r0, #0
  401382:	db78      	blt.n	401476 <sd_mmc_check+0x352>
			if ((resp & OCR_CCS) != 0) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  401384:	3d01      	subs	r5, #1
  401386:	d005      	beq.n	401394 <sd_mmc_check+0x270>
	 */
	retry = 2100;
	do {
		// CMD55 - Indicate to the card that the next command is an
		// application specific command rather than a standard command.
		if (!driver_send_cmd(SDMMC_CMD55_APP_CMD, 0)) {
  401388:	f241 1037 	movw	r0, #4407	; 0x1137
  40138c:	2100      	movs	r1, #0
  40138e:	47b0      	blx	r6
  401390:	2800      	cmp	r0, #0
  401392:	d1ea      	bne.n	40136a <sd_mmc_check+0x246>
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		// Try to get the SD card's operating condition
		if (!sd_mci_op_cond(v2)) {
			// It is not a SD card
			sd_mmc_debug("Start MMC Install\n\r");
			sd_mmc_card->type = CARD_TYPE_MMC;
  401394:	683b      	ldr	r3, [r7, #0]
  401396:	2202      	movs	r2, #2
  401398:	73da      	strb	r2, [r3, #15]
static bool sd_mmc_mci_install_mmc(void)
{
	uint8_t b_authorize_high_speed;

	// CMD0 - Reset all cards to idle state.
	if (!driver_send_cmd(SDMMC_MCI_CMD0_GO_IDLE_STATE, 0)) {
  40139a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
  40139e:	2100      	movs	r1, #0
  4013a0:	47b0      	blx	r6
  4013a2:	2800      	cmp	r0, #0
  4013a4:	d0c5      	beq.n	401332 <sd_mmc_check+0x20e>
  4013a6:	f241 0569 	movw	r5, #4201	; 0x1069
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4013aa:	f8df 803c 	ldr.w	r8, [pc, #60]	; 4013e8 <sd_mmc_check+0x2c4>
  4013ae:	e025      	b.n	4013fc <sd_mmc_check+0x2d8>
  4013b0:	20000f56 	.word	0x20000f56
  4013b4:	004010d5 	.word	0x004010d5
  4013b8:	00406aa0 	.word	0x00406aa0
  4013bc:	00406a60 	.word	0x00406a60
  4013c0:	00401ec1 	.word	0x00401ec1
  4013c4:	00081133 	.word	0x00081133
  4013c8:	0040206d 	.word	0x0040206d
  4013cc:	004020d5 	.word	0x004020d5
  4013d0:	00401e0d 	.word	0x00401e0d
  4013d4:	00400fa9 	.word	0x00400fa9
  4013d8:	00401e19 	.word	0x00401e19
  4013dc:	00401e9d 	.word	0x00401e9d
  4013e0:	00400fd5 	.word	0x00400fd5
  4013e4:	20000f50 	.word	0x20000f50
  4013e8:	00401eed 	.word	0x00401eed
  4013ec:	401f8000 	.word	0x401f8000
  4013f0:	00401f19 	.word	0x00401f19
  4013f4:	00401ea1 	.word	0x00401ea1
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
			}
			break;
		}
		if (retry-- == 0) {
  4013f8:	3d01      	subs	r5, #1
  4013fa:	d09a      	beq.n	401332 <sd_mmc_check+0x20e>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  4013fc:	49af      	ldr	r1, [pc, #700]	; (4016bc <sd_mmc_check+0x598>)
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  4013fe:	f8df 92fc 	ldr.w	r9, [pc, #764]	; 4016fc <sd_mmc_check+0x5d8>
	 * 6 = cmd byte size
	 * 6 = response byte size
	 */
	retry = 4200;
	do {
		if (!driver_send_cmd(MMC_MCI_CMD1_SEND_OP_COND,
  401402:	f244 5001 	movw	r0, #17665	; 0x4501
  401406:	47b0      	blx	r6
  401408:	2800      	cmp	r0, #0
  40140a:	d092      	beq.n	401332 <sd_mmc_check+0x20e>
			sd_mmc_debug("%s: CMD1 MCI Fail - Busy retry %d\n\r",
					__func__, (int)(4200 - retry));
			return false;
		}
		// Check busy flag
		resp = driver_get_response();
  40140c:	47c0      	blx	r8
		if (resp & OCR_POWER_UP_BUSY) {
  40140e:	2800      	cmp	r0, #0
  401410:	daf2      	bge.n	4013f8 <sd_mmc_check+0x2d4>
			// Check OCR value
			if ((resp & OCR_ACCESS_MODE_MASK)
  401412:	f000 40c0 	and.w	r0, r0, #1610612736	; 0x60000000
  401416:	f1b0 4f80 	cmp.w	r0, #1073741824	; 0x40000000
  40141a:	d104      	bne.n	401426 <sd_mmc_check+0x302>
					== OCR_ACCESS_MODE_SECTOR) {
				sd_mmc_card->type |= CARD_TYPE_HC;
  40141c:	683b      	ldr	r3, [r7, #0]
  40141e:	7bda      	ldrb	r2, [r3, #15]
  401420:	f042 0208 	orr.w	r2, r2, #8
  401424:	73da      	strb	r2, [r3, #15]
		return false;
	}

	// Put the Card in Identify Mode
	// Note: The CID is not used in this stack
	if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  401426:	f645 3002 	movw	r0, #23298	; 0x5b02
  40142a:	2100      	movs	r1, #0
  40142c:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 401700 <sd_mmc_check+0x5dc>
  401430:	47b0      	blx	r6
  401432:	2800      	cmp	r0, #0
  401434:	f43f af7d 	beq.w	401332 <sd_mmc_check+0x20e>
		return false;
	}
	// Assign relative address to the card.
	sd_mmc_card->rca = 1;
  401438:	683b      	ldr	r3, [r7, #0]
  40143a:	4da1      	ldr	r5, [pc, #644]	; (4016c0 <sd_mmc_check+0x59c>)
  40143c:	2201      	movs	r2, #1
  40143e:	819a      	strh	r2, [r3, #12]
	if (!driver_send_cmd(MMC_CMD3_SET_RELATIVE_ADDR,
  401440:	f241 1003 	movw	r0, #4355	; 0x1103
  401444:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  401448:	47c0      	blx	r8
  40144a:	2800      	cmp	r0, #0
  40144c:	f43f af71 	beq.w	401332 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	// Get the Card-Specific Data
	if (!sd_mmc_cmd9_mci()) {
  401450:	4b9c      	ldr	r3, [pc, #624]	; (4016c4 <sd_mmc_check+0x5a0>)
  401452:	4798      	blx	r3
  401454:	2800      	cmp	r0, #0
  401456:	f43f af6c 	beq.w	401332 <sd_mmc_check+0x20e>
 	uint32_t unit;
	uint32_t mul;
	uint32_t tran_speed;

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
  40145a:	682b      	ldr	r3, [r5, #0]
  40145c:	7c9a      	ldrb	r2, [r3, #18]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  40145e:	f3c2 0283 	ubfx	r2, r2, #2, #4
  401462:	3a01      	subs	r2, #1
  401464:	2a03      	cmp	r2, #3
  401466:	f200 817c 	bhi.w	401762 <sd_mmc_check+0x63e>
  40146a:	e8df f012 	tbh	[pc, r2, lsl #1]
  40146e:	0177      	.short	0x0177
  401470:	0124017d 	.word	0x0124017d
  401474:	0068      	.short	0x0068
			return false;
		}
		resp = driver_get_response();
		if (resp & OCR_POWER_UP_BUSY) {
			// Card is ready
			if ((resp & OCR_CCS) != 0) {
  401476:	0041      	lsls	r1, r0, #1
  401478:	d50f      	bpl.n	40149a <sd_mmc_check+0x376>
				sd_mmc_card->type |= CARD_TYPE_HC;
  40147a:	683a      	ldr	r2, [r7, #0]
  40147c:	7bd3      	ldrb	r3, [r2, #15]
  40147e:	f043 0308 	orr.w	r3, r3, #8
  401482:	73d3      	strb	r3, [r2, #15]
			sd_mmc_card->type = CARD_TYPE_MMC;
			return sd_mmc_mci_install_mmc();
		}
	}

	if (sd_mmc_card->type & CARD_TYPE_SD) {
  401484:	07db      	lsls	r3, r3, #31
  401486:	f57f ae6d 	bpl.w	401164 <sd_mmc_check+0x40>
		// SD MEMORY, Put the Card in Identify Mode
		// Note: The CID is not used in this stack
		if (!driver_send_cmd(SDMMC_CMD2_ALL_SEND_CID, 0)) {
  40148a:	f645 3002 	movw	r0, #23298	; 0x5b02
  40148e:	2100      	movs	r1, #0
  401490:	47b0      	blx	r6
  401492:	2800      	cmp	r0, #0
  401494:	f47f ae66 	bne.w	401164 <sd_mmc_check+0x40>
  401498:	e74b      	b.n	401332 <sd_mmc_check+0x20e>
  40149a:	683b      	ldr	r3, [r7, #0]
  40149c:	7bdb      	ldrb	r3, [r3, #15]
  40149e:	e7f1      	b.n	401484 <sd_mmc_check+0x360>
		// Valid new configuration
		sd_mmc_configure_slot();
	}
	// SD MEMORY, Set default block size
	if (sd_mmc_card->type & CARD_TYPE_SD) {
		if (!driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  4014a0:	f241 1010 	movw	r0, #4368	; 0x1110
  4014a4:	f44f 7100 	mov.w	r1, #512	; 0x200
  4014a8:	47b0      	blx	r6
  4014aa:	2800      	cmp	r0, #0
  4014ac:	f43f af42 	beq.w	401334 <sd_mmc_check+0x210>
  4014b0:	f8d8 2000 	ldr.w	r2, [r8]
  4014b4:	e71b      	b.n	4012ee <sd_mmc_check+0x1ca>
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4014b6:	7e59      	ldrb	r1, [r3, #25]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4014b8:	7e98      	ldrb	r0, [r3, #26]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4014ba:	7eda      	ldrb	r2, [r3, #27]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4014bc:	0409      	lsls	r1, r1, #16
  4014be:	ea41 2100 	orr.w	r1, r1, r0, lsl #8
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4014c2:	430a      	orrs	r2, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  4014c4:	f3c2 0215 	ubfx	r2, r2, #0, #22
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
				(SD_CSD_2_0_C_SIZE(sd_mmc_card->csd) + 1)
				* 512;
  4014c8:	3201      	adds	r2, #1
  4014ca:	0252      	lsls	r2, r2, #9
	 * ----------------------------------------------------
	 * For high capacity SD card:
	 * memory capacity = (C_SIZE+1) * 512K byte
	 */
	if (CSD_STRUCTURE_VERSION(sd_mmc_card->csd) >= SD_CSD_VER_2_0) {
		sd_mmc_card->capacity =
  4014cc:	605a      	str	r2, [r3, #4]
  4014ce:	e697      	b.n	401200 <sd_mmc_check+0xdc>
 */
static bool sd_cm6_set_high_speed(void)
{
	uint8_t switch_status[SD_SW_STATUS_BSIZE];

	if (!driver_adtc_start(SD_CMD6_SWITCH_FUNC,
  4014d0:	f04f 0a01 	mov.w	sl, #1
  4014d4:	f8cd a000 	str.w	sl, [sp]
  4014d8:	4653      	mov	r3, sl
  4014da:	487b      	ldr	r0, [pc, #492]	; (4016c8 <sd_mmc_check+0x5a4>)
  4014dc:	497b      	ldr	r1, [pc, #492]	; (4016cc <sd_mmc_check+0x5a8>)
  4014de:	f8df c204 	ldr.w	ip, [pc, #516]	; 4016e4 <sd_mmc_check+0x5c0>
  4014e2:	2240      	movs	r2, #64	; 0x40
  4014e4:	47e0      	blx	ip
  4014e6:	2800      	cmp	r0, #0
  4014e8:	f43f af24 	beq.w	401334 <sd_mmc_check+0x210>
			| SD_CMD6_GRP2_DEFAULT
			| SD_CMD6_GRP1_HIGH_SPEED,
			SD_SW_STATUS_BSIZE, 1, true)) {
		return false;
	}
	if (!driver_start_read_blocks(switch_status, 1)) {
  4014ec:	a804      	add	r0, sp, #16
  4014ee:	4651      	mov	r1, sl
  4014f0:	4b77      	ldr	r3, [pc, #476]	; (4016d0 <sd_mmc_check+0x5ac>)
  4014f2:	4798      	blx	r3
  4014f4:	2800      	cmp	r0, #0
  4014f6:	f43f af1d 	beq.w	401334 <sd_mmc_check+0x210>
		return false;
	}
	if (!driver_wait_end_of_read_blocks()) {
  4014fa:	4b76      	ldr	r3, [pc, #472]	; (4016d4 <sd_mmc_check+0x5b0>)
  4014fc:	4798      	blx	r3
  4014fe:	2800      	cmp	r0, #0
  401500:	f43f af18 	beq.w	401334 <sd_mmc_check+0x210>
		return false;
	}

	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401504:	47c8      	blx	r9
  401506:	0600      	lsls	r0, r0, #24
  401508:	f53f af14 	bmi.w	401334 <sd_mmc_check+0x210>
  40150c:	f89d 3020 	ldrb.w	r3, [sp, #32]
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	if (SD_SW_STATUS_FUN_GRP1_RC(switch_status)
  401510:	f003 030f 	and.w	r3, r3, #15
  401514:	2b0f      	cmp	r3, #15
  401516:	f43f aee1 	beq.w	4012dc <sd_mmc_check+0x1b8>
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40151a:	f89d 302d 	ldrb.w	r3, [sp, #45]	; 0x2d
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40151e:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
			== SD_SW_STATUS_FUN_GRP_RC_ERROR) {
		// No supported, it is not a protocol error
		return true;
	}
	if (SD_SW_STATUS_FUN_GRP1_BUSY(switch_status)) {
  401522:	ea53 2202 	orrs.w	r2, r3, r2, lsl #8
  401526:	f47f af05 	bne.w	401334 <sd_mmc_check+0x210>
		sd_mmc_debug("%s: CMD6 SD_SW_STATUS_FUN_GRP1_BUSY\n\r", __func__);
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
  40152a:	47c0      	blx	r8
	sd_mmc_card->high_speed = 1;
  40152c:	f8db 3000 	ldr.w	r3, [fp]
	sd_mmc_card->clock *= 2;
  401530:	681a      	ldr	r2, [r3, #0]
		return false;
	}
	// CMD6 function switching period is within 8 clocks
	// after the end bit of status data.
	driver_send_clock();
	sd_mmc_card->high_speed = 1;
  401532:	f883 a022 	strb.w	sl, [r3, #34]	; 0x22
	sd_mmc_card->clock *= 2;
  401536:	fa02 f20a 	lsl.w	r2, r2, sl
  40153a:	601a      	str	r2, [r3, #0]
  40153c:	e6ce      	b.n	4012dc <sd_mmc_check+0x1b8>
	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
		break;

	case 4:
		sd_mmc_card->version = CARD_VER_MMC_4;
  40153e:	2240      	movs	r2, #64	; 0x40
  401540:	741a      	strb	r2, [r3, #16]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401542:	7d5a      	ldrb	r2, [r3, #21]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401544:	f893 e019 	ldrb.w	lr, [r3, #25]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401548:	4963      	ldr	r1, [pc, #396]	; (4016d8 <sd_mmc_check+0x5b4>)
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  40154a:	4864      	ldr	r0, [pc, #400]	; (4016dc <sd_mmc_check+0x5b8>)
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  40154c:	f893 c018 	ldrb.w	ip, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  401550:	7e9d      	ldrb	r5, [r3, #26]
		break;
	}

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
  401552:	f002 0807 	and.w	r8, r2, #7
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
  401556:	f3c2 02c3 	ubfx	r2, r2, #3, #4
	sd_mmc_card->clock = unit * mul * 1000;
  40155a:	f851 1028 	ldr.w	r1, [r1, r8, lsl #2]
  40155e:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401562:	ea4f 028e 	mov.w	r2, lr, lsl #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401566:	ea42 228c 	orr.w	r2, r2, ip, lsl #10
  40156a:	f44f 7e7a 	mov.w	lr, #1000	; 0x3e8
  40156e:	fb0e f101 	mul.w	r1, lr, r1
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401572:	ea42 1295 	orr.w	r2, r2, r5, lsr #6
  401576:	fb00 f001 	mul.w	r0, r0, r1
	}
	value &=  ((uint32_t)1 << size) - 1;
  40157a:	f3c2 020b 	ubfx	r2, r2, #0, #12
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  40157e:	f640 71ff 	movw	r1, #4095	; 0xfff
  401582:	428a      	cmp	r2, r1

	// Get MMC memory max transfer speed in Hz.
	tran_speed = CSD_TRAN_SPEED(sd_mmc_card->csd);
	unit = sd_mmc_trans_units[tran_speed & 0x7];
	mul = mmc_trans_multipliers[(tran_speed >> 3) & 0xF];
	sd_mmc_card->clock = unit * mul * 1000;
  401584:	6018      	str	r0, [r3, #0]
	 * BLOCK_LEN = 2 ^ READ_BL_LEN      (READ_BL_LEN < 12)
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
  401586:	d011      	beq.n	4015ac <sd_mmc_check+0x488>
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  401588:	7ed9      	ldrb	r1, [r3, #27]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  40158a:	7f1d      	ldrb	r5, [r3, #28]
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  40158c:	7dd8      	ldrb	r0, [r3, #23]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  40158e:	0049      	lsls	r1, r1, #1
  401590:	ea41 11d5 	orr.w	r1, r1, r5, lsr #7
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
	}
	value &=  ((uint32_t)1 << size) - 1;
  401594:	f001 0107 	and.w	r1, r1, #7
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  401598:	3201      	adds	r2, #1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
  40159a:	3102      	adds	r1, #2
	 * ----------------------------------------------------
	 * For high capacity SD/MMC card:
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
  40159c:	fa02 f101 	lsl.w	r1, r2, r1
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4015a0:	f000 020f 	and.w	r2, r0, #15
  4015a4:	fa01 f202 	lsl.w	r2, r1, r2
			(1 << MMC_CSD_READ_BL_LEN(sd_mmc_card->csd)) / 1024;
  4015a8:	0a92      	lsrs	r2, r2, #10
	 * memory capacity = SEC_COUNT * 512 byte
	 */
	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) != 0xFFF) {
		uint32_t blocknr = ((MMC_CSD_C_SIZE(sd_mmc_card->csd) + 1) *
			(1 << (MMC_CSD_C_SIZE_MULT(sd_mmc_card->csd) + 2)));
		sd_mmc_card->capacity = blocknr *
  4015aa:	605a      	str	r2, [r3, #4]
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
			(uint32_t)sd_mmc_card->rca << 16)) {
  4015ac:	8999      	ldrh	r1, [r3, #12]
	if (!sd_mmc_cmd9_mci()) {
		return false;
	}
	mmc_decode_csd();
	// Select the and put it into Transfer Mode
	if (!driver_send_cmd(SDMMC_CMD7_SELECT_CARD_CMD,
  4015ae:	f243 1007 	movw	r0, #12551	; 0x3107
  4015b2:	0409      	lsls	r1, r1, #16
  4015b4:	47b0      	blx	r6
  4015b6:	2800      	cmp	r0, #0
  4015b8:	f43f aebb 	beq.w	401332 <sd_mmc_check+0x20e>
			(uint32_t)sd_mmc_card->rca << 16)) {
		return false;
	}
	if (sd_mmc_card->version >= CARD_VER_MMC_4) {
  4015bc:	683b      	ldr	r3, [r7, #0]
  4015be:	7c1b      	ldrb	r3, [r3, #16]
  4015c0:	2b3f      	cmp	r3, #63	; 0x3f
  4015c2:	f240 80b1 	bls.w	401728 <sd_mmc_check+0x604>
{
	uint16_t i;
	uint32_t ext_csd;
	uint32_t sec_count;

	if (!driver_adtc_start(MMC_CMD8_SEND_EXT_CSD, 0,
  4015c6:	2100      	movs	r1, #0
  4015c8:	9100      	str	r1, [sp, #0]
  4015ca:	4845      	ldr	r0, [pc, #276]	; (4016e0 <sd_mmc_check+0x5bc>)
  4015cc:	4d45      	ldr	r5, [pc, #276]	; (4016e4 <sd_mmc_check+0x5c0>)
  4015ce:	f44f 7200 	mov.w	r2, #512	; 0x200
  4015d2:	2301      	movs	r3, #1
  4015d4:	47a8      	blx	r5
  4015d6:	2800      	cmp	r0, #0
  4015d8:	f43f aeab 	beq.w	401332 <sd_mmc_check+0x20e>
  4015dc:	f8df 8124 	ldr.w	r8, [pc, #292]	; 401704 <sd_mmc_check+0x5e0>
  4015e0:	2532      	movs	r5, #50	; 0x32
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
  4015e2:	a803      	add	r0, sp, #12
  4015e4:	47c0      	blx	r8
  4015e6:	3d01      	subs	r5, #1
  4015e8:	b2ad      	uxth	r5, r5
  4015ea:	2800      	cmp	r0, #0
  4015ec:	f43f aea1 	beq.w	401332 <sd_mmc_check+0x20e>
	//** Read and decode Extended Extended CSD
	// Note: The read access is done in byte to avoid a buffer
	// of EXT_CSD_BSIZE Byte in stack.

	// Read card type
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
  4015f0:	2d00      	cmp	r5, #0
  4015f2:	d1f6      	bne.n	4015e2 <sd_mmc_check+0x4be>
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  4015f4:	683b      	ldr	r3, [r7, #0]
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  4015f6:	9a03      	ldr	r2, [sp, #12]
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4015f8:	7e5d      	ldrb	r5, [r3, #25]
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  4015fa:	7e18      	ldrb	r0, [r3, #24]
 */
static inline uint32_t SDMMC_UNSTUFF_BITS(uint8_t *reg, uint16_t reg_size,
		uint16_t pos, uint8_t size)
{
	uint32_t value;
	value = reg[((reg_size - pos + 7) / 8) - 1] >> (pos % 8);
  4015fc:	7e99      	ldrb	r1, [r3, #26]
	if (((pos % 8) + size) > 8) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 2] << (8 - (pos % 8));
  4015fe:	00ab      	lsls	r3, r5, #2
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401600:	ea43 2380 	orr.w	r3, r3, r0, lsl #10
	}
	if (((pos % 8) + size) > 16) {
		value |= (uint32_t)reg[((reg_size - pos + 7) / 8) - 3] << (16 - (pos % 8));
  401604:	ea43 1191 	orr.w	r1, r3, r1, lsr #6
	}
	value &=  ((uint32_t)1 << size) - 1;
  401608:	f3c1 010b 	ubfx	r1, r1, #0, #12
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  40160c:	f640 73ff 	movw	r3, #4095	; 0xfff
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  401610:	f002 0202 	and.w	r2, r2, #2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  401614:	4299      	cmp	r1, r3
	for (i = 0; i < (EXT_CSD_CARD_TYPE_INDEX + 4) / 4; i++) {
		if (!driver_read_word(&ext_csd)) {
			return false;
		}
	}
	*b_authorize_high_speed = (ext_csd >> ((EXT_CSD_CARD_TYPE_INDEX % 4) * 8))
  401616:	fa5f fa82 	uxtb.w	sl, r2
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
  40161a:	f04f 0532 	mov.w	r5, #50	; 0x32
  40161e:	f10d 0b10 	add.w	fp, sp, #16
  401622:	d073      	beq.n	40170c <sd_mmc_check+0x5e8>
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
		if (!driver_read_word(&sec_count)) {
  401624:	4658      	mov	r0, fp
  401626:	47c0      	blx	r8
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  401628:	3501      	adds	r5, #1
  40162a:	b2ad      	uxth	r5, r5
		if (!driver_read_word(&sec_count)) {
  40162c:	2800      	cmp	r0, #0
  40162e:	f43f ae80 	beq.w	401332 <sd_mmc_check+0x20e>
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
	}
	for (; i < EXT_CSD_BSIZE / 4; i++) {
  401632:	2d7f      	cmp	r5, #127	; 0x7f
  401634:	d9f6      	bls.n	401624 <sd_mmc_check+0x500>
		// For MMC 4.0 Higher version
		// Get EXT_CSD
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
  401636:	4d2c      	ldr	r5, [pc, #176]	; (4016e8 <sd_mmc_check+0x5c4>)
  401638:	f8df 80cc 	ldr.w	r8, [pc, #204]	; 401708 <sd_mmc_check+0x5e4>
  40163c:	7828      	ldrb	r0, [r5, #0]
  40163e:	47c0      	blx	r8
  401640:	2803      	cmp	r0, #3
  401642:	d918      	bls.n	401676 <sd_mmc_check+0x552>
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  401644:	7828      	ldrb	r0, [r5, #0]
  401646:	47c0      	blx	r8
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  401648:	2804      	cmp	r0, #4
		if (!mmc_cmd8(&b_authorize_high_speed)) {
			return false;
		}
		if (4 <= driver_get_bus_width(sd_mmc_slot_sel)) {
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
  40164a:	4680      	mov	r8, r0
 */
static bool mmc_cmd6_set_bus_width(uint8_t bus_width)
{
	uint32_t arg;

	switch (bus_width) {
  40164c:	d070      	beq.n	401730 <sd_mmc_check+0x60c>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  40164e:	4927      	ldr	r1, [pc, #156]	; (4016ec <sd_mmc_check+0x5c8>)
  401650:	4b27      	ldr	r3, [pc, #156]	; (4016f0 <sd_mmc_check+0x5cc>)
  401652:	2808      	cmp	r0, #8
  401654:	bf18      	it	ne
  401656:	4619      	movne	r1, r3
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_1BIT;
		break;
	}
	if (!driver_send_cmd(MMC_CMD6_SWITCH, arg)) {
  401658:	f243 1006 	movw	r0, #12550	; 0x3106
  40165c:	47b0      	blx	r6
  40165e:	2800      	cmp	r0, #0
  401660:	f43f ae68 	beq.w	401334 <sd_mmc_check+0x210>
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401664:	47c8      	blx	r9
  401666:	0602      	lsls	r2, r0, #24
  401668:	f53f ae64 	bmi.w	401334 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  40166c:	683b      	ldr	r3, [r7, #0]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  40166e:	4a21      	ldr	r2, [pc, #132]	; (4016f4 <sd_mmc_check+0x5d0>)
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->bus_width = bus_width;
  401670:	f883 8011 	strb.w	r8, [r3, #17]
			// Enable more bus width
			if (!mmc_cmd6_set_bus_width(driver_get_bus_width(sd_mmc_slot_sel))) {
				return false;
			}
			// Reinitialize the slot with the bus width
			sd_mmc_configure_slot();
  401674:	4790      	blx	r2
		}
		if (driver_is_high_speed_capable() && b_authorize_high_speed) {
  401676:	4b20      	ldr	r3, [pc, #128]	; (4016f8 <sd_mmc_check+0x5d4>)
  401678:	4798      	blx	r3
  40167a:	b110      	cbz	r0, 401682 <sd_mmc_check+0x55e>
  40167c:	f1ba 0f00 	cmp.w	sl, #0
  401680:	d158      	bne.n	401734 <sd_mmc_check+0x610>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_4BIT;
		break;
	default:
		arg = MMC_CMD6_ACCESS_SET_BITS
  401682:	f04f 080a 	mov.w	r8, #10
		// Retry is a WORKAROUND for no compliance card (Atmel Internal ref. MMC19):
		// These cards seem not ready immediatly
		// after the end of busy of mmc_cmd6_set_high_speed()

		// Set default block size
		if (driver_send_cmd(SDMMC_CMD16_SET_BLOCKLEN, SD_MMC_BLOCK_SIZE)) {
  401686:	f241 1010 	movw	r0, #4368	; 0x1110
  40168a:	f44f 7100 	mov.w	r1, #512	; 0x200
  40168e:	47b0      	blx	r6
  401690:	f108 38ff 	add.w	r8, r8, #4294967295
  401694:	2800      	cmp	r0, #0
  401696:	d16a      	bne.n	40176e <sd_mmc_check+0x64a>
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
	}

	uint8_t retry = 10;
	while (retry--) {
  401698:	f018 08ff 	ands.w	r8, r8, #255	; 0xff
  40169c:	f43f ae4a 	beq.w	401334 <sd_mmc_check+0x210>
  4016a0:	e7f1      	b.n	401686 <sd_mmc_check+0x562>
			sd_mmc_card->version = CARD_VER_SD_2_0;
		}
		break;

	default:
		sd_mmc_card->version = CARD_VER_SD_1_0;
  4016a2:	f8da 3000 	ldr.w	r3, [sl]
  4016a6:	2210      	movs	r2, #16
  4016a8:	741a      	strb	r2, [r3, #16]
  4016aa:	e5e9      	b.n	401280 <sd_mmc_check+0x15c>
	case SD_SCR_SD_SPEC_1_0_01:
		sd_mmc_card->version = CARD_VER_SD_1_0;
		break;

	case SD_SCR_SD_SPEC_1_10:
		sd_mmc_card->version = CARD_VER_SD_1_10;
  4016ac:	f8da 3000 	ldr.w	r3, [sl]
  4016b0:	221a      	movs	r2, #26
  4016b2:	741a      	strb	r2, [r3, #16]
  4016b4:	e5e4      	b.n	401280 <sd_mmc_check+0x15c>
	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
		break;

	case 3:
		sd_mmc_card->version = CARD_VER_MMC_3;
  4016b6:	2230      	movs	r2, #48	; 0x30
  4016b8:	741a      	strb	r2, [r3, #16]
  4016ba:	e742      	b.n	401542 <sd_mmc_check+0x41e>
  4016bc:	401f8000 	.word	0x401f8000
  4016c0:	20000f50 	.word	0x20000f50
  4016c4:	004010d5 	.word	0x004010d5
  4016c8:	00081106 	.word	0x00081106
  4016cc:	80ffff01 	.word	0x80ffff01
  4016d0:	0040206d 	.word	0x0040206d
  4016d4:	004020d5 	.word	0x004020d5
  4016d8:	00406aa0 	.word	0x00406aa0
  4016dc:	00406abc 	.word	0x00406abc
  4016e0:	00081108 	.word	0x00081108
  4016e4:	00401f19 	.word	0x00401f19
  4016e8:	20000f56 	.word	0x20000f56
  4016ec:	01b70200 	.word	0x01b70200
  4016f0:	01b70000 	.word	0x01b70000
  4016f4:	00400fa9 	.word	0x00400fa9
  4016f8:	00401e19 	.word	0x00401e19
  4016fc:	00401eed 	.word	0x00401eed
  401700:	00401ec1 	.word	0x00401ec1
  401704:	00401fc9 	.word	0x00401fc9
  401708:	00401e0d 	.word	0x00401e0d

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
			if (!driver_read_word(&sec_count)) {
  40170c:	4658      	mov	r0, fp
  40170e:	47c0      	blx	r8
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  401710:	3501      	adds	r5, #1
  401712:	b2ad      	uxth	r5, r5
			if (!driver_read_word(&sec_count)) {
  401714:	2800      	cmp	r0, #0
  401716:	f43f ae0c 	beq.w	401332 <sd_mmc_check+0x20e>
			& MMC_CTYPE_52MHZ;

	if (MMC_CSD_C_SIZE(sd_mmc_card->csd) == 0xFFF) {
		// For high capacity SD/MMC card,
		// memory capacity = SEC_COUNT * 512 byte
		for (; i <(EXT_CSD_SEC_COUNT_INDEX + 4) / 4; i++) {
  40171a:	2d36      	cmp	r5, #54	; 0x36
  40171c:	d1f6      	bne.n	40170c <sd_mmc_check+0x5e8>
			if (!driver_read_word(&sec_count)) {
				return false;
			}
		}
		sd_mmc_card->capacity = sec_count / 2;
  40171e:	9a04      	ldr	r2, [sp, #16]
  401720:	683b      	ldr	r3, [r7, #0]
  401722:	0852      	lsrs	r2, r2, #1
  401724:	605a      	str	r2, [r3, #4]
  401726:	e77d      	b.n	401624 <sd_mmc_check+0x500>
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
		}
	} else {
		// Reinitialize the slot with the new speed
		sd_mmc_configure_slot();
  401728:	4b12      	ldr	r3, [pc, #72]	; (401774 <sd_mmc_check+0x650>)
  40172a:	4d13      	ldr	r5, [pc, #76]	; (401778 <sd_mmc_check+0x654>)
  40172c:	4798      	blx	r3
  40172e:	e7a8      	b.n	401682 <sd_mmc_check+0x55e>
		arg = MMC_CMD6_ACCESS_SET_BITS
				| MMC_CMD6_INDEX_BUS_WIDTH
				| MMC_CMD6_VALUE_BUS_WIDTH_8BIT;
		break;
	case 4:
		arg = MMC_CMD6_ACCESS_SET_BITS
  401730:	4912      	ldr	r1, [pc, #72]	; (40177c <sd_mmc_check+0x658>)
  401732:	e791      	b.n	401658 <sd_mmc_check+0x534>
 *
 * \return true if success, otherwise false
 */
static bool mmc_cmd6_set_high_speed(void)
{
	if (!driver_send_cmd(MMC_CMD6_SWITCH,
  401734:	f243 1006 	movw	r0, #12550	; 0x3106
  401738:	4911      	ldr	r1, [pc, #68]	; (401780 <sd_mmc_check+0x65c>)
  40173a:	47b0      	blx	r6
  40173c:	2800      	cmp	r0, #0
  40173e:	f43f adf9 	beq.w	401334 <sd_mmc_check+0x210>
			MMC_CMD6_ACCESS_WRITE_BYTE
			| MMC_CMD6_INDEX_HS_TIMING
			| MMC_CMD6_VALUE_HS_TIMING_ENABLE)) {
		return false;
	}
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
  401742:	47c8      	blx	r9
  401744:	0603      	lsls	r3, r0, #24
  401746:	f53f adf5 	bmi.w	401334 <sd_mmc_check+0x210>
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  40174a:	683b      	ldr	r3, [r7, #0]
	sd_mmc_card->clock = 52000000lu;
  40174c:	4a0d      	ldr	r2, [pc, #52]	; (401784 <sd_mmc_check+0x660>)
  40174e:	601a      	str	r2, [r3, #0]
	if (driver_get_response() & CARD_STATUS_SWITCH_ERROR) {
		// No supported, it is not a protocol error
		sd_mmc_debug("%s: CMD6 CARD_STATUS_SWITCH_ERROR\n\r", __func__);
		return false;
	}
	sd_mmc_card->high_speed = 1;
  401750:	2201      	movs	r2, #1
  401752:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
			// Enable HS
			if (!mmc_cmd6_set_high_speed()) {
				return false;
			}
			// Reinitialize the slot with the new speed
			sd_mmc_configure_slot();
  401756:	4b07      	ldr	r3, [pc, #28]	; (401774 <sd_mmc_check+0x650>)
  401758:	4798      	blx	r3
  40175a:	e792      	b.n	401682 <sd_mmc_check+0x55e>
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
		break;

	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
  40175c:	2214      	movs	r2, #20
  40175e:	741a      	strb	r2, [r3, #16]
  401760:	e6ef      	b.n	401542 <sd_mmc_check+0x41e>

	// Get MMC System Specification version supported by the card
	switch (MMC_CSD_SPEC_VERS(sd_mmc_card->csd)) {
	default:
	case 0:
		sd_mmc_card->version = CARD_VER_MMC_1_2;
  401762:	2212      	movs	r2, #18
  401764:	741a      	strb	r2, [r3, #16]
  401766:	e6ec      	b.n	401542 <sd_mmc_check+0x41e>
	case 1:
		sd_mmc_card->version = CARD_VER_MMC_1_4;
		break;

	case 2:
		sd_mmc_card->version = CARD_VER_MMC_2_2;
  401768:	2222      	movs	r2, #34	; 0x22
  40176a:	741a      	strb	r2, [r3, #16]
  40176c:	e6e9      	b.n	401542 <sd_mmc_check+0x41e>
  40176e:	683a      	ldr	r2, [r7, #0]
  401770:	e5bd      	b.n	4012ee <sd_mmc_check+0x1ca>
  401772:	bf00      	nop
  401774:	00400fa9 	.word	0x00400fa9
  401778:	20000f56 	.word	0x20000f56
  40177c:	01b70100 	.word	0x01b70100
  401780:	03b90100 	.word	0x03b90100
  401784:	03197500 	.word	0x03197500

00401788 <sd_mmc_get_type>:
	sd_mmc_deselect_slot();
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
  401788:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40178a:	b108      	cbz	r0, 401790 <sd_mmc_get_type+0x8>
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
  40178c:	2000      	movs	r0, #0
  40178e:	bd08      	pop	{r3, pc}
  401790:	4b08      	ldr	r3, [pc, #32]	; (4017b4 <sd_mmc_get_type+0x2c>)
  401792:	4798      	blx	r3
	return SD_MMC_ERR_UNUSABLE;
}

card_type_t sd_mmc_get_type(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  401794:	2800      	cmp	r0, #0
  401796:	d1f9      	bne.n	40178c <sd_mmc_get_type+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401798:	4b07      	ldr	r3, [pc, #28]	; (4017b8 <sd_mmc_get_type+0x30>)
  40179a:	781b      	ldrb	r3, [r3, #0]
  40179c:	b11b      	cbz	r3, 4017a6 <sd_mmc_get_type+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  40179e:	4b07      	ldr	r3, [pc, #28]	; (4017bc <sd_mmc_get_type+0x34>)
  4017a0:	681b      	ldr	r3, [r3, #0]
  4017a2:	7bd8      	ldrb	r0, [r3, #15]
}
  4017a4:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4017a6:	4b06      	ldr	r3, [pc, #24]	; (4017c0 <sd_mmc_get_type+0x38>)
  4017a8:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return CARD_TYPE_UNKNOWN;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->type;
  4017aa:	4b04      	ldr	r3, [pc, #16]	; (4017bc <sd_mmc_get_type+0x34>)
  4017ac:	681b      	ldr	r3, [r3, #0]
  4017ae:	7bd8      	ldrb	r0, [r3, #15]
}
  4017b0:	bd08      	pop	{r3, pc}
  4017b2:	bf00      	nop
  4017b4:	00400fd5 	.word	0x00400fd5
  4017b8:	20000f56 	.word	0x20000f56
  4017bc:	20000f50 	.word	0x20000f50
  4017c0:	00401e9d 	.word	0x00401e9d

004017c4 <sd_mmc_get_capacity>:
	sd_mmc_deselect_slot();
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
  4017c4:	b508      	push	{r3, lr}
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  4017c6:	b108      	cbz	r0, 4017cc <sd_mmc_get_capacity+0x8>
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
  4017c8:	2000      	movs	r0, #0
  4017ca:	bd08      	pop	{r3, pc}
  4017cc:	4b08      	ldr	r3, [pc, #32]	; (4017f0 <sd_mmc_get_capacity+0x2c>)
  4017ce:	4798      	blx	r3
	return sd_mmc_card->version;
}

uint32_t sd_mmc_get_capacity(uint8_t slot)
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
  4017d0:	2800      	cmp	r0, #0
  4017d2:	d1f9      	bne.n	4017c8 <sd_mmc_get_capacity+0x4>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4017d4:	4b07      	ldr	r3, [pc, #28]	; (4017f4 <sd_mmc_get_capacity+0x30>)
  4017d6:	781b      	ldrb	r3, [r3, #0]
  4017d8:	b11b      	cbz	r3, 4017e2 <sd_mmc_get_capacity+0x1e>
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  4017da:	4b07      	ldr	r3, [pc, #28]	; (4017f8 <sd_mmc_get_capacity+0x34>)
  4017dc:	681b      	ldr	r3, [r3, #0]
  4017de:	6858      	ldr	r0, [r3, #4]
}
  4017e0:	bd08      	pop	{r3, pc}
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4017e2:	4b06      	ldr	r3, [pc, #24]	; (4017fc <sd_mmc_get_capacity+0x38>)
  4017e4:	4798      	blx	r3
{
	if (SD_MMC_OK != sd_mmc_select_slot(slot)) {
		return 0;
	}
	sd_mmc_deselect_slot();
	return sd_mmc_card->capacity;
  4017e6:	4b04      	ldr	r3, [pc, #16]	; (4017f8 <sd_mmc_get_capacity+0x34>)
  4017e8:	681b      	ldr	r3, [r3, #0]
  4017ea:	6858      	ldr	r0, [r3, #4]
}
  4017ec:	bd08      	pop	{r3, pc}
  4017ee:	bf00      	nop
  4017f0:	00400fd5 	.word	0x00400fd5
  4017f4:	20000f56 	.word	0x20000f56
  4017f8:	20000f50 	.word	0x20000f50
  4017fc:	00401e9d 	.word	0x00401e9d

00401800 <sd_mmc_is_write_protected>:
			== SD_MMC_0_WP_DETECT_VALUE) {
		return true;
	}
#endif
	return false;
}
  401800:	2000      	movs	r0, #0
  401802:	4770      	bx	lr

00401804 <sd_mmc_init_read_blocks>:

sd_mmc_err_t sd_mmc_init_read_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401804:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  401808:	468b      	mov	fp, r1
  40180a:	b083      	sub	sp, #12
  40180c:	4692      	mov	sl, r2
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40180e:	b128      	cbz	r0, 40181c <sd_mmc_init_read_blocks+0x18>
		return SD_MMC_ERR_SLOT;
  401810:	f04f 0904 	mov.w	r9, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401814:	4648      	mov	r0, r9
  401816:	b003      	add	sp, #12
  401818:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40181c:	4b26      	ldr	r3, [pc, #152]	; (4018b8 <sd_mmc_init_read_blocks+0xb4>)
  40181e:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  401820:	4681      	mov	r9, r0
  401822:	2800      	cmp	r0, #0
  401824:	d1f6      	bne.n	401814 <sd_mmc_init_read_blocks+0x10>
  401826:	4c25      	ldr	r4, [pc, #148]	; (4018bc <sd_mmc_init_read_blocks+0xb8>)
  401828:	4d25      	ldr	r5, [pc, #148]	; (4018c0 <sd_mmc_init_read_blocks+0xbc>)
  40182a:	4e26      	ldr	r6, [pc, #152]	; (4018c4 <sd_mmc_init_read_blocks+0xc0>)
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  40182c:	4f26      	ldr	r7, [pc, #152]	; (4018c8 <sd_mmc_init_read_blocks+0xc4>)
  40182e:	e004      	b.n	40183a <sd_mmc_init_read_blocks+0x36>
  401830:	47b8      	blx	r7
  401832:	05c2      	lsls	r2, r0, #23
  401834:	d414      	bmi.n	401860 <sd_mmc_init_read_blocks+0x5c>
				break;
			}
		}
		if (nec_timeout-- == 0) {
  401836:	3c01      	subs	r4, #1
  401838:	d009      	beq.n	40184e <sd_mmc_init_read_blocks+0x4a>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  40183a:	682b      	ldr	r3, [r5, #0]
				return false;
			}
			// Check busy flag
			if (driver_get_response() & CARD_STATUS_READY_FOR_DATA) {
  40183c:	f8df 8088 	ldr.w	r8, [pc, #136]	; 4018c8 <sd_mmc_init_read_blocks+0xc4>
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
					(uint32_t)sd_mmc_card->rca << 16)) {
  401840:	8999      	ldrh	r1, [r3, #12]
			// Check busy flag
			if (!(driver_get_response() & 0xFF)) {
				break;
			}
		} else {
			if (!driver_send_cmd(SDMMC_MCI_CMD13_SEND_STATUS,
  401842:	f241 100d 	movw	r0, #4365	; 0x110d
  401846:	0409      	lsls	r1, r1, #16
  401848:	47b0      	blx	r6
  40184a:	2800      	cmp	r0, #0
  40184c:	d1f0      	bne.n	401830 <sd_mmc_init_read_blocks+0x2c>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40184e:	4b1f      	ldr	r3, [pc, #124]	; (4018cc <sd_mmc_init_read_blocks+0xc8>)
  401850:	781b      	ldrb	r3, [r3, #0]
  401852:	b33b      	cbz	r3, 4018a4 <sd_mmc_init_read_blocks+0xa0>
		arg = (start * SD_MMC_BLOCK_SIZE);
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  401854:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401858:	4648      	mov	r0, r9
  40185a:	b003      	add	sp, #12
  40185c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401860:	682b      	ldr	r3, [r5, #0]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  401862:	481b      	ldr	r0, [pc, #108]	; (4018d0 <sd_mmc_init_read_blocks+0xcc>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401864:	7bdb      	ldrb	r3, [r3, #15]
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD18_READ_MULTIPLE_BLOCK;
	} else {
		cmd = SDMMC_CMD17_READ_SINGLE_BLOCK;
  401866:	4a1b      	ldr	r2, [pc, #108]	; (4018d4 <sd_mmc_init_read_blocks+0xd0>)
  401868:	f1ba 0f01 	cmp.w	sl, #1
  40186c:	bf98      	it	ls
  40186e:	4610      	movls	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401870:	071b      	lsls	r3, r3, #28
  401872:	d401      	bmi.n	401878 <sd_mmc_init_read_blocks+0x74>
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  401874:	ea4f 2b4b 	mov.w	fp, fp, lsl #9
	}

	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  401878:	2301      	movs	r3, #1
  40187a:	9300      	str	r3, [sp, #0]
  40187c:	4659      	mov	r1, fp
  40187e:	f44f 7200 	mov.w	r2, #512	; 0x200
  401882:	4653      	mov	r3, sl
  401884:	4c14      	ldr	r4, [pc, #80]	; (4018d8 <sd_mmc_init_read_blocks+0xd4>)
  401886:	47a0      	blx	r4
  401888:	2800      	cmp	r0, #0
  40188a:	d0e0      	beq.n	40184e <sd_mmc_init_read_blocks+0x4a>
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  40188c:	47c0      	blx	r8
		if (resp & CARD_STATUS_ERR_RD_WR) {
  40188e:	4b13      	ldr	r3, [pc, #76]	; (4018dc <sd_mmc_init_read_blocks+0xd8>)
  401890:	4003      	ands	r3, r0
  401892:	2b00      	cmp	r3, #0
  401894:	d1db      	bne.n	40184e <sd_mmc_init_read_blocks+0x4a>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  401896:	4a12      	ldr	r2, [pc, #72]	; (4018e0 <sd_mmc_init_read_blocks+0xdc>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  401898:	4b12      	ldr	r3, [pc, #72]	; (4018e4 <sd_mmc_init_read_blocks+0xe0>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  40189a:	f8a2 a000 	strh.w	sl, [r2]
	sd_mmc_nb_block_to_tranfer = nb_block;
  40189e:	f8a3 a000 	strh.w	sl, [r3]
	return SD_MMC_OK;
  4018a2:	e7b7      	b.n	401814 <sd_mmc_init_read_blocks+0x10>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4018a4:	2000      	movs	r0, #0
  4018a6:	4b10      	ldr	r3, [pc, #64]	; (4018e8 <sd_mmc_init_read_blocks+0xe4>)
  4018a8:	4798      	blx	r3
	}

	// Wait for data ready status
	if (!sd_mmc_cmd13()) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  4018aa:	f04f 0905 	mov.w	r9, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4018ae:	4648      	mov	r0, r9
  4018b0:	b003      	add	sp, #12
  4018b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4018b6:	bf00      	nop
  4018b8:	00400fd5 	.word	0x00400fd5
  4018bc:	00030d41 	.word	0x00030d41
  4018c0:	20000f50 	.word	0x20000f50
  4018c4:	00401ec1 	.word	0x00401ec1
  4018c8:	00401eed 	.word	0x00401eed
  4018cc:	20000f56 	.word	0x20000f56
  4018d0:	00101112 	.word	0x00101112
  4018d4:	00081111 	.word	0x00081111
  4018d8:	00401f19 	.word	0x00401f19
  4018dc:	e4580000 	.word	0xe4580000
  4018e0:	20000f54 	.word	0x20000f54
  4018e4:	20000f4c 	.word	0x20000f4c
  4018e8:	00401e9d 	.word	0x00401e9d

004018ec <sd_mmc_start_read_blocks>:

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4018ec:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4018ee:	4b07      	ldr	r3, [pc, #28]	; (40190c <sd_mmc_start_read_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_read_blocks(void *dest, uint16_t nb_block)
{
  4018f0:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);

	if (!driver_start_read_blocks(dest, nb_block)) {
  4018f2:	4798      	blx	r3
  4018f4:	4603      	mov	r3, r0
  4018f6:	b918      	cbnz	r0, 401900 <sd_mmc_start_read_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  4018f8:	4a05      	ldr	r2, [pc, #20]	; (401910 <sd_mmc_start_read_blocks+0x24>)
  4018fa:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  4018fc:	2005      	movs	r0, #5
  4018fe:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401900:	4b03      	ldr	r3, [pc, #12]	; (401910 <sd_mmc_start_read_blocks+0x24>)
  401902:	881a      	ldrh	r2, [r3, #0]
  401904:	1b14      	subs	r4, r2, r4
  401906:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401908:	2000      	movs	r0, #0
}
  40190a:	bd10      	pop	{r4, pc}
  40190c:	0040206d 	.word	0x0040206d
  401910:	20000f54 	.word	0x20000f54

00401914 <sd_mmc_wait_end_of_read_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  401914:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_read_blocks()) {
  401916:	4b12      	ldr	r3, [pc, #72]	; (401960 <sd_mmc_wait_end_of_read_blocks+0x4c>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
  401918:	4604      	mov	r4, r0
	if (!driver_wait_end_of_read_blocks()) {
  40191a:	4798      	blx	r3
  40191c:	b908      	cbnz	r0, 401922 <sd_mmc_wait_end_of_read_blocks+0xe>
		return SD_MMC_ERR_COMM;
  40191e:	2005      	movs	r0, #5
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
	}
	sd_mmc_deselect_slot();
	return SD_MMC_OK;
}
  401920:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401922:	4b10      	ldr	r3, [pc, #64]	; (401964 <sd_mmc_wait_end_of_read_blocks+0x50>)
sd_mmc_err_t sd_mmc_wait_end_of_read_blocks(bool abort)
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401924:	b99c      	cbnz	r4, 40194e <sd_mmc_wait_end_of_read_blocks+0x3a>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  401926:	881b      	ldrh	r3, [r3, #0]
  401928:	b97b      	cbnz	r3, 40194a <sd_mmc_wait_end_of_read_blocks+0x36>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  40192a:	4b0f      	ldr	r3, [pc, #60]	; (401968 <sd_mmc_wait_end_of_read_blocks+0x54>)
  40192c:	881b      	ldrh	r3, [r3, #0]
  40192e:	2b01      	cmp	r3, #1
  401930:	d005      	beq.n	40193e <sd_mmc_wait_end_of_read_blocks+0x2a>
		return SD_MMC_OK;
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  401932:	f243 100c 	movw	r0, #12556	; 0x310c
  401936:	2100      	movs	r1, #0
  401938:	4c0c      	ldr	r4, [pc, #48]	; (40196c <sd_mmc_wait_end_of_read_blocks+0x58>)
  40193a:	47a0      	blx	r4
  40193c:	b150      	cbz	r0, 401954 <sd_mmc_wait_end_of_read_blocks+0x40>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  40193e:	4b0c      	ldr	r3, [pc, #48]	; (401970 <sd_mmc_wait_end_of_read_blocks+0x5c>)
  401940:	781b      	ldrb	r3, [r3, #0]
  401942:	b913      	cbnz	r3, 40194a <sd_mmc_wait_end_of_read_blocks+0x36>
		driver_deselect_device(sd_mmc_slot_sel);
  401944:	2000      	movs	r0, #0
  401946:	4b0b      	ldr	r3, [pc, #44]	; (401974 <sd_mmc_wait_end_of_read_blocks+0x60>)
  401948:	4798      	blx	r3

	// All blocks are transfered then stop read operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  40194a:	2000      	movs	r0, #0
  40194c:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_read_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  40194e:	2200      	movs	r2, #0
  401950:	801a      	strh	r2, [r3, #0]
  401952:	e7ea      	b.n	40192a <sd_mmc_wait_end_of_read_blocks+0x16>
	}
	// WORKAROUND for no compliance card (Atmel Internal ref. !MMC7 !SD19):
	// The errors on this command must be ignored
	// and one retry can be necessary in SPI mode for no compliance card.
	if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
		driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0);
  401954:	4601      	mov	r1, r0
  401956:	f243 100c 	movw	r0, #12556	; 0x310c
  40195a:	47a0      	blx	r4
  40195c:	e7ef      	b.n	40193e <sd_mmc_wait_end_of_read_blocks+0x2a>
  40195e:	bf00      	nop
  401960:	004020d5 	.word	0x004020d5
  401964:	20000f54 	.word	0x20000f54
  401968:	20000f4c 	.word	0x20000f4c
  40196c:	00401ec1 	.word	0x00401ec1
  401970:	20000f56 	.word	0x20000f56
  401974:	00401e9d 	.word	0x00401e9d

00401978 <sd_mmc_init_write_blocks>:
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_init_write_blocks(uint8_t slot, uint32_t start,
		uint16_t nb_block)
{
  401978:	b570      	push	{r4, r5, r6, lr}
  40197a:	4615      	mov	r5, r2
  40197c:	b084      	sub	sp, #16
 * \retval SD_MMC_INIT_ONGOING Card initialization requested
 * \retval SD_MMC_OK           Card present
 */
static sd_mmc_err_t sd_mmc_select_slot(uint8_t slot)
{
	if (slot >= SD_MMC_MEM_CNT) {
  40197e:	b118      	cbz	r0, 401988 <sd_mmc_init_write_blocks+0x10>
		return SD_MMC_ERR_SLOT;
  401980:	2404      	movs	r4, #4
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  401982:	4620      	mov	r0, r4
  401984:	b004      	add	sp, #16
  401986:	bd70      	pop	{r4, r5, r6, pc}
  401988:	9103      	str	r1, [sp, #12]
  40198a:	4b18      	ldr	r3, [pc, #96]	; (4019ec <sd_mmc_init_write_blocks+0x74>)
  40198c:	4798      	blx	r3
{
	sd_mmc_err_t sd_mmc_err;
	uint32_t cmd, arg, resp;

	sd_mmc_err = sd_mmc_select_slot(slot);
	if (sd_mmc_err != SD_MMC_OK) {
  40198e:	9903      	ldr	r1, [sp, #12]
  401990:	4604      	mov	r4, r0
  401992:	2800      	cmp	r0, #0
  401994:	d1f5      	bne.n	401982 <sd_mmc_init_write_blocks+0xa>
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  401996:	4b16      	ldr	r3, [pc, #88]	; (4019f0 <sd_mmc_init_write_blocks+0x78>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  401998:	4a16      	ldr	r2, [pc, #88]	; (4019f4 <sd_mmc_init_write_blocks+0x7c>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40199a:	681b      	ldr	r3, [r3, #0]
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  40199c:	4816      	ldr	r0, [pc, #88]	; (4019f8 <sd_mmc_init_write_blocks+0x80>)
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  40199e:	7bdb      	ldrb	r3, [r3, #15]
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4019a0:	4e16      	ldr	r6, [pc, #88]	; (4019fc <sd_mmc_init_write_blocks+0x84>)
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_WP;
	}

	if (nb_block > 1) {
		cmd = SDMMC_CMD25_WRITE_MULTIPLE_BLOCK;
  4019a2:	2d01      	cmp	r5, #1
  4019a4:	bf88      	it	hi
  4019a6:	4610      	movhi	r0, r2
	}
	/*
	 * SDSC Card (CCS=0) uses byte unit address,
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
  4019a8:	071b      	lsls	r3, r3, #28
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4019aa:	f04f 0301 	mov.w	r3, #1
	 * SDHC and SDXC Cards (CCS=1) use block unit address (512 Bytes unit).
	 */
	if (sd_mmc_card->type & CARD_TYPE_HC) {
		arg = start;
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
  4019ae:	bf58      	it	pl
  4019b0:	0249      	lslpl	r1, r1, #9
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
  4019b2:	9300      	str	r3, [sp, #0]
  4019b4:	f44f 7200 	mov.w	r2, #512	; 0x200
  4019b8:	462b      	mov	r3, r5
  4019ba:	47b0      	blx	r6
  4019bc:	b930      	cbnz	r0, 4019cc <sd_mmc_init_write_blocks+0x54>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  4019be:	4b10      	ldr	r3, [pc, #64]	; (401a00 <sd_mmc_init_write_blocks+0x88>)
  4019c0:	781b      	ldrb	r3, [r3, #0]
  4019c2:	b173      	cbz	r3, 4019e2 <sd_mmc_init_write_blocks+0x6a>
	} else {
		arg = (start * SD_MMC_BLOCK_SIZE);
	}
	if (!driver_adtc_start(cmd, arg, SD_MMC_BLOCK_SIZE, nb_block, true)) {
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
  4019c4:	2405      	movs	r4, #5
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}
  4019c6:	4620      	mov	r0, r4
  4019c8:	b004      	add	sp, #16
  4019ca:	bd70      	pop	{r4, r5, r6, pc}
		sd_mmc_deselect_slot();
		return SD_MMC_ERR_COMM;
	}
	// Check response
	if (sd_mmc_is_mci()) {
		resp = driver_get_response();
  4019cc:	4b0d      	ldr	r3, [pc, #52]	; (401a04 <sd_mmc_init_write_blocks+0x8c>)
  4019ce:	4798      	blx	r3
		if (resp & CARD_STATUS_ERR_RD_WR) {
  4019d0:	4b0d      	ldr	r3, [pc, #52]	; (401a08 <sd_mmc_init_write_blocks+0x90>)
  4019d2:	4003      	ands	r3, r0
  4019d4:	2b00      	cmp	r3, #0
  4019d6:	d1f2      	bne.n	4019be <sd_mmc_init_write_blocks+0x46>
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4019d8:	4a0c      	ldr	r2, [pc, #48]	; (401a0c <sd_mmc_init_write_blocks+0x94>)
	sd_mmc_nb_block_to_tranfer = nb_block;
  4019da:	4b0d      	ldr	r3, [pc, #52]	; (401a10 <sd_mmc_init_write_blocks+0x98>)
					__func__, (int)SDMMC_CMD_GET_INDEX(cmd), resp);
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
		}
	}
	sd_mmc_nb_block_remaining = nb_block;
  4019dc:	8015      	strh	r5, [r2, #0]
	sd_mmc_nb_block_to_tranfer = nb_block;
  4019de:	801d      	strh	r5, [r3, #0]
	return SD_MMC_OK;
  4019e0:	e7cf      	b.n	401982 <sd_mmc_init_write_blocks+0xa>
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
		driver_deselect_device(sd_mmc_slot_sel);
  4019e2:	2000      	movs	r0, #0
  4019e4:	4b0b      	ldr	r3, [pc, #44]	; (401a14 <sd_mmc_init_write_blocks+0x9c>)
  4019e6:	4798      	blx	r3
  4019e8:	e7ec      	b.n	4019c4 <sd_mmc_init_write_blocks+0x4c>
  4019ea:	bf00      	nop
  4019ec:	00400fd5 	.word	0x00400fd5
  4019f0:	20000f50 	.word	0x20000f50
  4019f4:	00109119 	.word	0x00109119
  4019f8:	00089118 	.word	0x00089118
  4019fc:	00401f19 	.word	0x00401f19
  401a00:	20000f56 	.word	0x20000f56
  401a04:	00401eed 	.word	0x00401eed
  401a08:	e4580000 	.word	0xe4580000
  401a0c:	20000f54 	.word	0x20000f54
  401a10:	20000f4c 	.word	0x20000f4c
  401a14:	00401e9d 	.word	0x00401e9d

00401a18 <sd_mmc_start_write_blocks>:
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  401a18:	b510      	push	{r4, lr}
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  401a1a:	4b07      	ldr	r3, [pc, #28]	; (401a38 <sd_mmc_start_write_blocks+0x20>)
	sd_mmc_nb_block_to_tranfer = nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_start_write_blocks(const void *src, uint16_t nb_block)
{
  401a1c:	460c      	mov	r4, r1
	Assert(sd_mmc_nb_block_remaining >= nb_block);
	if (!driver_start_write_blocks(src, nb_block)) {
  401a1e:	4798      	blx	r3
  401a20:	4603      	mov	r3, r0
  401a22:	b918      	cbnz	r0, 401a2c <sd_mmc_start_write_blocks+0x14>
		sd_mmc_nb_block_remaining = 0;
  401a24:	4a05      	ldr	r2, [pc, #20]	; (401a3c <sd_mmc_start_write_blocks+0x24>)
  401a26:	8013      	strh	r3, [r2, #0]
		return SD_MMC_ERR_COMM;
  401a28:	2005      	movs	r0, #5
  401a2a:	bd10      	pop	{r4, pc}
	}
	sd_mmc_nb_block_remaining -= nb_block;
  401a2c:	4b03      	ldr	r3, [pc, #12]	; (401a3c <sd_mmc_start_write_blocks+0x24>)
  401a2e:	881a      	ldrh	r2, [r3, #0]
  401a30:	1b14      	subs	r4, r2, r4
  401a32:	801c      	strh	r4, [r3, #0]
	return SD_MMC_OK;
  401a34:	2000      	movs	r0, #0
}
  401a36:	bd10      	pop	{r4, pc}
  401a38:	00402179 	.word	0x00402179
  401a3c:	20000f54 	.word	0x20000f54

00401a40 <sd_mmc_wait_end_of_write_blocks>:

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401a40:	b510      	push	{r4, lr}
	if (!driver_wait_end_of_write_blocks()) {
  401a42:	4b14      	ldr	r3, [pc, #80]	; (401a94 <sd_mmc_wait_end_of_write_blocks+0x54>)
	sd_mmc_nb_block_remaining -= nb_block;
	return SD_MMC_OK;
}

sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
  401a44:	4604      	mov	r4, r0
	if (!driver_wait_end_of_write_blocks()) {
  401a46:	4798      	blx	r3
  401a48:	b908      	cbnz	r0, 401a4e <sd_mmc_wait_end_of_write_blocks+0xe>
	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
			sd_mmc_deselect_slot();
			return SD_MMC_ERR_COMM;
  401a4a:	2005      	movs	r0, #5
  401a4c:	bd10      	pop	{r4, pc}
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401a4e:	4b12      	ldr	r3, [pc, #72]	; (401a98 <sd_mmc_wait_end_of_write_blocks+0x58>)
sd_mmc_err_t sd_mmc_wait_end_of_write_blocks(bool abort)
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
  401a50:	b994      	cbnz	r4, 401a78 <sd_mmc_wait_end_of_write_blocks+0x38>
		sd_mmc_nb_block_remaining = 0;
	} else if (sd_mmc_nb_block_remaining) {
  401a52:	881b      	ldrh	r3, [r3, #0]
  401a54:	b9e3      	cbnz	r3, 401a90 <sd_mmc_wait_end_of_write_blocks+0x50>
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401a56:	4b11      	ldr	r3, [pc, #68]	; (401a9c <sd_mmc_wait_end_of_write_blocks+0x5c>)
  401a58:	881b      	ldrh	r3, [r3, #0]
  401a5a:	2b01      	cmp	r3, #1
  401a5c:	d012      	beq.n	401a84 <sd_mmc_wait_end_of_write_blocks+0x44>
	}

	if (sd_mmc_is_mci()) {
		// Note: SPI multiblock writes terminate using a special
		// token, not a STOP_TRANSMISSION request.
		if (!driver_adtc_stop(SDMMC_CMD12_STOP_TRANSMISSION, 0)) {
  401a5e:	f243 100c 	movw	r0, #12556	; 0x310c
  401a62:	2100      	movs	r1, #0
  401a64:	4b0e      	ldr	r3, [pc, #56]	; (401aa0 <sd_mmc_wait_end_of_write_blocks+0x60>)
  401a66:	4798      	blx	r3
  401a68:	b960      	cbnz	r0, 401a84 <sd_mmc_wait_end_of_write_blocks+0x44>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401a6a:	4b0e      	ldr	r3, [pc, #56]	; (401aa4 <sd_mmc_wait_end_of_write_blocks+0x64>)
  401a6c:	781b      	ldrb	r3, [r3, #0]
  401a6e:	2b00      	cmp	r3, #0
  401a70:	d1eb      	bne.n	401a4a <sd_mmc_wait_end_of_write_blocks+0xa>
		driver_deselect_device(sd_mmc_slot_sel);
  401a72:	4b0d      	ldr	r3, [pc, #52]	; (401aa8 <sd_mmc_wait_end_of_write_blocks+0x68>)
  401a74:	4798      	blx	r3
  401a76:	e7e8      	b.n	401a4a <sd_mmc_wait_end_of_write_blocks+0xa>
{
	if (!driver_wait_end_of_write_blocks()) {
		return SD_MMC_ERR_COMM;
	}
	if (abort) {
		sd_mmc_nb_block_remaining = 0;
  401a78:	2200      	movs	r2, #0
  401a7a:	801a      	strh	r2, [r3, #0]
	} else if (sd_mmc_nb_block_remaining) {
		return SD_MMC_OK;
	}

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
  401a7c:	4b07      	ldr	r3, [pc, #28]	; (401a9c <sd_mmc_wait_end_of_write_blocks+0x5c>)
  401a7e:	881b      	ldrh	r3, [r3, #0]
  401a80:	2b01      	cmp	r3, #1
  401a82:	d1ec      	bne.n	401a5e <sd_mmc_wait_end_of_write_blocks+0x1e>
/**
 * \brief Deselect the current card slot
 */
static void sd_mmc_deselect_slot(void)
{
	if (sd_mmc_slot_sel < SD_MMC_MEM_CNT) {
  401a84:	4b07      	ldr	r3, [pc, #28]	; (401aa4 <sd_mmc_wait_end_of_write_blocks+0x64>)
  401a86:	781b      	ldrb	r3, [r3, #0]
  401a88:	b913      	cbnz	r3, 401a90 <sd_mmc_wait_end_of_write_blocks+0x50>
		driver_deselect_device(sd_mmc_slot_sel);
  401a8a:	2000      	movs	r0, #0
  401a8c:	4b06      	ldr	r3, [pc, #24]	; (401aa8 <sd_mmc_wait_end_of_write_blocks+0x68>)
  401a8e:	4798      	blx	r3

	// All blocks are transfered then stop write operation
	if (sd_mmc_nb_block_to_tranfer == 1) {
		// Single block transfer, then nothing to do
		sd_mmc_deselect_slot();
		return SD_MMC_OK;
  401a90:	2000      	movs	r0, #0
  401a92:	bd10      	pop	{r4, pc}
  401a94:	004021e5 	.word	0x004021e5
  401a98:	20000f54 	.word	0x20000f54
  401a9c:	20000f4c 	.word	0x20000f4c
  401aa0:	00401ec1 	.word	0x00401ec1
  401aa4:	20000f56 	.word	0x20000f56
  401aa8:	00401e9d 	.word	0x00401e9d

00401aac <sd_mmc_test_unit_ready>:
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401aac:	b510      	push	{r4, lr}
	switch (sd_mmc_check(slot))
  401aae:	4b0f      	ldr	r3, [pc, #60]	; (401aec <sd_mmc_test_unit_ready+0x40>)
 */

static bool sd_mmc_ejected[2] = {false, false};

Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
  401ab0:	4604      	mov	r4, r0
	switch (sd_mmc_check(slot))
  401ab2:	4798      	blx	r3
  401ab4:	2801      	cmp	r0, #1
  401ab6:	d00d      	beq.n	401ad4 <sd_mmc_test_unit_ready+0x28>
  401ab8:	d307      	bcc.n	401aca <sd_mmc_test_unit_ready+0x1e>
  401aba:	2802      	cmp	r0, #2
  401abc:	d103      	bne.n	401ac6 <sd_mmc_test_unit_ready+0x1a>

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;

	case SD_MMC_ERR_NO_CARD:
		sd_mmc_ejected[slot] = false;
  401abe:	4b0c      	ldr	r3, [pc, #48]	; (401af0 <sd_mmc_test_unit_ready+0x44>)
  401ac0:	2200      	movs	r2, #0
  401ac2:	551a      	strb	r2, [r3, r4]
		return CTRL_NO_PRESENT;
  401ac4:	bd10      	pop	{r4, pc}

	default:
		return CTRL_FAIL;
  401ac6:	2001      	movs	r0, #1
  401ac8:	bd10      	pop	{r4, pc}
Ctrl_status sd_mmc_test_unit_ready(uint8_t slot)
{
	switch (sd_mmc_check(slot))
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
  401aca:	4b09      	ldr	r3, [pc, #36]	; (401af0 <sd_mmc_test_unit_ready+0x44>)
  401acc:	5d1b      	ldrb	r3, [r3, r4]
  401ace:	b11b      	cbz	r3, 401ad8 <sd_mmc_test_unit_ready+0x2c>
			return CTRL_NO_PRESENT;
  401ad0:	2002      	movs	r0, #2
		return CTRL_NO_PRESENT;

	default:
		return CTRL_FAIL;
	}
}
  401ad2:	bd10      	pop	{r4, pc}
		}
		// It is not a memory card
		return CTRL_NO_PRESENT;

	case SD_MMC_INIT_ONGOING:
		return CTRL_BUSY;
  401ad4:	2003      	movs	r0, #3
  401ad6:	bd10      	pop	{r4, pc}
	{
	case SD_MMC_OK:
		if (sd_mmc_ejected[slot]) {
			return CTRL_NO_PRESENT;
		}
		if (sd_mmc_get_type(slot) & (CARD_TYPE_SD | CARD_TYPE_MMC)) {
  401ad8:	4620      	mov	r0, r4
  401ada:	4b06      	ldr	r3, [pc, #24]	; (401af4 <sd_mmc_test_unit_ready+0x48>)
  401adc:	4798      	blx	r3
  401ade:	f010 0f03 	tst.w	r0, #3
			return CTRL_GOOD;
  401ae2:	bf0c      	ite	eq
  401ae4:	2002      	moveq	r0, #2
  401ae6:	2000      	movne	r0, #0
  401ae8:	bd10      	pop	{r4, pc}
  401aea:	bf00      	nop
  401aec:	00401125 	.word	0x00401125
  401af0:	20000f58 	.word	0x20000f58
  401af4:	00401789 	.word	0x00401789

00401af8 <sd_mmc_test_unit_ready_0>:
		return CTRL_FAIL;
	}
}

Ctrl_status sd_mmc_test_unit_ready_0(void)
{
  401af8:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(0);
  401afa:	2000      	movs	r0, #0
  401afc:	4b01      	ldr	r3, [pc, #4]	; (401b04 <sd_mmc_test_unit_ready_0+0xc>)
  401afe:	4798      	blx	r3
}
  401b00:	bd08      	pop	{r3, pc}
  401b02:	bf00      	nop
  401b04:	00401aad 	.word	0x00401aad

00401b08 <sd_mmc_test_unit_ready_1>:


Ctrl_status sd_mmc_test_unit_ready_1(void)
{
  401b08:	b508      	push	{r3, lr}
	return sd_mmc_test_unit_ready(1);
  401b0a:	2001      	movs	r0, #1
  401b0c:	4b01      	ldr	r3, [pc, #4]	; (401b14 <sd_mmc_test_unit_ready_1+0xc>)
  401b0e:	4798      	blx	r3
}
  401b10:	bd08      	pop	{r3, pc}
  401b12:	bf00      	nop
  401b14:	00401aad 	.word	0x00401aad

00401b18 <sd_mmc_read_capacity>:

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401b18:	b538      	push	{r3, r4, r5, lr}
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401b1a:	4b05      	ldr	r3, [pc, #20]	; (401b30 <sd_mmc_read_capacity+0x18>)
{
	return sd_mmc_test_unit_ready(1);
}

Ctrl_status sd_mmc_read_capacity(uint8_t slot, uint32_t *nb_sector)
{
  401b1c:	460d      	mov	r5, r1
  401b1e:	4604      	mov	r4, r0
	// Return last sector address (-1)
	*nb_sector = (sd_mmc_get_capacity(slot) * 2) - 1;
  401b20:	4798      	blx	r3
  401b22:	0040      	lsls	r0, r0, #1
  401b24:	3801      	subs	r0, #1
  401b26:	6028      	str	r0, [r5, #0]
	return sd_mmc_test_unit_ready(slot);
  401b28:	4b02      	ldr	r3, [pc, #8]	; (401b34 <sd_mmc_read_capacity+0x1c>)
  401b2a:	4620      	mov	r0, r4
  401b2c:	4798      	blx	r3
}
  401b2e:	bd38      	pop	{r3, r4, r5, pc}
  401b30:	004017c5 	.word	0x004017c5
  401b34:	00401aad 	.word	0x00401aad

00401b38 <sd_mmc_read_capacity_0>:

Ctrl_status sd_mmc_read_capacity_0(uint32_t *nb_sector)
{
  401b38:	b508      	push	{r3, lr}
  401b3a:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(0, nb_sector);
  401b3c:	4b01      	ldr	r3, [pc, #4]	; (401b44 <sd_mmc_read_capacity_0+0xc>)
  401b3e:	2000      	movs	r0, #0
  401b40:	4798      	blx	r3
}
  401b42:	bd08      	pop	{r3, pc}
  401b44:	00401b19 	.word	0x00401b19

00401b48 <sd_mmc_read_capacity_1>:

Ctrl_status sd_mmc_read_capacity_1(uint32_t *nb_sector)
{
  401b48:	b508      	push	{r3, lr}
  401b4a:	4601      	mov	r1, r0
	return sd_mmc_read_capacity(1, nb_sector);
  401b4c:	4b01      	ldr	r3, [pc, #4]	; (401b54 <sd_mmc_read_capacity_1+0xc>)
  401b4e:	2001      	movs	r0, #1
  401b50:	4798      	blx	r3
}
  401b52:	bd08      	pop	{r3, pc}
  401b54:	00401b19 	.word	0x00401b19

00401b58 <sd_mmc_unload_0>:

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  401b58:	4b01      	ldr	r3, [pc, #4]	; (401b60 <sd_mmc_unload_0+0x8>)
  401b5a:	7018      	strb	r0, [r3, #0]
}

bool sd_mmc_unload_0(bool unload)
{
	return sd_mmc_unload(0, unload);
}
  401b5c:	2001      	movs	r0, #1
  401b5e:	4770      	bx	lr
  401b60:	20000f58 	.word	0x20000f58

00401b64 <sd_mmc_unload_1>:
	return sd_mmc_read_capacity(1, nb_sector);
}

bool sd_mmc_unload(uint8_t slot, bool unload)
{
	sd_mmc_ejected[slot] = unload;
  401b64:	4b01      	ldr	r3, [pc, #4]	; (401b6c <sd_mmc_unload_1+0x8>)
  401b66:	7058      	strb	r0, [r3, #1]
}

bool sd_mmc_unload_1(bool unload)
{
	return sd_mmc_unload(1, unload);
}
  401b68:	2001      	movs	r0, #1
  401b6a:	4770      	bx	lr
  401b6c:	20000f58 	.word	0x20000f58

00401b70 <sd_mmc_wr_protect_0>:
{
	return sd_mmc_is_write_protected(slot);
}

bool sd_mmc_wr_protect_0(void)
{
  401b70:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  401b72:	2000      	movs	r0, #0
  401b74:	4b01      	ldr	r3, [pc, #4]	; (401b7c <sd_mmc_wr_protect_0+0xc>)
  401b76:	4798      	blx	r3
}

bool sd_mmc_wr_protect_0(void)
{
	return sd_mmc_wr_protect(0);
}
  401b78:	bd08      	pop	{r3, pc}
  401b7a:	bf00      	nop
  401b7c:	00401801 	.word	0x00401801

00401b80 <sd_mmc_wr_protect_1>:

bool sd_mmc_wr_protect_1(void)
{
  401b80:	b508      	push	{r3, lr}
	return sd_mmc_unload(1, unload);
}

bool sd_mmc_wr_protect(uint8_t slot)
{
	return sd_mmc_is_write_protected(slot);
  401b82:	2001      	movs	r0, #1
  401b84:	4b01      	ldr	r3, [pc, #4]	; (401b8c <sd_mmc_wr_protect_1+0xc>)
  401b86:	4798      	blx	r3
}

bool sd_mmc_wr_protect_1(void)
{
	return sd_mmc_wr_protect(1);
}
  401b88:	bd08      	pop	{r3, pc}
  401b8a:	bf00      	nop
  401b8c:	00401801 	.word	0x00401801

00401b90 <sd_mmc_removal_0>:
}

bool sd_mmc_removal_0(void)
{
	return sd_mmc_removal(0);
}
  401b90:	2001      	movs	r0, #1
  401b92:	4770      	bx	lr

00401b94 <sd_mmc_removal_1>:

bool sd_mmc_removal_1(void)
{
	return sd_mmc_removal(1);
}
  401b94:	2001      	movs	r0, #1
  401b96:	4770      	bx	lr

00401b98 <sd_mmc_mem_2_ram>:
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  401b98:	b510      	push	{r4, lr}
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  401b9a:	4b0b      	ldr	r3, [pc, #44]	; (401bc8 <sd_mmc_mem_2_ram+0x30>)
/**
 * \name MEM <-> RAM Interface
 * @{
 */
Ctrl_status sd_mmc_mem_2_ram(uint8_t slot, uint32_t addr, void *ram)
{
  401b9c:	4614      	mov	r4, r2
	switch (sd_mmc_init_read_blocks(slot, addr, 1)) {
  401b9e:	2201      	movs	r2, #1
  401ba0:	4798      	blx	r3
  401ba2:	b120      	cbz	r0, 401bae <sd_mmc_mem_2_ram+0x16>
  401ba4:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  401ba6:	bf0c      	ite	eq
  401ba8:	2002      	moveq	r0, #2
  401baa:	2001      	movne	r0, #1
  401bac:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
  401bae:	4620      	mov	r0, r4
  401bb0:	2101      	movs	r1, #1
  401bb2:	4b06      	ldr	r3, [pc, #24]	; (401bcc <sd_mmc_mem_2_ram+0x34>)
  401bb4:	4798      	blx	r3
  401bb6:	b108      	cbz	r0, 401bbc <sd_mmc_mem_2_ram+0x24>
		return CTRL_FAIL;
  401bb8:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  401bba:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_read_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_read_blocks(false)) {
  401bbc:	4b04      	ldr	r3, [pc, #16]	; (401bd0 <sd_mmc_mem_2_ram+0x38>)
  401bbe:	4798      	blx	r3
		return CTRL_FAIL;
  401bc0:	3000      	adds	r0, #0
  401bc2:	bf18      	it	ne
  401bc4:	2001      	movne	r0, #1
  401bc6:	bd10      	pop	{r4, pc}
  401bc8:	00401805 	.word	0x00401805
  401bcc:	004018ed 	.word	0x004018ed
  401bd0:	00401915 	.word	0x00401915

00401bd4 <sd_mmc_mem_2_ram_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_mem_2_ram_0(uint32_t addr, void *ram)
{
  401bd4:	b508      	push	{r3, lr}
  401bd6:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(0, addr, ram);
  401bd8:	4b02      	ldr	r3, [pc, #8]	; (401be4 <sd_mmc_mem_2_ram_0+0x10>)
  401bda:	4601      	mov	r1, r0
  401bdc:	2000      	movs	r0, #0
  401bde:	4798      	blx	r3
}
  401be0:	bd08      	pop	{r3, pc}
  401be2:	bf00      	nop
  401be4:	00401b99 	.word	0x00401b99

00401be8 <sd_mmc_mem_2_ram_1>:

Ctrl_status sd_mmc_mem_2_ram_1(uint32_t addr, void *ram)
{
  401be8:	b508      	push	{r3, lr}
  401bea:	460a      	mov	r2, r1
	return sd_mmc_mem_2_ram(1, addr, ram);
  401bec:	4b02      	ldr	r3, [pc, #8]	; (401bf8 <sd_mmc_mem_2_ram_1+0x10>)
  401bee:	4601      	mov	r1, r0
  401bf0:	2001      	movs	r0, #1
  401bf2:	4798      	blx	r3
}
  401bf4:	bd08      	pop	{r3, pc}
  401bf6:	bf00      	nop
  401bf8:	00401b99 	.word	0x00401b99

00401bfc <sd_mmc_ram_2_mem>:

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401bfc:	b510      	push	{r4, lr}
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401bfe:	4b0b      	ldr	r3, [pc, #44]	; (401c2c <sd_mmc_ram_2_mem+0x30>)
{
	return sd_mmc_mem_2_ram(1, addr, ram);
}

Ctrl_status sd_mmc_ram_2_mem(uint8_t slot, uint32_t addr, const void *ram)
{
  401c00:	4614      	mov	r4, r2
	switch (sd_mmc_init_write_blocks(slot, addr, 1)) {
  401c02:	2201      	movs	r2, #1
  401c04:	4798      	blx	r3
  401c06:	b120      	cbz	r0, 401c12 <sd_mmc_ram_2_mem+0x16>
  401c08:	2802      	cmp	r0, #2
	case SD_MMC_OK:
		break;
	case SD_MMC_ERR_NO_CARD:
		return CTRL_NO_PRESENT;
	default:
		return CTRL_FAIL;
  401c0a:	bf0c      	ite	eq
  401c0c:	2002      	moveq	r0, #2
  401c0e:	2001      	movne	r0, #1
  401c10:	bd10      	pop	{r4, pc}
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
  401c12:	4620      	mov	r0, r4
  401c14:	2101      	movs	r1, #1
  401c16:	4b06      	ldr	r3, [pc, #24]	; (401c30 <sd_mmc_ram_2_mem+0x34>)
  401c18:	4798      	blx	r3
  401c1a:	b108      	cbz	r0, 401c20 <sd_mmc_ram_2_mem+0x24>
		return CTRL_FAIL;
  401c1c:	2001      	movs	r0, #1
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
		return CTRL_FAIL;
	}
	return CTRL_GOOD;
}
  401c1e:	bd10      	pop	{r4, pc}
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_start_write_blocks(ram, 1)) {
		return CTRL_FAIL;
	}
	if (SD_MMC_OK != sd_mmc_wait_end_of_write_blocks(false)) {
  401c20:	4b04      	ldr	r3, [pc, #16]	; (401c34 <sd_mmc_ram_2_mem+0x38>)
  401c22:	4798      	blx	r3
		return CTRL_FAIL;
  401c24:	3000      	adds	r0, #0
  401c26:	bf18      	it	ne
  401c28:	2001      	movne	r0, #1
  401c2a:	bd10      	pop	{r4, pc}
  401c2c:	00401979 	.word	0x00401979
  401c30:	00401a19 	.word	0x00401a19
  401c34:	00401a41 	.word	0x00401a41

00401c38 <sd_mmc_ram_2_mem_0>:
	}
	return CTRL_GOOD;
}

Ctrl_status sd_mmc_ram_2_mem_0(uint32_t addr, const void *ram)
{
  401c38:	b508      	push	{r3, lr}
  401c3a:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(0, addr, ram);
  401c3c:	4b02      	ldr	r3, [pc, #8]	; (401c48 <sd_mmc_ram_2_mem_0+0x10>)
  401c3e:	4601      	mov	r1, r0
  401c40:	2000      	movs	r0, #0
  401c42:	4798      	blx	r3
}
  401c44:	bd08      	pop	{r3, pc}
  401c46:	bf00      	nop
  401c48:	00401bfd 	.word	0x00401bfd

00401c4c <sd_mmc_ram_2_mem_1>:

Ctrl_status sd_mmc_ram_2_mem_1(uint32_t addr, const void *ram)
{
  401c4c:	b508      	push	{r3, lr}
  401c4e:	460a      	mov	r2, r1
	return sd_mmc_ram_2_mem(1, addr, ram);
  401c50:	4b02      	ldr	r3, [pc, #8]	; (401c5c <sd_mmc_ram_2_mem_1+0x10>)
  401c52:	4601      	mov	r1, r0
  401c54:	2001      	movs	r0, #1
  401c56:	4798      	blx	r3
}
  401c58:	bd08      	pop	{r3, pc}
  401c5a:	bf00      	nop
  401c5c:	00401bfd 	.word	0x00401bfd

00401c60 <mem_test_unit_ready>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c60:	2801      	cmp	r0, #1
  return LUN_ID_0;
}


Ctrl_status mem_test_unit_ready(U8 lun)
{
  401c62:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c64:	d901      	bls.n	401c6a <mem_test_unit_ready+0xa>
  401c66:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401c68:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].test_unit_ready() :
  401c6a:	0140      	lsls	r0, r0, #5
  401c6c:	4b01      	ldr	r3, [pc, #4]	; (401c74 <mem_test_unit_ready+0x14>)
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c6e:	581b      	ldr	r3, [r3, r0]
  401c70:	4798      	blx	r3
  401c72:	bd08      	pop	{r3, pc}
  401c74:	00406afc 	.word	0x00406afc

00401c78 <mem_read_capacity>:
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c78:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status mem_read_capacity(U8 lun, U32 *u32_nb_sector)
{
  401c7a:	b508      	push	{r3, lr}
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c7c:	d901      	bls.n	401c82 <mem_read_capacity+0xa>
  401c7e:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return status;
}
  401c80:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
#if MAX_LUN
         (lun < MAX_LUN) ? lun_desc[lun].read_capacity(u32_nb_sector) :
  401c82:	4b03      	ldr	r3, [pc, #12]	; (401c90 <mem_read_capacity+0x18>)
  401c84:	eb03 1340 	add.w	r3, r3, r0, lsl #5
{
  Ctrl_status status;

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  status =
  401c88:	4608      	mov	r0, r1
  401c8a:	685b      	ldr	r3, [r3, #4]
  401c8c:	4798      	blx	r3
  401c8e:	bd08      	pop	{r3, pc}
  401c90:	00406afc 	.word	0x00406afc

00401c94 <mem_sector_size>:
#endif

  Ctrl_access_unlock();

  return sector_size;
}
  401c94:	2801      	cmp	r0, #1
  401c96:	bf8c      	ite	hi
  401c98:	2000      	movhi	r0, #0
  401c9a:	2001      	movls	r0, #1
  401c9c:	4770      	bx	lr
  401c9e:	bf00      	nop

00401ca0 <mem_wr_protect>:

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401ca0:	2801      	cmp	r0, #1

  return unloaded;
}

bool mem_wr_protect(U8 lun)
{
  401ca2:	b508      	push	{r3, lr}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401ca4:	d901      	bls.n	401caa <mem_wr_protect+0xa>
  401ca6:	2001      	movs	r0, #1
#endif

  Ctrl_access_unlock();

  return wr_protect;
}
  401ca8:	bd08      	pop	{r3, pc}

  if (!Ctrl_access_lock()) return true;

  wr_protect =
#if MAX_LUN
             (lun < MAX_LUN) ? lun_desc[lun].wr_protect() :
  401caa:	4b03      	ldr	r3, [pc, #12]	; (401cb8 <mem_wr_protect+0x18>)
  401cac:	eb03 1040 	add.w	r0, r3, r0, lsl #5
  401cb0:	68c3      	ldr	r3, [r0, #12]
  401cb2:	4798      	blx	r3
  401cb4:	bd08      	pop	{r3, pc}
  401cb6:	bf00      	nop
  401cb8:	00406afc 	.word	0x00406afc

00401cbc <memory_2_ram>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401cbc:	2801      	cmp	r0, #1
 */
//! @{


Ctrl_status memory_2_ram(U8 lun, U32 addr, void *ram)
{
  401cbe:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401cc0:	d901      	bls.n	401cc6 <memory_2_ram+0xa>
  401cc2:	2001      	movs	r0, #1
  memory_stop_read_action();

  Ctrl_access_unlock();

  return status;
}
  401cc4:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].mem_2_ram(addr, ram) :
  401cc6:	4b04      	ldr	r3, [pc, #16]	; (401cd8 <memory_2_ram+0x1c>)
  401cc8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_read_action(1);
  status =
  401ccc:	4608      	mov	r0, r1
  401cce:	695b      	ldr	r3, [r3, #20]
  401cd0:	4611      	mov	r1, r2
  401cd2:	4798      	blx	r3
  401cd4:	bd08      	pop	{r3, pc}
  401cd6:	bf00      	nop
  401cd8:	00406afc 	.word	0x00406afc

00401cdc <ram_2_memory>:
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401cdc:	2801      	cmp	r0, #1
  return status;
}


Ctrl_status ram_2_memory(U8 lun, U32 addr, const void *ram)
{
  401cde:	b508      	push	{r3, lr}
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401ce0:	d901      	bls.n	401ce6 <ram_2_memory+0xa>
  401ce2:	2001      	movs	r0, #1
  memory_stop_write_action();

  Ctrl_access_unlock();

  return status;
}
  401ce4:	bd08      	pop	{r3, pc}
  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
#if MAX_LUN
           (lun < MAX_LUN) ? lun_desc[lun].ram_2_mem(addr, ram) :
  401ce6:	4b04      	ldr	r3, [pc, #16]	; (401cf8 <ram_2_memory+0x1c>)
  401ce8:	eb03 1340 	add.w	r3, r3, r0, lsl #5
#endif

  if (!Ctrl_access_lock()) return CTRL_FAIL;

  memory_start_write_action(1);
  status =
  401cec:	4608      	mov	r0, r1
  401cee:	699b      	ldr	r3, [r3, #24]
  401cf0:	4611      	mov	r1, r2
  401cf2:	4798      	blx	r3
  401cf4:	bd08      	pop	{r3, pc}
  401cf6:	bf00      	nop
  401cf8:	00406afc 	.word	0x00406afc

00401cfc <hsmci_send_cmd_execute>:
 *
 * \return true if success, otherwise false
 */
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
  401cfc:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401d00:	f001 033f 	and.w	r3, r1, #63	; 0x3f
	if (cmd & SDMMC_RESP_PRESENT) {
  401d04:	05cf      	lsls	r7, r1, #23
static bool hsmci_send_cmd_execute(uint32_t cmdr, sdmmc_cmd_def_t cmd,
		uint32_t arg)
{
	uint32_t sr;

	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
  401d06:	ea43 0000 	orr.w	r0, r3, r0
	if (cmd & SDMMC_RESP_PRESENT) {
  401d0a:	d503      	bpl.n	401d14 <hsmci_send_cmd_execute+0x18>
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
  401d0c:	050e      	lsls	r6, r1, #20
  401d0e:	d530      	bpl.n	401d72 <hsmci_send_cmd_execute+0x76>
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
  401d10:	f440 5084 	orr.w	r0, r0, #4224	; 0x1080
	if (cmd & SDMMC_CMD_OPENDRAIN) {
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401d14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
		}
	}
	if (cmd & SDMMC_CMD_OPENDRAIN) {
  401d18:	044c      	lsls	r4, r1, #17
		cmdr |= HSMCI_CMDR_OPDCMD_OPENDRAIN;
  401d1a:	bf48      	it	mi
  401d1c:	f440 6000 	orrmi.w	r0, r0, #2048	; 0x800
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
  401d20:	611a      	str	r2, [r3, #16]
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401d22:	461d      	mov	r5, r3
  401d24:	f401 5480 	and.w	r4, r1, #4096	; 0x1000
	}

	// Write argument
	HSMCI->HSMCI_ARGR = arg;
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;
  401d28:	6158      	str	r0, [r3, #20]
  401d2a:	e004      	b.n	401d36 <hsmci_send_cmd_execute+0x3a>

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
		if (cmd & SDMMC_RESP_CRC) {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401d2c:	f413 0f1f 	tst.w	r3, #10420224	; 0x9f0000
  401d30:	d12c      	bne.n	401d8c <hsmci_send_cmd_execute+0x90>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));
  401d32:	07da      	lsls	r2, r3, #31
  401d34:	d424      	bmi.n	401d80 <hsmci_send_cmd_execute+0x84>
	// Write and start command
	HSMCI->HSMCI_CMDR = cmdr;

	// Wait end of command
	do {
		sr = HSMCI->HSMCI_SR;
  401d36:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
  401d3a:	6c2b      	ldr	r3, [r5, #64]	; 0x40
		if (cmd & SDMMC_RESP_CRC) {
  401d3c:	2c00      	cmp	r4, #0
  401d3e:	d1f5      	bne.n	401d2c <hsmci_send_cmd_execute+0x30>
						__func__, cmd, sr);
				hsmci_reset();
				return false;
			}
		} else {
			if (sr & (HSMCI_SR_CSTOE | HSMCI_SR_RTOE
  401d40:	f413 0f1b 	tst.w	r3, #10158080	; 0x9b0000
  401d44:	d0f5      	beq.n	401d32 <hsmci_send_cmd_execute+0x36>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d46:	f8d2 c004 	ldr.w	ip, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d4a:	6897      	ldr	r7, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d4c:	68d6      	ldr	r6, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d4e:	69d5      	ldr	r5, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d50:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d52:	f04f 0880 	mov.w	r8, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d56:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d58:	f8c2 8000 	str.w	r8, [r2]
	HSMCI->HSMCI_MR = mr;
  401d5c:	f8c2 c004 	str.w	ip, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401d60:	6097      	str	r7, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401d62:	60d6      	str	r6, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401d64:	61d5      	str	r5, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401d66:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d68:	6013      	str	r3, [r2, #0]
					| HSMCI_SR_RENDE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401d6a:	4620      	mov	r0, r4
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401d6c:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401d70:	4770      	bx	lr
	cmdr |= HSMCI_CMDR_CMDNB(cmd) | HSMCI_CMDR_SPCMD_STD;
	if (cmd & SDMMC_RESP_PRESENT) {
		cmdr |= HSMCI_CMDR_MAXLAT;
		if (cmd & SDMMC_RESP_136) {
			cmdr |= HSMCI_CMDR_RSPTYP_136_BIT;
		} else if (cmd & SDMMC_RESP_BUSY) {
  401d72:	048d      	lsls	r5, r1, #18
			cmdr |= HSMCI_CMDR_RSPTYP_R1B;
  401d74:	bf4c      	ite	mi
  401d76:	f440 5086 	orrmi.w	r0, r0, #4288	; 0x10c0
		} else {
			cmdr |= HSMCI_CMDR_RSPTYP_48_BIT;
  401d7a:	f440 5082 	orrpl.w	r0, r0, #4160	; 0x1040
  401d7e:	e7c9      	b.n	401d14 <hsmci_send_cmd_execute+0x18>
				return false;
			}
		}
	} while (!(sr & HSMCI_SR_CMDRDY));

	if (cmd & SDMMC_RESP_BUSY) {
  401d80:	048b      	lsls	r3, r1, #18
  401d82:	d415      	bmi.n	401db0 <hsmci_send_cmd_execute+0xb4>
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
  401d84:	2001      	movs	r0, #1
}
  401d86:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401d8a:	4770      	bx	lr
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d8c:	2080      	movs	r0, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401d8e:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401d90:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401d92:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401d94:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401d96:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401d98:	6010      	str	r0, [r2, #0]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401d9a:	2305      	movs	r3, #5
					| HSMCI_SR_RENDE | HSMCI_SR_RCRCE
					| HSMCI_SR_RDIRE | HSMCI_SR_RINDE)) {
				hsmci_debug("%s: CMD 0x%08x sr 0x%08x error\n\r",
						__func__, cmd, sr);
				hsmci_reset();
				return false;
  401d9c:	2000      	movs	r0, #0
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
	HSMCI->HSMCI_MR = mr;
  401d9e:	6057      	str	r7, [r2, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401da0:	6096      	str	r6, [r2, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401da2:	60d5      	str	r5, [r2, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401da4:	61d4      	str	r4, [r2, #28]
	HSMCI->HSMCI_CFG = cfg;
  401da6:	6551      	str	r1, [r2, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401da8:	6013      	str	r3, [r2, #0]
		if (!hsmci_wait_busy()) {
			return false;
		}
	}
	return true;
}
  401daa:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
  401dae:	4770      	bx	lr
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401db0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401db4:	4619      	mov	r1, r3
  401db6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
  401db8:	f04f 30ff 	mov.w	r0, #4294967295
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401dbc:	f003 0330 	and.w	r3, r3, #48	; 0x30
  401dc0:	2b20      	cmp	r3, #32
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401dc2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
		if (busy_wait-- == 0) {
			hsmci_debug("%s: timeout\n\r", __func__);
			hsmci_reset();
			return false;
		}
	} while (!((sr & HSMCI_SR_NOTBUSY) && ((sr & HSMCI_SR_DTIP) == 0)));
  401dc6:	d0dd      	beq.n	401d84 <hsmci_send_cmd_execute+0x88>
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
		if (busy_wait-- == 0) {
  401dc8:	3801      	subs	r0, #1
{
	uint32_t busy_wait = 0xFFFFFFFF;
	uint32_t sr;

	do {
		sr = HSMCI->HSMCI_SR;
  401dca:	6c0b      	ldr	r3, [r1, #64]	; 0x40
		if (busy_wait-- == 0) {
  401dcc:	d1f6      	bne.n	401dbc <hsmci_send_cmd_execute+0xc0>
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401dce:	f04f 0c80 	mov.w	ip, #128	; 0x80
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401dd2:	6857      	ldr	r7, [r2, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401dd4:	6896      	ldr	r6, [r2, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401dd6:	68d5      	ldr	r5, [r2, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401dd8:	69d4      	ldr	r4, [r2, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401dda:	6d51      	ldr	r1, [r2, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401ddc:	f8c2 c000 	str.w	ip, [r2]
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401de0:	2305      	movs	r3, #5
  401de2:	e7dc      	b.n	401d9e <hsmci_send_cmd_execute+0xa2>

00401de4 <hsmci_init>:

//-------------------------------------------------------------------
//--------------------- PUBLIC FUNCTIONS ----------------------------

void hsmci_init(void)
{
  401de4:	b510      	push	{r4, lr}
	pmc_enable_periph_clk(ID_HSMCI);
  401de6:	4b08      	ldr	r3, [pc, #32]	; (401e08 <hsmci_init+0x24>)
  401de8:	2012      	movs	r0, #18
  401dea:	4798      	blx	r3
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401dec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401df0:	2272      	movs	r2, #114	; 0x72
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401df2:	2411      	movs	r4, #17
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401df4:	f44f 60e0 	mov.w	r0, #1792	; 0x700

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401df8:	2105      	movs	r1, #5
	// Enable clock for DMA controller
	pmc_enable_periph_clk(ID_DMAC);
#endif

	// Set the Data Timeout Register to 2 Mega Cycles
	HSMCI->HSMCI_DTOR = HSMCI_DTOR_DTOMUL_1048576 | HSMCI_DTOR_DTOCYC(2);
  401dfa:	609a      	str	r2, [r3, #8]
	// Set Completion Signal Timeout to 2 Mega Cycles
	HSMCI->HSMCI_CSTOR = HSMCI_CSTOR_CSTOMUL_1048576 | HSMCI_CSTOR_CSTOCYC(2);
  401dfc:	61da      	str	r2, [r3, #28]
	// Set Configuration Register
	HSMCI->HSMCI_CFG = HSMCI_CFG_FIFOMODE | HSMCI_CFG_FERRCTRL;
  401dfe:	655c      	str	r4, [r3, #84]	; 0x54
	// Set power saving to maximum value
	HSMCI->HSMCI_MR = HSMCI_MR_PWSDIV_Msk;
  401e00:	6058      	str	r0, [r3, #4]

	// Enable the HSMCI and the Power Saving
	HSMCI->HSMCI_CR = HSMCI_CR_MCIEN | HSMCI_CR_PWSEN;
  401e02:	6019      	str	r1, [r3, #0]
  401e04:	bd10      	pop	{r4, pc}
  401e06:	bf00      	nop
  401e08:	00405649 	.word	0x00405649

00401e0c <hsmci_get_bus_width>:
}

uint8_t hsmci_get_bus_width(uint8_t slot)
{
	switch (slot) {
  401e0c:	2800      	cmp	r0, #0
		return SD_MMC_HSMCI_SLOT_1_SIZE;
#endif
	default:
		return 0; // Slot number wrong
	}
}
  401e0e:	bf0c      	ite	eq
  401e10:	2004      	moveq	r0, #4
  401e12:	2000      	movne	r0, #0
  401e14:	4770      	bx	lr
  401e16:	bf00      	nop

00401e18 <hsmci_is_high_speed_capable>:

bool hsmci_is_high_speed_capable(void)
{
	return true;
}
  401e18:	2001      	movs	r0, #1
  401e1a:	4770      	bx	lr

00401e1c <hsmci_select_device>:
void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
  401e1c:	b33b      	cbz	r3, 401e6e <hsmci_select_device+0x52>
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401e1e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e22:	0049      	lsls	r1, r1, #1
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
  401e24:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401e26:	f440 7080 	orr.w	r0, r0, #256	; 0x100
  401e2a:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e2c:	4b1a      	ldr	r3, [pc, #104]	; (401e98 <hsmci_select_device+0x7c>)
  401e2e:	4299      	cmp	r1, r3
  401e30:	d827      	bhi.n	401e82 <hsmci_select_device+0x66>
		clkdiv = mck / (2 * speed);
  401e32:	3301      	adds	r3, #1
		rest = mck % (2 * speed);
  401e34:	4618      	mov	r0, r3
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
		clkdiv = mck / (2 * speed);
  401e36:	fbb3 f3f1 	udiv	r3, r3, r1
		rest = mck % (2 * speed);
  401e3a:	fb01 f103 	mul.w	r1, r1, r3
  401e3e:	1a40      	subs	r0, r0, r1
		if (rest > 0) {
  401e40:	bb08      	cbnz	r0, 401e86 <hsmci_select_device+0x6a>
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
		}
		if (clkdiv > 0) {
  401e42:	bb0b      	cbnz	r3, 401e88 <hsmci_select_device+0x6c>
  401e44:	4619      	mov	r1, r3
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401e46:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401e4a:	2a04      	cmp	r2, #4
			clkdiv -= 1;
		}
	} else {
		clkdiv = 0;
	}
	HSMCI->HSMCI_MR &= ~HSMCI_MR_CLKDIV_Msk;
  401e4c:	6858      	ldr	r0, [r3, #4]
  401e4e:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
  401e52:	6058      	str	r0, [r3, #4]
	HSMCI->HSMCI_MR |= HSMCI_MR_CLKDIV(clkdiv);
  401e54:	6858      	ldr	r0, [r3, #4]
  401e56:	ea41 0100 	orr.w	r1, r1, r0
  401e5a:	6059      	str	r1, [r3, #4]
#endif
	default:
		Assert(false); // Slot number wrong
	}

	switch (bus_width) {
  401e5c:	d017      	beq.n	401e8e <hsmci_select_device+0x72>
  401e5e:	2a08      	cmp	r2, #8
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e60:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
}

void hsmci_select_device(uint8_t slot, uint32_t clock, uint8_t bus_width, bool high_speed)
{
	uint32_t hsmci_slot = HSMCI_SDCR_SDCSEL_SLOTA;
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
  401e64:	bf0c      	ite	eq
  401e66:	22c0      	moveq	r2, #192	; 0xc0
  401e68:	2200      	movne	r2, #0
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e6a:	60da      	str	r2, [r3, #12]
  401e6c:	4770      	bx	lr
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401e6e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e72:	0049      	lsls	r1, r1, #1
	uint32_t hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;

	if (high_speed) {
		HSMCI->HSMCI_CFG |= HSMCI_CFG_HSMODE;
	} else {
		HSMCI->HSMCI_CFG &= ~HSMCI_CFG_HSMODE;
  401e74:	6d58      	ldr	r0, [r3, #84]	; 0x54
  401e76:	f420 7080 	bic.w	r0, r0, #256	; 0x100
  401e7a:	6558      	str	r0, [r3, #84]	; 0x54
#else
	uint32_t clkdiv = 0;
	uint32_t rest = 0;

	// Speed = MCK clock / (2 * (CLKDIV + 1))
	if ((speed * 2) < mck) {
  401e7c:	4b06      	ldr	r3, [pc, #24]	; (401e98 <hsmci_select_device+0x7c>)
  401e7e:	4299      	cmp	r1, r3
  401e80:	d9d7      	bls.n	401e32 <hsmci_select_device+0x16>
  401e82:	2100      	movs	r1, #0
  401e84:	e7df      	b.n	401e46 <hsmci_select_device+0x2a>
		clkdiv = mck / (2 * speed);
		rest = mck % (2 * speed);
		if (rest > 0) {
			// Ensure that the card speed not be higher than expected.
			clkdiv++;
  401e86:	3301      	adds	r3, #1
		}
		if (clkdiv > 0) {
			clkdiv -= 1;
  401e88:	3b01      	subs	r3, #1
  401e8a:	b2d9      	uxtb	r1, r3
  401e8c:	e7db      	b.n	401e46 <hsmci_select_device+0x2a>
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e8e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	case 1:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_1;
		break;

	case 4:
		hsmci_bus_width = HSMCI_SDCR_SDCBUS_4;
  401e92:	2280      	movs	r2, #128	; 0x80
		break;

	default:
		Assert(false); // Bus width wrong
	}
	HSMCI->HSMCI_SDCR = hsmci_slot | hsmci_bus_width;
  401e94:	60da      	str	r2, [r3, #12]
  401e96:	4770      	bx	lr
  401e98:	07270dff 	.word	0x07270dff

00401e9c <hsmci_deselect_device>:
}

void hsmci_deselect_device(uint8_t slot)
{
  401e9c:	4770      	bx	lr
  401e9e:	bf00      	nop

00401ea0 <hsmci_send_clock>:
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ea0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401ea4:	2000      	movs	r0, #0
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ea6:	685a      	ldr	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401ea8:	f44f 6110 	mov.w	r1, #2304	; 0x900
}

void hsmci_send_clock(void)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401eac:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401eb0:	605a      	str	r2, [r3, #4]
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
  401eb2:	6118      	str	r0, [r3, #16]
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401eb4:	461a      	mov	r2, r3
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
	// Write argument
	HSMCI->HSMCI_ARGR = 0;
	// Write and start initialization command
	HSMCI->HSMCI_CMDR = HSMCI_CMDR_RSPTYP_NORESP
  401eb6:	6159      	str	r1, [r3, #20]
			| HSMCI_CMDR_SPCMD_INIT
			| HSMCI_CMDR_OPDCMD_OPENDRAIN;
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
  401eb8:	6c13      	ldr	r3, [r2, #64]	; 0x40
  401eba:	07db      	lsls	r3, r3, #31
  401ebc:	d5fc      	bpl.n	401eb8 <hsmci_send_clock+0x18>
}
  401ebe:	4770      	bx	lr

00401ec0 <hsmci_send_cmd>:

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401ec0:	b570      	push	{r4, r5, r6, lr}
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ec2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401ec6:	2400      	movs	r4, #0
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ec8:	685a      	ldr	r2, [r3, #4]
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401eca:	4d07      	ldr	r5, [pc, #28]	; (401ee8 <hsmci_send_cmd+0x28>)
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
	// Configure command
	HSMCI->HSMCI_MR &= ~(HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF | HSMCI_MR_FBYTE);
  401ecc:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
  401ed0:	605a      	str	r2, [r3, #4]
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401ed2:	685e      	ldr	r6, [r3, #4]
  401ed4:	f426 4600 	bic.w	r6, r6, #32768	; 0x8000
	// Wait end of initialization command
	while (!(HSMCI->HSMCI_SR & HSMCI_SR_CMDRDY));
}

bool hsmci_send_cmd(sdmmc_cmd_def_t cmd, uint32_t arg)
{
  401ed8:	460a      	mov	r2, r1
	// Disable DMA for HSMCI
	HSMCI->HSMCI_DMA = 0;
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401eda:	605e      	str	r6, [r3, #4]
#endif
	HSMCI->HSMCI_BLKR = 0;
	return hsmci_send_cmd_execute(0, cmd, arg);
  401edc:	4601      	mov	r1, r0
#endif
#ifdef HSMCI_MR_PDCMODE
	// Disable PDC for HSMCI
	HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
#endif
	HSMCI->HSMCI_BLKR = 0;
  401ede:	619c      	str	r4, [r3, #24]
	return hsmci_send_cmd_execute(0, cmd, arg);
  401ee0:	4620      	mov	r0, r4
  401ee2:	47a8      	blx	r5
}
  401ee4:	bd70      	pop	{r4, r5, r6, pc}
  401ee6:	bf00      	nop
  401ee8:	00401cfd 	.word	0x00401cfd

00401eec <hsmci_get_response>:

uint32_t hsmci_get_response(void)
{
	return HSMCI->HSMCI_RSPR[0];
  401eec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  401ef0:	6a18      	ldr	r0, [r3, #32]
}
  401ef2:	4770      	bx	lr

00401ef4 <hsmci_get_response_128>:

void hsmci_get_response_128(uint8_t* response)
{
  401ef4:	b430      	push	{r4, r5}
  401ef6:	f100 0510 	add.w	r5, r0, #16
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
  401efa:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401efe:	6a23      	ldr	r3, [r4, #32]
		response++;
		*response = (response_32 >> 16) & 0xFF;
		response++;
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
  401f00:	70c3      	strb	r3, [r0, #3]
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401f02:	0e19      	lsrs	r1, r3, #24
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401f04:	0c1a      	lsrs	r2, r3, #16
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401f06:	0a1b      	lsrs	r3, r3, #8
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
		response_32 = HSMCI->HSMCI_RSPR[0];
		*response = (response_32 >> 24) & 0xFF;
  401f08:	7001      	strb	r1, [r0, #0]
		response++;
		*response = (response_32 >> 16) & 0xFF;
  401f0a:	7042      	strb	r2, [r0, #1]
		response++;
		*response = (response_32 >>  8) & 0xFF;
  401f0c:	7083      	strb	r3, [r0, #2]
  401f0e:	3004      	adds	r0, #4

void hsmci_get_response_128(uint8_t* response)
{
	uint32_t response_32;

	for (uint8_t i = 0; i < 4; i++) {
  401f10:	42a8      	cmp	r0, r5
  401f12:	d1f4      	bne.n	401efe <hsmci_get_response_128+0xa>
		*response = (response_32 >>  8) & 0xFF;
		response++;
		*response = (response_32 >>  0) & 0xFF;
		response++;
	}
}
  401f14:	bc30      	pop	{r4, r5}
  401f16:	4770      	bx	lr

00401f18 <hsmci_adtc_start>:

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401f18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  401f1a:	460e      	mov	r6, r1
  401f1c:	f89d 5018 	ldrb.w	r5, [sp, #24]
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401f20:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		response++;
	}
}

bool hsmci_adtc_start(sdmmc_cmd_def_t cmd, uint32_t arg, uint16_t block_size, uint16_t nb_block, bool access_block)
{
  401f24:	4604      	mov	r4, r0
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401f26:	6848      	ldr	r0, [r1, #4]
		HSMCI->HSMCI_DMA = 0;
	}
#endif

#ifdef HSMCI_MR_PDCMODE
	if (access_block) {
  401f28:	b34d      	cbz	r5, 401f7e <hsmci_adtc_start+0x66>
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
  401f2a:	f440 4000 	orr.w	r0, r0, #32768	; 0x8000
  401f2e:	6048      	str	r0, [r1, #4]
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401f30:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
	// Force byte transfer if needed
	if (block_size & 0x3) {
  401f34:	0797      	lsls	r7, r2, #30
#endif

	// Enabling Read/Write Proof allows to stop the HSMCI Clock during
	// read/write  access if the internal FIFO is full.
	// This will guarantee data integrity, not bandwidth.
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
  401f36:	6841      	ldr	r1, [r0, #4]
  401f38:	f441 51c0 	orr.w	r1, r1, #6144	; 0x1800
  401f3c:	6041      	str	r1, [r0, #4]
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  401f3e:	6841      	ldr	r1, [r0, #4]
  401f40:	bf14      	ite	ne
  401f42:	f441 5100 	orrne.w	r1, r1, #8192	; 0x2000
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401f46:	f421 5100 	biceq.w	r1, r1, #8192	; 0x2000
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401f4a:	f414 4f00 	tst.w	r4, #32768	; 0x8000
	HSMCI->HSMCI_MR |= HSMCI_MR_WRPROOF | HSMCI_MR_RDPROOF;
	// Force byte transfer if needed
	if (block_size & 0x3) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  401f4e:	6041      	str	r1, [r0, #4]
	}

	if (cmd & SDMMC_CMD_WRITE) {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
  401f50:	bf0c      	ite	eq
  401f52:	f44f 20a0 	moveq.w	r0, #327680	; 0x50000
  401f56:	f44f 3080 	movne.w	r0, #65536	; 0x10000
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401f5a:	03e5      	lsls	r5, r4, #15
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401f5c:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_WRITE;
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
  401f60:	d421      	bmi.n	401fa6 <hsmci_adtc_start+0x8e>
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
  401f62:	ea43 4502 	orr.w	r5, r3, r2, lsl #16
  401f66:	618d      	str	r5, [r1, #24]
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
  401f68:	03a1      	lsls	r1, r4, #14
  401f6a:	d40c      	bmi.n	401f86 <hsmci_adtc_start+0x6e>
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
  401f6c:	0367      	lsls	r7, r4, #13
  401f6e:	d420      	bmi.n	401fb2 <hsmci_adtc_start+0x9a>
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
		} else if (cmd & SDMMC_CMD_SINGLE_BLOCK) {
  401f70:	0325      	lsls	r5, r4, #12
  401f72:	d40a      	bmi.n	401f8a <hsmci_adtc_start+0x72>
			cmdr |= HSMCI_CMDR_TRTYP_SINGLE;
		} else if (cmd & SDMMC_CMD_MULTI_BLOCK) {
  401f74:	02e1      	lsls	r1, r4, #11
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
  401f76:	bf48      	it	mi
  401f78:	f440 2000 	orrmi.w	r0, r0, #524288	; 0x80000
  401f7c:	e005      	b.n	401f8a <hsmci_adtc_start+0x72>
	if (access_block) {
		// Enable PDC for HSMCI
		HSMCI->HSMCI_MR |= HSMCI_MR_PDCMODE;
	} else {
		// Disable PDC for HSMCI
		HSMCI->HSMCI_MR &= ~HSMCI_MR_PDCMODE;
  401f7e:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
  401f82:	6048      	str	r0, [r1, #4]
  401f84:	e7d4      	b.n	401f30 <hsmci_adtc_start+0x18>
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
	} else {
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
  401f86:	f440 1020 	orr.w	r0, r0, #2621440	; 0x280000
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401f8a:	490b      	ldr	r1, [pc, #44]	; (401fb8 <hsmci_adtc_start+0xa0>)
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401f8c:	f8df e034 	ldr.w	lr, [pc, #52]	; 401fc4 <hsmci_adtc_start+0xac>
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401f90:	4f0a      	ldr	r7, [pc, #40]	; (401fbc <hsmci_adtc_start+0xa4>)
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
  401f92:	800a      	strh	r2, [r1, #0]
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401f94:	4d0a      	ldr	r5, [pc, #40]	; (401fc0 <hsmci_adtc_start+0xa8>)
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;
  401f96:	803b      	strh	r3, [r7, #0]

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401f98:	4621      	mov	r1, r4
  401f9a:	4632      	mov	r2, r6
			cmdr |= HSMCI_CMDR_TRTYP_MULTIPLE;
		} else {
			Assert(false); // Incorrect flags
		}
	}
	hsmci_transfert_pos = 0;
  401f9c:	2400      	movs	r4, #0
  401f9e:	f8ce 4000 	str.w	r4, [lr]
	hsmci_block_size = block_size;
	hsmci_nb_block = nb_block;

	return hsmci_send_cmd_execute(cmdr, cmd, arg);
  401fa2:	47a8      	blx	r5
}
  401fa4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401fa6:	f3c2 0508 	ubfx	r5, r2, #0, #9
	} else {
		cmdr = HSMCI_CMDR_TRCMD_START_DATA | HSMCI_CMDR_TRDIR_READ;
	}

	if (cmd & SDMMC_CMD_SDIO_BYTE) {
			cmdr |= HSMCI_CMDR_TRTYP_BYTE;
  401faa:	f440 1000 	orr.w	r0, r0, #2097152	; 0x200000
			// Value 0 corresponds to a 512-byte transfer
			HSMCI->HSMCI_BLKR = ((block_size % 512) << HSMCI_BLKR_BCNT_Pos);
  401fae:	618d      	str	r5, [r1, #24]
  401fb0:	e7eb      	b.n	401f8a <hsmci_adtc_start+0x72>
		HSMCI->HSMCI_BLKR = (block_size << HSMCI_BLKR_BLKLEN_Pos) |
				(nb_block << HSMCI_BLKR_BCNT_Pos);
		if (cmd & SDMMC_CMD_SDIO_BLOCK) {
			cmdr |= HSMCI_CMDR_TRTYP_BLOCK;
		} else if (cmd & SDMMC_CMD_STREAM) {
			cmdr |= HSMCI_CMDR_TRTYP_STREAM;
  401fb2:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000
  401fb6:	e7e8      	b.n	401f8a <hsmci_adtc_start+0x72>
  401fb8:	20000f5c 	.word	0x20000f5c
  401fbc:	20000f5e 	.word	0x20000f5e
  401fc0:	00401cfd 	.word	0x00401cfd
  401fc4:	20000f60 	.word	0x20000f60

00401fc8 <hsmci_read_word>:
{
	return hsmci_send_cmd_execute(HSMCI_CMDR_TRCMD_STOP_DATA, cmd, arg);
}

bool hsmci_read_word(uint32_t* value)
{
  401fc8:	b4f0      	push	{r4, r5, r6, r7}

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401fca:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
  401fce:	e001      	b.n	401fd4 <hsmci_read_word+0xc>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));
  401fd0:	0792      	lsls	r2, r2, #30
  401fd2:	d417      	bmi.n	402004 <hsmci_read_word+0x3c>

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401fd4:	6c22      	ldr	r2, [r4, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401fd6:	4b21      	ldr	r3, [pc, #132]	; (40205c <hsmci_read_word+0x94>)
  401fd8:	4013      	ands	r3, r2

	Assert(((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos);

	// Wait data available
	do {
		sr = HSMCI->HSMCI_SR;
  401fda:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  401fde:	2b00      	cmp	r3, #0
  401fe0:	d0f6      	beq.n	401fd0 <hsmci_read_word+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  401fe2:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  401fe4:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  401fe6:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  401fe8:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  401fea:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401fec:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401fee:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  401ff0:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  401ff2:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  401ff4:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  401ff6:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  401ff8:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  401ffa:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  401ffc:	600b      	str	r3, [r1, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  401ffe:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402000:	bcf0      	pop	{r4, r5, r6, r7}
  402002:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  402004:	4a16      	ldr	r2, [pc, #88]	; (402060 <hsmci_read_word+0x98>)
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  402006:	4c17      	ldr	r4, [pc, #92]	; (402064 <hsmci_read_word+0x9c>)
  402008:	4d17      	ldr	r5, [pc, #92]	; (402068 <hsmci_read_word+0xa0>)
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  40200a:	6813      	ldr	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40200c:	8826      	ldrh	r6, [r4, #0]
  40200e:	882d      	ldrh	r5, [r5, #0]
			return false;
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
  402010:	6b0c      	ldr	r4, [r1, #48]	; 0x30
  402012:	6004      	str	r4, [r0, #0]
	hsmci_transfert_pos += 4;
  402014:	3304      	adds	r3, #4
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  402016:	fb06 f005 	mul.w	r0, r6, r5
  40201a:	4283      	cmp	r3, r0
		}
	} while (!(sr & HSMCI_SR_RXRDY));

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
  40201c:	6013      	str	r3, [r2, #0]
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
  40201e:	d202      	bcs.n	402026 <hsmci_read_word+0x5e>
  402020:	e019      	b.n	402056 <hsmci_read_word+0x8e>
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  402022:	0113      	lsls	r3, r2, #4
  402024:	d417      	bmi.n	402056 <hsmci_read_word+0x8e>
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  402026:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402028:	4b0c      	ldr	r3, [pc, #48]	; (40205c <hsmci_read_word+0x94>)
  40202a:	4013      	ands	r3, r2
	}

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI
	do {
		sr = HSMCI->HSMCI_SR;
  40202c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402030:	2b00      	cmp	r3, #0
  402032:	d0f6      	beq.n	402022 <hsmci_read_word+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402034:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  402036:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  402038:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40203a:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40203c:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40203e:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402040:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402042:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402044:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402046:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  402048:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40204a:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  40204c:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40204e:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: DMA sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  402050:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402052:	bcf0      	pop	{r4, r5, r6, r7}
  402054:	4770      	bx	lr

	// Read data
	*value = HSMCI->HSMCI_RDR;
	hsmci_transfert_pos += 4;
	if (((uint32_t)hsmci_block_size * hsmci_nb_block) > hsmci_transfert_pos) {
		return true;
  402056:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402058:	bcf0      	pop	{r4, r5, r6, r7}
  40205a:	4770      	bx	lr
  40205c:	c0600000 	.word	0xc0600000
  402060:	20000f60 	.word	0x20000f60
  402064:	20000f5c 	.word	0x20000f5c
  402068:	20000f5e 	.word	0x20000f5e

0040206c <hsmci_start_read_blocks>:
}
#endif // HSMCI_SR_DMADONE

#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
  40206c:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  40206e:	4b17      	ldr	r3, [pc, #92]	; (4020cc <hsmci_start_read_blocks+0x60>)
  402070:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  402072:	0784      	lsls	r4, r0, #30
#ifdef HSMCI_MR_PDCMODE
bool hsmci_start_read_blocks(void *dest, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  402074:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_RCR_RXCTR_Msk >> PERIPH_RCR_RXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
  402078:	d101      	bne.n	40207e <hsmci_start_read_blocks+0x12>
  40207a:	079a      	lsls	r2, r3, #30
  40207c:	d01e      	beq.n	4020bc <hsmci_start_read_blocks+0x50>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  40207e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  402082:	685a      	ldr	r2, [r3, #4]
  402084:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  402088:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  40208a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  40208e:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
  402090:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  402094:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
	hsmci_transfert_pos += nb_data;
  402096:	4a0e      	ldr	r2, [pc, #56]	; (4020d0 <hsmci_start_read_blocks+0x64>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  402098:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  40209a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  40209e:	bf54      	ite	pl
  4020a0:	088d      	lsrpl	r5, r1, #2
  4020a2:	460d      	movmi	r5, r1
	HSMCI->HSMCI_RNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4020a4:	2001      	movs	r0, #1
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_RPR = (uint32_t)dest;
	HSMCI->HSMCI_RCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4020a6:	f8c3 5104 	str.w	r5, [r3, #260]	; 0x104
			nb_data : nb_data / 4;
	HSMCI->HSMCI_RNCR = 0;
  4020aa:	f8c3 4114 	str.w	r4, [r3, #276]	; 0x114
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTEN;
  4020ae:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4020b2:	6813      	ldr	r3, [r2, #0]
  4020b4:	4419      	add	r1, r3
  4020b6:	6011      	str	r1, [r2, #0]
	return true;
}
  4020b8:	bc30      	pop	{r4, r5}
  4020ba:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)dest & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4020bc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4020c0:	685a      	ldr	r2, [r3, #4]
  4020c2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  4020c6:	605a      	str	r2, [r3, #4]
  4020c8:	e7df      	b.n	40208a <hsmci_start_read_blocks+0x1e>
  4020ca:	bf00      	nop
  4020cc:	20000f5c 	.word	0x20000f5c
  4020d0:	20000f60 	.word	0x20000f60

004020d4 <hsmci_wait_end_of_read_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_read_blocks(void)
{
  4020d4:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020d6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4020da:	e001      	b.n	4020e0 <hsmci_wait_end_of_read_blocks+0xc>
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));
  4020dc:	0452      	lsls	r2, r2, #17
  4020de:	d41b      	bmi.n	402118 <hsmci_wait_end_of_read_blocks+0x44>
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020e0:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4020e2:	4b21      	ldr	r3, [pc, #132]	; (402168 <hsmci_wait_end_of_read_blocks+0x94>)
  4020e4:	4013      	ands	r3, r2
{
	uint32_t sr;
	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4020e6:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  4020ea:	2b00      	cmp	r3, #0
  4020ec:	d0f6      	beq.n	4020dc <hsmci_wait_end_of_read_blocks+0x8>
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  4020ee:	f240 2302 	movw	r3, #514	; 0x202
  4020f2:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4020f6:	684f      	ldr	r7, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  4020f8:	688e      	ldr	r6, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  4020fa:	68cd      	ldr	r5, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  4020fc:	69cc      	ldr	r4, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  4020fe:	6d4a      	ldr	r2, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402100:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402102:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402104:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  402106:	604f      	str	r7, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402108:	608e      	str	r6, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40210a:	60cd      	str	r5, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40210c:	61cc      	str	r4, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  40210e:	654a      	str	r2, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402110:	600b      	str	r3, [r1, #0]
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			hsmci_reset();
			return false;
  402112:	2000      	movs	r0, #0
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402114:	bcf0      	pop	{r4, r5, r6, r7}
  402116:	4770      	bx	lr
			return false;
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  402118:	4a14      	ldr	r2, [pc, #80]	; (40216c <hsmci_wait_end_of_read_blocks+0x98>)
  40211a:	4815      	ldr	r0, [pc, #84]	; (402170 <hsmci_wait_end_of_read_blocks+0x9c>)
  40211c:	4b15      	ldr	r3, [pc, #84]	; (402174 <hsmci_wait_end_of_read_blocks+0xa0>)
  40211e:	8812      	ldrh	r2, [r2, #0]
  402120:	8800      	ldrh	r0, [r0, #0]
  402122:	681b      	ldr	r3, [r3, #0]
  402124:	fb00 f202 	mul.w	r2, r0, r2
  402128:	429a      	cmp	r2, r3
  40212a:	d902      	bls.n	402132 <hsmci_wait_end_of_read_blocks+0x5e>
  40212c:	e019      	b.n	402162 <hsmci_wait_end_of_read_blocks+0x8e>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
  40212e:	0113      	lsls	r3, r2, #4
  402130:	d417      	bmi.n	402162 <hsmci_wait_end_of_read_blocks+0x8e>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402132:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402134:	4b0c      	ldr	r3, [pc, #48]	; (402168 <hsmci_wait_end_of_read_blocks+0x94>)
  402136:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402138:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  40213c:	2b00      	cmp	r3, #0
  40213e:	d0f6      	beq.n	40212e <hsmci_wait_end_of_read_blocks+0x5a>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402140:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  402142:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  402144:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  402146:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  402148:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40214a:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40214c:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40214e:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402150:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402152:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  402154:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  402156:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  402158:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40215a:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  40215c:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  40215e:	bcf0      	pop	{r4, r5, r6, r7}
  402160:	4770      	bx	lr
		}

	} while (!(sr & HSMCI_SR_RXBUFF));

	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  402162:	2001      	movs	r0, #1
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_XFRDONE));
	return true;
}
  402164:	bcf0      	pop	{r4, r5, r6, r7}
  402166:	4770      	bx	lr
  402168:	c0600000 	.word	0xc0600000
  40216c:	20000f5e 	.word	0x20000f5e
  402170:	20000f5c 	.word	0x20000f5c
  402174:	20000f60 	.word	0x20000f60

00402178 <hsmci_start_write_blocks>:

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
  402178:	b430      	push	{r4, r5}
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  40217a:	4b18      	ldr	r3, [pc, #96]	; (4021dc <hsmci_start_write_blocks+0x64>)
  40217c:	881b      	ldrh	r3, [r3, #0]
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  40217e:	0784      	lsls	r4, r0, #30

bool hsmci_start_write_blocks(const void *src, uint16_t nb_block)
{
	uint32_t nb_data;

	nb_data = nb_block * hsmci_block_size;
  402180:	fb03 f101 	mul.w	r1, r3, r1
	Assert(nb_data <= (((uint32_t)hsmci_block_size * hsmci_nb_block) - hsmci_transfert_pos));
	Assert(nb_data <= (PERIPH_TCR_TXCTR_Msk >> PERIPH_TCR_TXCTR_Pos));

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
  402184:	d101      	bne.n	40218a <hsmci_start_write_blocks+0x12>
  402186:	079a      	lsls	r2, r3, #30
  402188:	d020      	beq.n	4021cc <hsmci_start_write_blocks+0x54>
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
  40218a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  40218e:	685a      	ldr	r2, [r3, #4]
  402190:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  402194:	605a      	str	r2, [r3, #4]
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  402196:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  40219a:	2400      	movs	r4, #0
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
  40219c:	f8c3 0108 	str.w	r0, [r3, #264]	; 0x108
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4021a0:	685b      	ldr	r3, [r3, #4]
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
	hsmci_transfert_pos += nb_data;
  4021a2:	4a0f      	ldr	r2, [pc, #60]	; (4021e0 <hsmci_start_write_blocks+0x68>)
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
			nb_data : nb_data / 4;
  4021a4:	049b      	lsls	r3, r3, #18
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4021a6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
			nb_data : nb_data / 4;
  4021aa:	bf54      	ite	pl
  4021ac:	088d      	lsrpl	r5, r1, #2
  4021ae:	460d      	movmi	r5, r1
	HSMCI->HSMCI_TNCR = 0;
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  4021b0:	f44f 7080 	mov.w	r0, #256	; 0x100
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
	}

	// Configure PDC transfer
	HSMCI->HSMCI_TPR = (uint32_t)src;
	HSMCI->HSMCI_TCR = (HSMCI->HSMCI_MR & HSMCI_MR_FBYTE) ?
  4021b4:	f8c3 510c 	str.w	r5, [r3, #268]	; 0x10c
			nb_data : nb_data / 4;
	HSMCI->HSMCI_TNCR = 0;
  4021b8:	f8c3 411c 	str.w	r4, [r3, #284]	; 0x11c
	// Start transfer
	HSMCI->HSMCI_PTCR = HSMCI_PTCR_TXTEN;
  4021bc:	f8c3 0120 	str.w	r0, [r3, #288]	; 0x120
	hsmci_transfert_pos += nb_data;
  4021c0:	6813      	ldr	r3, [r2, #0]
  4021c2:	4419      	add	r1, r3
  4021c4:	6011      	str	r1, [r2, #0]
	return true;
}
  4021c6:	2001      	movs	r0, #1
  4021c8:	bc30      	pop	{r4, r5}
  4021ca:	4770      	bx	lr

	// Handle unaligned memory address
	if (((uint32_t)src & 0x3) || (hsmci_block_size & 0x3)) {
		HSMCI->HSMCI_MR |= HSMCI_MR_FBYTE;
	} else {
		HSMCI->HSMCI_MR &= ~HSMCI_MR_FBYTE;
  4021cc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  4021d0:	685a      	ldr	r2, [r3, #4]
  4021d2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
  4021d6:	605a      	str	r2, [r3, #4]
  4021d8:	e7dd      	b.n	402196 <hsmci_start_write_blocks+0x1e>
  4021da:	bf00      	nop
  4021dc:	20000f5c 	.word	0x20000f5c
  4021e0:	20000f60 	.word	0x20000f60

004021e4 <hsmci_wait_end_of_write_blocks>:
	hsmci_transfert_pos += nb_data;
	return true;
}

bool hsmci_wait_end_of_write_blocks(void)
{
  4021e4:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021e6:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  4021ea:	e001      	b.n	4021f0 <hsmci_wait_end_of_write_blocks+0xc>
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));
  4021ec:	0412      	lsls	r2, r2, #16
  4021ee:	d41d      	bmi.n	40222c <hsmci_wait_end_of_write_blocks+0x48>
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021f0:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if (sr &
  4021f2:	4b22      	ldr	r3, [pc, #136]	; (40227c <hsmci_wait_end_of_write_blocks+0x98>)
  4021f4:	4013      	ands	r3, r2
	uint32_t sr;

	// Wait end of transfer
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  4021f6:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
		if (sr &
  4021fa:	2b00      	cmp	r3, #0
  4021fc:	d0f6      	beq.n	4021ec <hsmci_wait_end_of_write_blocks+0x8>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  4021fe:	f8d1 c004 	ldr.w	ip, [r1, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  402202:	688f      	ldr	r7, [r1, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  402204:	68ce      	ldr	r6, [r1, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  402206:	69cd      	ldr	r5, [r1, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  402208:	6d4c      	ldr	r4, [r1, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40220a:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40220c:	2205      	movs	r2, #5
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  40220e:	f240 2302 	movw	r3, #514	; 0x202
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402212:	6008      	str	r0, [r1, #0]
	HSMCI->HSMCI_MR = mr;
  402214:	f8c1 c004 	str.w	ip, [r1, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402218:	608f      	str	r7, [r1, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  40221a:	60ce      	str	r6, [r1, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40221c:	61cd      	str	r5, [r1, #28]
	HSMCI->HSMCI_CFG = cfg;
  40221e:	654c      	str	r4, [r1, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402220:	600a      	str	r2, [r1, #0]
				(HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x error\n\r",
					__func__, sr);
			hsmci_reset();
			HSMCI->HSMCI_PTCR = HSMCI_PTCR_RXTDIS | HSMCI_PTCR_TXTDIS;
  402222:	f8c1 3120 	str.w	r3, [r1, #288]	; 0x120
			return false;
  402226:	2000      	movs	r0, #0
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  402228:	bcf0      	pop	{r4, r5, r6, r7}
  40222a:	4770      	bx	lr
			return false;
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
  40222c:	4a14      	ldr	r2, [pc, #80]	; (402280 <hsmci_wait_end_of_write_blocks+0x9c>)
  40222e:	4815      	ldr	r0, [pc, #84]	; (402284 <hsmci_wait_end_of_write_blocks+0xa0>)
  402230:	4b15      	ldr	r3, [pc, #84]	; (402288 <hsmci_wait_end_of_write_blocks+0xa4>)
  402232:	8812      	ldrh	r2, [r2, #0]
  402234:	8800      	ldrh	r0, [r0, #0]
  402236:	681b      	ldr	r3, [r3, #0]
  402238:	fb00 f202 	mul.w	r2, r0, r2
  40223c:	429a      	cmp	r2, r3
  40223e:	d902      	bls.n	402246 <hsmci_wait_end_of_write_blocks+0x62>
  402240:	e019      	b.n	402276 <hsmci_wait_end_of_write_blocks+0x92>
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
  402242:	0693      	lsls	r3, r2, #26
  402244:	d417      	bmi.n	402276 <hsmci_wait_end_of_write_blocks+0x92>
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  402246:	6c0a      	ldr	r2, [r1, #64]	; 0x40
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402248:	4b0c      	ldr	r3, [pc, #48]	; (40227c <hsmci_wait_end_of_write_blocks+0x98>)
  40224a:	4013      	ands	r3, r2
		return true;
	}
	// It is the last transfer, then wait command completed
	// Note: no need of timeout, because it is include in HSMCI, see DTOE bit.
	do {
		sr = HSMCI->HSMCI_SR;
  40224c:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
  402250:	2b00      	cmp	r3, #0
  402252:	d0f6      	beq.n	402242 <hsmci_wait_end_of_write_blocks+0x5e>
/**
 * \brief Reset the HSMCI interface
 */
static void hsmci_reset(void)
{
	uint32_t mr = HSMCI->HSMCI_MR;
  402254:	6867      	ldr	r7, [r4, #4]
	uint32_t dtor = HSMCI->HSMCI_DTOR;
  402256:	68a6      	ldr	r6, [r4, #8]
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
  402258:	68e5      	ldr	r5, [r4, #12]
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
  40225a:	69e1      	ldr	r1, [r4, #28]
	uint32_t cfg = HSMCI->HSMCI_CFG;
  40225c:	6d62      	ldr	r2, [r4, #84]	; 0x54
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  40225e:	2080      	movs	r0, #128	; 0x80
	HSMCI->HSMCI_CFG = cfg;
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  402260:	2305      	movs	r3, #5
	uint32_t mr = HSMCI->HSMCI_MR;
	uint32_t dtor = HSMCI->HSMCI_DTOR;
	uint32_t sdcr = HSMCI->HSMCI_SDCR;
	uint32_t cstor = HSMCI->HSMCI_CSTOR;
	uint32_t cfg = HSMCI->HSMCI_CFG;
	HSMCI->HSMCI_CR = HSMCI_CR_SWRST;
  402262:	6020      	str	r0, [r4, #0]
	HSMCI->HSMCI_MR = mr;
  402264:	6067      	str	r7, [r4, #4]
	HSMCI->HSMCI_DTOR = dtor;
  402266:	60a6      	str	r6, [r4, #8]
	HSMCI->HSMCI_SDCR = sdcr;
  402268:	60e5      	str	r5, [r4, #12]
	HSMCI->HSMCI_CSTOR = cstor;
  40226a:	61e1      	str	r1, [r4, #28]
	HSMCI->HSMCI_CFG = cfg;
  40226c:	6562      	str	r2, [r4, #84]	; 0x54
#ifdef HSMCI_SR_DMADONE
	HSMCI->HSMCI_DMA = 0;
#endif
	// Enable the HSMCI
	HSMCI->HSMCI_CR = HSMCI_CR_PWSEN | HSMCI_CR_MCIEN;
  40226e:	6023      	str	r3, [r4, #0]
		if (sr & (HSMCI_SR_UNRE | HSMCI_SR_OVRE | \
				HSMCI_SR_DTOE | HSMCI_SR_DCRCE)) {
			hsmci_debug("%s: PDC sr 0x%08x last transfer error\n\r",
					__func__, sr);
			hsmci_reset();
			return false;
  402270:	2000      	movs	r0, #0
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  402272:	bcf0      	pop	{r4, r5, r6, r7}
  402274:	4770      	bx	lr
		}
	} while (!(sr & HSMCI_SR_TXBUFE));


	if (hsmci_transfert_pos < ((uint32_t)hsmci_block_size * hsmci_nb_block)) {
		return true;
  402276:	2001      	movs	r0, #1
			return false;
		}
	} while (!(sr & HSMCI_SR_NOTBUSY));
	Assert(HSMCI->HSMCI_SR & HSMCI_SR_FIFOEMPTY);
	return true;
}
  402278:	bcf0      	pop	{r4, r5, r6, r7}
  40227a:	4770      	bx	lr
  40227c:	c0600000 	.word	0xc0600000
  402280:	20000f5e 	.word	0x20000f5e
  402284:	20000f5c 	.word	0x20000f5c
  402288:	20000f60 	.word	0x20000f60

0040228c <pdc_disable_transfer>:
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
			ul_controls & (PERIPH_PTCR_RXTDIS | PERIPH_PTCR_TXTDIS);
  40228c:	f240 2302 	movw	r3, #514	; 0x202
  402290:	4019      	ands	r1, r3
		uint32_t ul_controls)
{
	/* Validate inputs. */
	Assert(p_pdc);
	
	p_pdc->PERIPH_PTCR =
  402292:	6201      	str	r1, [r0, #32]
  402294:	4770      	bx	lr
  402296:	bf00      	nop

00402298 <rtc_set_hour_mode>:
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  402298:	6843      	ldr	r3, [r0, #4]
 * \param p_rtc Pointer to an RTC instance.
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
  40229a:	b919      	cbnz	r1, 4022a4 <rtc_set_hour_mode+0xc>
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
	} else {
		p_rtc->RTC_MR &= (~RTC_MR_HRMOD);
  40229c:	f023 0301 	bic.w	r3, r3, #1
  4022a0:	6043      	str	r3, [r0, #4]
  4022a2:	4770      	bx	lr
 * \param ul_mode 1 for 12-hour mode, 0 for 24-hour mode.
 */
void rtc_set_hour_mode(Rtc *p_rtc, uint32_t ul_mode)
{
	if (ul_mode) {
		p_rtc->RTC_MR |= RTC_MR_HRMOD;
  4022a4:	f043 0301 	orr.w	r3, r3, #1
  4022a8:	6043      	str	r3, [r0, #4]
  4022aa:	4770      	bx	lr

004022ac <rtc_get_time>:
 * \param pul_minute Current minute.
 * \param pul_second Current second.
 */
void rtc_get_time(Rtc *p_rtc, uint32_t *pul_hour, uint32_t *pul_minute,
		uint32_t *pul_second)
{
  4022ac:	b430      	push	{r4, r5}
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
  4022ae:	6884      	ldr	r4, [r0, #8]
	while (ul_time != p_rtc->RTC_TIMR) {
  4022b0:	6885      	ldr	r5, [r0, #8]
  4022b2:	42ac      	cmp	r4, r5
  4022b4:	d003      	beq.n	4022be <rtc_get_time+0x12>
		ul_time = p_rtc->RTC_TIMR;
  4022b6:	6884      	ldr	r4, [r0, #8]
	uint32_t ul_time;
	uint32_t ul_temp;

	/* Get the current RTC time (multiple reads are necessary to insure a stable value). */
	ul_time = p_rtc->RTC_TIMR;
	while (ul_time != p_rtc->RTC_TIMR) {
  4022b8:	6885      	ldr	r5, [r0, #8]
  4022ba:	42a5      	cmp	r5, r4
  4022bc:	d1fb      	bne.n	4022b6 <rtc_get_time+0xa>
		ul_time = p_rtc->RTC_TIMR;
	}

	/* Hour */
	if (pul_hour) {
  4022be:	b161      	cbz	r1, 4022da <rtc_get_time+0x2e>
		ul_temp = (ul_time & RTC_TIMR_HOUR_Msk) >> RTC_TIMR_HOUR_Pos;
  4022c0:	f404 107c 	and.w	r0, r4, #4128768	; 0x3f0000
		*pul_hour = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022c4:	0d05      	lsrs	r5, r0, #20
  4022c6:	eb05 0585 	add.w	r5, r5, r5, lsl #2
  4022ca:	f3c0 4003 	ubfx	r0, r0, #16, #4
  4022ce:	eb00 0045 	add.w	r0, r0, r5, lsl #1

		if ((ul_time & RTC_TIMR_AMPM) == RTC_TIMR_AMPM) {
  4022d2:	0265      	lsls	r5, r4, #9
			*pul_hour += 12;
  4022d4:	bf48      	it	mi
  4022d6:	300c      	addmi	r0, #12
  4022d8:	6008      	str	r0, [r1, #0]
		}
	}

	/* Minute */
	if (pul_minute) {
  4022da:	b14a      	cbz	r2, 4022f0 <rtc_get_time+0x44>
		ul_temp = (ul_time & RTC_TIMR_MIN_Msk) >> RTC_TIMR_MIN_Pos;
  4022dc:	f404 41fe 	and.w	r1, r4, #32512	; 0x7f00
		*pul_minute = (ul_temp >> BCD_SHIFT) * BCD_FACTOR +  (ul_temp & BCD_MASK);
  4022e0:	0b08      	lsrs	r0, r1, #12
  4022e2:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  4022e6:	f3c1 2103 	ubfx	r1, r1, #8, #4
  4022ea:	eb01 0140 	add.w	r1, r1, r0, lsl #1
  4022ee:	6011      	str	r1, [r2, #0]
	}

	/* Second */
	if (pul_second) {
  4022f0:	b143      	cbz	r3, 402304 <rtc_get_time+0x58>
		ul_temp = (ul_time & RTC_TIMR_SEC_Msk) >> RTC_TIMR_SEC_Pos;
		*pul_second = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  4022f2:	f3c4 1202 	ubfx	r2, r4, #4, #3
  4022f6:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4022fa:	f004 040f 	and.w	r4, r4, #15
  4022fe:	eb04 0242 	add.w	r2, r4, r2, lsl #1
  402302:	601a      	str	r2, [r3, #0]
	}
}
  402304:	bc30      	pop	{r4, r5}
  402306:	4770      	bx	lr

00402308 <rtc_get_date>:
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  402308:	b4f0      	push	{r4, r5, r6, r7}
	uint32_t ul_date;
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
  40230a:	68c4      	ldr	r4, [r0, #12]
	while (ul_date != p_rtc->RTC_CALR) {
  40230c:	68c5      	ldr	r5, [r0, #12]
 * \param pul_day Current day.
 * \param pul_week Current day in current week.
 */
void rtc_get_date(Rtc *p_rtc, uint32_t *pul_year, uint32_t *pul_month,
		uint32_t *pul_day, uint32_t *pul_week)
{
  40230e:	9e04      	ldr	r6, [sp, #16]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  402310:	42ac      	cmp	r4, r5
  402312:	d003      	beq.n	40231c <rtc_get_date+0x14>
		ul_date = p_rtc->RTC_CALR;
  402314:	68c4      	ldr	r4, [r0, #12]
	uint32_t ul_cent;
	uint32_t ul_temp;

	/* Get the current date (multiple reads are necessary to insure a stable value). */
	ul_date = p_rtc->RTC_CALR;
	while (ul_date != p_rtc->RTC_CALR) {
  402316:	68c5      	ldr	r5, [r0, #12]
  402318:	42a5      	cmp	r5, r4
  40231a:	d1fb      	bne.n	402314 <rtc_get_date+0xc>
		ul_date = p_rtc->RTC_CALR;
	}

	/* Retrieve year */
	if (pul_year) {
  40231c:	b1a1      	cbz	r1, 402348 <rtc_get_date+0x40>
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
  40231e:	f404 457f 	and.w	r5, r4, #65280	; 0xff00
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402322:	0b2f      	lsrs	r7, r5, #12
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402324:	f3c4 1002 	ubfx	r0, r4, #4, #3
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402328:	eb07 0c87 	add.w	ip, r7, r7, lsl #2
  40232c:	f3c5 2503 	ubfx	r5, r5, #8, #4
	}

	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402330:	f004 070f 	and.w	r7, r4, #15
  402334:	eb00 0080 	add.w	r0, r0, r0, lsl #2
  402338:	eb07 0040 	add.w	r0, r7, r0, lsl #1
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  40233c:	eb05 054c 	add.w	r5, r5, ip, lsl #1
  402340:	2764      	movs	r7, #100	; 0x64
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402342:	fb07 5000 	mla	r0, r7, r0, r5
	/* Retrieve year */
	if (pul_year) {
		ul_temp = (ul_date & RTC_CALR_CENT_Msk) >> RTC_CALR_CENT_Pos;
		ul_cent = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
		ul_temp = (ul_date & RTC_CALR_YEAR_Msk) >> RTC_CALR_YEAR_Pos;
		*pul_year = (ul_cent * BCD_FACTOR * BCD_FACTOR) +
  402346:	6008      	str	r0, [r1, #0]
				(ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
	}

	/* Retrieve month */
	if (pul_month) {
  402348:	b14a      	cbz	r2, 40235e <rtc_get_date+0x56>
		ul_temp = (ul_date & RTC_CALR_MONTH_Msk) >> RTC_CALR_MONTH_Pos;
  40234a:	f404 10f8 	and.w	r0, r4, #2031616	; 0x1f0000
		*pul_month = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  40234e:	0d01      	lsrs	r1, r0, #20
  402350:	008d      	lsls	r5, r1, #2
  402352:	f3c0 4003 	ubfx	r0, r0, #16, #4
  402356:	4429      	add	r1, r5
  402358:	eb00 0141 	add.w	r1, r0, r1, lsl #1
  40235c:	6011      	str	r1, [r2, #0]
	}

	/* Retrieve day */
	if (pul_day) {
  40235e:	b14b      	cbz	r3, 402374 <rtc_get_date+0x6c>
		ul_temp = (ul_date & RTC_CALR_DATE_Msk) >> RTC_CALR_DATE_Pos;
  402360:	f004 527c 	and.w	r2, r4, #1056964608	; 0x3f000000
		*pul_day = (ul_temp >> BCD_SHIFT) * BCD_FACTOR + (ul_temp & BCD_MASK);
  402364:	0f11      	lsrs	r1, r2, #28
  402366:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  40236a:	f3c2 6203 	ubfx	r2, r2, #24, #4
  40236e:	eb02 0241 	add.w	r2, r2, r1, lsl #1
  402372:	601a      	str	r2, [r3, #0]
	}

	/* Retrieve week */
	if (pul_week) {
  402374:	b116      	cbz	r6, 40237c <rtc_get_date+0x74>
		*pul_week = ((ul_date & RTC_CALR_DAY_Msk) >> RTC_CALR_DAY_Pos);
  402376:	f3c4 5442 	ubfx	r4, r4, #21, #3
  40237a:	6034      	str	r4, [r6, #0]
	}
}
  40237c:	bcf0      	pop	{r4, r5, r6, r7}
  40237e:	4770      	bx	lr

00402380 <uart_disable_interrupt>:
 * \param p_uart Pointer to a UART instance.
 *  \param ul_sources Interrupts to be disabled.
 */
void uart_disable_interrupt(Uart *p_uart, uint32_t ul_sources)
{
	p_uart->UART_IDR = ul_sources;
  402380:	60c1      	str	r1, [r0, #12]
  402382:	4770      	bx	lr

00402384 <uart_get_status>:
 *
 * \return The current UART status.
 */
uint32_t uart_get_status(Uart *p_uart)
{
	return p_uart->UART_SR;
  402384:	6940      	ldr	r0, [r0, #20]
}
  402386:	4770      	bx	lr

00402388 <uart_write>:
 * \retval 1 I/O Failure, UART is not ready.
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
  402388:	6943      	ldr	r3, [r0, #20]
  40238a:	079b      	lsls	r3, r3, #30
		return 1;

	/* Send character */
	p_uart->UART_THR = uc_data;
  40238c:	bf46      	itte	mi
  40238e:	61c1      	strmi	r1, [r0, #28]
	return 0;
  402390:	2000      	movmi	r0, #0
 */
uint32_t uart_write(Uart *p_uart, const uint8_t uc_data)
{
	/* Check if the transmitter is ready */
	if (!(p_uart->UART_SR & UART_SR_TXRDY))
		return 1;
  402392:	2001      	movpl	r0, #1

	/* Send character */
	p_uart->UART_THR = uc_data;
	return 0;
}
  402394:	4770      	bx	lr
  402396:	bf00      	nop

00402398 <usart_enable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_enable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IER = ul_sources;
  402398:	6081      	str	r1, [r0, #8]
  40239a:	4770      	bx	lr

0040239c <usart_disable_interrupt>:
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
	p_usart->US_IDR = ul_sources;
  40239c:	60c1      	str	r1, [r0, #12]
  40239e:	4770      	bx	lr

004023a0 <usart_write>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
  4023a0:	6943      	ldr	r3, [r0, #20]
  4023a2:	079b      	lsls	r3, r3, #30
		return 1;
	}

	p_usart->US_THR = US_THR_TXCHR(c);
  4023a4:	bf43      	ittte	mi
  4023a6:	f3c1 0108 	ubfxmi	r1, r1, #0, #9
  4023aa:	61c1      	strmi	r1, [r0, #28]
	return 0;
  4023ac:	2000      	movmi	r0, #0
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
		return 1;
  4023ae:	2001      	movpl	r0, #1
	}

	p_usart->US_THR = US_THR_TXCHR(c);
	return 0;
}
  4023b0:	4770      	bx	lr
  4023b2:	bf00      	nop

004023b4 <usart_getchar>:
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	/* Wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
  4023b4:	6943      	ldr	r3, [r0, #20]
  4023b6:	07db      	lsls	r3, r3, #31
  4023b8:	d5fc      	bpl.n	4023b4 <usart_getchar>
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
  4023ba:	6983      	ldr	r3, [r0, #24]
  4023bc:	f3c3 0308 	ubfx	r3, r3, #0, #9
  4023c0:	600b      	str	r3, [r1, #0]

	return 0;
}
  4023c2:	2000      	movs	r0, #0
  4023c4:	4770      	bx	lr
  4023c6:	bf00      	nop

004023c8 <disk_initialize>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  4023c8:	b538      	push	{r3, r4, r5, lr}
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  4023ca:	2100      	movs	r1, #0
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_PROTECT).
 */
DSTATUS disk_initialize(BYTE drv)
{
  4023cc:	4604      	mov	r4, r0
	int i;
	Ctrl_status mem_status;

#if (SAM3S || SAM3U || SAM3N || SAM3XA || SAM4S)
	/* Default RTC configuration, 24-hour mode */
	rtc_set_hour_mode(RTC, 0);
  4023ce:	4b0b      	ldr	r3, [pc, #44]	; (4023fc <disk_initialize+0x34>)
  4023d0:	480b      	ldr	r0, [pc, #44]	; (402400 <disk_initialize+0x38>)
  4023d2:	4798      	blx	r3
	/* USB disk with multiple LUNs */
	if (drv > LUN_ID_USB + Lun_usb_get_lun()) {
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
  4023d4:	2c02      	cmp	r4, #2
  4023d6:	d807      	bhi.n	4023e8 <disk_initialize+0x20>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4023d8:	4620      	mov	r0, r4
  4023da:	4d0a      	ldr	r5, [pc, #40]	; (402404 <disk_initialize+0x3c>)
  4023dc:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
  4023de:	2803      	cmp	r0, #3
  4023e0:	d101      	bne.n	4023e6 <disk_initialize+0x1e>
		return STA_NOINIT;
	}
#endif
	/* Check LUN ready (USB disk report CTRL_BUSY then CTRL_GOOD) */
	for (i = 0; i < 2; i ++) {
		mem_status = mem_test_unit_ready(drv);
  4023e2:	4620      	mov	r0, r4
  4023e4:	47a8      	blx	r5
		if (CTRL_BUSY != mem_status) {
			break;
		}
	}
	if (mem_status != CTRL_GOOD) {
  4023e6:	b108      	cbz	r0, 4023ec <disk_initialize+0x24>
		return STA_NOINIT;
	}
#else
	if (drv > MAX_LUN) {
		/* At least one of the LUN should be defined */
		return STA_NOINIT;
  4023e8:	2001      	movs	r0, #1
  4023ea:	bd38      	pop	{r3, r4, r5, pc}
	if (mem_status != CTRL_GOOD) {
		return STA_NOINIT;
	}

	/* Check Write Protection Status */
	if (mem_wr_protect(drv)) {
  4023ec:	4620      	mov	r0, r4
  4023ee:	4b06      	ldr	r3, [pc, #24]	; (402408 <disk_initialize+0x40>)
  4023f0:	4798      	blx	r3
  4023f2:	2800      	cmp	r0, #0
		return STA_PROTECT;
  4023f4:	bf0c      	ite	eq
  4023f6:	2000      	moveq	r0, #0
  4023f8:	2004      	movne	r0, #4
	}

	/* The memory should already be initialized */
	return 0;
}
  4023fa:	bd38      	pop	{r3, r4, r5, pc}
  4023fc:	00402299 	.word	0x00402299
  402400:	400e1460 	.word	0x400e1460
  402404:	00401c61 	.word	0x00401c61
  402408:	00401ca1 	.word	0x00401ca1

0040240c <disk_status>:
 *
 * \return 0 or disk status in combination of DSTATUS bits
 *         (STA_NOINIT, STA_NODISK, STA_PROTECT).
 */
DSTATUS disk_status(BYTE drv)
{
  40240c:	b508      	push	{r3, lr}
	switch (mem_test_unit_ready(drv)) {
  40240e:	4b04      	ldr	r3, [pc, #16]	; (402420 <disk_status+0x14>)
  402410:	4798      	blx	r3
  402412:	b118      	cbz	r0, 40241c <disk_status+0x10>
  402414:	2802      	cmp	r0, #2
	case CTRL_GOOD:
		return 0;
	case CTRL_NO_PRESENT:
		return STA_NOINIT | STA_NODISK;
	default:
		return STA_NOINIT;
  402416:	bf0c      	ite	eq
  402418:	2003      	moveq	r0, #3
  40241a:	2001      	movne	r0, #1
	}
}
  40241c:	bd08      	pop	{r3, pc}
  40241e:	bf00      	nop
  402420:	00401c61 	.word	0x00401c61

00402424 <disk_read>:
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  402424:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402428:	4c18      	ldr	r4, [pc, #96]	; (40248c <disk_read+0x68>)
 * \param count Number of sectors to read (1..255).
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_read(BYTE drv, BYTE *buff, DWORD sector, BYTE count)
{
  40242a:	b083      	sub	sp, #12
  40242c:	460e      	mov	r6, r1
  40242e:	4615      	mov	r5, r2
  402430:	4698      	mov	r8, r3
  402432:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  402434:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  402436:	4604      	mov	r4, r0
  402438:	b918      	cbnz	r0, 402442 <disk_read+0x1e>
		return RES_ERROR;
  40243a:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40243c:	b003      	add	sp, #12
  40243e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  402442:	4b13      	ldr	r3, [pc, #76]	; (402490 <disk_read+0x6c>)
  402444:	4648      	mov	r0, r9
  402446:	a901      	add	r1, sp, #4
  402448:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  40244a:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  40244c:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  402450:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  402454:	442a      	add	r2, r5
  402456:	429a      	cmp	r2, r3
  402458:	d903      	bls.n	402462 <disk_read+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  40245a:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  40245c:	b003      	add	sp, #12
  40245e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402462:	f1b8 0f00 	cmp.w	r8, #0
  402466:	d00f      	beq.n	402488 <disk_read+0x64>
  402468:	f8df b028 	ldr.w	fp, [pc, #40]	; 402494 <disk_read+0x70>
  40246c:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  402470:	2700      	movs	r7, #0
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  402472:	4629      	mov	r1, r5
  402474:	4632      	mov	r2, r6
  402476:	4648      	mov	r0, r9
  402478:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  40247a:	3701      	adds	r7, #1
  40247c:	4425      	add	r5, r4
  40247e:	4456      	add	r6, sl
		if (memory_2_ram(drv, sector + uc_sector_size * i,
  402480:	2800      	cmp	r0, #0
  402482:	d1da      	bne.n	40243a <disk_read+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Read the data */
	for (i = 0; i < count; i++) {
  402484:	4547      	cmp	r7, r8
  402486:	d3f4      	bcc.n	402472 <disk_read+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  402488:	2000      	movs	r0, #0
  40248a:	e7d7      	b.n	40243c <disk_read+0x18>
  40248c:	00401c95 	.word	0x00401c95
  402490:	00401c79 	.word	0x00401c79
  402494:	00401cbd 	.word	0x00401cbd

00402498 <disk_write>:
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  402498:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  40249c:	4c18      	ldr	r4, [pc, #96]	; (402500 <disk_write+0x68>)
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
#if _READONLY == 0
DRESULT disk_write(BYTE drv, BYTE const *buff, DWORD sector, BYTE count)
{
  40249e:	b083      	sub	sp, #12
  4024a0:	460e      	mov	r6, r1
  4024a2:	4615      	mov	r5, r2
  4024a4:	4698      	mov	r8, r3
  4024a6:	4681      	mov	r9, r0
#if ACCESS_MEM_TO_RAM
	uint8_t uc_sector_size = mem_sector_size(drv);
  4024a8:	47a0      	blx	r4
	uint32_t i;
	uint32_t ul_last_sector_num;

	if (uc_sector_size == 0) {
  4024aa:	4604      	mov	r4, r0
  4024ac:	b918      	cbnz	r0, 4024b6 <disk_write+0x1e>
		return RES_ERROR;
  4024ae:	2001      	movs	r0, #1
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  4024b0:	b003      	add	sp, #12
  4024b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (uc_sector_size == 0) {
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
  4024b6:	4b13      	ldr	r3, [pc, #76]	; (402504 <disk_write+0x6c>)
  4024b8:	4648      	mov	r0, r9
  4024ba:	a901      	add	r1, sp, #4
  4024bc:	4798      	blx	r3
	if ((sector + count * uc_sector_size) >
			(ul_last_sector_num + 1) * uc_sector_size) {
  4024be:	9b01      	ldr	r3, [sp, #4]
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  4024c0:	fb18 f204 	smulbb	r2, r8, r4
			(ul_last_sector_num + 1) * uc_sector_size) {
  4024c4:	fb03 4304 	mla	r3, r3, r4, r4
		return RES_ERROR;
	}

	/* Check valid address */
	mem_read_capacity(drv, &ul_last_sector_num);
	if ((sector + count * uc_sector_size) >
  4024c8:	442a      	add	r2, r5
  4024ca:	429a      	cmp	r2, r3
  4024cc:	d903      	bls.n	4024d6 <disk_write+0x3e>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
  4024ce:	2004      	movs	r0, #4
	return RES_OK;

#else
	return RES_ERROR;
#endif
}
  4024d0:	b003      	add	sp, #12
  4024d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024d6:	f1b8 0f00 	cmp.w	r8, #0
  4024da:	d00f      	beq.n	4024fc <disk_write+0x64>
  4024dc:	f8df b028 	ldr.w	fp, [pc, #40]	; 402508 <disk_write+0x70>
  4024e0:	ea4f 2a44 	mov.w	sl, r4, lsl #9
  4024e4:	2700      	movs	r7, #0
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  4024e6:	4629      	mov	r1, r5
  4024e8:	4632      	mov	r2, r6
  4024ea:	4648      	mov	r0, r9
  4024ec:	47d8      	blx	fp
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024ee:	3701      	adds	r7, #1
  4024f0:	4425      	add	r5, r4
  4024f2:	4456      	add	r6, sl
		if (ram_2_memory(drv, sector + uc_sector_size * i,
  4024f4:	2800      	cmp	r0, #0
  4024f6:	d1da      	bne.n	4024ae <disk_write+0x16>
			(ul_last_sector_num + 1) * uc_sector_size) {
		return RES_PARERR;
	}

	/* Write the data */
	for (i = 0; i < count; i++) {
  4024f8:	4547      	cmp	r7, r8
  4024fa:	d3f4      	bcc.n	4024e6 <disk_write+0x4e>
				CTRL_GOOD) {
			return RES_ERROR;
		}
	}

	return RES_OK;
  4024fc:	2000      	movs	r0, #0
  4024fe:	e7d7      	b.n	4024b0 <disk_write+0x18>
  402500:	00401c95 	.word	0x00401c95
  402504:	00401c79 	.word	0x00401c79
  402508:	00401cdd 	.word	0x00401cdd

0040250c <disk_ioctl>:
 * \param buff Buffer to send/receive control data.
 *
 * \return RES_OK for success, otherwise DRESULT error code.
 */
DRESULT disk_ioctl(BYTE drv, BYTE ctrl, void *buff)
{
  40250c:	b510      	push	{r4, lr}
  40250e:	4614      	mov	r4, r2
  402510:	b082      	sub	sp, #8
	DRESULT res = RES_PARERR;

	switch (ctrl) {
  402512:	2903      	cmp	r1, #3
  402514:	d829      	bhi.n	40256a <disk_ioctl+0x5e>
  402516:	e8df f001 	tbb	[pc, r1]
  40251a:	131c      	.short	0x131c
  40251c:	0207      	.short	0x0207
	case GET_BLOCK_SIZE:
		*(DWORD *)buff = 1;
  40251e:	2301      	movs	r3, #1
  402520:	6013      	str	r3, [r2, #0]
		res = RES_OK;
  402522:	2000      	movs	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  402524:	b002      	add	sp, #8
  402526:	bd10      	pop	{r4, pc}
	break;

	/* Get sectors on the disk (WORD) */
	case GET_SECTOR_SIZE:
	{
		uint8_t uc_sector_size = mem_sector_size(drv);
  402528:	4b11      	ldr	r3, [pc, #68]	; (402570 <disk_ioctl+0x64>)
  40252a:	4798      	blx	r3

		if ((uc_sector_size != SECTOR_SIZE_512) &&
  40252c:	1e43      	subs	r3, r0, #1
  40252e:	b2db      	uxtb	r3, r3
  402530:	2b01      	cmp	r3, #1
  402532:	d916      	bls.n	402562 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_1024) &&
  402534:	2804      	cmp	r0, #4
  402536:	d014      	beq.n	402562 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_2048) &&
  402538:	2808      	cmp	r0, #8
  40253a:	d012      	beq.n	402562 <disk_ioctl+0x56>
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
  40253c:	2001      	movs	r0, #1
  40253e:	e7f1      	b.n	402524 <disk_ioctl+0x18>
	case GET_SECTOR_COUNT:
	{
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);
  402540:	a901      	add	r1, sp, #4
  402542:	4b0c      	ldr	r3, [pc, #48]	; (402574 <disk_ioctl+0x68>)
  402544:	4798      	blx	r3

		*(DWORD *)buff = ul_last_sector_num + 1;
  402546:	9b01      	ldr	r3, [sp, #4]

		res = RES_OK;
  402548:	2000      	movs	r0, #0
		uint32_t ul_last_sector_num;

		/* Check valid address */
		mem_read_capacity(drv, &ul_last_sector_num);

		*(DWORD *)buff = ul_last_sector_num + 1;
  40254a:	3301      	adds	r3, #1
  40254c:	6023      	str	r3, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  40254e:	b002      	add	sp, #8
  402550:	bd10      	pop	{r4, pc}
	}
	break;

	/* Make sure that data has been written */
	case CTRL_SYNC:
		if (mem_test_unit_ready(drv) == CTRL_GOOD) {
  402552:	4b09      	ldr	r3, [pc, #36]	; (402578 <disk_ioctl+0x6c>)
  402554:	4798      	blx	r3
			res = RES_OK;
  402556:	2800      	cmp	r0, #0
  402558:	bf14      	ite	ne
  40255a:	2003      	movne	r0, #3
  40255c:	2000      	moveq	r0, #0
	default:
		res = RES_PARERR;
	}

	return res;
}
  40255e:	b002      	add	sp, #8
  402560:	bd10      	pop	{r4, pc}
				(uc_sector_size != SECTOR_SIZE_4096)) {
			/* The sector size is not supported by the FatFS */
			return RES_ERROR;
		}

		*(U8 *)buff = uc_sector_size * SECTOR_SIZE_DEFAULT;
  402562:	2000      	movs	r0, #0
  402564:	7020      	strb	r0, [r4, #0]
	default:
		res = RES_PARERR;
	}

	return res;
}
  402566:	b002      	add	sp, #8
  402568:	bd10      	pop	{r4, pc}
			res = RES_NOTRDY;
		}
		break;

	default:
		res = RES_PARERR;
  40256a:	2004      	movs	r0, #4
  40256c:	e7da      	b.n	402524 <disk_ioctl+0x18>
  40256e:	bf00      	nop
  402570:	00401c95 	.word	0x00401c95
  402574:	00401c79 	.word	0x00401c79
  402578:	00401c61 	.word	0x00401c61

0040257c <get_fattime>:
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  40257c:	b530      	push	{r4, r5, lr}
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  40257e:	4c12      	ldr	r4, [pc, #72]	; (4025c8 <get_fattime+0x4c>)
  402580:	4d12      	ldr	r5, [pc, #72]	; (4025cc <get_fattime+0x50>)
 * bit4:0    Second (0..59)
 *
 * \return Current time.
 */
uint32_t get_fattime(void)
{
  402582:	b08b      	sub	sp, #44	; 0x2c
	uint32_t ul_time;
	uint32_t ul_hour, ul_minute, ul_second;
	uint32_t ul_year, ul_month, ul_day, ul_week;

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
  402584:	4620      	mov	r0, r4
  402586:	a903      	add	r1, sp, #12
  402588:	aa04      	add	r2, sp, #16
  40258a:	ab05      	add	r3, sp, #20
  40258c:	47a8      	blx	r5
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);
  40258e:	ab09      	add	r3, sp, #36	; 0x24
  402590:	4620      	mov	r0, r4
  402592:	9300      	str	r3, [sp, #0]
  402594:	a906      	add	r1, sp, #24
  402596:	aa07      	add	r2, sp, #28
  402598:	ab08      	add	r3, sp, #32
  40259a:	4c0d      	ldr	r4, [pc, #52]	; (4025d0 <get_fattime+0x54>)
  40259c:	47a0      	blx	r4

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
			| (ul_day << 16)
  40259e:	9d08      	ldr	r5, [sp, #32]
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  4025a0:	9c07      	ldr	r4, [sp, #28]
			| (ul_day << 16)
  4025a2:	9805      	ldr	r0, [sp, #20]
			| (ul_hour << 11)
  4025a4:	9903      	ldr	r1, [sp, #12]
			| (ul_minute << 5)
  4025a6:	9a04      	ldr	r2, [sp, #16]

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  4025a8:	9b06      	ldr	r3, [sp, #24]
			| (ul_month << 21)
			| (ul_day << 16)
  4025aa:	042d      	lsls	r5, r5, #16
	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
			| (ul_month << 21)
  4025ac:	ea45 5444 	orr.w	r4, r5, r4, lsl #21
			| (ul_day << 16)
  4025b0:	4320      	orrs	r0, r4
			| (ul_hour << 11)
  4025b2:	ea40 21c1 	orr.w	r1, r0, r1, lsl #11
			| (ul_minute << 5)
  4025b6:	ea41 1042 	orr.w	r0, r1, r2, lsl #5

	/* Retrieve date and time */
	rtc_get_time(RTC, &ul_hour, &ul_minute, &ul_second);
	rtc_get_date(RTC, &ul_year, &ul_month, &ul_day, &ul_week);

	ul_time = ((ul_year - 1980) << 25)
  4025ba:	f2a3 73bc 	subw	r3, r3, #1980	; 0x7bc
			| (ul_hour << 11)
			| (ul_minute << 5)
			| (ul_second << 0);

	return ul_time;
}
  4025be:	ea40 6043 	orr.w	r0, r0, r3, lsl #25
  4025c2:	b00b      	add	sp, #44	; 0x2c
  4025c4:	bd30      	pop	{r4, r5, pc}
  4025c6:	bf00      	nop
  4025c8:	400e1460 	.word	0x400e1460
  4025cc:	004022ad 	.word	0x004022ad
  4025d0:	00402309 	.word	0x00402309

004025d4 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dj,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
  4025d4:	b470      	push	{r4, r5, r6}
  4025d6:	4a19      	ldr	r2, [pc, #100]	; (40263c <chk_lock+0x68>)
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4025d8:	2600      	movs	r6, #0
  4025da:	4633      	mov	r3, r6
		if (Files[i].fs) {	/* Existing entry */
  4025dc:	f852 4c08 	ldr.w	r4, [r2, #-8]
  4025e0:	b174      	cbz	r4, 402600 <chk_lock+0x2c>
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  4025e2:	6805      	ldr	r5, [r0, #0]
  4025e4:	42ac      	cmp	r4, r5
  4025e6:	d010      	beq.n	40260a <chk_lock+0x36>
)
{
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
  4025e8:	3301      	adds	r3, #1
  4025ea:	2b03      	cmp	r3, #3
  4025ec:	f102 020c 	add.w	r2, r2, #12
  4025f0:	d1f4      	bne.n	4025dc <chk_lock+0x8>
		} else {			/* Blank entry */
			be++;
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  4025f2:	b93e      	cbnz	r6, 402604 <chk_lock+0x30>
  4025f4:	2902      	cmp	r1, #2
  4025f6:	bf14      	ite	ne
  4025f8:	2012      	movne	r0, #18
  4025fa:	2000      	moveq	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  4025fc:	bc70      	pop	{r4, r5, r6}
  4025fe:	4770      	bx	lr
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
				Files[i].clu == dj->sclust &&
				Files[i].idx == dj->index) break;
		} else {			/* Blank entry */
			be++;
  402600:	3601      	adds	r6, #1
  402602:	e7f1      	b.n	4025e8 <chk_lock+0x14>
		}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */
  402604:	2000      	movs	r0, #0

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
}
  402606:	bc70      	pop	{r4, r5, r6}
  402608:	4770      	bx	lr
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs) {	/* Existing entry */
			if (Files[i].fs == dj->fs &&	 	/* Check if the file matched with an open file */
  40260a:	f852 5c04 	ldr.w	r5, [r2, #-4]
  40260e:	6884      	ldr	r4, [r0, #8]
  402610:	42a5      	cmp	r5, r4
  402612:	d1e9      	bne.n	4025e8 <chk_lock+0x14>
				Files[i].clu == dj->sclust &&
  402614:	8815      	ldrh	r5, [r2, #0]
  402616:	88c4      	ldrh	r4, [r0, #6]
  402618:	42a5      	cmp	r5, r4
  40261a:	d1e5      	bne.n	4025e8 <chk_lock+0x14>
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40261c:	b109      	cbz	r1, 402622 <chk_lock+0x4e>
  40261e:	2010      	movs	r0, #16
  402620:	e7ec      	b.n	4025fc <chk_lock+0x28>
  402622:	4a07      	ldr	r2, [pc, #28]	; (402640 <chk_lock+0x6c>)
  402624:	eb03 0343 	add.w	r3, r3, r3, lsl #1
  402628:	eb02 0383 	add.w	r3, r2, r3, lsl #2
}
  40262c:	bc70      	pop	{r4, r5, r6}
	}
	if (i == _FS_SHARE)	/* The file is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new file? */

	/* The file has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
  40262e:	895b      	ldrh	r3, [r3, #10]
  402630:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  402634:	bf14      	ite	ne
  402636:	2000      	movne	r0, #0
  402638:	2010      	moveq	r0, #16
}
  40263a:	4770      	bx	lr
  40263c:	20000f70 	.word	0x20000f70
  402640:	20000f68 	.word	0x20000f68

00402644 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  402644:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	DWORD wsect;


	wsect = fs->winsect;
  402648:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
	if (wsect != sector) {	/* Changed current window */
  40264a:	428d      	cmp	r5, r1
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
  40264c:	4604      	mov	r4, r0
  40264e:	460e      	mov	r6, r1
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
  402650:	d002      	beq.n	402658 <move_window+0x14>
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
  402652:	7903      	ldrb	r3, [r0, #4]
  402654:	b973      	cbnz	r3, 402674 <move_window+0x30>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  402656:	b916      	cbnz	r6, 40265e <move_window+0x1a>
				return FR_DISK_ERR;
			fs->winsect = sector;
		}
	}

	return FR_OK;
  402658:	2000      	movs	r0, #0
  40265a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				}
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
  40265e:	7860      	ldrb	r0, [r4, #1]
  402660:	4d17      	ldr	r5, [pc, #92]	; (4026c0 <move_window+0x7c>)
  402662:	f104 0130 	add.w	r1, r4, #48	; 0x30
  402666:	4632      	mov	r2, r6
  402668:	2301      	movs	r3, #1
  40266a:	47a8      	blx	r5
  40266c:	bb20      	cbnz	r0, 4026b8 <move_window+0x74>
				return FR_DISK_ERR;
			fs->winsect = sector;
  40266e:	62e6      	str	r6, [r4, #44]	; 0x2c
		}
	}

	return FR_OK;
}
  402670:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
  402674:	f100 0830 	add.w	r8, r0, #48	; 0x30
  402678:	4641      	mov	r1, r8
  40267a:	7840      	ldrb	r0, [r0, #1]
  40267c:	f8df 9044 	ldr.w	r9, [pc, #68]	; 4026c4 <move_window+0x80>
  402680:	462a      	mov	r2, r5
  402682:	2301      	movs	r3, #1
  402684:	47c8      	blx	r9
  402686:	b9b8      	cbnz	r0, 4026b8 <move_window+0x74>
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  402688:	69e3      	ldr	r3, [r4, #28]
  40268a:	6a22      	ldr	r2, [r4, #32]
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
  40268c:	7120      	strb	r0, [r4, #4]
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
  40268e:	441a      	add	r2, r3
  402690:	4295      	cmp	r5, r2
  402692:	d2e0      	bcs.n	402656 <move_window+0x12>
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  402694:	78e7      	ldrb	r7, [r4, #3]
  402696:	2f01      	cmp	r7, #1
  402698:	d801      	bhi.n	40269e <move_window+0x5a>
  40269a:	e7dc      	b.n	402656 <move_window+0x12>
  40269c:	69e3      	ldr	r3, [r4, #28]
					wsect += fs->fsize;
  40269e:	441d      	add	r5, r3
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4026a0:	3f01      	subs	r7, #1
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  4026a2:	462a      	mov	r2, r5
  4026a4:	7860      	ldrb	r0, [r4, #1]
  4026a6:	4641      	mov	r1, r8
  4026a8:	2301      	movs	r3, #1
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4026aa:	b2ff      	uxtb	r7, r7
					wsect += fs->fsize;
					disk_write(fs->drv, fs->win, wsect, 1);
  4026ac:	47c8      	blx	r9
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
			fs->wflag = 0;
			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
				BYTE nf;
				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
  4026ae:	2f01      	cmp	r7, #1
  4026b0:	d1f4      	bne.n	40269c <move_window+0x58>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
  4026b2:	2e00      	cmp	r6, #0
  4026b4:	d0d0      	beq.n	402658 <move_window+0x14>
  4026b6:	e7d2      	b.n	40265e <move_window+0x1a>
	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
#if !_FS_READONLY
		if (fs->wflag) {	/* Write back dirty window if needed */
			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
				return FR_DISK_ERR;
  4026b8:	2001      	movs	r0, #1
  4026ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  4026be:	bf00      	nop
  4026c0:	00402425 	.word	0x00402425
  4026c4:	00402499 	.word	0x00402499

004026c8 <sync>:
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4026c8:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	FRESULT res;


	res = move_window(fs, 0);
  4026cc:	2100      	movs	r1, #0
  4026ce:	4b31      	ldr	r3, [pc, #196]	; (402794 <sync+0xcc>)
#if !_FS_READONLY
static
FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
	FATFS *fs	/* File system object */
)
{
  4026d0:	4605      	mov	r5, r0
	FRESULT res;


	res = move_window(fs, 0);
  4026d2:	4798      	blx	r3
  4026d4:	4603      	mov	r3, r0
	if (res == FR_OK) {
  4026d6:	b950      	cbnz	r0, 4026ee <sync+0x26>
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4026d8:	782b      	ldrb	r3, [r5, #0]
  4026da:	2b03      	cmp	r3, #3
  4026dc:	d00a      	beq.n	4026f4 <sync+0x2c>
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
			fs->fsi_flag = 0;
		}
		/* Make sure that no pending write process in the physical drive */
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
  4026de:	2100      	movs	r1, #0
  4026e0:	4b2d      	ldr	r3, [pc, #180]	; (402798 <sync+0xd0>)
  4026e2:	7868      	ldrb	r0, [r5, #1]
  4026e4:	460a      	mov	r2, r1
  4026e6:	4798      	blx	r3
  4026e8:	1c03      	adds	r3, r0, #0
  4026ea:	bf18      	it	ne
  4026ec:	2301      	movne	r3, #1
			res = FR_DISK_ERR;
	}

	return res;
}
  4026ee:	4618      	mov	r0, r3
  4026f0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}


	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
  4026f4:	796b      	ldrb	r3, [r5, #5]
  4026f6:	2b00      	cmp	r3, #0
  4026f8:	d0f1      	beq.n	4026de <sync+0x16>
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
  4026fa:	f105 0130 	add.w	r1, r5, #48	; 0x30

	res = move_window(fs, 0);
	if (res == FR_OK) {
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
  4026fe:	62e8      	str	r0, [r5, #44]	; 0x2c
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  402700:	460b      	mov	r3, r1
  402702:	f505 720c 	add.w	r2, r5, #560	; 0x230

	while (cnt--)
		*d++ = (BYTE)val;
  402706:	f803 0b01 	strb.w	r0, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  40270a:	4293      	cmp	r3, r2
		*d++ = (BYTE)val;
  40270c:	f04f 0400 	mov.w	r4, #0
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402710:	d1f9      	bne.n	402706 <sync+0x3e>
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402712:	692a      	ldr	r2, [r5, #16]
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402714:	68eb      	ldr	r3, [r5, #12]
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402716:	f885 2218 	strb.w	r2, [r5, #536]	; 0x218
  40271a:	f3c2 2b07 	ubfx	fp, r2, #8, #8
  40271e:	ea4f 4a12 	mov.w	sl, r2, lsr #16
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402722:	ea4f 4c13 	mov.w	ip, r3, lsr #16
  402726:	ea4f 6e13 	mov.w	lr, r3, lsr #24
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  40272a:	2052      	movs	r0, #82	; 0x52
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  40272c:	ea4f 6912 	mov.w	r9, r2, lsr #24
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402730:	f3c3 2807 	ubfx	r8, r3, #8, #8
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402734:	2261      	movs	r2, #97	; 0x61
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402736:	26aa      	movs	r6, #170	; 0xaa
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402738:	f885 b219 	strb.w	fp, [r5, #537]	; 0x219
  40273c:	f885 a21a 	strb.w	sl, [r5, #538]	; 0x21a
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402740:	f04f 0b41 	mov.w	fp, #65	; 0x41
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  402744:	f04f 0a72 	mov.w	sl, #114	; 0x72
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402748:	2755      	movs	r7, #85	; 0x55
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  40274a:	f885 321c 	strb.w	r3, [r5, #540]	; 0x21c
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  40274e:	f885 622f 	strb.w	r6, [r5, #559]	; 0x22f
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402752:	f885 0030 	strb.w	r0, [r5, #48]	; 0x30
  402756:	f885 0031 	strb.w	r0, [r5, #49]	; 0x31
  40275a:	f885 2032 	strb.w	r2, [r5, #50]	; 0x32
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  40275e:	f885 2217 	strb.w	r2, [r5, #535]	; 0x217
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
  402762:	f885 921b 	strb.w	r9, [r5, #539]	; 0x21b
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
  402766:	f885 821d 	strb.w	r8, [r5, #541]	; 0x21d
  40276a:	f885 c21e 	strb.w	ip, [r5, #542]	; 0x21e
  40276e:	f885 e21f 	strb.w	lr, [r5, #543]	; 0x21f
		/* Update FSInfo sector if needed */
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
			fs->winsect = 0;
			/* Create FSInfo structure */
			mem_set(fs->win, 0, 512);
			ST_WORD(fs->win+BS_55AA, 0xAA55);
  402772:	f885 722e 	strb.w	r7, [r5, #558]	; 0x22e
			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
  402776:	f885 b033 	strb.w	fp, [r5, #51]	; 0x33
			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
  40277a:	f885 b216 	strb.w	fp, [r5, #534]	; 0x216
  40277e:	f885 a214 	strb.w	sl, [r5, #532]	; 0x214
  402782:	f885 a215 	strb.w	sl, [r5, #533]	; 0x215
			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
			/* Write it into the FSInfo sector */
			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
  402786:	7868      	ldrb	r0, [r5, #1]
  402788:	696a      	ldr	r2, [r5, #20]
  40278a:	4e04      	ldr	r6, [pc, #16]	; (40279c <sync+0xd4>)
  40278c:	2301      	movs	r3, #1
  40278e:	47b0      	blx	r6
			fs->fsi_flag = 0;
  402790:	716c      	strb	r4, [r5, #5]
  402792:	e7a4      	b.n	4026de <sync+0x16>
  402794:	00402645 	.word	0x00402645
  402798:	0040250d 	.word	0x0040250d
  40279c:	00402499 	.word	0x00402499

004027a0 <validate>:
static
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
  4027a0:	b508      	push	{r3, lr}
	if (!fs || !fs->fs_type || fs->id != id)
  4027a2:	b108      	cbz	r0, 4027a8 <validate+0x8>
  4027a4:	7803      	ldrb	r3, [r0, #0]
  4027a6:	b90b      	cbnz	r3, 4027ac <validate+0xc>
		return FR_INVALID_OBJECT;
  4027a8:	2009      	movs	r0, #9

	if (disk_status(fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
}
  4027aa:	bd08      	pop	{r3, pc}
FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
	FATFS *fs,		/* Pointer to the file system object */
	WORD id			/* Member id of the target object to be checked */
)
{
	if (!fs || !fs->fs_type || fs->id != id)
  4027ac:	88c3      	ldrh	r3, [r0, #6]
  4027ae:	428b      	cmp	r3, r1
  4027b0:	d1fa      	bne.n	4027a8 <validate+0x8>
		return FR_INVALID_OBJECT;

	ENTER_FF(fs);		/* Lock file system */

	if (disk_status(fs->drv) & STA_NOINIT)
  4027b2:	4b04      	ldr	r3, [pc, #16]	; (4027c4 <validate+0x24>)
  4027b4:	7840      	ldrb	r0, [r0, #1]
  4027b6:	4798      	blx	r3
  4027b8:	f010 0f01 	tst.w	r0, #1
		return FR_NOT_READY;
  4027bc:	bf0c      	ite	eq
  4027be:	2000      	moveq	r0, #0
  4027c0:	2003      	movne	r0, #3
  4027c2:	bd08      	pop	{r3, pc}
  4027c4:	0040240d 	.word	0x0040240d

004027c8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  4027c8:	b570      	push	{r4, r5, r6, lr}
  4027ca:	4604      	mov	r4, r0
  4027cc:	460a      	mov	r2, r1
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
  4027ce:	7840      	ldrb	r0, [r0, #1]
  4027d0:	4d1d      	ldr	r5, [pc, #116]	; (402848 <check_fs+0x80>)
  4027d2:	f104 0130 	add.w	r1, r4, #48	; 0x30
  4027d6:	2301      	movs	r3, #1
  4027d8:	47a8      	blx	r5
  4027da:	b108      	cbz	r0, 4027e0 <check_fs+0x18>
		return 3;
  4027dc:	2003      	movs	r0, #3
  4027de:	bd70      	pop	{r4, r5, r6, pc}
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
  4027e0:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  4027e4:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e
  4027e8:	4b18      	ldr	r3, [pc, #96]	; (40284c <check_fs+0x84>)
  4027ea:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  4027ee:	b212      	sxth	r2, r2
  4027f0:	429a      	cmp	r2, r3
  4027f2:	d001      	beq.n	4027f8 <check_fs+0x30>
		return 2;
  4027f4:	2002      	movs	r0, #2
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
  4027f6:	bd70      	pop	{r4, r5, r6, pc}
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
  4027f8:	f894 2068 	ldrb.w	r2, [r4, #104]	; 0x68
  4027fc:	f894 6069 	ldrb.w	r6, [r4, #105]	; 0x69
  402800:	f894 5066 	ldrb.w	r5, [r4, #102]	; 0x66
  402804:	f894 1067 	ldrb.w	r1, [r4, #103]	; 0x67
  402808:	4b11      	ldr	r3, [pc, #68]	; (402850 <check_fs+0x88>)
  40280a:	0412      	lsls	r2, r2, #16
  40280c:	ea42 6206 	orr.w	r2, r2, r6, lsl #24
  402810:	432a      	orrs	r2, r5
  402812:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  402816:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
  40281a:	429a      	cmp	r2, r3
  40281c:	d0eb      	beq.n	4027f6 <check_fs+0x2e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
  40281e:	f894 2084 	ldrb.w	r2, [r4, #132]	; 0x84
  402822:	f894 5085 	ldrb.w	r5, [r4, #133]	; 0x85
  402826:	f894 1082 	ldrb.w	r1, [r4, #130]	; 0x82
  40282a:	f894 0083 	ldrb.w	r0, [r4, #131]	; 0x83
  40282e:	0412      	lsls	r2, r2, #16
  402830:	ea42 6205 	orr.w	r2, r2, r5, lsl #24
  402834:	430a      	orrs	r2, r1
  402836:	ea42 2000 	orr.w	r0, r2, r0, lsl #8
  40283a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		return 0;
  40283e:	1ac0      	subs	r0, r0, r3
  402840:	bf18      	it	ne
  402842:	2001      	movne	r0, #1
  402844:	bd70      	pop	{r4, r5, r6, pc}
  402846:	bf00      	nop
  402848:	00402425 	.word	0x00402425
  40284c:	ffffaa55 	.word	0xffffaa55
  402850:	00544146 	.word	0x00544146

00402854 <chk_mounted>:
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402854:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	BYTE fmt, b, pi, *tbl;
	UINT vol;
	DSTATUS stat;
	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
	WORD nrsv;
	const TCHAR *p = *path;
  402858:	6803      	ldr	r3, [r0, #0]
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
  40285a:	781c      	ldrb	r4, [r3, #0]
  40285c:	3c30      	subs	r4, #48	; 0x30
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  40285e:	2c09      	cmp	r4, #9
FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
	FATFS **rfs,		/* Pointer to pointer to the found file system object */
	BYTE chk_wp			/* !=0: Check media write protection for write access */
)
{
  402860:	4615      	mov	r5, r2
	const TCHAR *p = *path;
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
  402862:	d802      	bhi.n	40286a <chk_mounted+0x16>
  402864:	785a      	ldrb	r2, [r3, #1]
  402866:	2a3a      	cmp	r2, #58	; 0x3a
  402868:	d015      	beq.n	402896 <chk_mounted+0x42>
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
  40286a:	4bbd      	ldr	r3, [pc, #756]	; (402b60 <chk_mounted+0x30c>)
  40286c:	681c      	ldr	r4, [r3, #0]
  40286e:	600c      	str	r4, [r1, #0]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  402870:	b174      	cbz	r4, 402890 <chk_mounted+0x3c>

	ENTER_FF(fs);						/* Lock file system */

	if (fs->fs_type) {					/* If the logical drive has been mounted */
  402872:	7823      	ldrb	r3, [r4, #0]
  402874:	b1b3      	cbz	r3, 4028a4 <chk_mounted+0x50>
		stat = disk_status(fs->drv);
  402876:	4bbb      	ldr	r3, [pc, #748]	; (402b64 <chk_mounted+0x310>)
  402878:	7860      	ldrb	r0, [r4, #1]
  40287a:	4798      	blx	r3
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
  40287c:	07c3      	lsls	r3, r0, #31
  40287e:	d411      	bmi.n	4028a4 <chk_mounted+0x50>
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
  402880:	b305      	cbz	r5, 4028c4 <chk_mounted+0x70>
				return FR_WRITE_PROTECTED;
  402882:	f010 0f04 	tst.w	r0, #4
  402886:	bf0c      	ite	eq
  402888:	2000      	moveq	r0, #0
  40288a:	200a      	movne	r0, #10
  40288c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
  402890:	200c      	movs	r0, #12
  402892:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	FATFS *fs;

	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
		p += 2; *path = p;				/* Return pointer to the path name */
  402896:	3302      	adds	r3, #2
  402898:	6003      	str	r3, [r0, #0]
		vol = 0;						/* Use drive 0 */
#endif
	}

	/* Check if the file system object is valid or not */
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
  40289a:	2c00      	cmp	r4, #0
  40289c:	d0e5      	beq.n	40286a <chk_mounted+0x16>
		return FR_INVALID_DRIVE;
  40289e:	200b      	movs	r0, #11
  4028a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
  4028a4:	2000      	movs	r0, #0
  4028a6:	7020      	strb	r0, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
  4028a8:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
  4028aa:	4baf      	ldr	r3, [pc, #700]	; (402b68 <chk_mounted+0x314>)
  4028ac:	4798      	blx	r3
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
  4028ae:	07c7      	lsls	r7, r0, #31
  4028b0:	d502      	bpl.n	4028b8 <chk_mounted+0x64>
		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
  4028b2:	2003      	movs	r0, #3
  4028b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
  4028b8:	b13d      	cbz	r5, 4028ca <chk_mounted+0x76>
  4028ba:	0746      	lsls	r6, r0, #29
  4028bc:	d505      	bpl.n	4028ca <chk_mounted+0x76>
		return FR_WRITE_PROTECTED;
  4028be:	200a      	movs	r0, #10
  4028c0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fs->fs_type) {					/* If the logical drive has been mounted */
		stat = disk_status(fs->drv);
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
				return FR_WRITE_PROTECTED;
			return FR_OK;				/* The file system object is valid */
  4028c4:	4628      	mov	r0, r5
  4028c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4028ca:	4620      	mov	r0, r4
  4028cc:	2100      	movs	r1, #0
  4028ce:	4da7      	ldr	r5, [pc, #668]	; (402b6c <chk_mounted+0x318>)
  4028d0:	47a8      	blx	r5
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
  4028d2:	2801      	cmp	r0, #1
  4028d4:	d007      	beq.n	4028e6 <chk_mounted+0x92>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
  4028d6:	2600      	movs	r6, #0
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  4028d8:	2803      	cmp	r0, #3
  4028da:	f000 80bf 	beq.w	402a5c <chk_mounted+0x208>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
  4028de:	b1c0      	cbz	r0, 402912 <chk_mounted+0xbe>
  4028e0:	200d      	movs	r0, #13
  4028e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
  4028e6:	f894 31f2 	ldrb.w	r3, [r4, #498]	; 0x1f2
  4028ea:	2b00      	cmp	r3, #0
  4028ec:	d0f8      	beq.n	4028e0 <chk_mounted+0x8c>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
  4028ee:	f894 21f8 	ldrb.w	r2, [r4, #504]	; 0x1f8
  4028f2:	f894 11f9 	ldrb.w	r1, [r4, #505]	; 0x1f9
  4028f6:	f894 31f6 	ldrb.w	r3, [r4, #502]	; 0x1f6
  4028fa:	f894 61f7 	ldrb.w	r6, [r4, #503]	; 0x1f7
  4028fe:	0412      	lsls	r2, r2, #16
  402900:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
  402904:	4313      	orrs	r3, r2
  402906:	ea43 2606 	orr.w	r6, r3, r6, lsl #8
			fmt = check_fs(fs, bsect);		/* Check the partition */
  40290a:	4631      	mov	r1, r6
  40290c:	4620      	mov	r0, r4
  40290e:	47a8      	blx	r5
  402910:	e7e2      	b.n	4028d8 <chk_mounted+0x84>
	if (fmt == 3) return FR_DISK_ERR;
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
  402912:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
  402916:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
  40291a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40291e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  402922:	d1dd      	bne.n	4028e0 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
  402924:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
  402928:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
  40292c:	ea53 2101 	orrs.w	r1, r3, r1, lsl #8
  402930:	d10d      	bne.n	40294e <chk_mounted+0xfa>
  402932:	f894 2056 	ldrb.w	r2, [r4, #86]	; 0x56
  402936:	f894 0057 	ldrb.w	r0, [r4, #87]	; 0x57
  40293a:	f894 3054 	ldrb.w	r3, [r4, #84]	; 0x54
  40293e:	f894 1055 	ldrb.w	r1, [r4, #85]	; 0x55
  402942:	0412      	lsls	r2, r2, #16
  402944:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
  402948:	4313      	orrs	r3, r2
  40294a:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  40294e:	f894 0040 	ldrb.w	r0, [r4, #64]	; 0x40
	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;
  402952:	61e1      	str	r1, [r4, #28]

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  402954:	1e43      	subs	r3, r0, #1
  402956:	2b01      	cmp	r3, #1

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
  402958:	70e0      	strb	r0, [r4, #3]
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
  40295a:	d8c1      	bhi.n	4028e0 <chk_mounted+0x8c>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
  40295c:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
  402960:	70a3      	strb	r3, [r4, #2]
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
  402962:	2b00      	cmp	r3, #0
  402964:	d0bc      	beq.n	4028e0 <chk_mounted+0x8c>
  402966:	1e5a      	subs	r2, r3, #1
  402968:	421a      	tst	r2, r3
  40296a:	d1b9      	bne.n	4028e0 <chk_mounted+0x8c>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  40296c:	f894 5042 	ldrb.w	r5, [r4, #66]	; 0x42
  402970:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
  402974:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  402978:	0715      	lsls	r5, r2, #28
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
  40297a:	8122      	strh	r2, [r4, #8]
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
  40297c:	d1b0      	bne.n	4028e0 <chk_mounted+0x8c>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
  40297e:	f894 7044 	ldrb.w	r7, [r4, #68]	; 0x44
  402982:	f894 5043 	ldrb.w	r5, [r4, #67]	; 0x43
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
  402986:	ea55 2507 	orrs.w	r5, r5, r7, lsl #8
  40298a:	d10f      	bne.n	4029ac <chk_mounted+0x158>
  40298c:	f894 c052 	ldrb.w	ip, [r4, #82]	; 0x52
  402990:	f894 8053 	ldrb.w	r8, [r4, #83]	; 0x53
  402994:	f894 5050 	ldrb.w	r5, [r4, #80]	; 0x50
  402998:	f894 7051 	ldrb.w	r7, [r4, #81]	; 0x51
  40299c:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
  4029a0:	ea4c 6c08 	orr.w	ip, ip, r8, lsl #24
  4029a4:	ea4c 0505 	orr.w	r5, ip, r5
  4029a8:	ea45 2507 	orr.w	r5, r5, r7, lsl #8

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
  4029ac:	f894 c03f 	ldrb.w	ip, [r4, #63]	; 0x3f
  4029b0:	f894 703e 	ldrb.w	r7, [r4, #62]	; 0x3e
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
  4029b4:	ea57 270c 	orrs.w	r7, r7, ip, lsl #8
  4029b8:	d092      	beq.n	4028e0 <chk_mounted+0x8c>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
  4029ba:	fb00 fc01 	mul.w	ip, r0, r1

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
  4029be:	eb07 1012 	add.w	r0, r7, r2, lsr #4
  4029c2:	4460      	add	r0, ip
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
  4029c4:	4285      	cmp	r5, r0
  4029c6:	d38b      	bcc.n	4028e0 <chk_mounted+0x8c>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
  4029c8:	1a2d      	subs	r5, r5, r0
  4029ca:	fbb5 f3f3 	udiv	r3, r5, r3
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
  4029ce:	2b00      	cmp	r3, #0
  4029d0:	d086      	beq.n	4028e0 <chk_mounted+0x8c>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4029d2:	f640 75f5 	movw	r5, #4085	; 0xff5
  4029d6:	42ab      	cmp	r3, r5
  4029d8:	f240 80c0 	bls.w	402b5c <chk_mounted+0x308>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  4029dc:	f64f 75f5 	movw	r5, #65525	; 0xfff5
  4029e0:	42ab      	cmp	r3, r5
  4029e2:	f200 80a0 	bhi.w	402b26 <chk_mounted+0x2d2>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
  4029e6:	2502      	movs	r5, #2
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4029e8:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  4029ea:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4029ec:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  4029ee:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  4029f0:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  4029f2:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
  4029f4:	2a00      	cmp	r2, #0
  4029f6:	f43f af73 	beq.w	4028e0 <chk_mounted+0x8c>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4029fa:	4467      	add	r7, ip
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  4029fc:	2d02      	cmp	r5, #2
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
  4029fe:	6267      	str	r7, [r4, #36]	; 0x24
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402a00:	f000 808f 	beq.w	402b22 <chk_mounted+0x2ce>
  402a04:	eb03 0243 	add.w	r2, r3, r3, lsl #1
  402a08:	f003 0301 	and.w	r3, r3, #1
  402a0c:	eb03 0352 	add.w	r3, r3, r2, lsr #1
  402a10:	2501      	movs	r5, #1
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
  402a12:	f203 13ff 	addw	r3, r3, #511	; 0x1ff
  402a16:	ebb1 2f53 	cmp.w	r1, r3, lsr #9
  402a1a:	f4ff af61 	bcc.w	4028e0 <chk_mounted+0x8c>
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  402a1e:	f04f 32ff 	mov.w	r2, #4294967295
	fs->last_clust = 0;
  402a22:	2300      	movs	r3, #0

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  402a24:	2d03      	cmp	r5, #3
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;

#if !_FS_READONLY
	/* Initialize cluster allocation information */
	fs->free_clust = 0xFFFFFFFF;
  402a26:	6122      	str	r2, [r4, #16]
	fs->last_clust = 0;
  402a28:	60e3      	str	r3, [r4, #12]

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
  402a2a:	d01a      	beq.n	402a62 <chk_mounted+0x20e>
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402a2c:	4e50      	ldr	r6, [pc, #320]	; (402b70 <chk_mounted+0x31c>)
  402a2e:	4951      	ldr	r1, [pc, #324]	; (402b74 <chk_mounted+0x320>)
  402a30:	8830      	ldrh	r0, [r6, #0]
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
  402a32:	7025      	strb	r5, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
  402a34:	3001      	adds	r0, #1
	fs->winsect = 0;		/* Invalidate sector cache */
  402a36:	2200      	movs	r2, #0
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
  402a38:	b280      	uxth	r0, r0
  402a3a:	8030      	strh	r0, [r6, #0]
  402a3c:	80e0      	strh	r0, [r4, #6]
	fs->winsect = 0;		/* Invalidate sector cache */
	fs->wflag = 0;
  402a3e:	4613      	mov	r3, r2
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
	fs->id = ++Fsid;		/* File system mount ID */
	fs->winsect = 0;		/* Invalidate sector cache */
  402a40:	62e2      	str	r2, [r4, #44]	; 0x2c
	fs->wflag = 0;
  402a42:	7122      	strb	r2, [r4, #4]
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  402a44:	4615      	mov	r5, r2
  402a46:	4608      	mov	r0, r1
  402a48:	58ca      	ldr	r2, [r1, r3]
  402a4a:	4294      	cmp	r4, r2
  402a4c:	bf08      	it	eq
  402a4e:	501d      	streq	r5, [r3, r0]
  402a50:	330c      	adds	r3, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  402a52:	2b24      	cmp	r3, #36	; 0x24
  402a54:	d1f8      	bne.n	402a48 <chk_mounted+0x1f4>
#endif
#if _FS_SHARE				/* Clear file lock semaphores */
	clear_lock(fs);
#endif

	return FR_OK;
  402a56:	2000      	movs	r0, #0
  402a58:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
  402a5c:	2001      	movs	r0, #1
  402a5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402a62:	f894 1061 	ldrb.w	r1, [r4, #97]	; 0x61
  402a66:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
	fs->free_clust = 0xFFFFFFFF;
	fs->last_clust = 0;

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
  402a6a:	7163      	strb	r3, [r4, #5]
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
  402a6c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  402a70:	4432      	add	r2, r6
  402a72:	6162      	str	r2, [r4, #20]
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a74:	7860      	ldrb	r0, [r4, #1]
  402a76:	4e40      	ldr	r6, [pc, #256]	; (402b78 <chk_mounted+0x324>)
  402a78:	f104 0130 	add.w	r1, r4, #48	; 0x30
  402a7c:	2301      	movs	r3, #1
  402a7e:	47b0      	blx	r6
  402a80:	2800      	cmp	r0, #0
  402a82:	d1d3      	bne.n	402a2c <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a84:	f894 122f 	ldrb.w	r1, [r4, #559]	; 0x22f
  402a88:	f894 222e 	ldrb.w	r2, [r4, #558]	; 0x22e

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a8c:	4b3b      	ldr	r3, [pc, #236]	; (402b7c <chk_mounted+0x328>)
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402a8e:	ea42 2201 	orr.w	r2, r2, r1, lsl #8

	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
  402a92:	b212      	sxth	r2, r2
  402a94:	429a      	cmp	r2, r3
  402a96:	d1c9      	bne.n	402a2c <chk_mounted+0x1d8>
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402a98:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
  402a9c:	f894 6033 	ldrb.w	r6, [r4, #51]	; 0x33
  402aa0:	f894 2030 	ldrb.w	r2, [r4, #48]	; 0x30
  402aa4:	f894 1031 	ldrb.w	r1, [r4, #49]	; 0x31
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402aa8:	4b35      	ldr	r3, [pc, #212]	; (402b80 <chk_mounted+0x32c>)
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402aaa:	0400      	lsls	r0, r0, #16
  402aac:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
  402ab0:	4302      	orrs	r2, r0
  402ab2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	/* Get fsinfo if available */
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
  402ab6:	429a      	cmp	r2, r3
  402ab8:	d1b8      	bne.n	402a2c <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402aba:	f894 0216 	ldrb.w	r0, [r4, #534]	; 0x216
  402abe:	f894 6217 	ldrb.w	r6, [r4, #535]	; 0x217
  402ac2:	f894 2214 	ldrb.w	r2, [r4, #532]	; 0x214
  402ac6:	f894 1215 	ldrb.w	r1, [r4, #533]	; 0x215
  402aca:	0400      	lsls	r0, r0, #16
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402acc:	f103 53ff 	add.w	r3, r3, #534773760	; 0x1fe00000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402ad0:	ea40 6006 	orr.w	r0, r0, r6, lsl #24
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402ad4:	f503 5300 	add.w	r3, r3, #8192	; 0x2000
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402ad8:	4302      	orrs	r2, r0
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402ada:	3320      	adds	r3, #32
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
  402adc:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	if (fmt == FS_FAT32) {
	 	fs->fsi_flag = 0;
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
  402ae0:	429a      	cmp	r2, r3
  402ae2:	d1a3      	bne.n	402a2c <chk_mounted+0x1d8>
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402ae4:	f894 721e 	ldrb.w	r7, [r4, #542]	; 0x21e
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402ae8:	f894 621a 	ldrb.w	r6, [r4, #538]	; 0x21a
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402aec:	f894 821f 	ldrb.w	r8, [r4, #543]	; 0x21f
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402af0:	f894 c21b 	ldrb.w	ip, [r4, #539]	; 0x21b
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402af4:	f894 221c 	ldrb.w	r2, [r4, #540]	; 0x21c
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402af8:	f894 3218 	ldrb.w	r3, [r4, #536]	; 0x218
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402afc:	f894 021d 	ldrb.w	r0, [r4, #541]	; 0x21d
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b00:	f894 1219 	ldrb.w	r1, [r4, #537]	; 0x219
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402b04:	043f      	lsls	r7, r7, #16
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b06:	0436      	lsls	r6, r6, #16
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402b08:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b0c:	ea46 660c 	orr.w	r6, r6, ip, lsl #24
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402b10:	433a      	orrs	r2, r7
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b12:	4333      	orrs	r3, r6
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402b14:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b18:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
  402b1c:	60e2      	str	r2, [r4, #12]
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
  402b1e:	6123      	str	r3, [r4, #16]
  402b20:	e784      	b.n	402a2c <chk_mounted+0x1d8>
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
  402b22:	005b      	lsls	r3, r3, #1
  402b24:	e775      	b.n	402a12 <chk_mounted+0x1be>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402b26:	3302      	adds	r3, #2
	fs->database = bsect + sysect;						/* Data start sector */
  402b28:	4430      	add	r0, r6
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402b2a:	4437      	add	r7, r6
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
  402b2c:	61a3      	str	r3, [r4, #24]
	fs->database = bsect + sysect;						/* Data start sector */
  402b2e:	62a0      	str	r0, [r4, #40]	; 0x28
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
  402b30:	6227      	str	r7, [r4, #32]
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
  402b32:	2a00      	cmp	r2, #0
  402b34:	f47f aed4 	bne.w	4028e0 <chk_mounted+0x8c>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402b38:	f894 505e 	ldrb.w	r5, [r4, #94]	; 0x5e
  402b3c:	f894 705f 	ldrb.w	r7, [r4, #95]	; 0x5f
  402b40:	f894 205c 	ldrb.w	r2, [r4, #92]	; 0x5c
  402b44:	f894 005d 	ldrb.w	r0, [r4, #93]	; 0x5d
  402b48:	042d      	lsls	r5, r5, #16
  402b4a:	ea45 6507 	orr.w	r5, r5, r7, lsl #24
  402b4e:	432a      	orrs	r2, r5
  402b50:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
  402b54:	009b      	lsls	r3, r3, #2
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
	fs->database = bsect + sysect;						/* Data start sector */
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
	if (fmt == FS_FAT32) {
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
  402b56:	6262      	str	r2, [r4, #36]	; 0x24
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
  402b58:	2503      	movs	r5, #3
  402b5a:	e75a      	b.n	402a12 <chk_mounted+0x1be>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
  402b5c:	2501      	movs	r5, #1
  402b5e:	e743      	b.n	4029e8 <chk_mounted+0x194>
  402b60:	20000f8c 	.word	0x20000f8c
  402b64:	0040240d 	.word	0x0040240d
  402b68:	004023c9 	.word	0x004023c9
  402b6c:	004027c9 	.word	0x004027c9
  402b70:	20000f64 	.word	0x20000f64
  402b74:	20000f68 	.word	0x20000f68
  402b78:	00402425 	.word	0x00402425
  402b7c:	ffffaa55 	.word	0xffffaa55
  402b80:	41615252 	.word	0x41615252

00402b84 <get_fat.part.3>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  402b84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  402b88:	7803      	ldrb	r3, [r0, #0]
  402b8a:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


static DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
  402b8c:	4604      	mov	r4, r0
  402b8e:	460d      	mov	r5, r1


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
  402b90:	d048      	beq.n	402c24 <get_fat.part.3+0xa0>
  402b92:	2b03      	cmp	r3, #3
  402b94:	d029      	beq.n	402bea <get_fat.part.3+0x66>
  402b96:	2b01      	cmp	r3, #1
  402b98:	d003      	beq.n	402ba2 <get_fat.part.3+0x1e>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
  402b9a:	f04f 30ff 	mov.w	r0, #4294967295
}
  402b9e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402ba2:	6a01      	ldr	r1, [r0, #32]
  402ba4:	4f29      	ldr	r7, [pc, #164]	; (402c4c <get_fat.part.3+0xc8>)
	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
		return 1;

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
  402ba6:	eb05 0655 	add.w	r6, r5, r5, lsr #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402baa:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402bae:	47b8      	blx	r7
  402bb0:	2800      	cmp	r0, #0
  402bb2:	d1f2      	bne.n	402b9a <get_fat.part.3+0x16>
		wc = fs->win[bc % SS(fs)]; bc++;
  402bb4:	f3c6 0308 	ubfx	r3, r6, #0, #9
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402bb8:	6a21      	ldr	r1, [r4, #32]

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  402bba:	4423      	add	r3, r4
  402bbc:	3601      	adds	r6, #1
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402bbe:	eb01 2156 	add.w	r1, r1, r6, lsr #9
  402bc2:	4620      	mov	r0, r4

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
  402bc4:	f893 8030 	ldrb.w	r8, [r3, #48]	; 0x30
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
  402bc8:	47b8      	blx	r7
  402bca:	2800      	cmp	r0, #0
  402bcc:	d1e5      	bne.n	402b9a <get_fat.part.3+0x16>
		wc |= fs->win[bc % SS(fs)] << 8;
  402bce:	f3c6 0608 	ubfx	r6, r6, #0, #9
  402bd2:	4434      	add	r4, r6
  402bd4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402bd8:	ea48 2003 	orr.w	r0, r8, r3, lsl #8
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
  402bdc:	07eb      	lsls	r3, r5, #31
  402bde:	bf4c      	ite	mi
  402be0:	0900      	lsrmi	r0, r0, #4
  402be2:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
  402be6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
		p = &fs->win[clst * 2 % SS(fs)];
		return LD_WORD(p);

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
  402bea:	6a01      	ldr	r1, [r0, #32]
  402bec:	4b17      	ldr	r3, [pc, #92]	; (402c4c <get_fat.part.3+0xc8>)
  402bee:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402bf2:	4798      	blx	r3
  402bf4:	2800      	cmp	r0, #0
  402bf6:	d1d0      	bne.n	402b9a <get_fat.part.3+0x16>
		p = &fs->win[clst * 4 % SS(fs)];
  402bf8:	00ad      	lsls	r5, r5, #2
  402bfa:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402bfe:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402c02:	4423      	add	r3, r4
		return LD_DWORD(p) & 0x0FFFFFFF;
  402c04:	442c      	add	r4, r5
  402c06:	78d8      	ldrb	r0, [r3, #3]
  402c08:	7899      	ldrb	r1, [r3, #2]
  402c0a:	785a      	ldrb	r2, [r3, #1]
  402c0c:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
  402c10:	0600      	lsls	r0, r0, #24
  402c12:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
  402c16:	ea40 2002 	orr.w	r0, r0, r2, lsl #8
  402c1a:	4318      	orrs	r0, r3
  402c1c:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
  402c20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
  402c24:	6a01      	ldr	r1, [r0, #32]
  402c26:	4b09      	ldr	r3, [pc, #36]	; (402c4c <get_fat.part.3+0xc8>)
  402c28:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402c2c:	4798      	blx	r3
  402c2e:	2800      	cmp	r0, #0
  402c30:	d1b3      	bne.n	402b9a <get_fat.part.3+0x16>
		p = &fs->win[clst * 2 % SS(fs)];
  402c32:	006d      	lsls	r5, r5, #1
  402c34:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
		return LD_WORD(p);
  402c38:	1963      	adds	r3, r4, r5
  402c3a:	461c      	mov	r4, r3
  402c3c:	f893 3030 	ldrb.w	r3, [r3, #48]	; 0x30
  402c40:	f894 0031 	ldrb.w	r0, [r4, #49]	; 0x31
  402c44:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
  402c48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402c4c:	00402645 	.word	0x00402645

00402c50 <dir_sdi>:
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	DWORD clst;
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
  402c52:	6883      	ldr	r3, [r0, #8]
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c54:	4604      	mov	r4, r0
	WORD ic;


	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402c56:	2b01      	cmp	r3, #1
static
FRESULT dir_sdi (
	DIR *dj,		/* Pointer to directory object */
	WORD idx		/* Directory index number */
)
{
  402c58:	460d      	mov	r5, r1
	DWORD clst;
	WORD ic;


	dj->index = idx;
  402c5a:	80e1      	strh	r1, [r4, #6]
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
  402c5c:	d003      	beq.n	402c66 <dir_sdi+0x16>
  402c5e:	6800      	ldr	r0, [r0, #0]
  402c60:	6982      	ldr	r2, [r0, #24]
  402c62:	4293      	cmp	r3, r2
  402c64:	d301      	bcc.n	402c6a <dir_sdi+0x1a>
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
  402c66:	2002      	movs	r0, #2
  402c68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
  402c6a:	b9b3      	cbnz	r3, 402c9a <dir_sdi+0x4a>
  402c6c:	7803      	ldrb	r3, [r0, #0]
  402c6e:	2b03      	cmp	r3, #3
  402c70:	d010      	beq.n	402c94 <dir_sdi+0x44>
		clst = dj->fs->dirbase;

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
		dj->clust = clst;
  402c72:	2300      	movs	r3, #0
  402c74:	60e3      	str	r3, [r4, #12]
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
  402c76:	8903      	ldrh	r3, [r0, #8]
  402c78:	42ab      	cmp	r3, r5
  402c7a:	d9f4      	bls.n	402c66 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402c7c:	6a43      	ldr	r3, [r0, #36]	; 0x24
  402c7e:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402c82:	6123      	str	r3, [r4, #16]
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
  402c84:	f005 050f 	and.w	r5, r5, #15
  402c88:	eb00 1045 	add.w	r0, r0, r5, lsl #5
  402c8c:	3030      	adds	r0, #48	; 0x30
  402c8e:	6160      	str	r0, [r4, #20]

	return FR_OK;	/* Seek succeeded */
  402c90:	2000      	movs	r0, #0
  402c92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	dj->index = idx;
	clst = dj->sclust;
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
		clst = dj->fs->dirbase;
  402c94:	6a43      	ldr	r3, [r0, #36]	; 0x24

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
  402c96:	2b00      	cmp	r3, #0
  402c98:	d0eb      	beq.n	402c72 <dir_sdi+0x22>
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
  402c9a:	7886      	ldrb	r6, [r0, #2]
  402c9c:	0136      	lsls	r6, r6, #4
		while (idx >= ic) {	/* Follow cluster chain */
  402c9e:	42b5      	cmp	r5, r6
  402ca0:	d319      	bcc.n	402cd6 <dir_sdi+0x86>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402ca2:	2b01      	cmp	r3, #1
  402ca4:	d9df      	bls.n	402c66 <dir_sdi+0x16>
  402ca6:	1bad      	subs	r5, r5, r6
  402ca8:	429a      	cmp	r2, r3
  402caa:	b2ad      	uxth	r5, r5
  402cac:	d9db      	bls.n	402c66 <dir_sdi+0x16>
  402cae:	4f11      	ldr	r7, [pc, #68]	; (402cf4 <dir_sdi+0xa4>)
  402cb0:	e008      	b.n	402cc4 <dir_sdi+0x74>
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
  402cb2:	2801      	cmp	r0, #1
  402cb4:	d9d7      	bls.n	402c66 <dir_sdi+0x16>
  402cb6:	6820      	ldr	r0, [r4, #0]
  402cb8:	6982      	ldr	r2, [r0, #24]
  402cba:	429a      	cmp	r2, r3
  402cbc:	d9d3      	bls.n	402c66 <dir_sdi+0x16>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
  402cbe:	42ae      	cmp	r6, r5
  402cc0:	d809      	bhi.n	402cd6 <dir_sdi+0x86>
  402cc2:	460d      	mov	r5, r1
  402cc4:	4619      	mov	r1, r3
  402cc6:	47b8      	blx	r7
  402cc8:	1ba9      	subs	r1, r5, r6
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
  402cca:	1c42      	adds	r2, r0, #1
  402ccc:	4603      	mov	r3, r0
  402cce:	b289      	uxth	r1, r1
  402cd0:	d1ef      	bne.n	402cb2 <dir_sdi+0x62>
  402cd2:	2001      	movs	r0, #1
  402cd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
  402cd6:	60e3      	str	r3, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cd8:	6982      	ldr	r2, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402cda:	3b02      	subs	r3, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402cdc:	3a02      	subs	r2, #2
  402cde:	4293      	cmp	r3, r2
	return clst * fs->csize + fs->database;
  402ce0:	bf3b      	ittet	cc
  402ce2:	7881      	ldrbcc	r1, [r0, #2]
  402ce4:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402ce6:	2300      	movcs	r3, #0
	return clst * fs->csize + fs->database;
  402ce8:	fb01 2303 	mlacc	r3, r1, r3, r2
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
  402cec:	eb03 1315 	add.w	r3, r3, r5, lsr #4
  402cf0:	6123      	str	r3, [r4, #16]
  402cf2:	e7c7      	b.n	402c84 <dir_sdi+0x34>
  402cf4:	00402b85 	.word	0x00402b85

00402cf8 <put_fat.part.4>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402cf8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402cfc:	7803      	ldrb	r3, [r0, #0]
  402cfe:	2b02      	cmp	r3, #2
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

static FRESULT put_fat (
  402d00:	4604      	mov	r4, r0
  402d02:	460d      	mov	r5, r1
  402d04:	4616      	mov	r6, r2

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
  402d06:	d05b      	beq.n	402dc0 <put_fat.part.4+0xc8>
  402d08:	2b03      	cmp	r3, #3
  402d0a:	d039      	beq.n	402d80 <put_fat.part.4+0x88>
  402d0c:	2b01      	cmp	r3, #1
  402d0e:	d004      	beq.n	402d1a <put_fat.part.4+0x22>
			val |= LD_DWORD(p) & 0xF0000000;
			ST_DWORD(p, val);
			break;

		default :
			res = FR_INT_ERR;
  402d10:	2002      	movs	r0, #2
		}
		fs->wflag = 1;
  402d12:	2301      	movs	r3, #1
  402d14:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402d16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d1a:	6a01      	ldr	r1, [r0, #32]
  402d1c:	f8df 80d4 	ldr.w	r8, [pc, #212]	; 402df4 <put_fat.part.4+0xfc>
		res = FR_INT_ERR;

	} else {
		switch (fs->fs_type) {
		case FS_FAT12 :
			bc = clst; bc += bc / 2;
  402d20:	eb05 0755 	add.w	r7, r5, r5, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d24:	eb01 2157 	add.w	r1, r1, r7, lsr #9
  402d28:	47c0      	blx	r8
			if (res != FR_OK) break;
  402d2a:	2800      	cmp	r0, #0
  402d2c:	d1f1      	bne.n	402d12 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402d2e:	f3c7 0308 	ubfx	r3, r7, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
  402d32:	f015 0501 	ands.w	r5, r5, #1
  402d36:	4423      	add	r3, r4
  402d38:	b2f2      	uxtb	r2, r6
  402d3a:	d006      	beq.n	402d4a <put_fat.part.4+0x52>
  402d3c:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
  402d40:	f001 010f 	and.w	r1, r1, #15
  402d44:	ea41 1202 	orr.w	r2, r1, r2, lsl #4
  402d48:	b2d2      	uxtb	r2, r2
  402d4a:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d4e:	6a21      	ldr	r1, [r4, #32]
			bc = clst; bc += bc / 2;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
  402d50:	3701      	adds	r7, #1
			fs->wflag = 1;
  402d52:	2301      	movs	r3, #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d54:	eb01 2157 	add.w	r1, r1, r7, lsr #9
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
			bc++;
			fs->wflag = 1;
  402d58:	7123      	strb	r3, [r4, #4]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
  402d5a:	4620      	mov	r0, r4
  402d5c:	47c0      	blx	r8
			if (res != FR_OK) break;
  402d5e:	2800      	cmp	r0, #0
  402d60:	d1d7      	bne.n	402d12 <put_fat.part.4+0x1a>
			p = &fs->win[bc % SS(fs)];
  402d62:	f3c7 0708 	ubfx	r7, r7, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402d66:	2d00      	cmp	r5, #0
  402d68:	d13f      	bne.n	402dea <put_fat.part.4+0xf2>
  402d6a:	4427      	add	r7, r4
  402d6c:	f3c6 2603 	ubfx	r6, r6, #8, #4
  402d70:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
  402d74:	f023 030f 	bic.w	r3, r3, #15
  402d78:	431e      	orrs	r6, r3
  402d7a:	f887 6030 	strb.w	r6, [r7, #48]	; 0x30
  402d7e:	e7c8      	b.n	402d12 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
			break;

		case FS_FAT32 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
  402d80:	6a01      	ldr	r1, [r0, #32]
  402d82:	4b1c      	ldr	r3, [pc, #112]	; (402df4 <put_fat.part.4+0xfc>)
  402d84:	eb01 11d5 	add.w	r1, r1, r5, lsr #7
  402d88:	4798      	blx	r3
			if (res != FR_OK) break;
  402d8a:	2800      	cmp	r0, #0
  402d8c:	d1c1      	bne.n	402d12 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 4 % SS(fs)];
  402d8e:	00ad      	lsls	r5, r5, #2
  402d90:	f405 75fe 	and.w	r5, r5, #508	; 0x1fc
  402d94:	f105 0330 	add.w	r3, r5, #48	; 0x30
  402d98:	4423      	add	r3, r4
			val |= LD_DWORD(p) & 0xF0000000;
  402d9a:	4425      	add	r5, r4
  402d9c:	78da      	ldrb	r2, [r3, #3]
  402d9e:	0612      	lsls	r2, r2, #24
  402da0:	f002 4270 	and.w	r2, r2, #4026531840	; 0xf0000000
  402da4:	4316      	orrs	r6, r2
			ST_DWORD(p, val);
  402da6:	f3c6 2707 	ubfx	r7, r6, #8, #8
  402daa:	0c31      	lsrs	r1, r6, #16
  402dac:	0e32      	lsrs	r2, r6, #24
  402dae:	f885 6030 	strb.w	r6, [r5, #48]	; 0x30
  402db2:	705f      	strb	r7, [r3, #1]
  402db4:	7099      	strb	r1, [r3, #2]
  402db6:	70da      	strb	r2, [r3, #3]
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402db8:	2301      	movs	r3, #1
  402dba:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402dbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
			break;

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
  402dc0:	6a01      	ldr	r1, [r0, #32]
  402dc2:	4b0c      	ldr	r3, [pc, #48]	; (402df4 <put_fat.part.4+0xfc>)
  402dc4:	eb01 2115 	add.w	r1, r1, r5, lsr #8
  402dc8:	4798      	blx	r3
			if (res != FR_OK) break;
  402dca:	2800      	cmp	r0, #0
  402dcc:	d1a1      	bne.n	402d12 <put_fat.part.4+0x1a>
			p = &fs->win[clst * 2 % SS(fs)];
  402dce:	006d      	lsls	r5, r5, #1
  402dd0:	f405 75ff 	and.w	r5, r5, #510	; 0x1fe
			ST_WORD(p, (WORD)val);
  402dd4:	1962      	adds	r2, r4, r5
  402dd6:	f3c6 2307 	ubfx	r3, r6, #8, #8
  402dda:	f882 3031 	strb.w	r3, [r2, #49]	; 0x31
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402dde:	2301      	movs	r3, #1

		case FS_FAT16 :
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
			if (res != FR_OK) break;
			p = &fs->win[clst * 2 % SS(fs)];
			ST_WORD(p, (WORD)val);
  402de0:	f882 6030 	strb.w	r6, [r2, #48]	; 0x30
			break;

		default :
			res = FR_INT_ERR;
		}
		fs->wflag = 1;
  402de4:	7123      	strb	r3, [r4, #4]
	}

	return res;
}
  402de6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			bc++;
			fs->wflag = 1;
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
			if (res != FR_OK) break;
			p = &fs->win[bc % SS(fs)];
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
  402dea:	f3c6 1607 	ubfx	r6, r6, #4, #8
  402dee:	4427      	add	r7, r4
  402df0:	e7c3      	b.n	402d7a <put_fat.part.4+0x82>
  402df2:	bf00      	nop
  402df4:	00402645 	.word	0x00402645

00402df8 <create_chain>:
static
DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
	FATFS *fs,			/* File system object */
	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
)
{
  402df8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  402dfc:	4605      	mov	r5, r0
	DWORD cs, ncl, scl;
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
  402dfe:	4688      	mov	r8, r1
  402e00:	bb01      	cbnz	r1, 402e44 <create_chain+0x4c>
		scl = fs->last_clust;			/* Get suggested start point */
  402e02:	68c6      	ldr	r6, [r0, #12]
  402e04:	6983      	ldr	r3, [r0, #24]
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402e06:	b35e      	cbz	r6, 402e60 <create_chain+0x68>
  402e08:	429e      	cmp	r6, r3
  402e0a:	bf28      	it	cs
  402e0c:	2601      	movcs	r6, #1
  402e0e:	4f2e      	ldr	r7, [pc, #184]	; (402ec8 <create_chain+0xd0>)
  402e10:	4634      	mov	r4, r6
  402e12:	e00f      	b.n	402e34 <create_chain+0x3c>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402e14:	2e01      	cmp	r6, #1
  402e16:	d925      	bls.n	402e64 <create_chain+0x6c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402e18:	2b02      	cmp	r3, #2
  402e1a:	d910      	bls.n	402e3e <create_chain+0x46>

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
  402e1c:	2402      	movs	r4, #2
  402e1e:	4628      	mov	r0, r5
  402e20:	4621      	mov	r1, r4
  402e22:	47b8      	blx	r7
			if (ncl > scl) return 0;	/* No free cluster */
		}
		cs = get_fat(fs, ncl);			/* Get the cluster status */
		if (cs == 0) break;				/* Found a free cluster */
  402e24:	b338      	cbz	r0, 402e76 <create_chain+0x7e>
		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
  402e26:	1c41      	adds	r1, r0, #1
  402e28:	d021      	beq.n	402e6e <create_chain+0x76>
  402e2a:	2801      	cmp	r0, #1
  402e2c:	d007      	beq.n	402e3e <create_chain+0x46>
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
  402e2e:	42a6      	cmp	r6, r4
  402e30:	d018      	beq.n	402e64 <create_chain+0x6c>
  402e32:	69ab      	ldr	r3, [r5, #24]
		scl = clst;
	}

	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
  402e34:	3401      	adds	r4, #1
		if (ncl >= fs->n_fatent) {		/* Wrap around */
  402e36:	429c      	cmp	r4, r3
  402e38:	d2ec      	bcs.n	402e14 <create_chain+0x1c>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402e3a:	2c01      	cmp	r4, #1
  402e3c:	d8ef      	bhi.n	402e1e <create_chain+0x26>
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402e3e:	2001      	movs	r0, #1
	}

	return ncl;		/* Return new cluster number or error code */
}
  402e40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402e44:	2901      	cmp	r1, #1
  402e46:	d9fa      	bls.n	402e3e <create_chain+0x46>
  402e48:	6983      	ldr	r3, [r0, #24]
  402e4a:	4299      	cmp	r1, r3
  402e4c:	d2f7      	bcs.n	402e3e <create_chain+0x46>
  402e4e:	4b1e      	ldr	r3, [pc, #120]	; (402ec8 <create_chain+0xd0>)
  402e50:	4798      	blx	r3
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
	}
	else {					/* Stretch the current chain */
		cs = get_fat(fs, clst);			/* Check the cluster status */
		if (cs < 2) return 1;			/* It is an invalid cluster */
  402e52:	2801      	cmp	r0, #1
  402e54:	d9f3      	bls.n	402e3e <create_chain+0x46>
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
  402e56:	69ab      	ldr	r3, [r5, #24]
  402e58:	4283      	cmp	r3, r0
  402e5a:	d8f1      	bhi.n	402e40 <create_chain+0x48>
  402e5c:	4646      	mov	r6, r8
  402e5e:	e7d6      	b.n	402e0e <create_chain+0x16>
	FRESULT res;


	if (clst == 0) {		/* Create a new chain */
		scl = fs->last_clust;			/* Get suggested start point */
		if (!scl || scl >= fs->n_fatent) scl = 1;
  402e60:	2601      	movs	r6, #1
  402e62:	e7d4      	b.n	402e0e <create_chain+0x16>
	ncl = scl;				/* Start cluster */
	for (;;) {
		ncl++;							/* Next cluster */
		if (ncl >= fs->n_fatent) {		/* Wrap around */
			ncl = 2;
			if (ncl > scl) return 0;	/* No free cluster */
  402e64:	2000      	movs	r0, #0
  402e66:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
			fs->fsi_flag = 1;
		}
	} else {
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
  402e6a:	2801      	cmp	r0, #1
  402e6c:	d1e7      	bne.n	402e3e <create_chain+0x46>
  402e6e:	f04f 30ff 	mov.w	r0, #4294967295
  402e72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402e76:	69ab      	ldr	r3, [r5, #24]
  402e78:	42a3      	cmp	r3, r4
  402e7a:	d9e0      	bls.n	402e3e <create_chain+0x46>
  402e7c:	4628      	mov	r0, r5
  402e7e:	4621      	mov	r1, r4
  402e80:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
  402e84:	4e11      	ldr	r6, [pc, #68]	; (402ecc <create_chain+0xd4>)
  402e86:	47b0      	blx	r6
			return cs;
		if (ncl == scl) return 0;		/* No free cluster */
	}

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
  402e88:	2800      	cmp	r0, #0
  402e8a:	d1ee      	bne.n	402e6a <create_chain+0x72>
  402e8c:	f1b8 0f00 	cmp.w	r8, #0
  402e90:	d00b      	beq.n	402eaa <create_chain+0xb2>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  402e92:	f1b8 0f01 	cmp.w	r8, #1
  402e96:	d9d2      	bls.n	402e3e <create_chain+0x46>
  402e98:	69ab      	ldr	r3, [r5, #24]
  402e9a:	4598      	cmp	r8, r3
  402e9c:	d2cf      	bcs.n	402e3e <create_chain+0x46>
  402e9e:	4641      	mov	r1, r8
  402ea0:	4628      	mov	r0, r5
  402ea2:	4622      	mov	r2, r4
  402ea4:	47b0      	blx	r6

	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
  402ea6:	2800      	cmp	r0, #0
  402ea8:	d1df      	bne.n	402e6a <create_chain+0x72>
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
  402eaa:	692b      	ldr	r3, [r5, #16]
	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
	if (res == FR_OK && clst != 0) {
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
  402eac:	60ec      	str	r4, [r5, #12]
		if (fs->free_clust != 0xFFFFFFFF) {
  402eae:	1c5a      	adds	r2, r3, #1
  402eb0:	d006      	beq.n	402ec0 <create_chain+0xc8>
			fs->free_clust--;
  402eb2:	3b01      	subs	r3, #1
			fs->fsi_flag = 1;
  402eb4:	2201      	movs	r2, #1
		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
	}
	if (res == FR_OK) {
		fs->last_clust = ncl;			/* Update FSINFO */
		if (fs->free_clust != 0xFFFFFFFF) {
			fs->free_clust--;
  402eb6:	612b      	str	r3, [r5, #16]
			fs->fsi_flag = 1;
  402eb8:	716a      	strb	r2, [r5, #5]
  402eba:	4620      	mov	r0, r4
  402ebc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402ec0:	4620      	mov	r0, r4
  402ec2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  402ec6:	bf00      	nop
  402ec8:	00402b85 	.word	0x00402b85
  402ecc:	00402cf9 	.word	0x00402cf9

00402ed0 <dir_next>:
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402ed0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
  402ed4:	88c5      	ldrh	r5, [r0, #6]
  402ed6:	3501      	adds	r5, #1
  402ed8:	b2ad      	uxth	r5, r5
static
FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
	DIR *dj,		/* Pointer to directory object */
	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
)
{
  402eda:	4604      	mov	r4, r0
  402edc:	460e      	mov	r6, r1
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402ede:	b915      	cbnz	r5, 402ee6 <dir_next+0x16>
		return FR_NO_FILE;
  402ee0:	2004      	movs	r0, #4
  402ee2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
  402ee6:	6903      	ldr	r3, [r0, #16]
  402ee8:	2b00      	cmp	r3, #0
  402eea:	d0f9      	beq.n	402ee0 <dir_next+0x10>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
  402eec:	f015 070f 	ands.w	r7, r5, #15
  402ef0:	d008      	beq.n	402f04 <dir_next+0x34>
  402ef2:	6800      	ldr	r0, [r0, #0]
			}
		}
	}

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
  402ef4:	eb00 1347 	add.w	r3, r0, r7, lsl #5
  402ef8:	3330      	adds	r3, #48	; 0x30
  402efa:	6163      	str	r3, [r4, #20]
				dj->sect = clust2sect(dj->fs, clst);
			}
		}
	}

	dj->index = i;
  402efc:	80e5      	strh	r5, [r4, #6]
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
  402efe:	2000      	movs	r0, #0
  402f00:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402f04:	68c1      	ldr	r1, [r0, #12]
	i = dj->index + 1;
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */
  402f06:	3301      	adds	r3, #1
  402f08:	6103      	str	r3, [r0, #16]

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402f0a:	6800      	ldr	r0, [r0, #0]
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
  402f0c:	b161      	cbz	r1, 402f28 <dir_next+0x58>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
  402f0e:	7882      	ldrb	r2, [r0, #2]
  402f10:	3a01      	subs	r2, #1
  402f12:	ea12 1215 	ands.w	r2, r2, r5, lsr #4
  402f16:	d1ed      	bne.n	402ef4 <dir_next+0x24>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  402f18:	2901      	cmp	r1, #1
  402f1a:	d902      	bls.n	402f22 <dir_next+0x52>
  402f1c:	6982      	ldr	r2, [r0, #24]
  402f1e:	4291      	cmp	r1, r2
  402f20:	d306      	bcc.n	402f30 <dir_next+0x60>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402f22:	2002      	movs	r0, #2
  402f24:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
		dj->sect++;					/* Next sector */

		if (dj->clust == 0) {	/* Static table */
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
  402f28:	8902      	ldrh	r2, [r0, #8]
  402f2a:	42aa      	cmp	r2, r5
  402f2c:	d9d8      	bls.n	402ee0 <dir_next+0x10>
  402f2e:	e7e1      	b.n	402ef4 <dir_next+0x24>
  402f30:	4b34      	ldr	r3, [pc, #208]	; (403004 <dir_next+0x134>)
  402f32:	4798      	blx	r3
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
  402f34:	2801      	cmp	r0, #1
  402f36:	4680      	mov	r8, r0
  402f38:	d9f3      	bls.n	402f22 <dir_next+0x52>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f3a:	f1b0 3fff 	cmp.w	r0, #4294967295
  402f3e:	d01c      	beq.n	402f7a <dir_next+0xaa>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
  402f40:	6820      	ldr	r0, [r4, #0]
  402f42:	6982      	ldr	r2, [r0, #24]
  402f44:	4542      	cmp	r2, r8
  402f46:	d90e      	bls.n	402f66 <dir_next+0x96>
  402f48:	f1a8 0602 	sub.w	r6, r8, #2
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
  402f4c:	f8c4 800c 	str.w	r8, [r4, #12]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f50:	6982      	ldr	r2, [r0, #24]
  402f52:	3a02      	subs	r2, #2
  402f54:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402f56:	bf3b      	ittet	cc
  402f58:	7881      	ldrbcc	r1, [r0, #2]
  402f5a:	6a82      	ldrcc	r2, [r0, #40]	; 0x28
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402f5c:	2600      	movcs	r6, #0
	return clst * fs->csize + fs->database;
  402f5e:	fb01 2606 	mlacc	r6, r1, r6, r2
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
				dj->sect = clust2sect(dj->fs, clst);
  402f62:	6126      	str	r6, [r4, #16]
  402f64:	e7c6      	b.n	402ef4 <dir_next+0x24>
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
  402f66:	2e00      	cmp	r6, #0
  402f68:	d0ba      	beq.n	402ee0 <dir_next+0x10>
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
  402f6a:	68e1      	ldr	r1, [r4, #12]
  402f6c:	4b26      	ldr	r3, [pc, #152]	; (403008 <dir_next+0x138>)
  402f6e:	4798      	blx	r3
					if (clst == 0) return FR_DENIED;			/* No free cluster */
  402f70:	4680      	mov	r8, r0
  402f72:	b928      	cbnz	r0, 402f80 <dir_next+0xb0>
  402f74:	2007      	movs	r0, #7

	dj->index = i;
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;

	return FR_OK;
}
  402f76:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f7a:	2001      	movs	r0, #1
  402f7c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if !_FS_READONLY
					BYTE c;
					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
  402f80:	2801      	cmp	r0, #1
  402f82:	d0ce      	beq.n	402f22 <dir_next+0x52>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
  402f84:	f1b0 3fff 	cmp.w	r0, #4294967295
  402f88:	d0f7      	beq.n	402f7a <dir_next+0xaa>
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
  402f8a:	6820      	ldr	r0, [r4, #0]
  402f8c:	f8df 907c 	ldr.w	r9, [pc, #124]	; 40300c <dir_next+0x13c>
  402f90:	2100      	movs	r1, #0
  402f92:	47c8      	blx	r9
  402f94:	2800      	cmp	r0, #0
  402f96:	d1f0      	bne.n	402f7a <dir_next+0xaa>
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402f98:	6822      	ldr	r2, [r4, #0]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402f9a:	4601      	mov	r1, r0
					if (clst == 0) return FR_DENIED;			/* No free cluster */
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
  402f9c:	f102 0330 	add.w	r3, r2, #48	; 0x30
  402fa0:	f502 720c 	add.w	r2, r2, #560	; 0x230
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  402fa4:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  402fa8:	4293      	cmp	r3, r2
  402faa:	d1fb      	bne.n	402fa4 <dir_next+0xd4>
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402fac:	6823      	ldr	r3, [r4, #0]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402fae:	699a      	ldr	r2, [r3, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  402fb0:	f1a8 0602 	sub.w	r6, r8, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402fb4:	3a02      	subs	r2, #2
  402fb6:	4296      	cmp	r6, r2
	return clst * fs->csize + fs->database;
  402fb8:	bf3b      	ittet	cc
  402fba:	6a9a      	ldrcc	r2, [r3, #40]	; 0x28
  402fbc:	7899      	ldrbcc	r1, [r3, #2]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  402fbe:	2200      	movcs	r2, #0
	return clst * fs->csize + fs->database;
  402fc0:	fb01 2206 	mlacc	r2, r1, r6, r2
					if (clst == 1) return FR_INT_ERR;
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
  402fc4:	62da      	str	r2, [r3, #44]	; 0x2c
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fc6:	f04f 0a00 	mov.w	sl, #0
						dj->fs->wflag = 1;
  402fca:	f04f 0b01 	mov.w	fp, #1
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fce:	e00b      	b.n	402fe8 <dir_next+0x118>
						dj->fs->wflag = 1;
  402fd0:	f883 b004 	strb.w	fp, [r3, #4]
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402fd4:	6820      	ldr	r0, [r4, #0]
  402fd6:	47c8      	blx	r9
  402fd8:	f10a 0a01 	add.w	sl, sl, #1
  402fdc:	2800      	cmp	r0, #0
  402fde:	d1cc      	bne.n	402f7a <dir_next+0xaa>
						dj->fs->winsect++;
  402fe0:	6823      	ldr	r3, [r4, #0]
  402fe2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
  402fe4:	3201      	adds	r2, #1
  402fe6:	62da      	str	r2, [r3, #44]	; 0x2c
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402fe8:	6823      	ldr	r3, [r4, #0]
  402fea:	7898      	ldrb	r0, [r3, #2]
  402fec:	fa5f f28a 	uxtb.w	r2, sl
  402ff0:	4290      	cmp	r0, r2
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
  402ff2:	f04f 0100 	mov.w	r1, #0
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
					/* Clean-up stretched table */
					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
  402ff6:	d8eb      	bhi.n	402fd0 <dir_next+0x100>
						dj->fs->wflag = 1;
						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
						dj->fs->winsect++;
					}
					dj->fs->winsect -= c;						/* Rewind window address */
  402ff8:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
  402ffa:	1a8a      	subs	r2, r1, r2
  402ffc:	62da      	str	r2, [r3, #44]	; 0x2c
  402ffe:	6820      	ldr	r0, [r4, #0]
  403000:	e7a4      	b.n	402f4c <dir_next+0x7c>
  403002:	bf00      	nop
  403004:	00402b85 	.word	0x00402b85
  403008:	00402df9 	.word	0x00402df9
  40300c:	00402645 	.word	0x00402645

00403010 <dir_find.part.5>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  403010:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403014:	f04f 08ff 	mov.w	r8, #255	; 0xff
  403018:	b085      	sub	sp, #20
  40301a:	4f52      	ldr	r7, [pc, #328]	; (403164 <dir_find.part.5+0x154>)
  40301c:	f8df 914c 	ldr.w	r9, [pc, #332]	; 40316c <dir_find.part.5+0x15c>
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403020:	f8df a14c 	ldr.w	sl, [pc, #332]	; 403170 <dir_find.part.5+0x160>
/*-----------------------------------------------------------------------*/
/* Directory handling - Find an object in the directory                  */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_find (
  403024:	4605      	mov	r5, r0
  403026:	4646      	mov	r6, r8
  403028:	e008      	b.n	40303c <dir_find.part.5+0x2c>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40302a:	290f      	cmp	r1, #15
  40302c:	d03e      	beq.n	4030ac <dir_find.part.5+0x9c>
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40302e:	26ff      	movs	r6, #255	; 0xff
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
			break;
#endif
		res = dir_next(dj, 0);		/* Next entry */
  403030:	4628      	mov	r0, r5
  403032:	2100      	movs	r1, #0
  403034:	4b4c      	ldr	r3, [pc, #304]	; (403168 <dir_find.part.5+0x158>)
  403036:	4798      	blx	r3
	} while (res == FR_OK);
  403038:	2800      	cmp	r0, #0
  40303a:	d134      	bne.n	4030a6 <dir_find.part.5+0x96>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
  40303c:	6828      	ldr	r0, [r5, #0]
  40303e:	6929      	ldr	r1, [r5, #16]
  403040:	47b8      	blx	r7
		if (res != FR_OK) break;
  403042:	bb80      	cbnz	r0, 4030a6 <dir_find.part.5+0x96>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
  403044:	696c      	ldr	r4, [r5, #20]
		c = dir[DIR_Name];
  403046:	7822      	ldrb	r2, [r4, #0]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  403048:	2a00      	cmp	r2, #0
  40304a:	d078      	beq.n	40313e <dir_find.part.5+0x12e>
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  40304c:	7ae3      	ldrb	r3, [r4, #11]
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  40304e:	2ae5      	cmp	r2, #229	; 0xe5
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
#if _USE_LFN	/* LFN configuration */
		a = dir[DIR_Attr] & AM_MASK;
  403050:	f003 013f 	and.w	r1, r3, #63	; 0x3f
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
  403054:	d0eb      	beq.n	40302e <dir_find.part.5+0x1e>
  403056:	071b      	lsls	r3, r3, #28
  403058:	d4e7      	bmi.n	40302a <dir_find.part.5+0x1a>
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
  40305a:	290f      	cmp	r1, #15
  40305c:	d026      	beq.n	4030ac <dir_find.part.5+0x9c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  40305e:	b98e      	cbnz	r6, 403084 <dir_find.part.5+0x74>
  403060:	4694      	mov	ip, r2
  403062:	f104 060a 	add.w	r6, r4, #10
  403066:	4622      	mov	r2, r4
  403068:	4603      	mov	r3, r0
  40306a:	e001      	b.n	403070 <dir_find.part.5+0x60>
  40306c:	f812 cf01 	ldrb.w	ip, [r2, #1]!
)
{
	BYTE sum = 0;
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  403070:	01d9      	lsls	r1, r3, #7
  403072:	ea41 0353 	orr.w	r3, r1, r3, lsr #1
  403076:	fa5c f383 	uxtab	r3, ip, r3
  40307a:	42b2      	cmp	r2, r6
  40307c:	b2db      	uxtb	r3, r3
  40307e:	d1f5      	bne.n	40306c <dir_find.part.5+0x5c>
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
  403080:	4543      	cmp	r3, r8
  403082:	d010      	beq.n	4030a6 <dir_find.part.5+0x96>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  403084:	f64f 72ff 	movw	r2, #65535	; 0xffff
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  403088:	69ab      	ldr	r3, [r5, #24]
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
				}
			} else {					/* An SFN entry is found */
				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
  40308a:	842a      	strh	r2, [r5, #32]
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
  40308c:	7ada      	ldrb	r2, [r3, #11]
  40308e:	07d2      	lsls	r2, r2, #31
  403090:	d4cd      	bmi.n	40302e <dir_find.part.5+0x1e>
  403092:	f104 060b 	add.w	r6, r4, #11
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
  403096:	f814 1b01 	ldrb.w	r1, [r4], #1
  40309a:	f813 2b01 	ldrb.w	r2, [r3], #1
  40309e:	4291      	cmp	r1, r2
  4030a0:	d1c5      	bne.n	40302e <dir_find.part.5+0x1e>
  4030a2:	42b4      	cmp	r4, r6
  4030a4:	d1f7      	bne.n	403096 <dir_find.part.5+0x86>
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  4030a6:	b005      	add	sp, #20
  4030a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		a = dir[DIR_Attr] & AM_MASK;
		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
  4030ac:	69eb      	ldr	r3, [r5, #28]
  4030ae:	2b00      	cmp	r3, #0
  4030b0:	d0be      	beq.n	403030 <dir_find.part.5+0x20>
					if (c & LLE) {		/* Is it start of LFN sequence? */
  4030b2:	0651      	lsls	r1, r2, #25
  4030b4:	d53f      	bpl.n	403136 <dir_find.part.5+0x126>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  4030b6:	88e9      	ldrh	r1, [r5, #6]
			ord = 0xFF;
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
  4030b8:	f894 800d 	ldrb.w	r8, [r4, #13]
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
  4030bc:	8429      	strh	r1, [r5, #32]
		} else {
			if (a == AM_LFN) {			/* An LFN entry is found */
				if (dj->lfn) {
					if (c & LLE) {		/* Is it start of LFN sequence? */
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
  4030be:	f002 06bf 	and.w	r6, r2, #191	; 0xbf
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  4030c2:	7b61      	ldrb	r1, [r4, #13]
  4030c4:	4541      	cmp	r1, r8
  4030c6:	d1b2      	bne.n	40302e <dir_find.part.5+0x1e>
{
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
  4030c8:	7822      	ldrb	r2, [r4, #0]
  4030ca:	f8df b0a8 	ldr.w	fp, [pc, #168]	; 403174 <dir_find.part.5+0x164>
  4030ce:	f022 0240 	bic.w	r2, r2, #64	; 0x40
  4030d2:	3a01      	subs	r2, #1
  4030d4:	eb02 0c42 	add.w	ip, r2, r2, lsl #1
  4030d8:	eb02 0c8c 	add.w	ip, r2, ip, lsl #2
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4030dc:	f64f 78ff 	movw	r8, #65535	; 0xffff
	UINT i, s;
	WCHAR wc, uc;


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
  4030e0:	2201      	movs	r2, #1
  4030e2:	e003      	b.n	4030ec <dir_find.part.5+0xdc>
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
				return 0;				/* Not matched */
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
  4030e4:	4540      	cmp	r0, r8
  4030e6:	d135      	bne.n	403154 <dir_find.part.5+0x144>
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */
  4030e8:	45cb      	cmp	fp, r9
  4030ea:	d02c      	beq.n	403146 <dir_find.part.5+0x136>


	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
  4030ec:	f81b 0f01 	ldrb.w	r0, [fp, #1]!
  4030f0:	eb04 0e00 	add.w	lr, r4, r0
  4030f4:	5c20      	ldrb	r0, [r4, r0]
  4030f6:	f89e e001 	ldrb.w	lr, [lr, #1]
  4030fa:	ea40 200e 	orr.w	r0, r0, lr, lsl #8
		if (wc) {	/* Last char has not been processed */
  4030fe:	2a00      	cmp	r2, #0
  403100:	d0f0      	beq.n	4030e4 <dir_find.part.5+0xd4>
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  403102:	f10c 0201 	add.w	r2, ip, #1
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403106:	e88d 100a 	stmia.w	sp, {r1, r3, ip}
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  40310a:	9203      	str	r2, [sp, #12]
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  40310c:	47d0      	blx	sl
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  40310e:	f8dd c008 	ldr.w	ip, [sp, #8]
  403112:	f1bc 0ffe 	cmp.w	ip, #254	; 0xfe
	i = ((dir[LDIR_Ord] & ~LLE) - 1) * 13;	/* Get offset in the LFN buffer */
	s = 0; wc = 1;
	do {
		uc = LD_WORD(dir+LfnOfs[s]);	/* Pick an LFN character from the entry */
		if (wc) {	/* Last char has not been processed */
			wc = ff_wtoupper(uc);		/* Convert it to upper case */
  403116:	4602      	mov	r2, r0
			if (i >= _MAX_LFN || wc != ff_wtoupper(lfnbuf[i++]))	/* Compare it */
  403118:	e89d 000a 	ldmia.w	sp, {r1, r3}
  40311c:	d81a      	bhi.n	403154 <dir_find.part.5+0x144>
  40311e:	f833 001c 	ldrh.w	r0, [r3, ip, lsl #1]
  403122:	9202      	str	r2, [sp, #8]
  403124:	47d0      	blx	sl
  403126:	9a02      	ldr	r2, [sp, #8]
  403128:	4282      	cmp	r2, r0
  40312a:	e89d 000a 	ldmia.w	sp, {r1, r3}
  40312e:	d111      	bne.n	403154 <dir_find.part.5+0x144>
  403130:	f8dd c00c 	ldr.w	ip, [sp, #12]
  403134:	e7d8      	b.n	4030e8 <dir_find.part.5+0xd8>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403136:	42b2      	cmp	r2, r6
  403138:	f47f af79 	bne.w	40302e <dir_find.part.5+0x1e>
  40313c:	e7c1      	b.n	4030c2 <dir_find.part.5+0xb2>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
  40313e:	2004      	movs	r0, #4
#endif
		res = dir_next(dj, 0);		/* Next entry */
	} while (res == FR_OK);

	return res;
}
  403140:	b005      	add	sp, #20
  403142:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else {
			if (uc != 0xFFFF) return 0;	/* Check filler */
		}
	} while (++s < 13);				/* Repeat until all chars in the entry are checked */

	if ((dir[LDIR_Ord] & LLE) && wc && lfnbuf[i])	/* Last segment matched but different length */
  403146:	7820      	ldrb	r0, [r4, #0]
  403148:	0640      	lsls	r0, r0, #25
  40314a:	d506      	bpl.n	40315a <dir_find.part.5+0x14a>
  40314c:	b12a      	cbz	r2, 40315a <dir_find.part.5+0x14a>
  40314e:	f833 301c 	ldrh.w	r3, [r3, ip, lsl #1]
  403152:	b113      	cbz	r3, 40315a <dir_find.part.5+0x14a>
						sum = dir[LDIR_Chksum];
						c &= ~LLE; ord = c;	/* LFN start order */
						dj->lfn_idx = dj->index;
					}
					/* Check validity of the LFN entry and compare it with given name */
					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
  403154:	4688      	mov	r8, r1
  403156:	26ff      	movs	r6, #255	; 0xff
  403158:	e76a      	b.n	403030 <dir_find.part.5+0x20>
  40315a:	3e01      	subs	r6, #1
  40315c:	b2f6      	uxtb	r6, r6
  40315e:	4688      	mov	r8, r1
  403160:	e766      	b.n	403030 <dir_find.part.5+0x20>
  403162:	bf00      	nop
  403164:	00402645 	.word	0x00402645
  403168:	00402ed1 	.word	0x00402ed1
  40316c:	00406c0c 	.word	0x00406c0c
  403170:	00403db1 	.word	0x00403db1
  403174:	00406bff 	.word	0x00406bff

00403178 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  403178:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  40317c:	f8d0 a018 	ldr.w	sl, [r0, #24]
  403180:	69c5      	ldr	r5, [r0, #28]
#if !_FS_READONLY
static
FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
	DIR *dj				/* Target directory with object name to be created */
)
{
  403182:	b089      	sub	sp, #36	; 0x24
  403184:	f10a 36ff 	add.w	r6, sl, #4294967295
  403188:	4604      	mov	r4, r0
	WORD n, ne, is;
	BYTE sn[12], *fn, sum;
	WCHAR *lfn;


	fn = dj->fn; lfn = dj->lfn;
  40318a:	4632      	mov	r2, r6
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40318c:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  40318e:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  403192:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403196:	a908      	add	r1, sp, #32
  403198:	428b      	cmp	r3, r1
  40319a:	d1f8      	bne.n	40318e <dir_register+0x16>
	mem_cpy(sn, fn, 12);

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
  40319c:	f89d 301f 	ldrb.w	r3, [sp, #31]
  4031a0:	9301      	str	r3, [sp, #4]
  4031a2:	07da      	lsls	r2, r3, #31
  4031a4:	d456      	bmi.n	403254 <dir_register+0xdc>
  4031a6:	4fb1      	ldr	r7, [pc, #708]	; (40346c <dir_register+0x2f4>)
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
  4031a8:	9b01      	ldr	r3, [sp, #4]
  4031aa:	079b      	lsls	r3, r3, #30
  4031ac:	f100 80c2 	bmi.w	403334 <dir_register+0x1bc>
		for (ne = 0; lfn[ne]; ne++) ;
		ne = (ne + 25) / 13;
	} else {						/* Otherwise reserve only an SFN entry. */
		ne = 1;
  4031b0:	f04f 0901 	mov.w	r9, #1
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
  4031b4:	4620      	mov	r0, r4
  4031b6:	2100      	movs	r1, #0
  4031b8:	47b8      	blx	r7
	if (res != FR_OK) return res;
  4031ba:	2800      	cmp	r0, #0
  4031bc:	d147      	bne.n	40324e <dir_register+0xd6>
  4031be:	4682      	mov	sl, r0
  4031c0:	4eab      	ldr	r6, [pc, #684]	; (403470 <dir_register+0x2f8>)
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4031c2:	f8df 82b4 	ldr.w	r8, [pc, #692]	; 403478 <dir_register+0x300>
		ne = 1;
	}

	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
  4031c6:	4605      	mov	r5, r0
  4031c8:	e005      	b.n	4031d6 <dir_register+0x5e>
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
  4031ca:	461d      	mov	r5, r3
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4031cc:	47c0      	blx	r8
	} while (res == FR_OK);
  4031ce:	4603      	mov	r3, r0
  4031d0:	2800      	cmp	r0, #0
  4031d2:	f040 80ce 	bne.w	403372 <dir_register+0x1fa>
	/* Reserve contiguous entries */
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
  4031d6:	6921      	ldr	r1, [r4, #16]
  4031d8:	6820      	ldr	r0, [r4, #0]
  4031da:	47b0      	blx	r6
		if (res != FR_OK) break;
  4031dc:	4603      	mov	r3, r0
		c = *dj->dir;				/* Check the entry status */
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  4031de:	f105 0c01 	add.w	ip, r5, #1
		} else {
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
  4031e2:	4620      	mov	r0, r4
  4031e4:	2101      	movs	r1, #1
	res = dir_sdi(dj, 0);
	if (res != FR_OK) return res;
	n = is = 0;
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
  4031e6:	2b00      	cmp	r3, #0
  4031e8:	f040 80c3 	bne.w	403372 <dir_register+0x1fa>
		c = *dj->dir;				/* Check the entry status */
  4031ec:	6962      	ldr	r2, [r4, #20]
  4031ee:	7812      	ldrb	r2, [r2, #0]
		if (c == DDE || c == 0) {	/* Is it a blank entry? */
  4031f0:	2ae5      	cmp	r2, #229	; 0xe5
  4031f2:	d001      	beq.n	4031f8 <dir_register+0x80>
  4031f4:	2a00      	cmp	r2, #0
  4031f6:	d1e8      	bne.n	4031ca <dir_register+0x52>
			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
  4031f8:	b90d      	cbnz	r5, 4031fe <dir_register+0x86>
  4031fa:	f8b4 a006 	ldrh.w	sl, [r4, #6]
			if (++n == ne) break;	/* A contiguous entry that required count is found */
  4031fe:	fa1f f58c 	uxth.w	r5, ip
  403202:	454d      	cmp	r5, r9
  403204:	d1e2      	bne.n	4031cc <dir_register+0x54>
			n = 0;					/* Not a blank entry. Restart to search */
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
  403206:	f1b9 0f01 	cmp.w	r9, #1
  40320a:	f040 80b6 	bne.w	40337a <dir_register+0x202>
		} while (res == FR_OK);
	}
#endif

	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
  40320e:	6820      	ldr	r0, [r4, #0]
  403210:	6921      	ldr	r1, [r4, #16]
  403212:	47b0      	blx	r6
		if (res == FR_OK) {
  403214:	b9d8      	cbnz	r0, 40324e <dir_register+0xd6>
			dir = dj->dir;
  403216:	6965      	ldr	r5, [r4, #20]
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  403218:	4601      	mov	r1, r0
  40321a:	f105 0220 	add.w	r2, r5, #32
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40321e:	462b      	mov	r3, r5

	while (cnt--)
		*d++ = (BYTE)val;
  403220:	f803 1b01 	strb.w	r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  403224:	4293      	cmp	r3, r2
  403226:	d1fb      	bne.n	403220 <dir_register+0xa8>
	if (res == FR_OK) {		/* Initialize the SFN entry */
		res = move_window(dj->fs, dj->sect);
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
  403228:	69a2      	ldr	r2, [r4, #24]
  40322a:	f105 000b 	add.w	r0, r5, #11
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40322e:	462b      	mov	r3, r5
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403230:	f812 1b01 	ldrb.w	r1, [r2], #1
  403234:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403238:	4283      	cmp	r3, r0
  40323a:	d1f9      	bne.n	403230 <dir_register+0xb8>
		if (res == FR_OK) {
			dir = dj->dir;
			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
#if _USE_LFN
			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
  40323c:	69a3      	ldr	r3, [r4, #24]
  40323e:	7adb      	ldrb	r3, [r3, #11]
  403240:	f003 0318 	and.w	r3, r3, #24
  403244:	732b      	strb	r3, [r5, #12]
#endif
			dj->fs->wflag = 1;
  403246:	6823      	ldr	r3, [r4, #0]
  403248:	2201      	movs	r2, #1
  40324a:	711a      	strb	r2, [r3, #4]
  40324c:	2000      	movs	r0, #0
		}
	}

	return res;
}
  40324e:	b009      	add	sp, #36	; 0x24
  403250:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  403254:	2300      	movs	r3, #0
  403256:	4f85      	ldr	r7, [pc, #532]	; (40346c <dir_register+0x2f4>)
  403258:	f8df 8220 	ldr.w	r8, [pc, #544]	; 40347c <dir_register+0x304>
  40325c:	f88a 300b 	strb.w	r3, [sl, #11]
		for (n = 1; n < 100; n++) {
  403260:	f04f 0901 	mov.w	r9, #1

	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
  403264:	61e3      	str	r3, [r4, #28]
  403266:	f10d 0b1f 	add.w	fp, sp, #31
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
  40326a:	4632      	mov	r2, r6
  40326c:	ab05      	add	r3, sp, #20
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  40326e:	f813 1b01 	ldrb.w	r1, [r3], #1
  403272:	f802 1f01 	strb.w	r1, [r2, #1]!
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403276:	455b      	cmp	r3, fp
  403278:	d1f9      	bne.n	40326e <dir_register+0xf6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  40327a:	f1b9 0f05 	cmp.w	r9, #5
  40327e:	d957      	bls.n	403330 <dir_register+0x1b8>
  403280:	8828      	ldrh	r0, [r5, #0]
  403282:	4629      	mov	r1, r5
  403284:	464a      	mov	r2, r9
  403286:	e000      	b.n	40328a <dir_register+0x112>
		do seq = (seq >> 1) + (seq << 15) + (WORD)*lfn++; while (*lfn);
  403288:	4618      	mov	r0, r3
  40328a:	03d3      	lsls	r3, r2, #15
  40328c:	ea43 0252 	orr.w	r2, r3, r2, lsr #1
  403290:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403294:	fa10 f282 	uxtah	r2, r0, r2
  403298:	b292      	uxth	r2, r2
  40329a:	2b00      	cmp	r3, #0
  40329c:	d1f4      	bne.n	403288 <dir_register+0x110>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  40329e:	2307      	movs	r3, #7
	}

	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
  4032a0:	f002 000f 	and.w	r0, r2, #15
  4032a4:	f100 0130 	add.w	r1, r0, #48	; 0x30
		if (c > '9') c += 7;
  4032a8:	2939      	cmp	r1, #57	; 0x39
  4032aa:	bf88      	it	hi
  4032ac:	f100 0137 	addhi.w	r1, r0, #55	; 0x37
		ns[i--] = c;
  4032b0:	3b01      	subs	r3, #1
  4032b2:	a803      	add	r0, sp, #12
  4032b4:	4418      	add	r0, r3
		seq /= 16;
  4032b6:	f3c2 120f 	ubfx	r2, r2, #4, #16
	/* itoa (hexdecimal) */
	i = 7;
	do {
		c = (seq % 16) + '0';
		if (c > '9') c += 7;
		ns[i--] = c;
  4032ba:	7041      	strb	r1, [r0, #1]
		seq /= 16;
	} while (seq);
  4032bc:	2a00      	cmp	r2, #0
  4032be:	d1ef      	bne.n	4032a0 <dir_register+0x128>
	ns[i] = '~';
  4032c0:	a908      	add	r1, sp, #32
  4032c2:	4419      	add	r1, r3
  4032c4:	207e      	movs	r0, #126	; 0x7e
  4032c6:	f801 0c14 	strb.w	r0, [r1, #-20]

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  4032ca:	2b00      	cmp	r3, #0
  4032cc:	d04f      	beq.n	40336e <dir_register+0x1f6>
  4032ce:	f89a 1000 	ldrb.w	r1, [sl]
  4032d2:	2920      	cmp	r1, #32
  4032d4:	d014      	beq.n	403300 <dir_register+0x188>
  4032d6:	4651      	mov	r1, sl
  4032d8:	e003      	b.n	4032e2 <dir_register+0x16a>
  4032da:	f811 0f01 	ldrb.w	r0, [r1, #1]!
  4032de:	2820      	cmp	r0, #32
  4032e0:	d00e      	beq.n	403300 <dir_register+0x188>
  4032e2:	3201      	adds	r2, #1
  4032e4:	429a      	cmp	r2, r3
  4032e6:	d1f8      	bne.n	4032da <dir_register+0x162>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  4032e8:	2b07      	cmp	r3, #7
  4032ea:	d80b      	bhi.n	403304 <dir_register+0x18c>
  4032ec:	a908      	add	r1, sp, #32
  4032ee:	4419      	add	r1, r3
  4032f0:	3301      	adds	r3, #1
  4032f2:	f811 1c14 	ldrb.w	r1, [r1, #-20]
  4032f6:	f80a 1002 	strb.w	r1, [sl, r2]
  4032fa:	3201      	adds	r2, #1
	} while (j < 8);
  4032fc:	2a07      	cmp	r2, #7
  4032fe:	d807      	bhi.n	403310 <dir_register+0x198>
			if (j == i - 1) break;
			j++;
		}
	}
	do {
		dst[j++] = (i < 8) ? ns[i++] : ' ';
  403300:	2b07      	cmp	r3, #7
  403302:	d9f3      	bls.n	4032ec <dir_register+0x174>
  403304:	2120      	movs	r1, #32
  403306:	f80a 1002 	strb.w	r1, [sl, r2]
  40330a:	3201      	adds	r2, #1
	} while (j < 8);
  40330c:	2a07      	cmp	r2, #7
  40330e:	d9f7      	bls.n	403300 <dir_register+0x188>
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  403310:	4620      	mov	r0, r4
  403312:	2100      	movs	r1, #0
  403314:	47b8      	blx	r7
	if (res != FR_OK) return res;
  403316:	bb10      	cbnz	r0, 40335e <dir_register+0x1e6>
  403318:	4620      	mov	r0, r4
  40331a:	47c0      	blx	r8
	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
  40331c:	b9f8      	cbnz	r0, 40335e <dir_register+0x1e6>
	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
		return FR_INVALID_NAME;

	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
		for (n = 1; n < 100; n++) {
  40331e:	f109 0901 	add.w	r9, r9, #1
  403322:	fa1f f989 	uxth.w	r9, r9
  403326:	f1b9 0f64 	cmp.w	r9, #100	; 0x64
  40332a:	d19e      	bne.n	40326a <dir_register+0xf2>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
  40332c:	2007      	movs	r0, #7
  40332e:	e78e      	b.n	40324e <dir_register+0xd6>
	UINT i, j;


	mem_cpy(dst, src, 11);

	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
  403330:	464a      	mov	r2, r9
  403332:	e7b4      	b.n	40329e <dir_register+0x126>
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
		fn[NS] = sn[NS]; dj->lfn = lfn;
	}

	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
		for (ne = 0; lfn[ne]; ne++) ;
  403334:	882b      	ldrh	r3, [r5, #0]
  403336:	2b00      	cmp	r3, #0
  403338:	f43f af3a 	beq.w	4031b0 <dir_register+0x38>
  40333c:	2300      	movs	r3, #0
  40333e:	3301      	adds	r3, #1
  403340:	b29b      	uxth	r3, r3
  403342:	f835 2013 	ldrh.w	r2, [r5, r3, lsl #1]
  403346:	2a00      	cmp	r2, #0
  403348:	d1f9      	bne.n	40333e <dir_register+0x1c6>
  40334a:	4a4a      	ldr	r2, [pc, #296]	; (403474 <dir_register+0x2fc>)
  40334c:	3319      	adds	r3, #25
  40334e:	fb82 1903 	smull	r1, r9, r2, r3
  403352:	17db      	asrs	r3, r3, #31
  403354:	ebc3 09a9 	rsb	r9, r3, r9, asr #2
  403358:	fa1f f989 	uxth.w	r9, r9
  40335c:	e72a      	b.n	4031b4 <dir_register+0x3c>
			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
			res = dir_find(dj);				/* Check if the name collides with existing SFN */
			if (res != FR_OK) break;
		}
		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
  40335e:	2804      	cmp	r0, #4
  403360:	f47f af75 	bne.w	40324e <dir_register+0xd6>
		fn[NS] = sn[NS]; dj->lfn = lfn;
  403364:	9b01      	ldr	r3, [sp, #4]
  403366:	f88a 300b 	strb.w	r3, [sl, #11]
  40336a:	61e5      	str	r5, [r4, #28]
  40336c:	e71c      	b.n	4031a8 <dir_register+0x30>
		seq /= 16;
	} while (seq);
	ns[i] = '~';

	/* Append the number */
	for (j = 0; j < i && dst[j] != ' '; j++) {
  40336e:	461a      	mov	r2, r3
  403370:	e7c6      	b.n	403300 <dir_register+0x188>
  403372:	4618      	mov	r0, r3
			dj->fs->wflag = 1;
		}
	}

	return res;
}
  403374:	b009      	add	sp, #36	; 0x24
  403376:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
		res = dir_next(dj, 1);		/* Next entry with table stretch */
	} while (res == FR_OK);

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
  40337a:	4651      	mov	r1, sl
  40337c:	4620      	mov	r0, r4
  40337e:	47b8      	blx	r7
		if (res == FR_OK) {
  403380:	4603      	mov	r3, r0
  403382:	2800      	cmp	r0, #0
  403384:	d1f5      	bne.n	403372 <dir_register+0x1fa>
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
  403386:	69a2      	ldr	r2, [r4, #24]
static
BYTE sum_sfn (
	const BYTE *dir		/* Ptr to directory entry */
)
{
	BYTE sum = 0;
  403388:	4683      	mov	fp, r0
  40338a:	f102 000b 	add.w	r0, r2, #11
	UINT n = 11;

	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
  40338e:	f812 3b01 	ldrb.w	r3, [r2], #1
  403392:	ea4f 11cb 	mov.w	r1, fp, lsl #7
  403396:	ea41 0b5b 	orr.w	fp, r1, fp, lsr #1
  40339a:	fa53 fb8b 	uxtab	fp, r3, fp
  40339e:	4282      	cmp	r2, r0
  4033a0:	fa5f fb8b 	uxtb.w	fp, fp
  4033a4:	d1f3      	bne.n	40338e <dir_register+0x216>

	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
		res = dir_sdi(dj, is);
		if (res == FR_OK) {
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
  4033a6:	f109 39ff 	add.w	r9, r9, #4294967295
  4033aa:	fa1f f989 	uxth.w	r9, r9
  4033ae:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 403480 <dir_register+0x308>
  4033b2:	f8cd b000 	str.w	fp, [sp]
  4033b6:	46cb      	mov	fp, r9
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
  4033b8:	6820      	ldr	r0, [r4, #0]
  4033ba:	6921      	ldr	r1, [r4, #16]
  4033bc:	47b0      	blx	r6
  4033be:	4603      	mov	r3, r0
				if (res != FR_OK) break;
  4033c0:	2800      	cmp	r0, #0
  4033c2:	d1d6      	bne.n	403372 <dir_register+0x1fa>
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4033c4:	fa5f fa8b 	uxtb.w	sl, fp
  4033c8:	6965      	ldr	r5, [r4, #20]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  4033ca:	9b00      	ldr	r3, [sp, #0]
			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
  4033cc:	f8d4 901c 	ldr.w	r9, [r4, #28]
{
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
  4033d0:	736b      	strb	r3, [r5, #13]
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  4033d2:	f10a 32ff 	add.w	r2, sl, #4294967295
  4033d6:	eb02 0142 	add.w	r1, r2, r2, lsl #1
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  4033da:	270f      	movs	r7, #15
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  4033dc:	4603      	mov	r3, r0
	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
	dir[LDIR_Type] = 0;
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
  4033de:	eb02 0181 	add.w	r1, r2, r1, lsl #2
	UINT i, s;
	WCHAR wc;


	dir[LDIR_Chksum] = sum;			/* Set check sum */
	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
  4033e2:	72ef      	strb	r7, [r5, #11]
	dir[LDIR_Type] = 0;
  4033e4:	7328      	strb	r0, [r5, #12]
	ST_WORD(dir+LDIR_FstClusLO, 0);
  4033e6:	76a8      	strb	r0, [r5, #26]
  4033e8:	76e8      	strb	r0, [r5, #27]

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
  4033ea:	4602      	mov	r2, r0
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033ec:	f64f 77ff 	movw	r7, #65535	; 0xffff
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033f0:	20ff      	movs	r0, #255	; 0xff
  4033f2:	e010      	b.n	403416 <dir_register+0x29e>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  4033f4:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033f8:	f805 300e 	strb.w	r3, [r5, lr]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  4033fc:	3201      	adds	r2, #1

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  4033fe:	44ae      	add	lr, r5
  403400:	ea4f 2c13 	mov.w	ip, r3, lsr #8
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
  403404:	2b00      	cmp	r3, #0
  403406:	bf08      	it	eq
  403408:	463b      	moveq	r3, r7
	} while (++s < 13);
  40340a:	2a0d      	cmp	r2, #13
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40340c:	f101 0101 	add.w	r1, r1, #1
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403410:	f88e c001 	strb.w	ip, [lr, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  403414:	d00c      	beq.n	403430 <dir_register+0x2b8>
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  403416:	42bb      	cmp	r3, r7
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403418:	f818 e002 	ldrb.w	lr, [r8, r2]
	ST_WORD(dir+LDIR_FstClusLO, 0);

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
  40341c:	d1ea      	bne.n	4033f4 <dir_register+0x27c>
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  40341e:	eb05 0c0e 	add.w	ip, r5, lr
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  403422:	3201      	adds	r2, #1
  403424:	2a0d      	cmp	r2, #13

	i = (ord - 1) * 13;				/* Get offset in the LFN buffer */
	s = wc = 0;
	do {
		if (wc != 0xFFFF) wc = lfnbuf[i++];	/* Get an effective char */
		ST_WORD(dir+LfnOfs[s], wc);	/* Put it */
  403426:	f805 000e 	strb.w	r0, [r5, lr]
  40342a:	f88c 0001 	strb.w	r0, [ip, #1]
		if (!wc) wc = 0xFFFF;		/* Padding chars following last char */
	} while (++s < 13);
  40342e:	d1f2      	bne.n	403416 <dir_register+0x29e>
	if (wc == 0xFFFF || !lfnbuf[i]) ord |= LLE;	/* Bottom LFN part is the start of LFN sequence */
  403430:	f64f 72ff 	movw	r2, #65535	; 0xffff
  403434:	4293      	cmp	r3, r2
  403436:	d002      	beq.n	40343e <dir_register+0x2c6>
  403438:	f839 3011 	ldrh.w	r3, [r9, r1, lsl #1]
  40343c:	b90b      	cbnz	r3, 403442 <dir_register+0x2ca>
  40343e:	f04a 0a40 	orr.w	sl, sl, #64	; 0x40
	dir[LDIR_Ord] = ord;			/* Set the LFN order */
  403442:	f885 a000 	strb.w	sl, [r5]
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  403446:	6823      	ldr	r3, [r4, #0]
				res = dir_next(dj, 0);	/* Next entry */
  403448:	4a0b      	ldr	r2, [pc, #44]	; (403478 <dir_register+0x300>)
			ne--;
			do {					/* Store LFN entries in bottom first */
				res = move_window(dj->fs, dj->sect);
				if (res != FR_OK) break;
				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
				dj->fs->wflag = 1;
  40344a:	2101      	movs	r1, #1
  40344c:	7119      	strb	r1, [r3, #4]
				res = dir_next(dj, 0);	/* Next entry */
  40344e:	4620      	mov	r0, r4
  403450:	2100      	movs	r1, #0
  403452:	4790      	blx	r2
			} while (res == FR_OK && --ne);
  403454:	4603      	mov	r3, r0
  403456:	2800      	cmp	r0, #0
  403458:	d18b      	bne.n	403372 <dir_register+0x1fa>
  40345a:	f10b 3bff 	add.w	fp, fp, #4294967295
  40345e:	fa1f fb8b 	uxth.w	fp, fp
  403462:	f1bb 0f00 	cmp.w	fp, #0
  403466:	d1a7      	bne.n	4033b8 <dir_register+0x240>
  403468:	e6d1      	b.n	40320e <dir_register+0x96>
  40346a:	bf00      	nop
  40346c:	00402c51 	.word	0x00402c51
  403470:	00402645 	.word	0x00402645
  403474:	4ec4ec4f 	.word	0x4ec4ec4f
  403478:	00402ed1 	.word	0x00402ed1
  40347c:	00403011 	.word	0x00403011
  403480:	00406c00 	.word	0x00406c00

00403484 <remove_chain.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  403484:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403488:	4604      	mov	r4, r0
  40348a:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  40348c:	69a3      	ldr	r3, [r4, #24]
  40348e:	4f16      	ldr	r7, [pc, #88]	; (4034e8 <remove_chain.part.6+0x64>)
  403490:	f8df 8058 	ldr.w	r8, [pc, #88]	; 4034ec <remove_chain.part.6+0x68>
  403494:	429d      	cmp	r5, r3
  403496:	d220      	bcs.n	4034da <remove_chain.part.6+0x56>
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  403498:	2d01      	cmp	r5, #1
  40349a:	d90b      	bls.n	4034b4 <remove_chain.part.6+0x30>
  40349c:	4620      	mov	r0, r4
  40349e:	4629      	mov	r1, r5
  4034a0:	47b8      	blx	r7

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
  4034a2:	4606      	mov	r6, r0
  4034a4:	b1c8      	cbz	r0, 4034da <remove_chain.part.6+0x56>
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4034a6:	2801      	cmp	r0, #1
  4034a8:	d004      	beq.n	4034b4 <remove_chain.part.6+0x30>
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4034aa:	3001      	adds	r0, #1
  4034ac:	d018      	beq.n	4034e0 <remove_chain.part.6+0x5c>
	UINT bc;
	BYTE *p;
	FRESULT res;


	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  4034ae:	69a3      	ldr	r3, [r4, #24]
  4034b0:	429d      	cmp	r5, r3
  4034b2:	d302      	bcc.n	4034ba <remove_chain.part.6+0x36>
	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
  4034b4:	2002      	movs	r0, #2
  4034b6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4034ba:	2200      	movs	r2, #0
  4034bc:	4629      	mov	r1, r5
  4034be:	4620      	mov	r0, r4
  4034c0:	47c0      	blx	r8
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
				fs->free_clust++;
				fs->fsi_flag = 1;
  4034c2:	2201      	movs	r2, #1
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
			if (res != FR_OK) break;
  4034c4:	b968      	cbnz	r0, 4034e2 <remove_chain.part.6+0x5e>
			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
  4034c6:	6923      	ldr	r3, [r4, #16]
  4034c8:	1c59      	adds	r1, r3, #1
  4034ca:	d002      	beq.n	4034d2 <remove_chain.part.6+0x4e>
				fs->free_clust++;
  4034cc:	4413      	add	r3, r2
  4034ce:	6123      	str	r3, [r4, #16]
				fs->fsi_flag = 1;
  4034d0:	7162      	strb	r2, [r4, #5]
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4034d2:	69a3      	ldr	r3, [r4, #24]
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  4034d4:	4635      	mov	r5, r6
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
		res = FR_INT_ERR;

	} else {
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
  4034d6:	429d      	cmp	r5, r3
  4034d8:	d3de      	bcc.n	403498 <remove_chain.part.6+0x14>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
  4034da:	2000      	movs	r0, #0
  4034dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		res = FR_OK;
		while (clst < fs->n_fatent) {			/* Not a last link? */
			nxt = get_fat(fs, clst);			/* Get cluster status */
			if (nxt == 0) break;				/* Empty cluster? */
			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
  4034e0:	2001      	movs	r0, #1
			clst = nxt;	/* Next cluster */
		}
	}

	return res;
}
  4034e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4034e6:	bf00      	nop
  4034e8:	00402b85 	.word	0x00402b85
  4034ec:	00402cf9 	.word	0x00402cf9

004034f0 <follow_path>:
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  4034f0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  4034f4:	780b      	ldrb	r3, [r1, #0]
  4034f6:	2b2f      	cmp	r3, #47	; 0x2f
static
FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
	DIR *dj,			/* Directory object to return last directory and found object */
	const TCHAR *path	/* Full-path string to find a file or directory */
)
{
  4034f8:	b083      	sub	sp, #12
  4034fa:	4689      	mov	r9, r1
  4034fc:	4606      	mov	r6, r0
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
  4034fe:	f000 8133 	beq.w	403768 <follow_path+0x278>
  403502:	2b5c      	cmp	r3, #92	; 0x5c
  403504:	f000 8130 	beq.w	403768 <follow_path+0x278>
		path++;
	dj->sclust = 0;						/* Start from the root dir */
  403508:	2400      	movs	r4, #0
  40350a:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  40350c:	f899 0000 	ldrb.w	r0, [r9]
  403510:	281f      	cmp	r0, #31
  403512:	f240 8132 	bls.w	40377a <follow_path+0x28a>
  403516:	4da7      	ldr	r5, [pc, #668]	; (4037b4 <follow_path+0x2c4>)
  403518:	e001      	b.n	40351e <follow_path+0x2e>
  40351a:	f819 0f01 	ldrb.w	r0, [r9, #1]!
	WCHAR w, *lfn;
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
  40351e:	282f      	cmp	r0, #47	; 0x2f
  403520:	d0fb      	beq.n	40351a <follow_path+0x2a>
  403522:	285c      	cmp	r0, #92	; 0x5c
  403524:	d0f9      	beq.n	40351a <follow_path+0x2a>
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  403526:	281f      	cmp	r0, #31
	UINT i, ni, si, di;
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
  403528:	69f7      	ldr	r7, [r6, #28]
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  40352a:	f240 80ec 	bls.w	403706 <follow_path+0x216>
  40352e:	282f      	cmp	r0, #47	; 0x2f
  403530:	d02d      	beq.n	40358e <follow_path+0x9e>
  403532:	285c      	cmp	r0, #92	; 0x5c
  403534:	d02b      	beq.n	40358e <follow_path+0x9e>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403536:	2101      	movs	r1, #1
  403538:	f1a7 0b02 	sub.w	fp, r7, #2
  40353c:	46ca      	mov	sl, r9
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  40353e:	2401      	movs	r4, #1
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403540:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  403542:	b300      	cbz	r0, 403586 <follow_path+0x96>
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
  403544:	287f      	cmp	r0, #127	; 0x7f
  403546:	d809      	bhi.n	40355c <follow_path+0x6c>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  403548:	2822      	cmp	r0, #34	; 0x22
  40354a:	d01c      	beq.n	403586 <follow_path+0x96>
  40354c:	4a9a      	ldr	r2, [pc, #616]	; (4037b8 <follow_path+0x2c8>)
  40354e:	e001      	b.n	403554 <follow_path+0x64>
  403550:	4298      	cmp	r0, r3
  403552:	d018      	beq.n	403586 <follow_path+0x96>
  403554:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  403558:	2b00      	cmp	r3, #0
  40355a:	d1f9      	bne.n	403550 <follow_path+0x60>
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
  40355c:	f82b 0f02 	strh.w	r0, [fp, #2]!
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403560:	f81a 0f01 	ldrb.w	r0, [sl, #1]!
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  403564:	281f      	cmp	r0, #31
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  403566:	f104 0301 	add.w	r3, r4, #1
		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
  40356a:	f240 80ce 	bls.w	40370a <follow_path+0x21a>
  40356e:	282f      	cmp	r0, #47	; 0x2f
  403570:	d00f      	beq.n	403592 <follow_path+0xa2>
  403572:	285c      	cmp	r0, #92	; 0x5c
  403574:	d00d      	beq.n	403592 <follow_path+0xa2>
		if (di >= _MAX_LFN)				/* Reject too long name */
  403576:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
  40357a:	d004      	beq.n	403586 <follow_path+0x96>
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  40357c:	2101      	movs	r1, #1
	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
	for (;;) {
		w = p[si++];					/* Get a character */
  40357e:	461c      	mov	r4, r3
			b = (BYTE)p[si++];			/* Get 2nd byte */
			if (!IsDBCS2(b))
				return FR_INVALID_NAME;	/* Reject invalid sequence */
			w = (w << 8) + b;			/* Create a DBC */
		}
		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
  403580:	47a8      	blx	r5
		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
  403582:	2800      	cmp	r0, #0
  403584:	d1de      	bne.n	403544 <follow_path+0x54>
		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
  403586:	2006      	movs	r0, #6
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403588:	b003      	add	sp, #12
  40358a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  40358e:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  403590:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  403592:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  403594:	f04f 0b00 	mov.w	fp, #0
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  403598:	2c00      	cmp	r4, #0
  40359a:	d0f4      	beq.n	403586 <follow_path+0x96>
  40359c:	eb07 0044 	add.w	r0, r7, r4, lsl #1
		w = lfn[di-1];
  4035a0:	f830 2d02 	ldrh.w	r2, [r0, #-2]!
		if (w != ' ' && w != '.') break;
  4035a4:	2a20      	cmp	r2, #32
  4035a6:	d001      	beq.n	4035ac <follow_path+0xbc>
  4035a8:	2a2e      	cmp	r2, #46	; 0x2e
  4035aa:	d102      	bne.n	4035b2 <follow_path+0xc2>
			dj->fn[i] = (i < di) ? '.' : ' ';
		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
		return FR_OK;
	}
#endif
	while (di) {						/* Strip trailing spaces and dots */
  4035ac:	3c01      	subs	r4, #1
  4035ae:	d1f7      	bne.n	4035a0 <follow_path+0xb0>
  4035b0:	e7e9      	b.n	403586 <follow_path+0x96>
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  4035b2:	2300      	movs	r3, #0
  4035b4:	f827 3014 	strh.w	r3, [r7, r4, lsl #1]

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
  4035b8:	69b3      	ldr	r3, [r6, #24]
		if (w != ' ' && w != '.') break;
		di--;
	}
	if (!di) return FR_INVALID_NAME;	/* Reject nul string */

	lfn[di] = 0;						/* LFN is created */
  4035ba:	eb07 0044 	add.w	r0, r7, r4, lsl #1
  4035be:	f103 010b 	add.w	r1, r3, #11
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
  4035c2:	2220      	movs	r2, #32
  4035c4:	f803 2b01 	strb.w	r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
  4035c8:	428b      	cmp	r3, r1
  4035ca:	d1fb      	bne.n	4035c4 <follow_path+0xd4>
  4035cc:	1ebb      	subs	r3, r7, #2
  4035ce:	f04f 0a00 	mov.w	sl, #0
  4035d2:	e001      	b.n	4035d8 <follow_path+0xe8>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4035d4:	f10a 0a01 	add.w	sl, sl, #1
  4035d8:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  4035dc:	2a20      	cmp	r2, #32
  4035de:	d0f9      	beq.n	4035d4 <follow_path+0xe4>
  4035e0:	2a2e      	cmp	r2, #46	; 0x2e
  4035e2:	d0f7      	beq.n	4035d4 <follow_path+0xe4>
	if (si) cf |= NS_LOSS | NS_LFN;
  4035e4:	f1ba 0f00 	cmp.w	sl, #0
  4035e8:	d001      	beq.n	4035ee <follow_path+0xfe>
  4035ea:	f04b 0b03 	orr.w	fp, fp, #3
  4035ee:	4603      	mov	r3, r0
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
  4035f0:	f833 1d02 	ldrh.w	r1, [r3, #-2]!
  4035f4:	292e      	cmp	r1, #46	; 0x2e
  4035f6:	d001      	beq.n	4035fc <follow_path+0x10c>
  4035f8:	3c01      	subs	r4, #1
  4035fa:	d1f9      	bne.n	4035f0 <follow_path+0x100>

	lfn[di] = 0;						/* LFN is created */

	/* Create SFN in directory form */
	mem_set(dj->fn, ' ', 11);
	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
  4035fc:	f04f 0c00 	mov.w	ip, #0
  403600:	4610      	mov	r0, r2
  403602:	46e0      	mov	r8, ip
  403604:	2308      	movs	r3, #8
	if (si) cf |= NS_LOSS | NS_LFN;
	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
  403606:	f10a 0a01 	add.w	sl, sl, #1
		if (!w) break;					/* Break on end of the LFN */
  40360a:	b378      	cbz	r0, 40366c <follow_path+0x17c>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  40360c:	2820      	cmp	r0, #32
  40360e:	d01f      	beq.n	403650 <follow_path+0x160>
  403610:	282e      	cmp	r0, #46	; 0x2e
  403612:	d01b      	beq.n	40364c <follow_path+0x15c>
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
  403614:	459c      	cmp	ip, r3
  403616:	d220      	bcs.n	40365a <follow_path+0x16a>
  403618:	4554      	cmp	r4, sl
  40361a:	d07a      	beq.n	403712 <follow_path+0x222>
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
  40361c:	287f      	cmp	r0, #127	; 0x7f
  40361e:	f200 8083 	bhi.w	403728 <follow_path+0x238>
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
  403622:	282b      	cmp	r0, #43	; 0x2b
  403624:	f000 8090 	beq.w	403748 <follow_path+0x258>
  403628:	4a64      	ldr	r2, [pc, #400]	; (4037bc <follow_path+0x2cc>)
  40362a:	e002      	b.n	403632 <follow_path+0x142>
  40362c:	4288      	cmp	r0, r1
  40362e:	f000 808b 	beq.w	403748 <follow_path+0x258>
  403632:	f812 1f01 	ldrb.w	r1, [r2, #1]!
  403636:	2900      	cmp	r1, #0
  403638:	d1f8      	bne.n	40362c <follow_path+0x13c>
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
  40363a:	f1a0 0141 	sub.w	r1, r0, #65	; 0x41
  40363e:	2919      	cmp	r1, #25
  403640:	f200 80a6 	bhi.w	403790 <follow_path+0x2a0>
					b |= 2;
  403644:	f048 0802 	orr.w	r8, r8, #2
  403648:	b2c0      	uxtb	r0, r0
  40364a:	e080      	b.n	40374e <follow_path+0x25e>

	b = i = 0; ni = 8;
	for (;;) {
		w = lfn[si++];					/* Get an LFN char */
		if (!w) break;					/* Break on end of the LFN */
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
  40364c:	4554      	cmp	r4, sl
  40364e:	d060      	beq.n	403712 <follow_path+0x222>
			cf |= NS_LOSS | NS_LFN; continue;
  403650:	f04b 0b03 	orr.w	fp, fp, #3
  403654:	f837 001a 	ldrh.w	r0, [r7, sl, lsl #1]
  403658:	e7d5      	b.n	403606 <follow_path+0x116>
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  40365a:	2b0b      	cmp	r3, #11
  40365c:	f000 80a6 	beq.w	4037ac <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  403660:	4554      	cmp	r4, sl
  403662:	d058      	beq.n	403716 <follow_path+0x226>
			if (si > di) break;			/* No extension */
  403664:	45a2      	cmp	sl, r4

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
  403666:	f04b 0b03 	orr.w	fp, fp, #3
			if (si > di) break;			/* No extension */
  40366a:	d954      	bls.n	403716 <follow_path+0x226>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  40366c:	69b1      	ldr	r1, [r6, #24]
  40366e:	7808      	ldrb	r0, [r1, #0]
  403670:	28e5      	cmp	r0, #229	; 0xe5
  403672:	d075      	beq.n	403760 <follow_path+0x270>

	if (ni == 8) b <<= 2;
  403674:	2b08      	cmp	r3, #8
  403676:	bf04      	itt	eq
  403678:	ea4f 0288 	moveq.w	r2, r8, lsl #2
  40367c:	fa5f f882 	uxtbeq.w	r8, r2
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
  403680:	f008 030c 	and.w	r3, r8, #12
  403684:	2b0c      	cmp	r3, #12
  403686:	d068      	beq.n	40375a <follow_path+0x26a>
  403688:	f008 0003 	and.w	r0, r8, #3
  40368c:	2803      	cmp	r0, #3
  40368e:	d064      	beq.n	40375a <follow_path+0x26a>
		cf |= NS_LFN;
	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
  403690:	f01b 0f02 	tst.w	fp, #2
  403694:	d109      	bne.n	4036aa <follow_path+0x1ba>
		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
  403696:	f008 0203 	and.w	r2, r8, #3
  40369a:	2a01      	cmp	r2, #1
  40369c:	bf08      	it	eq
  40369e:	f04b 0b10 	orreq.w	fp, fp, #16
		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
  4036a2:	2b04      	cmp	r3, #4
  4036a4:	bf08      	it	eq
  4036a6:	f04b 0b08 	orreq.w	fp, fp, #8
	}

	dj->fn[NS] = cf;	/* SFN is created */
  4036aa:	f881 b00b 	strb.w	fp, [r1, #11]
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
  4036ae:	4630      	mov	r0, r6
  4036b0:	2100      	movs	r1, #0
  4036b2:	4b43      	ldr	r3, [pc, #268]	; (4037c0 <follow_path+0x2d0>)
  4036b4:	4798      	blx	r3
	if (res != FR_OK) return res;
  4036b6:	b9d0      	cbnz	r0, 4036ee <follow_path+0x1fe>
  4036b8:	4b42      	ldr	r3, [pc, #264]	; (4037c4 <follow_path+0x2d4>)
  4036ba:	4630      	mov	r0, r6
  4036bc:	4798      	blx	r3
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  4036be:	69b3      	ldr	r3, [r6, #24]
  4036c0:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
  4036c2:	b9b0      	cbnz	r0, 4036f2 <follow_path+0x202>
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
  4036c4:	0759      	lsls	r1, r3, #29
  4036c6:	f53f af5f 	bmi.w	403588 <follow_path+0x98>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
  4036ca:	6973      	ldr	r3, [r6, #20]
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
  4036cc:	7ada      	ldrb	r2, [r3, #11]
  4036ce:	06d2      	lsls	r2, r2, #27
  4036d0:	d568      	bpl.n	4037a4 <follow_path+0x2b4>
				res = FR_NO_PATH; break;
			}
			dj->sclust = LD_CLUST(dir);
  4036d2:	7d5c      	ldrb	r4, [r3, #21]
  4036d4:	7d1a      	ldrb	r2, [r3, #20]
  4036d6:	7ed8      	ldrb	r0, [r3, #27]
  4036d8:	7e99      	ldrb	r1, [r3, #26]
  4036da:	ea42 2204 	orr.w	r2, r2, r4, lsl #8
  4036de:	ea41 2300 	orr.w	r3, r1, r0, lsl #8
  4036e2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  4036e6:	60b3      	str	r3, [r6, #8]
  4036e8:	f899 0000 	ldrb.w	r0, [r9]
		}
  4036ec:	e717      	b.n	40351e <follow_path+0x2e>
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
  4036ee:	69b3      	ldr	r3, [r6, #24]
  4036f0:	7adb      	ldrb	r3, [r3, #11]
			if (res != FR_OK) {				/* Failed to find the object */
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
  4036f2:	2804      	cmp	r0, #4
  4036f4:	f47f af48 	bne.w	403588 <follow_path+0x98>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
  4036f8:	f013 0f04 	tst.w	r3, #4
  4036fc:	bf08      	it	eq
  4036fe:	2005      	moveq	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403700:	b003      	add	sp, #12
  403702:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	const TCHAR *p;

	/* Create LFN in Unicode */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	lfn = dj->lfn;
	si = di = 0;
  403706:	2400      	movs	r4, #0
	for (;;) {
		w = p[si++];					/* Get a character */
  403708:	2301      	movs	r3, #1
#endif
		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
			return FR_INVALID_NAME;
		lfn[di++] = w;					/* Store the Unicode char */
	}
	*path = &p[si];						/* Return pointer to the next segment */
  40370a:	4499      	add	r9, r3
	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
  40370c:	f04f 0b04 	mov.w	fp, #4
  403710:	e742      	b.n	403598 <follow_path+0xa8>
		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
  403712:	2b0b      	cmp	r3, #11
  403714:	d04a      	beq.n	4037ac <follow_path+0x2bc>
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
			b <<= 2; continue;
  403716:	ea4f 0288 	mov.w	r2, r8, lsl #2
  40371a:	fa5f f882 	uxtb.w	r8, r2
  40371e:	46a2      	mov	sl, r4
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
			}
			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
			if (si > di) break;			/* No extension */
			si = di; i = 8; ni = 11;	/* Enter extension section */
  403720:	230b      	movs	r3, #11
  403722:	f04f 0c08 	mov.w	ip, #8
  403726:	e795      	b.n	403654 <follow_path+0x164>
			b <<= 2; continue;
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
  403728:	2100      	movs	r1, #0
  40372a:	e88d 1008 	stmia.w	sp, {r3, ip}
  40372e:	47a8      	blx	r5
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  403730:	e89d 1008 	ldmia.w	sp, {r3, ip}
  403734:	b348      	cbz	r0, 40378a <follow_path+0x29a>
  403736:	4a24      	ldr	r2, [pc, #144]	; (4037c8 <follow_path+0x2d8>)
  403738:	4410      	add	r0, r2
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  40373a:	f04b 0b02 	orr.w	fp, fp, #2
		}

		if (w >= 0x80) {				/* Non ASCII char */
#ifdef _EXCVT
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
  40373e:	f810 0c80 	ldrb.w	r0, [r0, #-128]
			if (i >= ni - 1) {
				cf |= NS_LOSS | NS_LFN; i = ni; continue;
			}
			dj->fn[i++] = (BYTE)(w >> 8);
		} else {						/* Single byte char */
			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
  403742:	2800      	cmp	r0, #0
  403744:	f47f af6d 	bne.w	403622 <follow_path+0x132>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
  403748:	f04b 0b03 	orr.w	fp, fp, #3
  40374c:	205f      	movs	r0, #95	; 0x5f
						b |= 1; w -= 0x20;
					}
				}
			}
		}
		dj->fn[i++] = (BYTE)w;
  40374e:	69b1      	ldr	r1, [r6, #24]
  403750:	f801 000c 	strb.w	r0, [r1, ip]
  403754:	f10c 0c01 	add.w	ip, ip, #1
  403758:	e77c      	b.n	403654 <follow_path+0x164>

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */

	if (ni == 8) b <<= 2;
	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
		cf |= NS_LFN;
  40375a:	f04b 0b02 	orr.w	fp, fp, #2
  40375e:	e797      	b.n	403690 <follow_path+0x1a0>
			}
		}
		dj->fn[i++] = (BYTE)w;
	}

	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
  403760:	2005      	movs	r0, #5
  403762:	7008      	strb	r0, [r1, #0]
  403764:	69b1      	ldr	r1, [r6, #24]
  403766:	e785      	b.n	403674 <follow_path+0x184>
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
		path++;
  403768:	f109 0901 	add.w	r9, r9, #1
	dj->sclust = 0;						/* Start from the root dir */
  40376c:	2400      	movs	r4, #0
  40376e:	60b4      	str	r4, [r6, #8]
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
  403770:	f899 0000 	ldrb.w	r0, [r9]
  403774:	281f      	cmp	r0, #31
  403776:	f63f aece 	bhi.w	403516 <follow_path+0x26>
		res = dir_sdi(dj, 0);
  40377a:	4630      	mov	r0, r6
  40377c:	4621      	mov	r1, r4
  40377e:	4b10      	ldr	r3, [pc, #64]	; (4037c0 <follow_path+0x2d0>)
  403780:	4798      	blx	r3
		dj->dir = 0;
  403782:	6174      	str	r4, [r6, #20]
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  403784:	b003      	add	sp, #12
  403786:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			w = ff_convert(w, 0);		/* Unicode -> OEM code */
			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
#else
			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
#endif
			cf |= NS_LFN;				/* Force create LFN entry */
  40378a:	f04b 0b02 	orr.w	fp, fp, #2
  40378e:	e7db      	b.n	403748 <follow_path+0x258>
				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
			} else {
				if (IsUpper(w)) {		/* ASCII large capital */
					b |= 2;
				} else {
					if (IsLower(w)) {	/* ASCII small capital */
  403790:	f1a0 0161 	sub.w	r1, r0, #97	; 0x61
  403794:	2919      	cmp	r1, #25
						b |= 1; w -= 0x20;
  403796:	bf97      	itett	ls
  403798:	3820      	subls	r0, #32
  40379a:	b2c0      	uxtbhi	r0, r0
  40379c:	b2c0      	uxtbls	r0, r0
  40379e:	f048 0801 	orrls.w	r8, r8, #1
  4037a2:	e7d4      	b.n	40374e <follow_path+0x25e>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
  4037a4:	2005      	movs	r0, #5
			dj->sclust = LD_CLUST(dir);
		}
	}

	return res;
}
  4037a6:	b003      	add	sp, #12
  4037a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cf |= NS_LOSS | NS_LFN; continue;
		}

		if (i >= ni || si == di) {		/* Extension or end of SFN */
			if (ni == 11) {				/* Long extension */
				cf |= NS_LOSS | NS_LFN; break;
  4037ac:	f04b 0b03 	orr.w	fp, fp, #3
  4037b0:	230b      	movs	r3, #11
  4037b2:	e75b      	b.n	40366c <follow_path+0x17c>
  4037b4:	00403d65 	.word	0x00403d65
  4037b8:	00406bec 	.word	0x00406bec
  4037bc:	00406bf8 	.word	0x00406bf8
  4037c0:	00402c51 	.word	0x00402c51
  4037c4:	00403011 	.word	0x00403011
  4037c8:	00406b6c 	.word	0x00406b6c

004037cc <f_mount>:

FRESULT f_mount (
	BYTE vol,		/* Logical drive number to be mounted/unmounted */
	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
)
{
  4037cc:	b4f0      	push	{r4, r5, r6, r7}
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
  4037ce:	b110      	cbz	r0, 4037d6 <f_mount+0xa>
		return FR_INVALID_DRIVE;
  4037d0:	200b      	movs	r0, #11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
  4037d2:	bcf0      	pop	{r4, r5, r6, r7}
  4037d4:	4770      	bx	lr
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
  4037d6:	4d0b      	ldr	r5, [pc, #44]	; (403804 <f_mount+0x38>)
  4037d8:	682b      	ldr	r3, [r5, #0]

	if (rfs) {
  4037da:	b15b      	cbz	r3, 4037f4 <f_mount+0x28>
  4037dc:	4c0a      	ldr	r4, [pc, #40]	; (403808 <f_mount+0x3c>)
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
		if (Files[i].fs == fs) Files[i].fs = 0;
  4037de:	4607      	mov	r7, r0
  4037e0:	4626      	mov	r6, r4
  4037e2:	5822      	ldr	r2, [r4, r0]
  4037e4:	4293      	cmp	r3, r2
  4037e6:	bf08      	it	eq
  4037e8:	5187      	streq	r7, [r0, r6]
  4037ea:	300c      	adds	r0, #12
	FATFS *fs
)
{
	UINT i;

	for (i = 0; i < _FS_SHARE; i++) {
  4037ec:	2824      	cmp	r0, #36	; 0x24
  4037ee:	d1f8      	bne.n	4037e2 <f_mount+0x16>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
  4037f0:	2200      	movs	r2, #0
  4037f2:	701a      	strb	r2, [r3, #0]
	}

	if (fs) {
  4037f4:	b109      	cbz	r1, 4037fa <f_mount+0x2e>
		fs->fs_type = 0;		/* Clear new fs object */
  4037f6:	2300      	movs	r3, #0
  4037f8:	700b      	strb	r3, [r1, #0]
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
  4037fa:	6029      	str	r1, [r5, #0]

	return FR_OK;
  4037fc:	2000      	movs	r0, #0
}
  4037fe:	bcf0      	pop	{r4, r5, r6, r7}
  403800:	4770      	bx	lr
  403802:	bf00      	nop
  403804:	20000f8c 	.word	0x20000f8c
  403808:	20000f68 	.word	0x20000f68

0040380c <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  40380c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403810:	f5ad 7d0f 	sub.w	sp, sp, #572	; 0x23c
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	fp->fs = 0;			/* Clear file object */
  403814:	2300      	movs	r3, #0
  403816:	6003      	str	r3, [r0, #0]
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  403818:	4616      	mov	r6, r2
  40381a:	9101      	str	r1, [sp, #4]

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  40381c:	f002 021e 	and.w	r2, r2, #30
  403820:	4b9a      	ldr	r3, [pc, #616]	; (403a8c <f_open+0x280>)
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
  403822:	4604      	mov	r4, r0

	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
  403824:	a905      	add	r1, sp, #20
  403826:	a801      	add	r0, sp, #4
  403828:	4798      	blx	r3
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
  40382a:	ab02      	add	r3, sp, #8
  40382c:	aa0e      	add	r2, sp, #56	; 0x38
  40382e:	930b      	str	r3, [sp, #44]	; 0x2c
  403830:	920c      	str	r2, [sp, #48]	; 0x30


	fp->fs = 0;			/* Clear file object */

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  403832:	f006 071f 	and.w	r7, r6, #31
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
  403836:	b130      	cbz	r0, 403846 <f_open+0x3a>
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  403838:	f016 0f1c 	tst.w	r6, #28
  40383c:	d11a      	bne.n	403874 <f_open+0x68>
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40383e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403842:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	INIT_BUF(dj);
	if (res == FR_OK)
		res = follow_path(&dj, path);	/* Follow the file path */
  403846:	9901      	ldr	r1, [sp, #4]
  403848:	4b91      	ldr	r3, [pc, #580]	; (403a90 <f_open+0x284>)
  40384a:	a805      	add	r0, sp, #20
  40384c:	4798      	blx	r3
	dir = dj.dir;
  40384e:	9d0a      	ldr	r5, [sp, #40]	; 0x28

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
  403850:	2800      	cmp	r0, #0
  403852:	d1f1      	bne.n	403838 <f_open+0x2c>
		if (!dir)	/* Current dir itself */
  403854:	2d00      	cmp	r5, #0
  403856:	f000 80ab 	beq.w	4039b0 <f_open+0x1a4>
			res = FR_INVALID_NAME;
#if _FS_SHARE
		else
			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40385a:	f037 0801 	bics.w	r8, r7, #1
  40385e:	bf0c      	ite	eq
  403860:	2100      	moveq	r1, #0
  403862:	2101      	movne	r1, #1
  403864:	a805      	add	r0, sp, #20
  403866:	4b8b      	ldr	r3, [pc, #556]	; (403a94 <f_open+0x288>)
  403868:	4798      	blx	r3
#endif
	}
	/* Create or Open a file */
	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
  40386a:	f016 0f1c 	tst.w	r6, #28
  40386e:	d01b      	beq.n	4038a8 <f_open+0x9c>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
  403870:	2800      	cmp	r0, #0
  403872:	d050      	beq.n	403916 <f_open+0x10a>
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
  403874:	2804      	cmp	r0, #4
  403876:	d1e2      	bne.n	40383e <f_open+0x32>
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403878:	4b87      	ldr	r3, [pc, #540]	; (403a98 <f_open+0x28c>)
  40387a:	681a      	ldr	r2, [r3, #0]
  40387c:	b12a      	cbz	r2, 40388a <f_open+0x7e>
  40387e:	68da      	ldr	r2, [r3, #12]
  403880:	b11a      	cbz	r2, 40388a <f_open+0x7e>
  403882:	699b      	ldr	r3, [r3, #24]
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  403884:	2012      	movs	r0, #18
static
int enq_lock (void)	/* Check if an entry is available for a new file */
{
	UINT i;

	for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403886:	2b00      	cmp	r3, #0
  403888:	d1d9      	bne.n	40383e <f_open+0x32>
		DWORD dw, cl;

		if (res != FR_OK) {					/* No file, create new */
			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
#if _FS_SHARE
				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
  40388a:	a805      	add	r0, sp, #20
  40388c:	4b83      	ldr	r3, [pc, #524]	; (403a9c <f_open+0x290>)
  40388e:	4798      	blx	r3
#else
				res = dir_register(&dj);
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
  403890:	f047 0708 	orr.w	r7, r7, #8
			dir = dj.dir;					/* New entry */
  403894:	9d0a      	ldr	r5, [sp, #40]	; 0x28
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
  403896:	2800      	cmp	r0, #0
  403898:	d1d1      	bne.n	40383e <f_open+0x32>
  40389a:	0738      	lsls	r0, r7, #28
  40389c:	f100 808a 	bmi.w	4039b4 <f_open+0x1a8>
  4038a0:	9e05      	ldr	r6, [sp, #20]
  4038a2:	f027 0801 	bic.w	r8, r7, #1
  4038a6:	e011      	b.n	4038cc <f_open+0xc0>
				}
			}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
  4038a8:	2800      	cmp	r0, #0
  4038aa:	d1c8      	bne.n	40383e <f_open+0x32>
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
  4038ac:	7aeb      	ldrb	r3, [r5, #11]
  4038ae:	06d9      	lsls	r1, r3, #27
  4038b0:	d43e      	bmi.n	403930 <f_open+0x124>
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
  4038b2:	07b2      	lsls	r2, r6, #30
  4038b4:	d501      	bpl.n	4038ba <f_open+0xae>
  4038b6:	07db      	lsls	r3, r3, #31
  4038b8:	d435      	bmi.n	403926 <f_open+0x11a>
  4038ba:	f006 0308 	and.w	r3, r6, #8
  4038be:	b2db      	uxtb	r3, r3
  4038c0:	9e05      	ldr	r6, [sp, #20]
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
  4038c2:	b11b      	cbz	r3, 4038cc <f_open+0xc0>
			mode |= FA__WRITTEN;
  4038c4:	f047 0720 	orr.w	r7, r7, #32
  4038c8:	f027 0801 	bic.w	r8, r7, #1
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  4038cc:	6af3      	ldr	r3, [r6, #44]	; 0x2c
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
			Files[i].clu == dj->sclust &&
  4038ce:	9807      	ldr	r0, [sp, #28]
			Files[i].idx == dj->index) break;
  4038d0:	f8bd c01a 	ldrh.w	ip, [sp, #26]
  4038d4:	4a72      	ldr	r2, [pc, #456]	; (403aa0 <f_open+0x294>)
		}
	}
	if (res == FR_OK) {
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
  4038d6:	61e3      	str	r3, [r4, #28]
		fp->dir_ptr = dir;
  4038d8:	6225      	str	r5, [r4, #32]
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  4038da:	2300      	movs	r3, #0
		if (Files[i].fs == dj->fs &&
  4038dc:	f852 1c08 	ldr.w	r1, [r2, #-8]
  4038e0:	42b1      	cmp	r1, r6
  4038e2:	d02a      	beq.n	40393a <f_open+0x12e>
)
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
  4038e4:	3301      	adds	r3, #1
  4038e6:	2b03      	cmp	r3, #3
  4038e8:	f102 020c 	add.w	r2, r2, #12
  4038ec:	d1f6      	bne.n	4038dc <f_open+0xd0>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  4038ee:	4a6a      	ldr	r2, [pc, #424]	; (403a98 <f_open+0x28c>)
  4038f0:	6813      	ldr	r3, [r2, #0]
  4038f2:	2b00      	cmp	r3, #0
  4038f4:	f000 809a 	beq.w	403a2c <f_open+0x220>
  4038f8:	68d3      	ldr	r3, [r2, #12]
  4038fa:	2b00      	cmp	r3, #0
  4038fc:	f000 8095 	beq.w	403a2a <f_open+0x21e>
  403900:	6993      	ldr	r3, [r2, #24]
  403902:	2b00      	cmp	r3, #0
  403904:	f000 80ac 	beq.w	403a60 <f_open+0x254>
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403908:	2300      	movs	r3, #0
		if (!fp->lockid) res = FR_INT_ERR;
  40390a:	2002      	movs	r0, #2
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  40390c:	6263      	str	r3, [r4, #36]	; 0x24
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  40390e:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403912:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
#endif
			mode |= FA_CREATE_ALWAYS;		/* File is created */
			dir = dj.dir;					/* New entry */
		}
		else {								/* Any object is already existing */
			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
  403916:	7aeb      	ldrb	r3, [r5, #11]
  403918:	f013 0f11 	tst.w	r3, #17
  40391c:	d103      	bne.n	403926 <f_open+0x11a>
				res = FR_DENIED;
			} else {
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
  40391e:	0776      	lsls	r6, r6, #29
  403920:	d5bb      	bpl.n	40389a <f_open+0x8e>
					res = FR_EXIST;
  403922:	2008      	movs	r0, #8
  403924:	e78b      	b.n	40383e <f_open+0x32>
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
			} else {
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
  403926:	2007      	movs	r0, #7
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403928:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  40392c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		}
	}
	else {	/* Open an existing file */
		if (res == FR_OK) {						/* Follow succeeded */
			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
				res = FR_NO_FILE;
  403930:	2004      	movs	r0, #4
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403932:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403936:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
{
	UINT i;


	for (i = 0; i < _FS_SHARE; i++) {	/* Find the file */
		if (Files[i].fs == dj->fs &&
  40393a:	f852 1c04 	ldr.w	r1, [r2, #-4]
  40393e:	4281      	cmp	r1, r0
  403940:	d1d0      	bne.n	4038e4 <f_open+0xd8>
			Files[i].clu == dj->sclust &&
  403942:	8811      	ldrh	r1, [r2, #0]
  403944:	4561      	cmp	r1, ip
  403946:	d1cd      	bne.n	4038e4 <f_open+0xd8>
  403948:	0059      	lsls	r1, r3, #1
  40394a:	4a53      	ldr	r2, [pc, #332]	; (403a98 <f_open+0x28c>)
  40394c:	18c8      	adds	r0, r1, r3
  40394e:	eb02 0080 	add.w	r0, r2, r0, lsl #2
  403952:	8940      	ldrh	r0, [r0, #10]
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403954:	f1b8 0f00 	cmp.w	r8, #0
  403958:	d161      	bne.n	403a1e <f_open+0x212>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  40395a:	3001      	adds	r0, #1
  40395c:	b280      	uxth	r0, r0
  40395e:	4419      	add	r1, r3
  403960:	eb02 0281 	add.w	r2, r2, r1, lsl #2

	return i + 1;
  403964:	3301      	adds	r3, #1
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  403966:	8150      	strh	r0, [r2, #10]
		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
  403968:	6263      	str	r3, [r4, #36]	; 0x24
		if (!fp->lockid) res = FR_INT_ERR;
  40396a:	2b00      	cmp	r3, #0
  40396c:	d052      	beq.n	403a14 <f_open+0x208>
	}
#endif
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
  40396e:	71a7      	strb	r7, [r4, #6]
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
  403970:	7d68      	ldrb	r0, [r5, #21]
  403972:	7ea9      	ldrb	r1, [r5, #26]
  403974:	7d2a      	ldrb	r2, [r5, #20]
  403976:	7eeb      	ldrb	r3, [r5, #27]
  403978:	ea42 2200 	orr.w	r2, r2, r0, lsl #8
  40397c:	ea41 2303 	orr.w	r3, r1, r3, lsl #8
  403980:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
  403984:	6123      	str	r3, [r4, #16]
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  403986:	7fab      	ldrb	r3, [r5, #30]
  403988:	7fe8      	ldrb	r0, [r5, #31]
  40398a:	7f29      	ldrb	r1, [r5, #28]
  40398c:	7f6a      	ldrb	r2, [r5, #29]
		fp->fptr = 0;						/* File pointer */
		fp->dsect = 0;
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  40398e:	6026      	str	r6, [r4, #0]
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  403990:	041b      	lsls	r3, r3, #16
  403992:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
  403996:	430b      	orrs	r3, r1
		fp->fptr = 0;						/* File pointer */
  403998:	2000      	movs	r0, #0
	FREE_BUF();

	if (res == FR_OK) {
		fp->flag = mode;					/* File access mode */
		fp->sclust = LD_CLUST(dir);			/* File start cluster */
		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
  40399a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
  40399e:	60e3      	str	r3, [r4, #12]
		fp->fptr = 0;						/* File pointer */
  4039a0:	60a0      	str	r0, [r4, #8]
		fp->dsect = 0;
  4039a2:	61a0      	str	r0, [r4, #24]
#if _USE_FASTSEEK
		fp->cltbl = 0;						/* Normal seek mode */
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
  4039a4:	88f3      	ldrh	r3, [r6, #6]
  4039a6:	80a3      	strh	r3, [r4, #4]
	}

	LEAVE_FF(dj.fs, res);
}
  4039a8:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  4039ac:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	dir = dj.dir;

#if !_FS_READONLY	/* R/W configuration */
	if (res == FR_OK) {
		if (!dir)	/* Current dir itself */
			res = FR_INVALID_NAME;
  4039b0:	2006      	movs	r0, #6
  4039b2:	e741      	b.n	403838 <f_open+0x2c>
				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
  4039b4:	4b3b      	ldr	r3, [pc, #236]	; (403aa4 <f_open+0x298>)
  4039b6:	4798      	blx	r3
			ST_DWORD(dir+DIR_CrtTime, dw);
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  4039b8:	f895 c015 	ldrb.w	ip, [r5, #21]
  4039bc:	7eab      	ldrb	r3, [r5, #26]
  4039be:	7d29      	ldrb	r1, [r5, #20]
  4039c0:	7eea      	ldrb	r2, [r5, #27]
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  4039c2:	9e05      	ldr	r6, [sp, #20]
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039c4:	73a8      	strb	r0, [r5, #14]
  4039c6:	ea4f 4810 	mov.w	r8, r0, lsr #16
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
  4039ca:	ea41 210c 	orr.w	r1, r1, ip, lsl #8
  4039ce:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039d2:	f3c0 2907 	ubfx	r9, r0, #8, #8
			dir[DIR_Attr] = 0;					/* Reset attribute */
  4039d6:	2300      	movs	r3, #0
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039d8:	f885 8010 	strb.w	r8, [r5, #16]
  4039dc:	0e00      	lsrs	r0, r0, #24
			dir[DIR_Attr] = 0;					/* Reset attribute */
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
  4039de:	f04f 0c01 	mov.w	ip, #1
			if (cl) {							/* Remove the cluster chain if exist */
  4039e2:	ea52 4801 	orrs.w	r8, r2, r1, lsl #16
					res = FR_EXIST;
			}
		}
		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
			dw = get_fattime();					/* Created time */
			ST_DWORD(dir+DIR_CrtTime, dw);
  4039e6:	f885 900f 	strb.w	r9, [r5, #15]
  4039ea:	7468      	strb	r0, [r5, #17]
			dir[DIR_Attr] = 0;					/* Reset attribute */
  4039ec:	72eb      	strb	r3, [r5, #11]
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
  4039ee:	772b      	strb	r3, [r5, #28]
  4039f0:	776b      	strb	r3, [r5, #29]
  4039f2:	77ab      	strb	r3, [r5, #30]
  4039f4:	77eb      	strb	r3, [r5, #31]
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
  4039f6:	76ab      	strb	r3, [r5, #26]
  4039f8:	76eb      	strb	r3, [r5, #27]
  4039fa:	752b      	strb	r3, [r5, #20]
  4039fc:	756b      	strb	r3, [r5, #21]
			dj.fs->wflag = 1;
  4039fe:	f886 c004 	strb.w	ip, [r6, #4]
			if (cl) {							/* Remove the cluster chain if exist */
  403a02:	f43f af5f 	beq.w	4038c4 <f_open+0xb8>
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  403a06:	45e0      	cmp	r8, ip
			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
			cl = LD_CLUST(dir);					/* Get start cluster */
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
  403a08:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
	DWORD nxt;
#if _USE_ERASE
	DWORD scl = clst, ecl = clst, resion[2];
#endif

	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
  403a0c:	d002      	beq.n	403a14 <f_open+0x208>
  403a0e:	69b3      	ldr	r3, [r6, #24]
  403a10:	4598      	cmp	r8, r3
  403a12:	d327      	bcc.n	403a64 <f_open+0x258>
			mode |= FA__WRITTEN;
		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
		fp->dir_ptr = dir;
#if _FS_SHARE
		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
		if (!fp->lockid) res = FR_INT_ERR;
  403a14:	2002      	movs	r0, #2
#endif
		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
	}

	LEAVE_FF(dj.fs, res);
}
  403a16:	f50d 7d0f 	add.w	sp, sp, #572	; 0x23c
  403a1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403a1e:	2800      	cmp	r0, #0
  403a20:	f47f af72 	bne.w	403908 <f_open+0xfc>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
  403a24:	f44f 7080 	mov.w	r0, #256	; 0x100
  403a28:	e799      	b.n	40395e <f_open+0x152>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403a2a:	2301      	movs	r3, #1
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
  403a2c:	0059      	lsls	r1, r3, #1
  403a2e:	eb01 0c03 	add.w	ip, r1, r3
  403a32:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  403a36:	eb02 000c 	add.w	r0, r2, ip
  403a3a:	f842 600c 	str.w	r6, [r2, ip]
		Files[i].clu = dj->sclust;
  403a3e:	f8dd b01c 	ldr.w	fp, [sp, #28]
		Files[i].idx = dj->index;
  403a42:	f8bd a01a 	ldrh.w	sl, [sp, #26]

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
  403a46:	f8c0 b004 	str.w	fp, [r0, #4]
		Files[i].idx = dj->index;
		Files[i].ctr = 0;
  403a4a:	f04f 0c00 	mov.w	ip, #0
	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
		if (i == _FS_SHARE) return 0;	/* No space to register (int err) */
		Files[i].fs = dj->fs;
		Files[i].clu = dj->sclust;
		Files[i].idx = dj->index;
  403a4e:	f8a0 a008 	strh.w	sl, [r0, #8]
		Files[i].ctr = 0;
  403a52:	f8a0 c00a 	strh.w	ip, [r0, #10]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
  403a56:	f1b8 0f00 	cmp.w	r8, #0
  403a5a:	d1e3      	bne.n	403a24 <f_open+0x218>
  403a5c:	4640      	mov	r0, r8
  403a5e:	e77c      	b.n	40395a <f_open+0x14e>
			Files[i].clu == dj->sclust &&
			Files[i].idx == dj->index) break;
	}

	if (i == _FS_SHARE) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_SHARE && Files[i].fs; i++) ;
  403a60:	2302      	movs	r3, #2
  403a62:	e7e3      	b.n	403a2c <f_open+0x220>
  403a64:	4630      	mov	r0, r6
  403a66:	4641      	mov	r1, r8
  403a68:	4b0f      	ldr	r3, [pc, #60]	; (403aa8 <f_open+0x29c>)
  403a6a:	4798      	blx	r3
			ST_CLUST(dir, 0);					/* cluster = 0 */
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
  403a6c:	2800      	cmp	r0, #0
  403a6e:	f47f aee6 	bne.w	40383e <f_open+0x32>
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a72:	9805      	ldr	r0, [sp, #20]
					res = move_window(dj.fs, dw);
  403a74:	4b0d      	ldr	r3, [pc, #52]	; (403aac <f_open+0x2a0>)
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a76:	f108 32ff 	add.w	r2, r8, #4294967295
					res = move_window(dj.fs, dw);
  403a7a:	4649      	mov	r1, r9
			dj.fs->wflag = 1;
			if (cl) {							/* Remove the cluster chain if exist */
				dw = dj.fs->winsect;
				res = remove_chain(dj.fs, cl);
				if (res == FR_OK) {
					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
  403a7c:	60c2      	str	r2, [r0, #12]
					res = move_window(dj.fs, dw);
  403a7e:	4798      	blx	r3
				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
					res = FR_DENIED;
			}
		}
	}
	if (res == FR_OK) {
  403a80:	2800      	cmp	r0, #0
  403a82:	f47f aedc 	bne.w	40383e <f_open+0x32>
  403a86:	9e05      	ldr	r6, [sp, #20]
  403a88:	e71c      	b.n	4038c4 <f_open+0xb8>
  403a8a:	bf00      	nop
  403a8c:	00402855 	.word	0x00402855
  403a90:	004034f1 	.word	0x004034f1
  403a94:	004025d5 	.word	0x004025d5
  403a98:	20000f68 	.word	0x20000f68
  403a9c:	00403179 	.word	0x00403179
  403aa0:	20000f70 	.word	0x20000f70
  403aa4:	0040257d 	.word	0x0040257d
  403aa8:	00403485 	.word	0x00403485
  403aac:	00402645 	.word	0x00402645

00403ab0 <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403ab0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  403ab4:	469b      	mov	fp, r3
  403ab6:	4606      	mov	r6, r0
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */
  403ab8:	2300      	movs	r3, #0
  403aba:	f8cb 3000 	str.w	r3, [fp]
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403abe:	b083      	sub	sp, #12
  403ac0:	460d      	mov	r5, r1
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  403ac2:	6800      	ldr	r0, [r0, #0]
  403ac4:	88b1      	ldrh	r1, [r6, #4]
  403ac6:	4b62      	ldr	r3, [pc, #392]	; (403c50 <f_read+0x1a0>)
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
  403ac8:	4614      	mov	r4, r2
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
  403aca:	4798      	blx	r3
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
  403acc:	b928      	cbnz	r0, 403ada <f_read+0x2a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
  403ace:	79b3      	ldrb	r3, [r6, #6]
  403ad0:	061f      	lsls	r7, r3, #24
  403ad2:	d405      	bmi.n	403ae0 <f_read+0x30>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
  403ad4:	07d8      	lsls	r0, r3, #31
  403ad6:	d407      	bmi.n	403ae8 <f_read+0x38>
		LEAVE_FF(fp->fs, FR_DENIED);
  403ad8:	2007      	movs	r0, #7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403ada:	b003      	add	sp, #12
  403adc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	*br = 0;	/* Initialize byte counter */

	res = validate(fp->fs, fp->id);				/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
  403ae0:	2002      	movs	r0, #2
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
  403ae2:	b003      	add	sp, #12
  403ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
  403ae8:	68b1      	ldr	r1, [r6, #8]
  403aea:	68f7      	ldr	r7, [r6, #12]
  403aec:	1a7f      	subs	r7, r7, r1
  403aee:	42bc      	cmp	r4, r7
  403af0:	bf38      	it	cc
  403af2:	4627      	movcc	r7, r4
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403af4:	2f00      	cmp	r7, #0
  403af6:	f000 80a8 	beq.w	403c4a <f_read+0x19a>
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403afa:	f3c1 0308 	ubfx	r3, r1, #0, #9
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403afe:	f8df 8158 	ldr.w	r8, [pc, #344]	; 403c58 <f_read+0x1a8>
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403b02:	f8df 9158 	ldr.w	r9, [pc, #344]	; 403c5c <f_read+0x1ac>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403b06:	2b00      	cmp	r3, #0
  403b08:	d13e      	bne.n	403b88 <f_read+0xd8>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
  403b0a:	6830      	ldr	r0, [r6, #0]
  403b0c:	7883      	ldrb	r3, [r0, #2]
  403b0e:	3b01      	subs	r3, #1
  403b10:	ea03 2351 	and.w	r3, r3, r1, lsr #9
			if (!csect) {						/* On the cluster boundary? */
  403b14:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
  403b18:	d04b      	beq.n	403bb2 <f_read+0x102>
  403b1a:	6972      	ldr	r2, [r6, #20]
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403b1c:	6981      	ldr	r1, [r0, #24]
static DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
  403b1e:	f1a2 0c02 	sub.w	ip, r2, #2
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
  403b22:	3902      	subs	r1, #2
  403b24:	458c      	cmp	ip, r1
  403b26:	d271      	bcs.n	403c0c <f_read+0x15c>
	return clst * fs->csize + fs->database;
  403b28:	7882      	ldrb	r2, [r0, #2]
  403b2a:	6a81      	ldr	r1, [r0, #40]	; 0x28
  403b2c:	fb02 110c 	mla	r1, r2, ip, r1
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403b30:	2900      	cmp	r1, #0
  403b32:	d06b      	beq.n	403c0c <f_read+0x15c>
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403b34:	0a7c      	lsrs	r4, r7, #9
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
			sect += csect;
  403b36:	eb01 0a03 	add.w	sl, r1, r3
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
  403b3a:	d043      	beq.n	403bc4 <f_read+0x114>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
  403b3c:	1919      	adds	r1, r3, r4
  403b3e:	4291      	cmp	r1, r2
					cc = fp->fs->csize - csect;
  403b40:	bf88      	it	hi
  403b42:	ebc3 0402 	rsbhi	r4, r3, r2
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403b46:	b2e3      	uxtb	r3, r4
  403b48:	7840      	ldrb	r0, [r0, #1]
  403b4a:	4629      	mov	r1, r5
  403b4c:	4652      	mov	r2, sl
  403b4e:	47c0      	blx	r8
					ABORT(fp->fs, FR_DISK_ERR);
  403b50:	79b3      	ldrb	r3, [r6, #6]
			sect += csect;
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
			if (cc) {							/* Read maximum contiguous sectors directly */
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
					cc = fp->fs->csize - csect;
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
  403b52:	2800      	cmp	r0, #0
  403b54:	d161      	bne.n	403c1a <f_read+0x16a>
#if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
  403b56:	065a      	lsls	r2, r3, #25
  403b58:	d504      	bpl.n	403b64 <f_read+0xb4>
  403b5a:	69b3      	ldr	r3, [r6, #24]
  403b5c:	ebca 0303 	rsb	r3, sl, r3
  403b60:	429c      	cmp	r4, r3
  403b62:	d85f      	bhi.n	403c24 <f_read+0x174>
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
  403b64:	0262      	lsls	r2, r4, #9
  403b66:	68b1      	ldr	r1, [r6, #8]
  403b68:	18ab      	adds	r3, r5, r2
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  403b6a:	4411      	add	r1, r2
  403b6c:	60b1      	str	r1, [r6, #8]
  403b6e:	f8db 1000 	ldr.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403b72:	1abf      	subs	r7, r7, r2
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
  403b74:	4411      	add	r1, r2
  403b76:	461d      	mov	r5, r3
  403b78:	f8cb 1000 	str.w	r1, [fp]
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
  403b7c:	d065      	beq.n	403c4a <f_read+0x19a>
  403b7e:	68b1      	ldr	r1, [r6, #8]
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
  403b80:	f3c1 0308 	ubfx	r3, r1, #0, #9
  403b84:	2b00      	cmp	r3, #0
  403b86:	d0c0      	beq.n	403b0a <f_read+0x5a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
  403b88:	f5c3 7200 	rsb	r2, r3, #512	; 0x200
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
  403b8c:	f103 0428 	add.w	r4, r3, #40	; 0x28
  403b90:	42ba      	cmp	r2, r7
  403b92:	bf28      	it	cs
  403b94:	463a      	movcs	r2, r7
  403b96:	4434      	add	r4, r6
  403b98:	462b      	mov	r3, r5
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403b9a:	2a00      	cmp	r2, #0
  403b9c:	d0e5      	beq.n	403b6a <f_read+0xba>
  403b9e:	18ab      	adds	r3, r5, r2
  403ba0:	4629      	mov	r1, r5
		*d++ = *s++;
  403ba2:	f814 5b01 	ldrb.w	r5, [r4], #1
  403ba6:	f801 5b01 	strb.w	r5, [r1], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403baa:	4299      	cmp	r1, r3
  403bac:	d1f9      	bne.n	403ba2 <f_read+0xf2>
  403bae:	68b1      	ldr	r1, [r6, #8]
  403bb0:	e7db      	b.n	403b6a <f_read+0xba>
	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
			if (!csect) {						/* On the cluster boundary? */
				if (fp->fptr == 0) {			/* On the top of the file? */
  403bb2:	bb29      	cbnz	r1, 403c00 <f_read+0x150>
					clst = fp->sclust;			/* Follow from the origin */
  403bb4:	6932      	ldr	r2, [r6, #16]
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
  403bb6:	2a01      	cmp	r2, #1
  403bb8:	d928      	bls.n	403c0c <f_read+0x15c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
  403bba:	1c51      	adds	r1, r2, #1
  403bbc:	d02c      	beq.n	403c18 <f_read+0x168>
  403bbe:	6830      	ldr	r0, [r6, #0]
				fp->clust = clst;				/* Update current cluster */
  403bc0:	6172      	str	r2, [r6, #20]
  403bc2:	e7ab      	b.n	403b1c <f_read+0x6c>
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
  403bc4:	69b2      	ldr	r2, [r6, #24]
  403bc6:	4552      	cmp	r2, sl
  403bc8:	d014      	beq.n	403bf4 <f_read+0x144>
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403bca:	79b3      	ldrb	r3, [r6, #6]
  403bcc:	065b      	lsls	r3, r3, #25
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403bce:	f106 0428 	add.w	r4, r6, #40	; 0x28
				continue;
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
  403bd2:	d509      	bpl.n	403be8 <f_read+0x138>
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403bd4:	2301      	movs	r3, #1
  403bd6:	7840      	ldrb	r0, [r0, #1]
  403bd8:	4621      	mov	r1, r4
  403bda:	47c8      	blx	r9
						ABORT(fp->fs, FR_DISK_ERR);
  403bdc:	79b3      	ldrb	r3, [r6, #6]
			}
#if !_FS_TINY
			if (fp->dsect != sect) {			/* Load data sector if not in cache */
#if !_FS_READONLY
				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403bde:	b9e0      	cbnz	r0, 403c1a <f_read+0x16a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
  403be0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403be4:	6830      	ldr	r0, [r6, #0]
  403be6:	71b3      	strb	r3, [r6, #6]
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
  403be8:	7840      	ldrb	r0, [r0, #1]
  403bea:	4621      	mov	r1, r4
  403bec:	4652      	mov	r2, sl
  403bee:	2301      	movs	r3, #1
  403bf0:	47c0      	blx	r8
  403bf2:	b988      	cbnz	r0, 403c18 <f_read+0x168>
  403bf4:	68b1      	ldr	r1, [r6, #8]
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
  403bf6:	f8c6 a018 	str.w	sl, [r6, #24]
  403bfa:	f3c1 0308 	ubfx	r3, r1, #0, #9
  403bfe:	e7c3      	b.n	403b88 <f_read+0xd8>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
  403c00:	6971      	ldr	r1, [r6, #20]
{
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
  403c02:	2901      	cmp	r1, #1
  403c04:	d902      	bls.n	403c0c <f_read+0x15c>
  403c06:	6982      	ldr	r2, [r0, #24]
  403c08:	4291      	cmp	r1, r2
  403c0a:	d318      	bcc.n	403c3e <f_read+0x18e>
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
				fp->clust = clst;				/* Update current cluster */
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
  403c0c:	79b3      	ldrb	r3, [r6, #6]
  403c0e:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403c12:	71b3      	strb	r3, [r6, #6]
  403c14:	2002      	movs	r0, #2
  403c16:	e760      	b.n	403ada <f_read+0x2a>
						ABORT(fp->fs, FR_DISK_ERR);
					fp->flag &= ~FA__DIRTY;
				}
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
  403c18:	79b3      	ldrb	r3, [r6, #6]
  403c1a:	f063 037f 	orn	r3, r3, #127	; 0x7f
  403c1e:	71b3      	strb	r3, [r6, #6]
  403c20:	2001      	movs	r0, #1
  403c22:	e75a      	b.n	403ada <f_read+0x2a>
#if _FS_TINY
				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
  403c24:	eb05 2343 	add.w	r3, r5, r3, lsl #9
  403c28:	f503 7000 	add.w	r0, r3, #512	; 0x200
  403c2c:	f106 0228 	add.w	r2, r6, #40	; 0x28
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
		*d++ = *s++;
  403c30:	f812 1b01 	ldrb.w	r1, [r2], #1
  403c34:	f803 1b01 	strb.w	r1, [r3], #1
		*(int*)d = *(int*)s;
		d += sizeof(int); s += sizeof(int);
		cnt -= sizeof(int);
	}
#endif
	while (cnt--)
  403c38:	4283      	cmp	r3, r0
  403c3a:	d1f9      	bne.n	403c30 <f_read+0x180>
  403c3c:	e792      	b.n	403b64 <f_read+0xb4>
  403c3e:	9301      	str	r3, [sp, #4]
  403c40:	4a04      	ldr	r2, [pc, #16]	; (403c54 <f_read+0x1a4>)
  403c42:	4790      	blx	r2
  403c44:	9b01      	ldr	r3, [sp, #4]
  403c46:	4602      	mov	r2, r0
  403c48:	e7b5      	b.n	403bb6 <f_read+0x106>
#else
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
  403c4a:	2000      	movs	r0, #0
  403c4c:	e745      	b.n	403ada <f_read+0x2a>
  403c4e:	bf00      	nop
  403c50:	004027a1 	.word	0x004027a1
  403c54:	00402b85 	.word	0x00402b85
  403c58:	00402425 	.word	0x00402425
  403c5c:	00402499 	.word	0x00402499

00403c60 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL *fp		/* Pointer to the file object */
)
{
  403c60:	b538      	push	{r3, r4, r5, lr}
  403c62:	4604      	mov	r4, r0
	FRESULT res;
	DWORD tim;
	BYTE *dir;


	res = validate(fp->fs, fp->id);		/* Check validity of the object */
  403c64:	4b27      	ldr	r3, [pc, #156]	; (403d04 <f_sync+0xa4>)
  403c66:	6800      	ldr	r0, [r0, #0]
  403c68:	88a1      	ldrh	r1, [r4, #4]
  403c6a:	4798      	blx	r3
	if (res == FR_OK) {
  403c6c:	b9d0      	cbnz	r0, 403ca4 <f_sync+0x44>
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
  403c6e:	79a2      	ldrb	r2, [r4, #6]
  403c70:	f002 0320 	and.w	r3, r2, #32
  403c74:	f003 00ff 	and.w	r0, r3, #255	; 0xff
  403c78:	b1a3      	cbz	r3, 403ca4 <f_sync+0x44>
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
  403c7a:	0653      	lsls	r3, r2, #25
  403c7c:	d50d      	bpl.n	403c9a <f_sync+0x3a>
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
  403c7e:	4621      	mov	r1, r4
  403c80:	69a2      	ldr	r2, [r4, #24]
  403c82:	f851 3b28 	ldr.w	r3, [r1], #40
  403c86:	4d20      	ldr	r5, [pc, #128]	; (403d08 <f_sync+0xa8>)
  403c88:	7858      	ldrb	r0, [r3, #1]
  403c8a:	2301      	movs	r3, #1
  403c8c:	47a8      	blx	r5
  403c8e:	2800      	cmp	r0, #0
  403c90:	d136      	bne.n	403d00 <f_sync+0xa0>
					LEAVE_FF(fp->fs, FR_DISK_ERR);
				fp->flag &= ~FA__DIRTY;
  403c92:	79a3      	ldrb	r3, [r4, #6]
  403c94:	f023 0340 	bic.w	r3, r3, #64	; 0x40
  403c98:	71a3      	strb	r3, [r4, #6]
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
  403c9a:	6820      	ldr	r0, [r4, #0]
  403c9c:	69e1      	ldr	r1, [r4, #28]
  403c9e:	4b1b      	ldr	r3, [pc, #108]	; (403d0c <f_sync+0xac>)
  403ca0:	4798      	blx	r3
			if (res == FR_OK) {
  403ca2:	b100      	cbz	r0, 403ca6 <f_sync+0x46>
			}
		}
	}

	LEAVE_FF(fp->fs, res);
}
  403ca4:	bd38      	pop	{r3, r4, r5, pc}
			}
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
  403ca6:	6a25      	ldr	r5, [r4, #32]
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
  403ca8:	4a19      	ldr	r2, [pc, #100]	; (403d10 <f_sync+0xb0>)
#endif
			/* Update the directory entry */
			res = move_window(fp->fs, fp->dir_sect);
			if (res == FR_OK) {
				dir = fp->dir_ptr;
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
  403caa:	7aeb      	ldrb	r3, [r5, #11]
  403cac:	f043 0320 	orr.w	r3, r3, #32
  403cb0:	72eb      	strb	r3, [r5, #11]
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
  403cb2:	68e3      	ldr	r3, [r4, #12]
  403cb4:	772b      	strb	r3, [r5, #28]
  403cb6:	89a3      	ldrh	r3, [r4, #12]
  403cb8:	0a1b      	lsrs	r3, r3, #8
  403cba:	776b      	strb	r3, [r5, #29]
  403cbc:	89e3      	ldrh	r3, [r4, #14]
  403cbe:	77ab      	strb	r3, [r5, #30]
  403cc0:	7be3      	ldrb	r3, [r4, #15]
  403cc2:	77eb      	strb	r3, [r5, #31]
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
  403cc4:	6923      	ldr	r3, [r4, #16]
  403cc6:	76ab      	strb	r3, [r5, #26]
  403cc8:	8a23      	ldrh	r3, [r4, #16]
  403cca:	0a1b      	lsrs	r3, r3, #8
  403ccc:	76eb      	strb	r3, [r5, #27]
  403cce:	8a63      	ldrh	r3, [r4, #18]
  403cd0:	752b      	strb	r3, [r5, #20]
  403cd2:	8a63      	ldrh	r3, [r4, #18]
  403cd4:	0a1b      	lsrs	r3, r3, #8
  403cd6:	756b      	strb	r3, [r5, #21]
				tim = get_fattime();						/* Update updated time */
  403cd8:	4790      	blx	r2
				ST_DWORD(dir+DIR_WrtTime, tim);
  403cda:	f3c0 2107 	ubfx	r1, r0, #8, #8
  403cde:	0c02      	lsrs	r2, r0, #16
  403ce0:	0e03      	lsrs	r3, r0, #24
  403ce2:	75e9      	strb	r1, [r5, #23]
  403ce4:	762a      	strb	r2, [r5, #24]
  403ce6:	75a8      	strb	r0, [r5, #22]
  403ce8:	766b      	strb	r3, [r5, #25]
				fp->flag &= ~FA__WRITTEN;
  403cea:	79a0      	ldrb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403cec:	6823      	ldr	r3, [r4, #0]
				res = sync(fp->fs);
  403cee:	4a09      	ldr	r2, [pc, #36]	; (403d14 <f_sync+0xb4>)
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403cf0:	f020 0020 	bic.w	r0, r0, #32
				fp->fs->wflag = 1;
  403cf4:	2101      	movs	r1, #1
				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
				tim = get_fattime();						/* Update updated time */
				ST_DWORD(dir+DIR_WrtTime, tim);
				fp->flag &= ~FA__WRITTEN;
  403cf6:	71a0      	strb	r0, [r4, #6]
				fp->fs->wflag = 1;
  403cf8:	7119      	strb	r1, [r3, #4]
				res = sync(fp->fs);
  403cfa:	6820      	ldr	r0, [r4, #0]
  403cfc:	4790      	blx	r2
  403cfe:	bd38      	pop	{r3, r4, r5, pc}
	if (res == FR_OK) {
		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
#if !_FS_TINY	/* Write-back dirty buffer */
			if (fp->flag & FA__DIRTY) {
				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
					LEAVE_FF(fp->fs, FR_DISK_ERR);
  403d00:	2001      	movs	r0, #1
  403d02:	e7cf      	b.n	403ca4 <f_sync+0x44>
  403d04:	004027a1 	.word	0x004027a1
  403d08:	00402499 	.word	0x00402499
  403d0c:	00402645 	.word	0x00402645
  403d10:	0040257d 	.word	0x0040257d
  403d14:	004026c9 	.word	0x004026c9

00403d18 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403d18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403d1a:	4b10      	ldr	r3, [pc, #64]	; (403d5c <f_close+0x44>)
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
  403d1c:	4604      	mov	r4, r0
	res = validate(fs, fp->id);
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	LEAVE_FF(fs, res);

#else
	res = f_sync(fp);		/* Flush cached data */
  403d1e:	4798      	blx	r3
#if _FS_SHARE
	if (res == FR_OK) {		/* Decrement open counter */
  403d20:	b998      	cbnz	r0, 403d4a <f_close+0x32>
{
	WORD n;
	FRESULT res;


	if (--i < _FS_SHARE) {
  403d22:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403d24:	3b01      	subs	r3, #1
  403d26:	2b02      	cmp	r3, #2
  403d28:	d810      	bhi.n	403d4c <f_close+0x34>
		n = Files[i].ctr;
  403d2a:	005d      	lsls	r5, r3, #1
  403d2c:	490c      	ldr	r1, [pc, #48]	; (403d60 <f_close+0x48>)
  403d2e:	18ea      	adds	r2, r5, r3
  403d30:	eb01 0282 	add.w	r2, r1, r2, lsl #2
  403d34:	3208      	adds	r2, #8
  403d36:	8856      	ldrh	r6, [r2, #2]
		if (n == 0x100) n = 0;
		if (n) n--;
  403d38:	f426 7780 	bic.w	r7, r6, #256	; 0x100
  403d3c:	b147      	cbz	r7, 403d50 <f_close+0x38>
  403d3e:	3e01      	subs	r6, #1
  403d40:	b2b6      	uxth	r6, r6
		Files[i].ctr = n;
  403d42:	8056      	strh	r6, [r2, #2]
		if (!n) Files[i].fs = 0;
  403d44:	b12e      	cbz	r6, 403d52 <f_close+0x3a>
#else
		res = dec_lock(fp->lockid);
#endif
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
  403d46:	2300      	movs	r3, #0
  403d48:	6023      	str	r3, [r4, #0]
	return res;
#endif
}
  403d4a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (n) n--;
		Files[i].ctr = n;
		if (!n) Files[i].fs = 0;
		res = FR_OK;
	} else {
		res = FR_INT_ERR;
  403d4c:	2002      	movs	r0, #2
  403d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	if (--i < _FS_SHARE) {
		n = Files[i].ctr;
		if (n == 0x100) n = 0;
		if (n) n--;
		Files[i].ctr = n;
  403d50:	8050      	strh	r0, [r2, #2]
		if (!n) Files[i].fs = 0;
  403d52:	442b      	add	r3, r5
  403d54:	009b      	lsls	r3, r3, #2
  403d56:	2200      	movs	r2, #0
  403d58:	50ca      	str	r2, [r1, r3]
  403d5a:	e7f4      	b.n	403d46 <f_close+0x2e>
  403d5c:	00403c61 	.word	0x00403c61
  403d60:	20000f68 	.word	0x20000f68

00403d64 <ff_convert>:
)
{
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403d64:	287f      	cmp	r0, #127	; 0x7f

WCHAR ff_convert (	/* Converted character, Returns zero on error */
	WCHAR	src,	/* Character code to be converted */
	UINT	dir		/* 0: Unicode to OEMCP, 1: OEMCP to Unicode */
)
{
  403d66:	b410      	push	{r4}
	WCHAR c;


	if (src < 0x80) {	/* ASCII */
  403d68:	d90e      	bls.n	403d88 <ff_convert+0x24>
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
  403d6a:	b981      	cbnz	r1, 403d8e <ff_convert+0x2a>
  403d6c:	4b0e      	ldr	r3, [pc, #56]	; (403da8 <ff_convert+0x44>)
  403d6e:	e001      	b.n	403d74 <ff_convert+0x10>
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];

		} else {		/* Unicode to OEMCP */
			for (c = 0; c < 0x80; c++) {
  403d70:	2980      	cmp	r1, #128	; 0x80
  403d72:	d015      	beq.n	403da0 <ff_convert+0x3c>
				if (src == Tbl[c]) break;
  403d74:	f833 2f02 	ldrh.w	r2, [r3, #2]!
  403d78:	4282      	cmp	r2, r0
  403d7a:	b28c      	uxth	r4, r1
  403d7c:	f101 0101 	add.w	r1, r1, #1
  403d80:	d1f6      	bne.n	403d70 <ff_convert+0xc>
  403d82:	f104 0080 	add.w	r0, r4, #128	; 0x80
  403d86:	b280      	uxth	r0, r0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d88:	f85d 4b04 	ldr.w	r4, [sp], #4
  403d8c:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403d8e:	28ff      	cmp	r0, #255	; 0xff
  403d90:	d806      	bhi.n	403da0 <ff_convert+0x3c>
  403d92:	3880      	subs	r0, #128	; 0x80
  403d94:	4b05      	ldr	r3, [pc, #20]	; (403dac <ff_convert+0x48>)
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d96:	f85d 4b04 	ldr.w	r4, [sp], #4
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403d9a:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403d9e:	4770      	bx	lr
	if (src < 0x80) {	/* ASCII */
		c = src;

	} else {
		if (dir) {		/* OEMCP to Unicode */
			c = (src >= 0x100) ? 0 : Tbl[src - 0x80];
  403da0:	2000      	movs	r0, #0
			c = (c + 0x80) & 0xFF;
		}
	}

	return c;
}
  403da2:	f85d 4b04 	ldr.w	r4, [sp], #4
  403da6:	4770      	bx	lr
  403da8:	00406dee 	.word	0x00406dee
  403dac:	00406df0 	.word	0x00406df0

00403db0 <ff_wtoupper>:
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403db0:	2861      	cmp	r0, #97	; 0x61
  403db2:	d00a      	beq.n	403dca <ff_wtoupper+0x1a>
  403db4:	4907      	ldr	r1, [pc, #28]	; (403dd4 <ff_wtoupper+0x24>)
  403db6:	2200      	movs	r2, #0
  403db8:	e001      	b.n	403dbe <ff_wtoupper+0xe>
  403dba:	4283      	cmp	r3, r0
  403dbc:	d006      	beq.n	403dcc <ff_wtoupper+0x1c>
  403dbe:	f831 3f02 	ldrh.w	r3, [r1, #2]!
  403dc2:	3201      	adds	r2, #1
  403dc4:	2b00      	cmp	r3, #0
  403dc6:	d1f8      	bne.n	403dba <ff_wtoupper+0xa>

	return tbl_lower[i] ? tbl_upper[i] : chr;
}
  403dc8:	4770      	bx	lr
	static const WCHAR tbl_lower[] = { 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0xA1, 0x00A2, 0x00A3, 0x00A5, 0x00AC, 0x00AF, 0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0x0FF, 0x101, 0x103, 0x105, 0x107, 0x109, 0x10B, 0x10D, 0x10F, 0x111, 0x113, 0x115, 0x117, 0x119, 0x11B, 0x11D, 0x11F, 0x121, 0x123, 0x125, 0x127, 0x129, 0x12B, 0x12D, 0x12F, 0x131, 0x133, 0x135, 0x137, 0x13A, 0x13C, 0x13E, 0x140, 0x142, 0x144, 0x146, 0x148, 0x14B, 0x14D, 0x14F, 0x151, 0x153, 0x155, 0x157, 0x159, 0x15B, 0x15D, 0x15F, 0x161, 0x163, 0x165, 0x167, 0x169, 0x16B, 0x16D, 0x16F, 0x171, 0x173, 0x175, 0x177, 0x17A, 0x17C, 0x17E, 0x192, 0x3B1, 0x3B2, 0x3B3, 0x3B4, 0x3B5, 0x3B6, 0x3B7, 0x3B8, 0x3B9, 0x3BA, 0x3BB, 0x3BC, 0x3BD, 0x3BE, 0x3BF, 0x3C0, 0x3C1, 0x3C3, 0x3C4, 0x3C5, 0x3C6, 0x3C7, 0x3C8, 0x3C9, 0x3CA, 0x430, 0x431, 0x432, 0x433, 0x434, 0x435, 0x436, 0x437, 0x438, 0x439, 0x43A, 0x43B, 0x43C, 0x43D, 0x43E, 0x43F, 0x440, 0x441, 0x442, 0x443, 0x444, 0x445, 0x446, 0x447, 0x448, 0x449, 0x44A, 0x44B, 0x44C, 0x44D, 0x44E, 0x44F, 0x451, 0x452, 0x453, 0x454, 0x455, 0x456, 0x457, 0x458, 0x459, 0x45A, 0x45B, 0x45C, 0x45E, 0x45F, 0x2170, 0x2171, 0x2172, 0x2173, 0x2174, 0x2175, 0x2176, 0x2177, 0x2178, 0x2179, 0x217A, 0x217B, 0x217C, 0x217D, 0x217E, 0x217F, 0xFF41, 0xFF42, 0xFF43, 0xFF44, 0xFF45, 0xFF46, 0xFF47, 0xFF48, 0xFF49, 0xFF4A, 0xFF4B, 0xFF4C, 0xFF4D, 0xFF4E, 0xFF4F, 0xFF50, 0xFF51, 0xFF52, 0xFF53, 0xFF54, 0xFF55, 0xFF56, 0xFF57, 0xFF58, 0xFF59, 0xFF5A, 0 };
	static const WCHAR tbl_upper[] = { 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x21, 0xFFE0, 0xFFE1, 0xFFE5, 0xFFE2, 0xFFE3, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0x178, 0x100, 0x102, 0x104, 0x106, 0x108, 0x10A, 0x10C, 0x10E, 0x110, 0x112, 0x114, 0x116, 0x118, 0x11A, 0x11C, 0x11E, 0x120, 0x122, 0x124, 0x126, 0x128, 0x12A, 0x12C, 0x12E, 0x130, 0x132, 0x134, 0x136, 0x139, 0x13B, 0x13D, 0x13F, 0x141, 0x143, 0x145, 0x147, 0x14A, 0x14C, 0x14E, 0x150, 0x152, 0x154, 0x156, 0x158, 0x15A, 0x15C, 0x15E, 0x160, 0x162, 0x164, 0x166, 0x168, 0x16A, 0x16C, 0x16E, 0x170, 0x172, 0x174, 0x176, 0x179, 0x17B, 0x17D, 0x191, 0x391, 0x392, 0x393, 0x394, 0x395, 0x396, 0x397, 0x398, 0x399, 0x39A, 0x39B, 0x39C, 0x39D, 0x39E, 0x39F, 0x3A0, 0x3A1, 0x3A3, 0x3A4, 0x3A5, 0x3A6, 0x3A7, 0x3A8, 0x3A9, 0x3AA, 0x410, 0x411, 0x412, 0x413, 0x414, 0x415, 0x416, 0x417, 0x418, 0x419, 0x41A, 0x41B, 0x41C, 0x41D, 0x41E, 0x41F, 0x420, 0x421, 0x422, 0x423, 0x424, 0x425, 0x426, 0x427, 0x428, 0x429, 0x42A, 0x42B, 0x42C, 0x42D, 0x42E, 0x42F, 0x401, 0x402, 0x403, 0x404, 0x405, 0x406, 0x407, 0x408, 0x409, 0x40A, 0x40B, 0x40C, 0x40E, 0x40F, 0x2160, 0x2161, 0x2162, 0x2163, 0x2164, 0x2165, 0x2166, 0x2167, 0x2168, 0x2169, 0x216A, 0x216B, 0x216C, 0x216D, 0x216E, 0x216F, 0xFF21, 0xFF22, 0xFF23, 0xFF24, 0xFF25, 0xFF26, 0xFF27, 0xFF28, 0xFF29, 0xFF2A, 0xFF2B, 0xFF2C, 0xFF2D, 0xFF2E, 0xFF2F, 0xFF30, 0xFF31, 0xFF32, 0xFF33, 0xFF34, 0xFF35, 0xFF36, 0xFF37, 0xFF38, 0xFF39, 0xFF3A, 0 };
	int i;


	for (i = 0; tbl_lower[i] && chr != tbl_lower[i]; i++) ;
  403dca:	2200      	movs	r2, #0

	return tbl_lower[i] ? tbl_upper[i] : chr;
  403dcc:	4b02      	ldr	r3, [pc, #8]	; (403dd8 <ff_wtoupper+0x28>)
  403dce:	f833 0012 	ldrh.w	r0, [r3, r2, lsl #1]
}
  403dd2:	4770      	bx	lr
  403dd4:	00406c10 	.word	0x00406c10
  403dd8:	00406ef0 	.word	0x00406ef0

00403ddc <vListInsertEnd>:

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
  403ddc:	6843      	ldr	r3, [r0, #4]

	pxNewListItem->pxNext = pxIndex->pxNext;
  403dde:	685a      	ldr	r2, [r3, #4]
  403de0:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxPrevious = pxList->pxIndex;
  403de2:	6842      	ldr	r2, [r0, #4]
  403de4:	608a      	str	r2, [r1, #8]
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403de6:	685a      	ldr	r2, [r3, #4]
  403de8:	6091      	str	r1, [r2, #8]
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
  403dea:	6059      	str	r1, [r3, #4]
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
  403dec:	6041      	str	r1, [r0, #4]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403dee:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403df0:	6803      	ldr	r3, [r0, #0]
  403df2:	3301      	adds	r3, #1
  403df4:	6003      	str	r3, [r0, #0]
  403df6:	4770      	bx	lr

00403df8 <vListInsert>:
}
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
  403df8:	b410      	push	{r4}
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
  403dfa:	680c      	ldr	r4, [r1, #0]
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
  403dfc:	1c63      	adds	r3, r4, #1
  403dfe:	d016      	beq.n	403e2e <vListInsert+0x36>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
  403e00:	68c3      	ldr	r3, [r0, #12]
  403e02:	681a      	ldr	r2, [r3, #0]
  403e04:	4294      	cmp	r4, r2
  403e06:	f100 0308 	add.w	r3, r0, #8
  403e0a:	d304      	bcc.n	403e16 <vListInsert+0x1e>
  403e0c:	685b      	ldr	r3, [r3, #4]
  403e0e:	685a      	ldr	r2, [r3, #4]
  403e10:	6812      	ldr	r2, [r2, #0]
  403e12:	4294      	cmp	r4, r2
  403e14:	d2fa      	bcs.n	403e0c <vListInsert+0x14>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
  403e16:	685a      	ldr	r2, [r3, #4]
  403e18:	604a      	str	r2, [r1, #4]
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
  403e1a:	6091      	str	r1, [r2, #8]
	pxNewListItem->pxPrevious = pxIterator;
  403e1c:	608b      	str	r3, [r1, #8]
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
  403e1e:	6059      	str	r1, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
  403e20:	6108      	str	r0, [r1, #16]

	( pxList->uxNumberOfItems )++;
  403e22:	6803      	ldr	r3, [r0, #0]
}
  403e24:	f85d 4b04 	ldr.w	r4, [sp], #4

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;

	( pxList->uxNumberOfItems )++;
  403e28:	3301      	adds	r3, #1
  403e2a:	6003      	str	r3, [r0, #0]
}
  403e2c:	4770      	bx	lr
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
	{
		pxIterator = pxList->xListEnd.pxPrevious;
  403e2e:	6903      	ldr	r3, [r0, #16]
  403e30:	e7f1      	b.n	403e16 <vListInsert+0x1e>
  403e32:	bf00      	nop

00403e34 <vListRemove>:

void vListRemove( xListItem *pxItemToRemove )
{
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
  403e34:	6843      	ldr	r3, [r0, #4]
  403e36:	6882      	ldr	r2, [r0, #8]
  403e38:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
  403e3a:	6883      	ldr	r3, [r0, #8]
  403e3c:	6842      	ldr	r2, [r0, #4]
  403e3e:	605a      	str	r2, [r3, #4]

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
  403e40:	6903      	ldr	r3, [r0, #16]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
  403e42:	685a      	ldr	r2, [r3, #4]
  403e44:	4282      	cmp	r2, r0
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
  403e46:	bf04      	itt	eq
  403e48:	6882      	ldreq	r2, [r0, #8]
  403e4a:	605a      	streq	r2, [r3, #4]
	}

	pxItemToRemove->pvContainer = NULL;
  403e4c:	2200      	movs	r2, #0
  403e4e:	6102      	str	r2, [r0, #16]
	( pxList->uxNumberOfItems )--;
  403e50:	681a      	ldr	r2, [r3, #0]
  403e52:	3a01      	subs	r2, #1
  403e54:	601a      	str	r2, [r3, #0]
  403e56:	4770      	bx	lr

00403e58 <SVC_Handler>:
/**
 * \brief Handler for Sytem supervisor call.
 */
void vPortSVCHandler(void)
{
	__asm volatile (" ldr r3, pxCurrentTCBConst2  \n"  /* Restore the context. */
  403e58:	4b06      	ldr	r3, [pc, #24]	; (403e74 <pxCurrentTCBConst2>)
  403e5a:	6819      	ldr	r1, [r3, #0]
  403e5c:	6808      	ldr	r0, [r1, #0]
  403e5e:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403e62:	f380 8809 	msr	PSP, r0
  403e66:	f04f 0000 	mov.w	r0, #0
  403e6a:	f380 8811 	msr	BASEPRI, r0
  403e6e:	f04e 0e0d 	orr.w	lr, lr, #13
  403e72:	4770      	bx	lr

00403e74 <pxCurrentTCBConst2>:
  403e74:	20001064 	.word	0x20001064

00403e78 <vPortYieldFromISR>:
 * \brief Yield PendSV to request a context switch.
 */
void vPortYieldFromISR(void)
{
	/* Set a PendSV to request a context switch. */
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403e78:	4b02      	ldr	r3, [pc, #8]	; (403e84 <vPortYieldFromISR+0xc>)
  403e7a:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403e7e:	601a      	str	r2, [r3, #0]
  403e80:	4770      	bx	lr
  403e82:	bf00      	nop
  403e84:	e000ed04 	.word	0xe000ed04

00403e88 <vPortEnterCritical>:
/**
 * \brief Enter Critical code.
 */
void vPortEnterCritical(void)
{
	portDISABLE_INTERRUPTS();
  403e88:	f04f 0000 	mov.w	r0, #0
  403e8c:	f380 8811 	msr	BASEPRI, r0
	uxCriticalNesting++;
  403e90:	4b02      	ldr	r3, [pc, #8]	; (403e9c <vPortEnterCritical+0x14>)
  403e92:	681a      	ldr	r2, [r3, #0]
  403e94:	3201      	adds	r2, #1
  403e96:	601a      	str	r2, [r3, #0]
  403e98:	4770      	bx	lr
  403e9a:	bf00      	nop
  403e9c:	200000b4 	.word	0x200000b4

00403ea0 <vPortExitCritical>:
/**
 * \brief Exit Critical code.
 */
void vPortExitCritical(void)
{
	uxCriticalNesting--;
  403ea0:	4a04      	ldr	r2, [pc, #16]	; (403eb4 <vPortExitCritical+0x14>)
  403ea2:	6813      	ldr	r3, [r2, #0]
  403ea4:	3b01      	subs	r3, #1
  403ea6:	6013      	str	r3, [r2, #0]
	if (uxCriticalNesting == 0) {
  403ea8:	b91b      	cbnz	r3, 403eb2 <vPortExitCritical+0x12>
		portENABLE_INTERRUPTS();
  403eaa:	f04f 0000 	mov.w	r0, #0
  403eae:	f380 8811 	msr	BASEPRI, r0
  403eb2:	4770      	bx	lr
  403eb4:	200000b4 	.word	0x200000b4

00403eb8 <PendSV_Handler>:
 * \brief Handler for Sytem interrupt-driven request.
 */
void xPortPendSVHandler(void)
{
	/* This is a naked function. */
	__asm volatile (" mrs r0, psp      \n"
  403eb8:	f3ef 8009 	mrs	r0, PSP
  403ebc:	4b0c      	ldr	r3, [pc, #48]	; (403ef0 <pxCurrentTCBConst>)
  403ebe:	681a      	ldr	r2, [r3, #0]
  403ec0:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403ec4:	6010      	str	r0, [r2, #0]
  403ec6:	e92d 4008 	stmdb	sp!, {r3, lr}
  403eca:	f04f 0000 	mov.w	r0, #0
  403ece:	f380 8811 	msr	BASEPRI, r0
  403ed2:	f000 fb63 	bl	40459c <vTaskSwitchContext>
  403ed6:	f04f 0000 	mov.w	r0, #0
  403eda:	f380 8811 	msr	BASEPRI, r0
  403ede:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  403ee2:	6819      	ldr	r1, [r3, #0]
  403ee4:	6808      	ldr	r0, [r1, #0]
  403ee6:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
  403eea:	f380 8809 	msr	PSP, r0
  403eee:	4770      	bx	lr

00403ef0 <pxCurrentTCBConst>:
  403ef0:	20001064 	.word	0x20001064

00403ef4 <xPortSysTickHandler>:

/**
 * \brief Handler for Sytem Tick interrupt.
 */
void xPortSysTickHandler(void)
{
  403ef4:	b508      	push	{r3, lr}
	unsigned portLONG ulDummy;

	/* If using preemption, also force a context switch. */
#if configUSE_PREEMPTION == 1
	*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
  403ef6:	4b07      	ldr	r3, [pc, #28]	; (403f14 <xPortSysTickHandler+0x20>)
  403ef8:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
  403efc:	601a      	str	r2, [r3, #0]
#endif

	ulDummy = portSET_INTERRUPT_MASK_FROM_ISR();
  403efe:	f04f 0000 	mov.w	r0, #0
  403f02:	f380 8811 	msr	BASEPRI, r0
	{
		vTaskIncrementTick();
  403f06:	4b04      	ldr	r3, [pc, #16]	; (403f18 <xPortSysTickHandler+0x24>)
  403f08:	4798      	blx	r3
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR(ulDummy);
  403f0a:	f04f 0000 	mov.w	r0, #0
  403f0e:	f380 8811 	msr	BASEPRI, r0
  403f12:	bd08      	pop	{r3, pc}
  403f14:	e000ed04 	.word	0xe000ed04
  403f18:	0040437d 	.word	0x0040437d

00403f1c <prvCopyDataToQueue>:
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403f1c:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403f1e:	6c03      	ldr	r3, [r0, #64]	; 0x40
	vPortFree( pxQueue );
}
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
  403f20:	4604      	mov	r4, r0
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
  403f22:	b933      	cbnz	r3, 403f32 <prvCopyDataToQueue+0x16>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  403f24:	6805      	ldr	r5, [r0, #0]
  403f26:	2d00      	cmp	r5, #0
  403f28:	d028      	beq.n	403f7c <prvCopyDataToQueue+0x60>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f2a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403f2c:	3301      	adds	r3, #1
  403f2e:	63a3      	str	r3, [r4, #56]	; 0x38
  403f30:	bd38      	pop	{r3, r4, r5, pc}
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
  403f32:	b982      	cbnz	r2, 403f56 <prvCopyDataToQueue+0x3a>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403f34:	461a      	mov	r2, r3
  403f36:	6880      	ldr	r0, [r0, #8]
  403f38:	4b13      	ldr	r3, [pc, #76]	; (403f88 <prvCopyDataToQueue+0x6c>)
  403f3a:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f3c:	68a1      	ldr	r1, [r4, #8]
  403f3e:	6c23      	ldr	r3, [r4, #64]	; 0x40
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f40:	6862      	ldr	r2, [r4, #4]
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f42:	440b      	add	r3, r1
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f44:	4293      	cmp	r3, r2
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
  403f46:	60a3      	str	r3, [r4, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
  403f48:	d3ef      	bcc.n	403f2a <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
  403f4a:	6823      	ldr	r3, [r4, #0]
  403f4c:	60a3      	str	r3, [r4, #8]
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  403f50:	3301      	adds	r3, #1
  403f52:	63a3      	str	r3, [r4, #56]	; 0x38
  403f54:	bd38      	pop	{r3, r4, r5, pc}
			pxQueue->pcWriteTo = pxQueue->pcHead;
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
  403f56:	461a      	mov	r2, r3
  403f58:	68c0      	ldr	r0, [r0, #12]
  403f5a:	4b0b      	ldr	r3, [pc, #44]	; (403f88 <prvCopyDataToQueue+0x6c>)
  403f5c:	4798      	blx	r3
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f5e:	6c22      	ldr	r2, [r4, #64]	; 0x40
  403f60:	68e3      	ldr	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f62:	6821      	ldr	r1, [r4, #0]
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f64:	4252      	negs	r2, r2
  403f66:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f68:	428b      	cmp	r3, r1
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
  403f6a:	60e3      	str	r3, [r4, #12]
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
  403f6c:	d2dd      	bcs.n	403f2a <prvCopyDataToQueue+0xe>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403f6e:	6863      	ldr	r3, [r4, #4]
  403f70:	441a      	add	r2, r3
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
  403f74:	60e2      	str	r2, [r4, #12]
		}
	}

	++( pxQueue->uxMessagesWaiting );
  403f76:	3301      	adds	r3, #1
  403f78:	63a3      	str	r3, [r4, #56]	; 0x38
  403f7a:	bd38      	pop	{r3, r4, r5, pc}
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
			{
				/* The mutex is no longer being held. */
				vTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
  403f7c:	6840      	ldr	r0, [r0, #4]
  403f7e:	4b03      	ldr	r3, [pc, #12]	; (403f8c <prvCopyDataToQueue+0x70>)
  403f80:	4798      	blx	r3
				pxQueue->pxMutexHolder = NULL;
  403f82:	6065      	str	r5, [r4, #4]
  403f84:	e7d1      	b.n	403f2a <prvCopyDataToQueue+0xe>
  403f86:	bf00      	nop
  403f88:	00406449 	.word	0x00406449
  403f8c:	00404849 	.word	0x00404849

00403f90 <prvCopyDataFromQueue>:
	++( pxQueue->uxMessagesWaiting );
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
  403f90:	b538      	push	{r3, r4, r5, lr}
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
  403f92:	6804      	ldr	r4, [r0, #0]
  403f94:	b164      	cbz	r4, 403fb0 <prvCopyDataFromQueue+0x20>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403f96:	68c3      	ldr	r3, [r0, #12]
  403f98:	6c02      	ldr	r2, [r0, #64]	; 0x40
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403f9a:	6845      	ldr	r5, [r0, #4]

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403f9c:	4413      	add	r3, r2
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
  403f9e:	42ab      	cmp	r3, r5

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
  403fa0:	60c3      	str	r3, [r0, #12]
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
  403fa2:	bf24      	itt	cs
  403fa4:	4623      	movcs	r3, r4
  403fa6:	60c4      	strcs	r4, [r0, #12]
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
  403fa8:	4608      	mov	r0, r1
  403faa:	4619      	mov	r1, r3
  403fac:	4b01      	ldr	r3, [pc, #4]	; (403fb4 <prvCopyDataFromQueue+0x24>)
  403fae:	4798      	blx	r3
  403fb0:	bd38      	pop	{r3, r4, r5, pc}
  403fb2:	bf00      	nop
  403fb4:	00406449 	.word	0x00406449

00403fb8 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
  403fb8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  403fbc:	4604      	mov	r4, r0

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
  403fbe:	4f23      	ldr	r7, [pc, #140]	; (40404c <prvUnlockQueue+0x94>)
  403fc0:	47b8      	blx	r7
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fc2:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403fc4:	2b00      	cmp	r3, #0
  403fc6:	dd18      	ble.n	403ffa <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403fc8:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403fca:	b1b3      	cbz	r3, 403ffa <prvUnlockQueue+0x42>
  403fcc:	f104 0624 	add.w	r6, r4, #36	; 0x24
  403fd0:	4d1f      	ldr	r5, [pc, #124]	; (404050 <prvUnlockQueue+0x98>)
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403fd2:	f8df 8080 	ldr.w	r8, [pc, #128]	; 404054 <prvUnlockQueue+0x9c>
  403fd6:	e006      	b.n	403fe6 <prvUnlockQueue+0x2e>
				}

				--( pxQueue->xTxLock );
  403fd8:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403fda:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fdc:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403fde:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403fe0:	dd0b      	ble.n	403ffa <prvUnlockQueue+0x42>
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  403fe2:	6a63      	ldr	r3, [r4, #36]	; 0x24
  403fe4:	b14b      	cbz	r3, 403ffa <prvUnlockQueue+0x42>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  403fe6:	4630      	mov	r0, r6
  403fe8:	47a8      	blx	r5
  403fea:	2800      	cmp	r0, #0
  403fec:	d0f4      	beq.n	403fd8 <prvUnlockQueue+0x20>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
  403fee:	47c0      	blx	r8
				}

				--( pxQueue->xTxLock );
  403ff0:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  403ff2:	3b01      	subs	r3, #1
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403ff4:	2b00      	cmp	r3, #0
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
				}

				--( pxQueue->xTxLock );
  403ff6:	64a3      	str	r3, [r4, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
  403ff8:	dcf3      	bgt.n	403fe2 <prvUnlockQueue+0x2a>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
  403ffa:	f04f 33ff 	mov.w	r3, #4294967295
  403ffe:	64a3      	str	r3, [r4, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
  404000:	f8df 8054 	ldr.w	r8, [pc, #84]	; 404058 <prvUnlockQueue+0xa0>
  404004:	47c0      	blx	r8

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
  404006:	47b8      	blx	r7
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  404008:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40400a:	2b00      	cmp	r3, #0
  40400c:	dd17      	ble.n	40403e <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40400e:	6923      	ldr	r3, [r4, #16]
  404010:	b1ab      	cbz	r3, 40403e <prvUnlockQueue+0x86>
  404012:	f104 0610 	add.w	r6, r4, #16
  404016:	4d0e      	ldr	r5, [pc, #56]	; (404050 <prvUnlockQueue+0x98>)
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
  404018:	4f0e      	ldr	r7, [pc, #56]	; (404054 <prvUnlockQueue+0x9c>)
  40401a:	e006      	b.n	40402a <prvUnlockQueue+0x72>
				}

				--( pxQueue->xRxLock );
  40401c:	6c63      	ldr	r3, [r4, #68]	; 0x44
  40401e:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  404020:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  404022:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  404024:	dd0b      	ble.n	40403e <prvUnlockQueue+0x86>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  404026:	6923      	ldr	r3, [r4, #16]
  404028:	b14b      	cbz	r3, 40403e <prvUnlockQueue+0x86>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
  40402a:	4630      	mov	r0, r6
  40402c:	47a8      	blx	r5
  40402e:	2800      	cmp	r0, #0
  404030:	d0f4      	beq.n	40401c <prvUnlockQueue+0x64>
				{
					vTaskMissedYield();
  404032:	47b8      	blx	r7
				}

				--( pxQueue->xRxLock );
  404034:	6c63      	ldr	r3, [r4, #68]	; 0x44
  404036:	3b01      	subs	r3, #1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  404038:	2b00      	cmp	r3, #0
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
				{
					vTaskMissedYield();
				}

				--( pxQueue->xRxLock );
  40403a:	6463      	str	r3, [r4, #68]	; 0x44
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
  40403c:	dcf3      	bgt.n	404026 <prvUnlockQueue+0x6e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
  40403e:	f04f 33ff 	mov.w	r3, #4294967295
  404042:	6463      	str	r3, [r4, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
  404044:	47c0      	blx	r8
  404046:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  40404a:	bf00      	nop
  40404c:	00403e89 	.word	0x00403e89
  404050:	004046bd 	.word	0x004046bd
  404054:	004047c1 	.word	0x004047c1
  404058:	00403ea1 	.word	0x00403ea1

0040405c <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  40405c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  404060:	4f37      	ldr	r7, [pc, #220]	; (404140 <xQueueGenericSend+0xe4>)
  404062:	4d38      	ldr	r5, [pc, #224]	; (404144 <xQueueGenericSend+0xe8>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  404064:	f8df a0fc 	ldr.w	sl, [pc, #252]	; 404164 <xQueueGenericSend+0x108>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  404068:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 404168 <xQueueGenericSend+0x10c>

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
  40406c:	b087      	sub	sp, #28
  40406e:	4604      	mov	r4, r0
  404070:	9203      	str	r2, [sp, #12]
  404072:	9101      	str	r1, [sp, #4]
  404074:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  404076:	46b9      	mov	r9, r7
#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  404078:	2600      	movs	r6, #0
  40407a:	e021      	b.n	4040c0 <xQueueGenericSend+0x64>
  40407c:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  40407e:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  404080:	47c0      	blx	r8
		prvLockQueue( pxQueue );
  404082:	47a8      	blx	r5
  404084:	6c63      	ldr	r3, [r4, #68]	; 0x44
  404086:	3301      	adds	r3, #1
  404088:	bf04      	itt	eq
  40408a:	2300      	moveq	r3, #0
  40408c:	6463      	streq	r3, [r4, #68]	; 0x44
  40408e:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  404090:	3301      	adds	r3, #1
  404092:	bf04      	itt	eq
  404094:	2300      	moveq	r3, #0
  404096:	64a3      	streq	r3, [r4, #72]	; 0x48
  404098:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  40409a:	4630      	mov	r0, r6
  40409c:	a903      	add	r1, sp, #12
  40409e:	4b2a      	ldr	r3, [pc, #168]	; (404148 <xQueueGenericSend+0xec>)
  4040a0:	4798      	blx	r3
  4040a2:	2800      	cmp	r0, #0
  4040a4:	d13a      	bne.n	40411c <xQueueGenericSend+0xc0>

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  4040a6:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
  4040a8:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38
  4040ac:	6be6      	ldr	r6, [r4, #60]	; 0x3c
	taskEXIT_CRITICAL();
  4040ae:	47c8      	blx	r9
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
  4040b0:	45b3      	cmp	fp, r6
  4040b2:	d012      	beq.n	4040da <xQueueGenericSend+0x7e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  4040b4:	4b25      	ldr	r3, [pc, #148]	; (40414c <xQueueGenericSend+0xf0>)
  4040b6:	4620      	mov	r0, r4
  4040b8:	4798      	blx	r3
				( void ) xTaskResumeAll();
  4040ba:	4b25      	ldr	r3, [pc, #148]	; (404150 <xQueueGenericSend+0xf4>)
  4040bc:	4798      	blx	r3
  4040be:	2601      	movs	r6, #1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
  4040c0:	47a8      	blx	r5
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  4040c2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  4040c4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  4040c6:	429a      	cmp	r2, r3
  4040c8:	d316      	bcc.n	4040f8 <xQueueGenericSend+0x9c>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  4040ca:	9803      	ldr	r0, [sp, #12]
  4040cc:	b300      	cbz	r0, 404110 <xQueueGenericSend+0xb4>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
  4040ce:	2e00      	cmp	r6, #0
  4040d0:	d1d4      	bne.n	40407c <xQueueGenericSend+0x20>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4040d2:	ae04      	add	r6, sp, #16
  4040d4:	4630      	mov	r0, r6
  4040d6:	47d0      	blx	sl
  4040d8:	e7d1      	b.n	40407e <xQueueGenericSend+0x22>
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
  4040da:	f104 0010 	add.w	r0, r4, #16
  4040de:	9903      	ldr	r1, [sp, #12]
  4040e0:	4b1c      	ldr	r3, [pc, #112]	; (404154 <xQueueGenericSend+0xf8>)
  4040e2:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
  4040e4:	4b19      	ldr	r3, [pc, #100]	; (40414c <xQueueGenericSend+0xf0>)
  4040e6:	4620      	mov	r0, r4
  4040e8:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( !xTaskResumeAll() )
  4040ea:	4b19      	ldr	r3, [pc, #100]	; (404150 <xQueueGenericSend+0xf4>)
  4040ec:	4798      	blx	r3
  4040ee:	2800      	cmp	r0, #0
  4040f0:	d1e5      	bne.n	4040be <xQueueGenericSend+0x62>
				{
					portYIELD_WITHIN_API();
  4040f2:	4b19      	ldr	r3, [pc, #100]	; (404158 <xQueueGenericSend+0xfc>)
  4040f4:	4798      	blx	r3
  4040f6:	e7e2      	b.n	4040be <xQueueGenericSend+0x62>
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  4040f8:	4b18      	ldr	r3, [pc, #96]	; (40415c <xQueueGenericSend+0x100>)
  4040fa:	9901      	ldr	r1, [sp, #4]
  4040fc:	9a02      	ldr	r2, [sp, #8]
  4040fe:	4620      	mov	r0, r4
  404100:	4798      	blx	r3

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  404102:	6a63      	ldr	r3, [r4, #36]	; 0x24
  404104:	b99b      	cbnz	r3, 40412e <xQueueGenericSend+0xd2>
						takes care of that. */
						portYIELD_WITHIN_API();
					}
				}

				taskEXIT_CRITICAL();
  404106:	47b8      	blx	r7

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
  404108:	2001      	movs	r0, #1
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  40410a:	b007      	add	sp, #28
  40410c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  404110:	9000      	str	r0, [sp, #0]
  404112:	47b8      	blx	r7

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
  404114:	9800      	ldr	r0, [sp, #0]
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
  404116:	b007      	add	sp, #28
  404118:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
  40411c:	4620      	mov	r0, r4
  40411e:	4b0b      	ldr	r3, [pc, #44]	; (40414c <xQueueGenericSend+0xf0>)
  404120:	4798      	blx	r3
			( void ) xTaskResumeAll();
  404122:	4b0b      	ldr	r3, [pc, #44]	; (404150 <xQueueGenericSend+0xf4>)
  404124:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
  404126:	2000      	movs	r0, #0
		}
	}
}
  404128:	b007      	add	sp, #28
  40412a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
  40412e:	f104 0024 	add.w	r0, r4, #36	; 0x24
  404132:	4b0b      	ldr	r3, [pc, #44]	; (404160 <xQueueGenericSend+0x104>)
  404134:	4798      	blx	r3
  404136:	2801      	cmp	r0, #1
  404138:	d1e5      	bne.n	404106 <xQueueGenericSend+0xaa>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
  40413a:	4b07      	ldr	r3, [pc, #28]	; (404158 <xQueueGenericSend+0xfc>)
  40413c:	4798      	blx	r3
  40413e:	e7e2      	b.n	404106 <xQueueGenericSend+0xaa>
  404140:	00403ea1 	.word	0x00403ea1
  404144:	00403e89 	.word	0x00403e89
  404148:	00404745 	.word	0x00404745
  40414c:	00403fb9 	.word	0x00403fb9
  404150:	004044a9 	.word	0x004044a9
  404154:	0040466d 	.word	0x0040466d
  404158:	00403e79 	.word	0x00403e79
  40415c:	00403f1d 	.word	0x00403f1d
  404160:	004046bd 	.word	0x004046bd
  404164:	0040472d 	.word	0x0040472d
  404168:	0040436d 	.word	0x0040436d

0040416c <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
  40416c:	b570      	push	{r4, r5, r6, lr}
  40416e:	4604      	mov	r4, r0
  404170:	4616      	mov	r6, r2
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
  404172:	f04f 0000 	mov.w	r0, #0
  404176:	f380 8811 	msr	BASEPRI, r0
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
  40417a:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  40417c:	6be0      	ldr	r0, [r4, #60]	; 0x3c
  40417e:	4285      	cmp	r5, r0
  404180:	d306      	bcc.n	404190 <xQueueGenericSendFromISR+0x24>
			xReturn = pdPASS;
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
  404182:	2300      	movs	r3, #0
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
  404184:	f04f 0000 	mov.w	r0, #0
  404188:	f380 8811 	msr	BASEPRI, r0

	return xReturn;
}
  40418c:	4618      	mov	r0, r3
  40418e:	bd70      	pop	{r4, r5, r6, pc}
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
  404190:	461a      	mov	r2, r3
  404192:	4620      	mov	r0, r4
  404194:	4b0a      	ldr	r3, [pc, #40]	; (4041c0 <xQueueGenericSendFromISR+0x54>)
  404196:	4798      	blx	r3

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
  404198:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  40419a:	1c5a      	adds	r2, r3, #1
  40419c:	d003      	beq.n	4041a6 <xQueueGenericSendFromISR+0x3a>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
  40419e:	3301      	adds	r3, #1
  4041a0:	64a3      	str	r3, [r4, #72]	; 0x48
			}

			xReturn = pdPASS;
  4041a2:	2301      	movs	r3, #1
  4041a4:	e7ee      	b.n	404184 <xQueueGenericSendFromISR+0x18>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4041a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
  4041a8:	2b00      	cmp	r3, #0
  4041aa:	d0fa      	beq.n	4041a2 <xQueueGenericSendFromISR+0x36>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4041ac:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4041b0:	4b04      	ldr	r3, [pc, #16]	; (4041c4 <xQueueGenericSendFromISR+0x58>)
  4041b2:	4798      	blx	r3
  4041b4:	2800      	cmp	r0, #0
  4041b6:	d0f4      	beq.n	4041a2 <xQueueGenericSendFromISR+0x36>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
  4041b8:	2301      	movs	r3, #1
  4041ba:	6033      	str	r3, [r6, #0]
  4041bc:	e7e2      	b.n	404184 <xQueueGenericSendFromISR+0x18>
  4041be:	bf00      	nop
  4041c0:	00403f1d 	.word	0x00403f1d
  4041c4:	004046bd 	.word	0x004046bd

004041c8 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  4041c8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  4041cc:	4f46      	ldr	r7, [pc, #280]	; (4042e8 <xQueueGenericReceive+0x120>)
  4041ce:	4d47      	ldr	r5, [pc, #284]	; (4042ec <xQueueGenericReceive+0x124>)
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  4041d0:	f8df a140 	ldr.w	sl, [pc, #320]	; 404314 <xQueueGenericReceive+0x14c>
		taskEXIT_CRITICAL();

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4041d4:	f8df 9140 	ldr.w	r9, [pc, #320]	; 404318 <xQueueGenericReceive+0x150>
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
  4041d8:	b087      	sub	sp, #28
  4041da:	4604      	mov	r4, r0
  4041dc:	9203      	str	r2, [sp, #12]
  4041de:	9101      	str	r1, [sp, #4]
  4041e0:	9302      	str	r3, [sp, #8]

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
		prvLockQueue( pxQueue );
  4041e2:	46b8      	mov	r8, r7
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
  4041e4:	2600      	movs	r6, #0
  4041e6:	e02a      	b.n	40423e <xQueueGenericReceive+0x76>
  4041e8:	ae04      	add	r6, sp, #16
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
  4041ea:	47b8      	blx	r7

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
  4041ec:	47c8      	blx	r9
		prvLockQueue( pxQueue );
  4041ee:	47a8      	blx	r5
  4041f0:	6c63      	ldr	r3, [r4, #68]	; 0x44
  4041f2:	3301      	adds	r3, #1
  4041f4:	bf04      	itt	eq
  4041f6:	2300      	moveq	r3, #0
  4041f8:	6463      	streq	r3, [r4, #68]	; 0x44
  4041fa:	6ca3      	ldr	r3, [r4, #72]	; 0x48
  4041fc:	3301      	adds	r3, #1
  4041fe:	bf04      	itt	eq
  404200:	2300      	moveq	r3, #0
  404202:	64a3      	streq	r3, [r4, #72]	; 0x48
  404204:	47b8      	blx	r7

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
  404206:	4630      	mov	r0, r6
  404208:	a903      	add	r1, sp, #12
  40420a:	4b39      	ldr	r3, [pc, #228]	; (4042f0 <xQueueGenericReceive+0x128>)
  40420c:	4798      	blx	r3
  40420e:	2800      	cmp	r0, #0
  404210:	d14d      	bne.n	4042ae <xQueueGenericReceive+0xe6>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  404212:	47a8      	blx	r5
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
  404214:	f8d4 b038 	ldr.w	fp, [r4, #56]	; 0x38

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
  404218:	4e34      	ldr	r6, [pc, #208]	; (4042ec <xQueueGenericReceive+0x124>)
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
	taskEXIT_CRITICAL();
  40421a:	47c0      	blx	r8
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) )
  40421c:	f1bb 0f00 	cmp.w	fp, #0
  404220:	d119      	bne.n	404256 <xQueueGenericReceive+0x8e>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  404222:	6823      	ldr	r3, [r4, #0]
  404224:	b303      	cbz	r3, 404268 <xQueueGenericReceive+0xa0>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
  404226:	f104 0024 	add.w	r0, r4, #36	; 0x24
  40422a:	9903      	ldr	r1, [sp, #12]
  40422c:	4b31      	ldr	r3, [pc, #196]	; (4042f4 <xQueueGenericReceive+0x12c>)
  40422e:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
  404230:	4b31      	ldr	r3, [pc, #196]	; (4042f8 <xQueueGenericReceive+0x130>)
  404232:	4620      	mov	r0, r4
  404234:	4798      	blx	r3
				if( !xTaskResumeAll() )
  404236:	4b31      	ldr	r3, [pc, #196]	; (4042fc <xQueueGenericReceive+0x134>)
  404238:	4798      	blx	r3
  40423a:	b190      	cbz	r0, 404262 <xQueueGenericReceive+0x9a>
  40423c:	2601      	movs	r6, #1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
  40423e:	47a8      	blx	r5
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
  404240:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  404242:	b9bb      	cbnz	r3, 404274 <xQueueGenericReceive+0xac>
				taskEXIT_CRITICAL();
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
  404244:	9803      	ldr	r0, [sp, #12]
  404246:	2800      	cmp	r0, #0
  404248:	d02b      	beq.n	4042a2 <xQueueGenericReceive+0xda>
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
  40424a:	2e00      	cmp	r6, #0
  40424c:	d1cc      	bne.n	4041e8 <xQueueGenericReceive+0x20>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
  40424e:	ae04      	add	r6, sp, #16
  404250:	4630      	mov	r0, r6
  404252:	47d0      	blx	sl
  404254:	e7c9      	b.n	4041ea <xQueueGenericReceive+0x22>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
  404256:	4620      	mov	r0, r4
  404258:	4b27      	ldr	r3, [pc, #156]	; (4042f8 <xQueueGenericReceive+0x130>)
  40425a:	4798      	blx	r3
				( void ) xTaskResumeAll();
  40425c:	4b27      	ldr	r3, [pc, #156]	; (4042fc <xQueueGenericReceive+0x134>)
  40425e:	4798      	blx	r3
  404260:	e7ec      	b.n	40423c <xQueueGenericReceive+0x74>

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( !xTaskResumeAll() )
				{
					portYIELD_WITHIN_API();
  404262:	4b27      	ldr	r3, [pc, #156]	; (404300 <xQueueGenericReceive+0x138>)
  404264:	4798      	blx	r3
  404266:	e7e9      	b.n	40423c <xQueueGenericReceive+0x74>

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
					{
						portENTER_CRITICAL();
  404268:	47b0      	blx	r6
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
  40426a:	6860      	ldr	r0, [r4, #4]
  40426c:	4b25      	ldr	r3, [pc, #148]	; (404304 <xQueueGenericReceive+0x13c>)
  40426e:	4798      	blx	r3
						}
						portEXIT_CRITICAL();
  404270:	47c0      	blx	r8
  404272:	e7d8      	b.n	404226 <xQueueGenericReceive+0x5e>
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  404274:	4b24      	ldr	r3, [pc, #144]	; (404308 <xQueueGenericReceive+0x140>)
  404276:	9901      	ldr	r1, [sp, #4]
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
  404278:	68e5      	ldr	r5, [r4, #12]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
  40427a:	4620      	mov	r0, r4
  40427c:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
  40427e:	9b02      	ldr	r3, [sp, #8]
  404280:	b9f3      	cbnz	r3, 4042c0 <xQueueGenericReceive+0xf8>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  404282:	6ba2      	ldr	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  404284:	6823      	ldr	r3, [r4, #0]
				if( xJustPeeking == pdFALSE )
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
  404286:	3a01      	subs	r2, #1
  404288:	63a2      	str	r2, [r4, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
  40428a:	b343      	cbz	r3, 4042de <xQueueGenericReceive+0x116>
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
  40428c:	6923      	ldr	r3, [r4, #16]
  40428e:	b1d3      	cbz	r3, 4042c6 <xQueueGenericReceive+0xfe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
  404290:	f104 0010 	add.w	r0, r4, #16
  404294:	4b1d      	ldr	r3, [pc, #116]	; (40430c <xQueueGenericReceive+0x144>)
  404296:	4798      	blx	r3
  404298:	2801      	cmp	r0, #1
  40429a:	d114      	bne.n	4042c6 <xQueueGenericReceive+0xfe>
						{
							portYIELD_WITHIN_API();
  40429c:	4b18      	ldr	r3, [pc, #96]	; (404300 <xQueueGenericReceive+0x138>)
  40429e:	4798      	blx	r3
  4042a0:	e011      	b.n	4042c6 <xQueueGenericReceive+0xfe>
			{
				if( xTicksToWait == ( portTickType ) 0 )
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
  4042a2:	9000      	str	r0, [sp, #0]
  4042a4:	47b8      	blx	r7
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
  4042a6:	9800      	ldr	r0, [sp, #0]
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  4042a8:	b007      	add	sp, #28
  4042aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
  4042ae:	4620      	mov	r0, r4
  4042b0:	4b11      	ldr	r3, [pc, #68]	; (4042f8 <xQueueGenericReceive+0x130>)
  4042b2:	4798      	blx	r3
			( void ) xTaskResumeAll();
  4042b4:	4b11      	ldr	r3, [pc, #68]	; (4042fc <xQueueGenericReceive+0x134>)
  4042b6:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
  4042b8:	2000      	movs	r0, #0
		}
	}
}
  4042ba:	b007      	add	sp, #28
  4042bc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4042c0:	6a63      	ldr	r3, [r4, #36]	; 0x24
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
  4042c2:	60e5      	str	r5, [r4, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
  4042c4:	b923      	cbnz	r3, 4042d0 <xQueueGenericReceive+0x108>
						}
					}

				}

				taskEXIT_CRITICAL();
  4042c6:	47b8      	blx	r7
				return pdPASS;
  4042c8:	2001      	movs	r0, #1
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
  4042ca:	b007      	add	sp, #28
  4042cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
  4042d0:	f104 0024 	add.w	r0, r4, #36	; 0x24
  4042d4:	4b0d      	ldr	r3, [pc, #52]	; (40430c <xQueueGenericReceive+0x144>)
  4042d6:	4798      	blx	r3
  4042d8:	2800      	cmp	r0, #0
  4042da:	d0f4      	beq.n	4042c6 <xQueueGenericReceive+0xfe>
  4042dc:	e7de      	b.n	40429c <xQueueGenericReceive+0xd4>
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
  4042de:	4b0c      	ldr	r3, [pc, #48]	; (404310 <xQueueGenericReceive+0x148>)
  4042e0:	4798      	blx	r3
  4042e2:	6060      	str	r0, [r4, #4]
  4042e4:	e7d2      	b.n	40428c <xQueueGenericReceive+0xc4>
  4042e6:	bf00      	nop
  4042e8:	00403ea1 	.word	0x00403ea1
  4042ec:	00403e89 	.word	0x00403e89
  4042f0:	00404745 	.word	0x00404745
  4042f4:	0040466d 	.word	0x0040466d
  4042f8:	00403fb9 	.word	0x00403fb9
  4042fc:	004044a9 	.word	0x004044a9
  404300:	00403e79 	.word	0x00403e79
  404304:	004047d9 	.word	0x004047d9
  404308:	00403f91 	.word	0x00403f91
  40430c:	004046bd 	.word	0x004046bd
  404310:	004047cd 	.word	0x004047cd
  404314:	0040472d 	.word	0x0040472d
  404318:	0040436d 	.word	0x0040436d

0040431c <prvAddCurrentTaskToDelayedList>:
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  40431c:	b510      	push	{r4, lr}
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  40431e:	4b0d      	ldr	r3, [pc, #52]	; (404354 <prvAddCurrentTaskToDelayedList+0x38>)

	if( xTimeToWake < xTickCount )
  404320:	4a0d      	ldr	r2, [pc, #52]	; (404358 <prvAddCurrentTaskToDelayedList+0x3c>)
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  404322:	6819      	ldr	r1, [r3, #0]

	if( xTimeToWake < xTickCount )
  404324:	6812      	ldr	r2, [r2, #0]
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
  404326:	6048      	str	r0, [r1, #4]

	if( xTimeToWake < xTickCount )
  404328:	4290      	cmp	r0, r2
	#endif
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
  40432a:	4604      	mov	r4, r0
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
  40432c:	d30b      	bcc.n	404346 <prvAddCurrentTaskToDelayedList+0x2a>
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40432e:	490b      	ldr	r1, [pc, #44]	; (40435c <prvAddCurrentTaskToDelayedList+0x40>)
  404330:	4a0b      	ldr	r2, [pc, #44]	; (404360 <prvAddCurrentTaskToDelayedList+0x44>)
  404332:	6808      	ldr	r0, [r1, #0]
  404334:	6819      	ldr	r1, [r3, #0]
  404336:	3104      	adds	r1, #4
  404338:	4790      	blx	r2

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
  40433a:	4b0a      	ldr	r3, [pc, #40]	; (404364 <prvAddCurrentTaskToDelayedList+0x48>)
  40433c:	681a      	ldr	r2, [r3, #0]
  40433e:	4294      	cmp	r4, r2
		{
			xNextTaskUnblockTime = xTimeToWake;
  404340:	bf38      	it	cc
  404342:	601c      	strcc	r4, [r3, #0]
  404344:	bd10      	pop	{r4, pc}
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );

	if( xTimeToWake < xTickCount )
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404346:	4908      	ldr	r1, [pc, #32]	; (404368 <prvAddCurrentTaskToDelayedList+0x4c>)
  404348:	4a05      	ldr	r2, [pc, #20]	; (404360 <prvAddCurrentTaskToDelayedList+0x44>)
  40434a:	6808      	ldr	r0, [r1, #0]
  40434c:	6819      	ldr	r1, [r3, #0]
  40434e:	3104      	adds	r1, #4
  404350:	4790      	blx	r2
  404352:	bd10      	pop	{r4, pc}
  404354:	20001064 	.word	0x20001064
  404358:	20000f94 	.word	0x20000f94
  40435c:	20001040 	.word	0x20001040
  404360:	00403df9 	.word	0x00403df9
  404364:	200000bc 	.word	0x200000bc
  404368:	20001038 	.word	0x20001038

0040436c <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
  40436c:	4b02      	ldr	r3, [pc, #8]	; (404378 <vTaskSuspendAll+0xc>)
  40436e:	681a      	ldr	r2, [r3, #0]
  404370:	3201      	adds	r2, #1
  404372:	601a      	str	r2, [r3, #0]
  404374:	4770      	bx	lr
  404376:	bf00      	nop
  404378:	2000107c 	.word	0x2000107c

0040437c <vTaskIncrementTick>:
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  40437c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404380:	4b3e      	ldr	r3, [pc, #248]	; (40447c <vTaskIncrementTick+0x100>)
  404382:	681b      	ldr	r3, [r3, #0]
 * documented in task.h
 *----------------------------------------------------------*/


void vTaskIncrementTick( void )
{
  404384:	b083      	sub	sp, #12
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  404386:	2b00      	cmp	r3, #0
  404388:	d150      	bne.n	40442c <vTaskIncrementTick+0xb0>
	{
		++xTickCount;
  40438a:	4c3d      	ldr	r4, [pc, #244]	; (404480 <vTaskIncrementTick+0x104>)
  40438c:	6823      	ldr	r3, [r4, #0]
  40438e:	3301      	adds	r3, #1
  404390:	6023      	str	r3, [r4, #0]
		if( xTickCount == ( portTickType ) 0 )
  404392:	6823      	ldr	r3, [r4, #0]
  404394:	2b00      	cmp	r3, #0
  404396:	d050      	beq.n	40443a <vTaskIncrementTick+0xbe>
  404398:	4a3a      	ldr	r2, [pc, #232]	; (404484 <vTaskIncrementTick+0x108>)
  40439a:	9201      	str	r2, [sp, #4]
  40439c:	6813      	ldr	r3, [r2, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  40439e:	6822      	ldr	r2, [r4, #0]
  4043a0:	4937      	ldr	r1, [pc, #220]	; (404480 <vTaskIncrementTick+0x104>)
  4043a2:	429a      	cmp	r2, r3
  4043a4:	d346      	bcc.n	404434 <vTaskIncrementTick+0xb8>
  4043a6:	4d38      	ldr	r5, [pc, #224]	; (404488 <vTaskIncrementTick+0x10c>)
  4043a8:	682b      	ldr	r3, [r5, #0]
  4043aa:	681b      	ldr	r3, [r3, #0]
  4043ac:	2b00      	cmp	r3, #0
  4043ae:	d036      	beq.n	40441e <vTaskIncrementTick+0xa2>
  4043b0:	682b      	ldr	r3, [r5, #0]
  4043b2:	68db      	ldr	r3, [r3, #12]
  4043b4:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  4043b8:	6809      	ldr	r1, [r1, #0]
  4043ba:	f8db 2004 	ldr.w	r2, [fp, #4]
  4043be:	428a      	cmp	r2, r1
  4043c0:	d857      	bhi.n	404472 <vTaskIncrementTick+0xf6>
  4043c2:	4f32      	ldr	r7, [pc, #200]	; (40448c <vTaskIncrementTick+0x110>)
  4043c4:	4e32      	ldr	r6, [pc, #200]	; (404490 <vTaskIncrementTick+0x114>)
  4043c6:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 4044a0 <vTaskIncrementTick+0x124>
  4043ca:	f8df 80d8 	ldr.w	r8, [pc, #216]	; 4044a4 <vTaskIncrementTick+0x128>
  4043ce:	e009      	b.n	4043e4 <vTaskIncrementTick+0x68>
  4043d0:	4a2d      	ldr	r2, [pc, #180]	; (404488 <vTaskIncrementTick+0x10c>)
  4043d2:	6813      	ldr	r3, [r2, #0]
  4043d4:	68db      	ldr	r3, [r3, #12]
  4043d6:	f8d3 b00c 	ldr.w	fp, [r3, #12]
  4043da:	6821      	ldr	r1, [r4, #0]
  4043dc:	f8db 2004 	ldr.w	r2, [fp, #4]
  4043e0:	428a      	cmp	r2, r1
  4043e2:	d846      	bhi.n	404472 <vTaskIncrementTick+0xf6>
  4043e4:	f10b 0a04 	add.w	sl, fp, #4
  4043e8:	4650      	mov	r0, sl
  4043ea:	47b8      	blx	r7
  4043ec:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
  4043f0:	f10b 0018 	add.w	r0, fp, #24
  4043f4:	b10a      	cbz	r2, 4043fa <vTaskIncrementTick+0x7e>
  4043f6:	4a25      	ldr	r2, [pc, #148]	; (40448c <vTaskIncrementTick+0x110>)
  4043f8:	4790      	blx	r2
  4043fa:	f8db 302c 	ldr.w	r3, [fp, #44]	; 0x2c
  4043fe:	6832      	ldr	r2, [r6, #0]
  404400:	4293      	cmp	r3, r2
  404402:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  404406:	bf88      	it	hi
  404408:	4a21      	ldrhi	r2, [pc, #132]	; (404490 <vTaskIncrementTick+0x114>)
  40440a:	eb09 0080 	add.w	r0, r9, r0, lsl #2
  40440e:	4651      	mov	r1, sl
  404410:	bf88      	it	hi
  404412:	6013      	strhi	r3, [r2, #0]
  404414:	47c0      	blx	r8
  404416:	682b      	ldr	r3, [r5, #0]
  404418:	681b      	ldr	r3, [r3, #0]
  40441a:	2b00      	cmp	r3, #0
  40441c:	d1d8      	bne.n	4043d0 <vTaskIncrementTick+0x54>
  40441e:	9a01      	ldr	r2, [sp, #4]
  404420:	f04f 33ff 	mov.w	r3, #4294967295
  404424:	6013      	str	r3, [r2, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  404426:	b003      	add	sp, #12
  404428:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
	}
	else
	{
		++uxMissedTicks;
  40442c:	4b19      	ldr	r3, [pc, #100]	; (404494 <vTaskIncrementTick+0x118>)
  40442e:	681a      	ldr	r2, [r3, #0]
  404430:	3201      	adds	r2, #1
  404432:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  404434:	b003      	add	sp, #12
  404436:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40443a:	4b13      	ldr	r3, [pc, #76]	; (404488 <vTaskIncrementTick+0x10c>)
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  40443c:	4916      	ldr	r1, [pc, #88]	; (404498 <vTaskIncrementTick+0x11c>)
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
  40443e:	6818      	ldr	r0, [r3, #0]
			pxDelayedTaskList = pxOverflowDelayedTaskList;
			pxOverflowDelayedTaskList = pxTemp;
			xNumOfOverflows++;
  404440:	4a16      	ldr	r2, [pc, #88]	; (40449c <vTaskIncrementTick+0x120>)
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
			pxDelayedTaskList = pxOverflowDelayedTaskList;
  404442:	680d      	ldr	r5, [r1, #0]
  404444:	601d      	str	r5, [r3, #0]
			pxOverflowDelayedTaskList = pxTemp;
  404446:	6008      	str	r0, [r1, #0]
			xNumOfOverflows++;
  404448:	6811      	ldr	r1, [r2, #0]
  40444a:	3101      	adds	r1, #1
  40444c:	6011      	str	r1, [r2, #0]

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
  40444e:	681a      	ldr	r2, [r3, #0]
  404450:	6812      	ldr	r2, [r2, #0]
  404452:	b932      	cbnz	r2, 404462 <vTaskIncrementTick+0xe6>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
  404454:	4b0b      	ldr	r3, [pc, #44]	; (404484 <vTaskIncrementTick+0x108>)
  404456:	4a0b      	ldr	r2, [pc, #44]	; (404484 <vTaskIncrementTick+0x108>)
  404458:	9301      	str	r3, [sp, #4]
  40445a:	f04f 33ff 	mov.w	r3, #4294967295
  40445e:	6013      	str	r3, [r2, #0]
  404460:	e79d      	b.n	40439e <vTaskIncrementTick+0x22>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  404462:	681b      	ldr	r3, [r3, #0]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404464:	4a07      	ldr	r2, [pc, #28]	; (404484 <vTaskIncrementTick+0x108>)
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  404466:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  404468:	9201      	str	r2, [sp, #4]
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
  40446a:	68db      	ldr	r3, [r3, #12]
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
  40446c:	685b      	ldr	r3, [r3, #4]
  40446e:	6013      	str	r3, [r2, #0]
  404470:	e795      	b.n	40439e <vTaskIncrementTick+0x22>
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
  404472:	9b01      	ldr	r3, [sp, #4]
  404474:	601a      	str	r2, [r3, #0]
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
  404476:	b003      	add	sp, #12
  404478:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40447c:	2000107c 	.word	0x2000107c
  404480:	20000f94 	.word	0x20000f94
  404484:	200000bc 	.word	0x200000bc
  404488:	20001040 	.word	0x20001040
  40448c:	00403e35 	.word	0x00403e35
  404490:	20000f90 	.word	0x20000f90
  404494:	20001080 	.word	0x20001080
  404498:	20001038 	.word	0x20001038
  40449c:	20001088 	.word	0x20001088
  4044a0:	20000f98 	.word	0x20000f98
  4044a4:	00403ddd 	.word	0x00403ddd

004044a8 <xTaskResumeAll>:
	++uxSchedulerSuspended;
}
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
  4044a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
  4044ac:	4b2d      	ldr	r3, [pc, #180]	; (404564 <xTaskResumeAll+0xbc>)
  4044ae:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
  4044b0:	4b2d      	ldr	r3, [pc, #180]	; (404568 <xTaskResumeAll+0xc0>)
  4044b2:	681a      	ldr	r2, [r3, #0]
  4044b4:	3a01      	subs	r2, #1
  4044b6:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4044b8:	681e      	ldr	r6, [r3, #0]
  4044ba:	2e00      	cmp	r6, #0
  4044bc:	d13c      	bne.n	404538 <xTaskResumeAll+0x90>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0 )
  4044be:	4b2b      	ldr	r3, [pc, #172]	; (40456c <xTaskResumeAll+0xc4>)
  4044c0:	681b      	ldr	r3, [r3, #0]
  4044c2:	2b00      	cmp	r3, #0
  4044c4:	d038      	beq.n	404538 <xTaskResumeAll+0x90>
  4044c6:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 404594 <xTaskResumeAll+0xec>
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  4044ca:	4f29      	ldr	r7, [pc, #164]	; (404570 <xTaskResumeAll+0xc8>)
					vListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
  4044cc:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 404598 <xTaskResumeAll+0xf0>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  4044d0:	46ca      	mov	sl, r9
  4044d2:	e01e      	b.n	404512 <xTaskResumeAll+0x6a>
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
  4044d4:	f8da 300c 	ldr.w	r3, [sl, #12]
  4044d8:	68dc      	ldr	r4, [r3, #12]
					vListRemove( &( pxTCB->xEventListItem ) );
  4044da:	f104 0018 	add.w	r0, r4, #24
					vListRemove( &( pxTCB->xGenericListItem ) );
  4044de:	1d25      	adds	r5, r4, #4
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					vListRemove( &( pxTCB->xEventListItem ) );
  4044e0:	47b8      	blx	r7
					vListRemove( &( pxTCB->xGenericListItem ) );
  4044e2:	4628      	mov	r0, r5
  4044e4:	47b8      	blx	r7
					prvAddTaskToReadyQueue( pxTCB );
  4044e6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4044e8:	f8d8 e000 	ldr.w	lr, [r8]
  4044ec:	4921      	ldr	r1, [pc, #132]	; (404574 <xTaskResumeAll+0xcc>)
  4044ee:	4a22      	ldr	r2, [pc, #136]	; (404578 <xTaskResumeAll+0xd0>)
  4044f0:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  4044f4:	4573      	cmp	r3, lr
  4044f6:	eb01 0080 	add.w	r0, r1, r0, lsl #2
  4044fa:	4629      	mov	r1, r5
  4044fc:	bf88      	it	hi
  4044fe:	f8c8 3000 	strhi.w	r3, [r8]
  404502:	4790      	blx	r2

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
  404504:	4b1d      	ldr	r3, [pc, #116]	; (40457c <xTaskResumeAll+0xd4>)
  404506:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
  404508:	681b      	ldr	r3, [r3, #0]
  40450a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
					{
						xYieldRequired = pdTRUE;
  40450c:	429a      	cmp	r2, r3
  40450e:	bf28      	it	cs
  404510:	2601      	movcs	r6, #1
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
  404512:	f8d9 3000 	ldr.w	r3, [r9]
  404516:	2b00      	cmp	r3, #0
  404518:	d1dc      	bne.n	4044d4 <xTaskResumeAll+0x2c>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  40451a:	4c19      	ldr	r4, [pc, #100]	; (404580 <xTaskResumeAll+0xd8>)
  40451c:	6823      	ldr	r3, [r4, #0]
  40451e:	b18b      	cbz	r3, 404544 <xTaskResumeAll+0x9c>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  404520:	6823      	ldr	r3, [r4, #0]
  404522:	b13b      	cbz	r3, 404534 <xTaskResumeAll+0x8c>
  404524:	4d17      	ldr	r5, [pc, #92]	; (404584 <xTaskResumeAll+0xdc>)
					{
						vTaskIncrementTick();
  404526:	47a8      	blx	r5
						--uxMissedTicks;
  404528:	6823      	ldr	r3, [r4, #0]
  40452a:	3b01      	subs	r3, #1
  40452c:	6023      	str	r3, [r4, #0]
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0 )
  40452e:	6823      	ldr	r3, [r4, #0]
  404530:	2b00      	cmp	r3, #0
  404532:	d1f8      	bne.n	404526 <xTaskResumeAll+0x7e>
  404534:	4b14      	ldr	r3, [pc, #80]	; (404588 <xTaskResumeAll+0xe0>)
  404536:	e00b      	b.n	404550 <xTaskResumeAll+0xa8>
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
  404538:	2400      	movs	r4, #0
					portYIELD_WITHIN_API();
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40453a:	4b14      	ldr	r3, [pc, #80]	; (40458c <xTaskResumeAll+0xe4>)
  40453c:	4798      	blx	r3

	return xAlreadyYielded;
}
  40453e:	4620      	mov	r0, r4
  404540:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
  404544:	2e01      	cmp	r6, #1
  404546:	d0f5      	beq.n	404534 <xTaskResumeAll+0x8c>
  404548:	4b0f      	ldr	r3, [pc, #60]	; (404588 <xTaskResumeAll+0xe0>)
  40454a:	681a      	ldr	r2, [r3, #0]
  40454c:	2a01      	cmp	r2, #1
  40454e:	d1f3      	bne.n	404538 <xTaskResumeAll+0x90>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404550:	2100      	movs	r1, #0
					portYIELD_WITHIN_API();
  404552:	4a0f      	ldr	r2, [pc, #60]	; (404590 <xTaskResumeAll+0xe8>)
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
  404554:	6019      	str	r1, [r3, #0]
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
				{
					xAlreadyYielded = pdTRUE;
  404556:	2401      	movs	r4, #1
					xMissedYield = pdFALSE;
					portYIELD_WITHIN_API();
  404558:	4790      	blx	r2
				}
			}
		}
	}
	taskEXIT_CRITICAL();
  40455a:	4b0c      	ldr	r3, [pc, #48]	; (40458c <xTaskResumeAll+0xe4>)
  40455c:	4798      	blx	r3

	return xAlreadyYielded;
}
  40455e:	4620      	mov	r0, r4
  404560:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  404564:	00403e89 	.word	0x00403e89
  404568:	2000107c 	.word	0x2000107c
  40456c:	20001044 	.word	0x20001044
  404570:	00403e35 	.word	0x00403e35
  404574:	20000f98 	.word	0x20000f98
  404578:	00403ddd 	.word	0x00403ddd
  40457c:	20001064 	.word	0x20001064
  404580:	20001080 	.word	0x20001080
  404584:	0040437d 	.word	0x0040437d
  404588:	2000105c 	.word	0x2000105c
  40458c:	00403ea1 	.word	0x00403ea1
  404590:	00403e79 	.word	0x00403e79
  404594:	20001048 	.word	0x20001048
  404598:	20000f90 	.word	0x20000f90

0040459c <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
  40459c:	b430      	push	{r4, r5}
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
  40459e:	4b29      	ldr	r3, [pc, #164]	; (404644 <vTaskSwitchContext+0xa8>)
  4045a0:	681b      	ldr	r3, [r3, #0]
  4045a2:	2b00      	cmp	r3, #0
  4045a4:	d134      	bne.n	404610 <vTaskSwitchContext+0x74>

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  4045a6:	4b28      	ldr	r3, [pc, #160]	; (404648 <vTaskSwitchContext+0xac>)
  4045a8:	4928      	ldr	r1, [pc, #160]	; (40464c <vTaskSwitchContext+0xb0>)
  4045aa:	681a      	ldr	r2, [r3, #0]
  4045ac:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4045b0:	0092      	lsls	r2, r2, #2
  4045b2:	588a      	ldr	r2, [r1, r2]
  4045b4:	b94a      	cbnz	r2, 4045ca <vTaskSwitchContext+0x2e>
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
  4045b6:	681a      	ldr	r2, [r3, #0]
  4045b8:	3a01      	subs	r2, #1
  4045ba:	601a      	str	r2, [r3, #0]

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
  4045bc:	681a      	ldr	r2, [r3, #0]
  4045be:	eb02 0282 	add.w	r2, r2, r2, lsl #2
  4045c2:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
  4045c6:	2a00      	cmp	r2, #0
  4045c8:	d0f5      	beq.n	4045b6 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4045ca:	681b      	ldr	r3, [r3, #0]
  4045cc:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4045d0:	eb01 0183 	add.w	r1, r1, r3, lsl #2
  4045d4:	f101 0208 	add.w	r2, r1, #8
  4045d8:	684b      	ldr	r3, [r1, #4]
  4045da:	685b      	ldr	r3, [r3, #4]
  4045dc:	604b      	str	r3, [r1, #4]
  4045de:	4293      	cmp	r3, r2
  4045e0:	d02c      	beq.n	40463c <vTaskSwitchContext+0xa0>

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045e2:	491b      	ldr	r1, [pc, #108]	; (404650 <vTaskSwitchContext+0xb4>)
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4045e4:	4a1b      	ldr	r2, [pc, #108]	; (404654 <vTaskSwitchContext+0xb8>)

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045e6:	6808      	ldr	r0, [r1, #0]
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  4045e8:	68db      	ldr	r3, [r3, #12]
  4045ea:	6013      	str	r3, [r2, #0]

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  4045ec:	b170      	cbz	r0, 40460c <vTaskSwitchContext+0x70>
  4045ee:	6813      	ldr	r3, [r2, #0]
  4045f0:	4819      	ldr	r0, [pc, #100]	; (404658 <vTaskSwitchContext+0xbc>)
  4045f2:	6c5c      	ldr	r4, [r3, #68]	; 0x44
  4045f4:	6803      	ldr	r3, [r0, #0]
  4045f6:	429c      	cmp	r4, r3
  4045f8:	d008      	beq.n	40460c <vTaskSwitchContext+0x70>
  4045fa:	4b18      	ldr	r3, [pc, #96]	; (40465c <vTaskSwitchContext+0xc0>)
  4045fc:	4d18      	ldr	r5, [pc, #96]	; (404660 <vTaskSwitchContext+0xc4>)
  4045fe:	681c      	ldr	r4, [r3, #0]
  404600:	682d      	ldr	r5, [r5, #0]
  404602:	3408      	adds	r4, #8
  404604:	42a5      	cmp	r5, r4
  404606:	d808      	bhi.n	40461a <vTaskSwitchContext+0x7e>
  404608:	2300      	movs	r3, #0
  40460a:	600b      	str	r3, [r1, #0]
	}
}
  40460c:	bc30      	pop	{r4, r5}
  40460e:	4770      	bx	lr
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
  404610:	4b14      	ldr	r3, [pc, #80]	; (404664 <vTaskSwitchContext+0xc8>)
  404612:	2201      	movs	r2, #1
  404614:	601a      	str	r2, [r3, #0]
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
  404616:	bc30      	pop	{r4, r5}
  404618:	4770      	bx	lr
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );

		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
  40461a:	4913      	ldr	r1, [pc, #76]	; (404668 <vTaskSwitchContext+0xcc>)
  40461c:	6812      	ldr	r2, [r2, #0]
  40461e:	681c      	ldr	r4, [r3, #0]
  404620:	680d      	ldr	r5, [r1, #0]
  404622:	6819      	ldr	r1, [r3, #0]
  404624:	6c52      	ldr	r2, [r2, #68]	; 0x44
  404626:	6002      	str	r2, [r0, #0]
  404628:	3104      	adds	r1, #4
  40462a:	6019      	str	r1, [r3, #0]
  40462c:	6818      	ldr	r0, [r3, #0]
  40462e:	6819      	ldr	r1, [r3, #0]
  404630:	6025      	str	r5, [r4, #0]
  404632:	3104      	adds	r1, #4
  404634:	6002      	str	r2, [r0, #0]
  404636:	6019      	str	r1, [r3, #0]
	}
}
  404638:	bc30      	pop	{r4, r5}
  40463a:	4770      	bx	lr
			--uxTopReadyPriority;
		}

		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
  40463c:	685b      	ldr	r3, [r3, #4]
  40463e:	604b      	str	r3, [r1, #4]
  404640:	e7cf      	b.n	4045e2 <vTaskSwitchContext+0x46>
  404642:	bf00      	nop
  404644:	2000107c 	.word	0x2000107c
  404648:	20000f90 	.word	0x20000f90
  40464c:	20000f98 	.word	0x20000f98
  404650:	2000103c 	.word	0x2000103c
  404654:	20001064 	.word	0x20001064
  404658:	200000b8 	.word	0x200000b8
  40465c:	20001060 	.word	0x20001060
  404660:	20001084 	.word	0x20001084
  404664:	2000105c 	.word	0x2000105c
  404668:	20000f94 	.word	0x20000f94

0040466c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  40466c:	b538      	push	{r3, r4, r5, lr}
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  40466e:	4c0c      	ldr	r4, [pc, #48]	; (4046a0 <vTaskPlaceOnEventList+0x34>)
  404670:	4b0c      	ldr	r3, [pc, #48]	; (4046a4 <vTaskPlaceOnEventList+0x38>)
  404672:	6822      	ldr	r2, [r4, #0]
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
  404674:	460d      	mov	r5, r1
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
  404676:	f102 0118 	add.w	r1, r2, #24
  40467a:	4798      	blx	r3

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  40467c:	6820      	ldr	r0, [r4, #0]
  40467e:	4b0a      	ldr	r3, [pc, #40]	; (4046a8 <vTaskPlaceOnEventList+0x3c>)
  404680:	3004      	adds	r0, #4
  404682:	4798      	blx	r3


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
  404684:	1c6b      	adds	r3, r5, #1
  404686:	d005      	beq.n	404694 <vTaskPlaceOnEventList+0x28>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  404688:	4a08      	ldr	r2, [pc, #32]	; (4046ac <vTaskPlaceOnEventList+0x40>)
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  40468a:	4b09      	ldr	r3, [pc, #36]	; (4046b0 <vTaskPlaceOnEventList+0x44>)
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
  40468c:	6810      	ldr	r0, [r2, #0]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
  40468e:	4428      	add	r0, r5
  404690:	4798      	blx	r3
  404692:	bd38      	pop	{r3, r4, r5, pc}
		if( xTicksToWait == portMAX_DELAY )
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
  404694:	6821      	ldr	r1, [r4, #0]
  404696:	4807      	ldr	r0, [pc, #28]	; (4046b4 <vTaskPlaceOnEventList+0x48>)
  404698:	4b07      	ldr	r3, [pc, #28]	; (4046b8 <vTaskPlaceOnEventList+0x4c>)
  40469a:	3104      	adds	r1, #4
  40469c:	4798      	blx	r3
  40469e:	bd38      	pop	{r3, r4, r5, pc}
  4046a0:	20001064 	.word	0x20001064
  4046a4:	00403df9 	.word	0x00403df9
  4046a8:	00403e35 	.word	0x00403e35
  4046ac:	20000f94 	.word	0x20000f94
  4046b0:	0040431d 	.word	0x0040431d
  4046b4:	20001068 	.word	0x20001068
  4046b8:	00403ddd 	.word	0x00403ddd

004046bc <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
  4046bc:	b570      	push	{r4, r5, r6, lr}
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  4046be:	68c3      	ldr	r3, [r0, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  4046c0:	4e13      	ldr	r6, [pc, #76]	; (404710 <xTaskRemoveFromEventList+0x54>)
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
  4046c2:	68dc      	ldr	r4, [r3, #12]
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
  4046c4:	f104 0518 	add.w	r5, r4, #24
  4046c8:	4628      	mov	r0, r5
  4046ca:	47b0      	blx	r6

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
  4046cc:	4b11      	ldr	r3, [pc, #68]	; (404714 <xTaskRemoveFromEventList+0x58>)
  4046ce:	681b      	ldr	r3, [r3, #0]
  4046d0:	b9cb      	cbnz	r3, 404706 <xTaskRemoveFromEventList+0x4a>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
  4046d2:	1d25      	adds	r5, r4, #4
  4046d4:	4628      	mov	r0, r5
  4046d6:	47b0      	blx	r6
		prvAddTaskToReadyQueue( pxUnblockedTCB );
  4046d8:	4a0f      	ldr	r2, [pc, #60]	; (404718 <xTaskRemoveFromEventList+0x5c>)
  4046da:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
  4046dc:	6811      	ldr	r1, [r2, #0]
  4046de:	480f      	ldr	r0, [pc, #60]	; (40471c <xTaskRemoveFromEventList+0x60>)
  4046e0:	428b      	cmp	r3, r1
  4046e2:	bf88      	it	hi
  4046e4:	6013      	strhi	r3, [r2, #0]
  4046e6:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4046ea:	4a0d      	ldr	r2, [pc, #52]	; (404720 <xTaskRemoveFromEventList+0x64>)
  4046ec:	4629      	mov	r1, r5
  4046ee:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  4046f2:	4790      	blx	r2
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
  4046f4:	4b0b      	ldr	r3, [pc, #44]	; (404724 <xTaskRemoveFromEventList+0x68>)
  4046f6:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
  4046f8:	681b      	ldr	r3, [r3, #0]
  4046fa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
  4046fc:	4298      	cmp	r0, r3
  4046fe:	bf34      	ite	cc
  404700:	2000      	movcc	r0, #0
  404702:	2001      	movcs	r0, #1
  404704:	bd70      	pop	{r4, r5, r6, pc}
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
  404706:	4629      	mov	r1, r5
  404708:	4807      	ldr	r0, [pc, #28]	; (404728 <xTaskRemoveFromEventList+0x6c>)
  40470a:	4b05      	ldr	r3, [pc, #20]	; (404720 <xTaskRemoveFromEventList+0x64>)
  40470c:	4798      	blx	r3
  40470e:	e7f1      	b.n	4046f4 <xTaskRemoveFromEventList+0x38>
  404710:	00403e35 	.word	0x00403e35
  404714:	2000107c 	.word	0x2000107c
  404718:	20000f90 	.word	0x20000f90
  40471c:	20000f98 	.word	0x20000f98
  404720:	00403ddd 	.word	0x00403ddd
  404724:	20001064 	.word	0x20001064
  404728:	20001048 	.word	0x20001048

0040472c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  40472c:	4a03      	ldr	r2, [pc, #12]	; (40473c <vTaskSetTimeOutState+0x10>)
	pxTimeOut->xTimeOnEntering = xTickCount;
  40472e:	4b04      	ldr	r3, [pc, #16]	; (404740 <vTaskSetTimeOutState+0x14>)
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404730:	6812      	ldr	r2, [r2, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  404732:	681b      	ldr	r3, [r3, #0]
  404734:	e880 000c 	stmia.w	r0, {r2, r3}
  404738:	4770      	bx	lr
  40473a:	bf00      	nop
  40473c:	20001088 	.word	0x20001088
  404740:	20000f94 	.word	0x20000f94

00404744 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  404744:	b570      	push	{r4, r5, r6, lr}
  404746:	460d      	mov	r5, r1
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  404748:	4b19      	ldr	r3, [pc, #100]	; (4047b0 <xTaskCheckForTimeOut+0x6c>)
	pxTimeOut->xTimeOnEntering = xTickCount;
}
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
  40474a:	4604      	mov	r4, r0
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
  40474c:	4798      	blx	r3
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
  40474e:	682b      	ldr	r3, [r5, #0]
  404750:	1c5a      	adds	r2, r3, #1
  404752:	d028      	beq.n	4047a6 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
  404754:	4817      	ldr	r0, [pc, #92]	; (4047b4 <xTaskCheckForTimeOut+0x70>)
  404756:	6822      	ldr	r2, [r4, #0]
  404758:	6801      	ldr	r1, [r0, #0]
  40475a:	428a      	cmp	r2, r1
  40475c:	d01b      	beq.n	404796 <xTaskCheckForTimeOut+0x52>
  40475e:	4916      	ldr	r1, [pc, #88]	; (4047b8 <xTaskCheckForTimeOut+0x74>)
  404760:	6862      	ldr	r2, [r4, #4]
  404762:	680e      	ldr	r6, [r1, #0]
  404764:	42b2      	cmp	r2, r6
  404766:	d911      	bls.n	40478c <xTaskCheckForTimeOut+0x48>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  404768:	680e      	ldr	r6, [r1, #0]
  40476a:	4913      	ldr	r1, [pc, #76]	; (4047b8 <xTaskCheckForTimeOut+0x74>)
  40476c:	1ab6      	subs	r6, r6, r2
  40476e:	42b3      	cmp	r3, r6
  404770:	d90c      	bls.n	40478c <xTaskCheckForTimeOut+0x48>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  404772:	680e      	ldr	r6, [r1, #0]
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
  404774:	6800      	ldr	r0, [r0, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
  404776:	6809      	ldr	r1, [r1, #0]
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
  404778:	1b9b      	subs	r3, r3, r6
  40477a:	441a      	add	r2, r3
  40477c:	602a      	str	r2, [r5, #0]
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40477e:	4b0f      	ldr	r3, [pc, #60]	; (4047bc <xTaskCheckForTimeOut+0x78>)

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
	pxTimeOut->xTimeOnEntering = xTickCount;
  404780:	e884 0003 	stmia.w	r4, {r0, r1}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
  404784:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  404786:	4798      	blx	r3

	return xReturn;
}
  404788:	4628      	mov	r0, r5
  40478a:	bd70      	pop	{r4, r5, r6, pc}
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
  40478c:	2501      	movs	r5, #1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  40478e:	4b0b      	ldr	r3, [pc, #44]	; (4047bc <xTaskCheckForTimeOut+0x78>)
  404790:	4798      	blx	r3

	return xReturn;
}
  404792:	4628      	mov	r0, r5
  404794:	bd70      	pop	{r4, r5, r6, pc}
  404796:	4908      	ldr	r1, [pc, #32]	; (4047b8 <xTaskCheckForTimeOut+0x74>)
  404798:	6862      	ldr	r2, [r4, #4]
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
  40479a:	680e      	ldr	r6, [r1, #0]
  40479c:	4906      	ldr	r1, [pc, #24]	; (4047b8 <xTaskCheckForTimeOut+0x74>)
  40479e:	1ab6      	subs	r6, r6, r2
  4047a0:	42b3      	cmp	r3, r6
  4047a2:	d8e6      	bhi.n	404772 <xTaskCheckForTimeOut+0x2e>
  4047a4:	e7f2      	b.n	40478c <xTaskCheckForTimeOut+0x48>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
  4047a6:	2500      	movs	r5, #0
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
  4047a8:	4b04      	ldr	r3, [pc, #16]	; (4047bc <xTaskCheckForTimeOut+0x78>)
  4047aa:	4798      	blx	r3

	return xReturn;
}
  4047ac:	4628      	mov	r0, r5
  4047ae:	bd70      	pop	{r4, r5, r6, pc}
  4047b0:	00403e89 	.word	0x00403e89
  4047b4:	20001088 	.word	0x20001088
  4047b8:	20000f94 	.word	0x20000f94
  4047bc:	00403ea1 	.word	0x00403ea1

004047c0 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
  4047c0:	4b01      	ldr	r3, [pc, #4]	; (4047c8 <vTaskMissedYield+0x8>)
  4047c2:	2201      	movs	r2, #1
  4047c4:	601a      	str	r2, [r3, #0]
  4047c6:	4770      	bx	lr
  4047c8:	2000105c 	.word	0x2000105c

004047cc <xTaskGetCurrentTaskHandle>:
	xTaskHandle xReturn;

		/* A critical section is not required as this is not called from
		an interrupt and the current TCB will always be the same for any
		individual execution thread. */
		xReturn = pxCurrentTCB;
  4047cc:	4b01      	ldr	r3, [pc, #4]	; (4047d4 <xTaskGetCurrentTaskHandle+0x8>)
  4047ce:	6818      	ldr	r0, [r3, #0]

		return xReturn;
	}
  4047d0:	4770      	bx	lr
  4047d2:	bf00      	nop
  4047d4:	20001064 	.word	0x20001064

004047d8 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4047d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4047da:	4d16      	ldr	r5, [pc, #88]	; (404834 <vTaskPriorityInherit+0x5c>)
  4047dc:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
  4047de:	682a      	ldr	r2, [r5, #0]
  4047e0:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
  4047e2:	4293      	cmp	r3, r2
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( xTaskHandle * const pxMutexHolder )
	{
  4047e4:	4604      	mov	r4, r0
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
  4047e6:	d20f      	bcs.n	404808 <vTaskPriorityInherit+0x30>
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047e8:	682a      	ldr	r2, [r5, #0]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047ea:	4e13      	ldr	r6, [pc, #76]	; (404838 <vTaskPriorityInherit+0x60>)
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047ec:	6ad1      	ldr	r1, [r2, #44]	; 0x2c

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047ee:	6942      	ldr	r2, [r0, #20]
  4047f0:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  4047f4:	eb06 0383 	add.w	r3, r6, r3, lsl #2
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047f8:	f1c1 0108 	rsb	r1, r1, #8

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  4047fc:	429a      	cmp	r2, r3
		configASSERT( pxMutexHolder );

		if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
		{
			/* Adjust the mutex holder state to account for its new priority. */
			listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxCurrentTCB->uxPriority );
  4047fe:	6181      	str	r1, [r0, #24]

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
  404800:	d003      	beq.n	40480a <vTaskPriorityInherit+0x32>
				prvAddTaskToReadyQueue( pxTCB );
			}
			else
			{
				/* Just inherit the priority. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  404802:	682b      	ldr	r3, [r5, #0]
  404804:	6adb      	ldr	r3, [r3, #44]	; 0x2c
  404806:	62c3      	str	r3, [r0, #44]	; 0x2c
  404808:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

			/* If the task being modified is in the ready state it will need to
			be moved in to a new list. */
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );
  40480a:	1d07      	adds	r7, r0, #4
  40480c:	4638      	mov	r0, r7
  40480e:	4b0b      	ldr	r3, [pc, #44]	; (40483c <vTaskPriorityInherit+0x64>)
  404810:	4798      	blx	r3

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  404812:	682b      	ldr	r3, [r5, #0]
				prvAddTaskToReadyQueue( pxTCB );
  404814:	4a0a      	ldr	r2, [pc, #40]	; (404840 <vTaskPriorityInherit+0x68>)
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  404816:	6adb      	ldr	r3, [r3, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  404818:	6811      	ldr	r1, [r2, #0]
			if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) )
			{
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Inherit the priority before being moved into the new list. */
				pxTCB->uxPriority = pxCurrentTCB->uxPriority;
  40481a:	62e3      	str	r3, [r4, #44]	; 0x2c
				prvAddTaskToReadyQueue( pxTCB );
  40481c:	428b      	cmp	r3, r1
  40481e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
  404822:	bf88      	it	hi
  404824:	6013      	strhi	r3, [r2, #0]
  404826:	eb06 0080 	add.w	r0, r6, r0, lsl #2
  40482a:	4639      	mov	r1, r7
  40482c:	4b05      	ldr	r3, [pc, #20]	; (404844 <vTaskPriorityInherit+0x6c>)
  40482e:	4798      	blx	r3
  404830:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404832:	bf00      	nop
  404834:	20001064 	.word	0x20001064
  404838:	20000f98 	.word	0x20000f98
  40483c:	00403e35 	.word	0x00403e35
  404840:	20000f90 	.word	0x20000f90
  404844:	00403ddd 	.word	0x00403ddd

00404848 <vTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityDisinherit( xTaskHandle * const pxMutexHolder )
	{
  404848:	b538      	push	{r3, r4, r5, lr}
	tskTCB * const pxTCB = ( tskTCB * ) pxMutexHolder;

		if( pxMutexHolder != NULL )
  40484a:	4604      	mov	r4, r0
  40484c:	b1c8      	cbz	r0, 404882 <vTaskPriorityDisinherit+0x3a>
		{
			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
  40484e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  404850:	6c83      	ldr	r3, [r0, #72]	; 0x48
  404852:	429a      	cmp	r2, r3
  404854:	d015      	beq.n	404882 <vTaskPriorityDisinherit+0x3a>
			{
				/* We must be the running task to be able to give the mutex back.
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );
  404856:	1d05      	adds	r5, r0, #4
  404858:	4628      	mov	r0, r5
  40485a:	4b0a      	ldr	r3, [pc, #40]	; (404884 <vTaskPriorityDisinherit+0x3c>)
  40485c:	4798      	blx	r3

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  40485e:	4a0a      	ldr	r2, [pc, #40]	; (404888 <vTaskPriorityDisinherit+0x40>)
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404860:	6ca3      	ldr	r3, [r4, #72]	; 0x48
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
				prvAddTaskToReadyQueue( pxTCB );
  404862:	6811      	ldr	r1, [r2, #0]
				Remove ourselves from the ready list we currently appear in. */
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
  404864:	62e3      	str	r3, [r4, #44]	; 0x2c
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  404866:	f1c3 0008 	rsb	r0, r3, #8
				prvAddTaskToReadyQueue( pxTCB );
  40486a:	428b      	cmp	r3, r1
				vListRemove( &( pxTCB->xGenericListItem ) );

				/* Disinherit the priority before adding ourselves into the new
				ready list. */
				pxTCB->uxPriority = pxTCB->uxBasePriority;
				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) pxTCB->uxPriority );
  40486c:	61a0      	str	r0, [r4, #24]
				prvAddTaskToReadyQueue( pxTCB );
  40486e:	4807      	ldr	r0, [pc, #28]	; (40488c <vTaskPriorityDisinherit+0x44>)
  404870:	bf88      	it	hi
  404872:	6013      	strhi	r3, [r2, #0]
  404874:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  404878:	4a05      	ldr	r2, [pc, #20]	; (404890 <vTaskPriorityDisinherit+0x48>)
  40487a:	4629      	mov	r1, r5
  40487c:	eb00 0083 	add.w	r0, r0, r3, lsl #2
  404880:	4790      	blx	r2
  404882:	bd38      	pop	{r3, r4, r5, pc}
  404884:	00403e35 	.word	0x00403e35
  404888:	20000f90 	.word	0x20000f90
  40488c:	20000f98 	.word	0x20000f98
  404890:	00403ddd 	.word	0x00403ddd

00404894 <WDT_Handler>:

/**
 *  \brief Handler for watchdog interrupt.
 */
void WDT_Handler(void)
{
  404894:	b508      	push	{r3, lr}

	/* Clear status bit to acknowledge interrupt by dummy read. */
	wdt_get_status(WDT);
  404896:	4803      	ldr	r0, [pc, #12]	; (4048a4 <WDT_Handler+0x10>)
  404898:	4b03      	ldr	r3, [pc, #12]	; (4048a8 <WDT_Handler+0x14>)
  40489a:	4798      	blx	r3

	debugPrintString("Restarting system!!!\r");
  40489c:	4803      	ldr	r0, [pc, #12]	; (4048ac <WDT_Handler+0x18>)
  40489e:	4b04      	ldr	r3, [pc, #16]	; (4048b0 <WDT_Handler+0x1c>)
  4048a0:	4798      	blx	r3
  4048a2:	bd08      	pop	{r3, pc}
  4048a4:	400e1450 	.word	0x400e1450
  4048a8:	00405695 	.word	0x00405695
  4048ac:	004070d0 	.word	0x004070d0
  4048b0:	00400e3d 	.word	0x00400e3d

004048b4 <itoa>:
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  4048b4:	b4f0      	push	{r4, r5, r6, r7}
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4048b6:	2a0a      	cmp	r2, #10
 *  Author: sean
 * Copyright Heddoko(TM) 2015, all rights reserved
 */ 

int itoa(int value, char* sp, int radix)
{
  4048b8:	b084      	sub	sp, #16
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  4048ba:	d028      	beq.n	40490e <itoa+0x5a>
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;
  4048bc:	2700      	movs	r7, #0
	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  4048be:	466e      	mov	r6, sp
  4048c0:	466b      	mov	r3, sp
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  4048c2:	b938      	cbnz	r0, 4048d4 <itoa+0x20>
  4048c4:	42b3      	cmp	r3, r6
  4048c6:	d110      	bne.n	4048ea <itoa+0x36>
	 {
		 i = v % radix;
  4048c8:	4604      	mov	r4, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
			*tp++ = i+'0';
  4048ca:	3430      	adds	r4, #48	; 0x30
  4048cc:	701c      	strb	r4, [r3, #0]
  4048ce:	3301      	adds	r3, #1
	 if (sign)
		 v = -value;
	 else
		v = (unsigned)value;

	 while (v || tp == tmp)
  4048d0:	2800      	cmp	r0, #0
  4048d2:	d0f7      	beq.n	4048c4 <itoa+0x10>
	 {
		 i = v % radix;
  4048d4:	fbb0 f5f2 	udiv	r5, r0, r2
  4048d8:	fb02 0415 	mls	r4, r2, r5, r0
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
		 if (i < 10)
  4048dc:	2c09      	cmp	r4, #9
		v = (unsigned)value;

	 while (v || tp == tmp)
	 {
		 i = v % radix;
		 v /= radix;	// v/=radix uses less CPU clocks than v=v/radix does
  4048de:	4628      	mov	r0, r5
		 if (i < 10)
  4048e0:	ddf3      	ble.n	4048ca <itoa+0x16>
			*tp++ = i+'0';
		 else
			*tp++ = i + 'a' - 10;
  4048e2:	3457      	adds	r4, #87	; 0x57
  4048e4:	701c      	strb	r4, [r3, #0]
  4048e6:	3301      	adds	r3, #1
  4048e8:	e7eb      	b.n	4048c2 <itoa+0xe>
	 }

	 int len = tp - tmp;
  4048ea:	1b98      	subs	r0, r3, r6

	 if (sign)
  4048ec:	b11f      	cbz	r7, 4048f6 <itoa+0x42>
	 {
		 *sp++ = '-';
  4048ee:	222d      	movs	r2, #45	; 0x2d
  4048f0:	700a      	strb	r2, [r1, #0]
		 len++;
  4048f2:	3001      	adds	r0, #1

	 int len = tp - tmp;

	 if (sign)
	 {
		 *sp++ = '-';
  4048f4:	3101      	adds	r1, #1
		 len++;
	 }

	 while (tp > tmp)
  4048f6:	42b3      	cmp	r3, r6
  4048f8:	d906      	bls.n	404908 <itoa+0x54>
  4048fa:	3901      	subs	r1, #1
	 *sp++ = *--tp;
  4048fc:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
  404900:	f801 2f01 	strb.w	r2, [r1, #1]!
	 {
		 *sp++ = '-';
		 len++;
	 }

	 while (tp > tmp)
  404904:	42b3      	cmp	r3, r6
  404906:	d1f9      	bne.n	4048fc <itoa+0x48>
	 *sp++ = *--tp;

	 return len;
  404908:	b004      	add	sp, #16
  40490a:	bcf0      	pop	{r4, r5, r6, r7}
  40490c:	4770      	bx	lr
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  40490e:	2800      	cmp	r0, #0
  404910:	dad4      	bge.n	4048bc <itoa+0x8>
	 if (sign)
		 v = -value;
  404912:	4240      	negs	r0, r0
	 char tmp[16];		// be careful with the length of the buffer
	 char *tp = tmp;
	 int i;
	 unsigned v;

	 int sign = (radix == 10 && value < 0);
  404914:	2701      	movs	r7, #1
  404916:	e7d2      	b.n	4048be <itoa+0xa>

00404918 <drv_gpio_int_cd>:
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  404918:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  40491a:	4e0b      	ldr	r6, [pc, #44]	; (404948 <drv_gpio_int_cd+0x30>)
  40491c:	4b0b      	ldr	r3, [pc, #44]	; (40494c <drv_gpio_int_cd+0x34>)
  40491e:	f8d6 0100 	ldr.w	r0, [r6, #256]	; 0x100
	pio_disable_interrupt(PIOB, PinMask);
  404922:	4d0b      	ldr	r5, [pc, #44]	; (404950 <drv_gpio_int_cd+0x38>)
 * @brief Interrupt routine for SD Card Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
  404924:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  404926:	4798      	blx	r3
	pio_disable_interrupt(PIOB, PinMask);
  404928:	4b0a      	ldr	r3, [pc, #40]	; (404954 <drv_gpio_int_cd+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
  40492a:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOB, PinMask);
  40492c:	4601      	mov	r1, r0
  40492e:	4628      	mov	r0, r5
  404930:	4798      	blx	r3
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
  404932:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_cd(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
  404934:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOB, PinMask);
  404936:	4806      	ldr	r0, [pc, #24]	; (404950 <drv_gpio_int_cd+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_SD_CD].pinId);
	pio_disable_interrupt(PIOB, PinMask);
	uint32_t ReadIsr = PIOB->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_SD_CD].gpioSetFlag = 1;
  404938:	bf04      	itt	eq
  40493a:	2301      	moveq	r3, #1
  40493c:	f886 310e 	strbeq.w	r3, [r6, #270]	; 0x10e
	}
	pio_enable_interrupt(PIOB, PinMask);
  404940:	4621      	mov	r1, r4
  404942:	4b05      	ldr	r3, [pc, #20]	; (404958 <drv_gpio_int_cd+0x40>)
  404944:	4798      	blx	r3
  404946:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404948:	20000178 	.word	0x20000178
  40494c:	00405471 	.word	0x00405471
  404950:	400e1000 	.word	0x400e1000
  404954:	004052ad 	.word	0x004052ad
  404958:	004052a5 	.word	0x004052a5

0040495c <drv_gpio_int_lbo>:
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  40495c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40495e:	4e0b      	ldr	r6, [pc, #44]	; (40498c <drv_gpio_int_lbo+0x30>)
  404960:	4b0b      	ldr	r3, [pc, #44]	; (404990 <drv_gpio_int_lbo+0x34>)
  404962:	f8d6 00f0 	ldr.w	r0, [r6, #240]	; 0xf0
	pio_disable_interrupt(PIOA, PinMask);
  404966:	4d0b      	ldr	r5, [pc, #44]	; (404994 <drv_gpio_int_lbo+0x38>)
 * @brief Interrupt routine for Low Battery Out
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
  404968:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40496a:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  40496c:	4b0a      	ldr	r3, [pc, #40]	; (404998 <drv_gpio_int_lbo+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
  40496e:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404970:	4601      	mov	r1, r0
  404972:	4628      	mov	r0, r5
  404974:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404976:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_lbo(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404978:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  40497a:	4806      	ldr	r0, [pc, #24]	; (404994 <drv_gpio_int_lbo+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_LBO].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_LBO].gpioSetFlag = 1;
  40497c:	bf04      	itt	eq
  40497e:	2301      	moveq	r3, #1
  404980:	f886 30fe 	strbeq.w	r3, [r6, #254]	; 0xfe
	}
	pio_enable_interrupt(PIOA, PinMask);
  404984:	4621      	mov	r1, r4
  404986:	4b05      	ldr	r3, [pc, #20]	; (40499c <drv_gpio_int_lbo+0x40>)
  404988:	4798      	blx	r3
  40498a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  40498c:	20000178 	.word	0x20000178
  404990:	00405471 	.word	0x00405471
  404994:	400e0e00 	.word	0x400e0e00
  404998:	004052ad 	.word	0x004052ad
  40499c:	004052a5 	.word	0x004052a5

004049a0 <drv_gpio_int_dc2>:
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  4049a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  4049a2:	4e0b      	ldr	r6, [pc, #44]	; (4049d0 <drv_gpio_int_dc2+0x30>)
  4049a4:	4b0b      	ldr	r3, [pc, #44]	; (4049d4 <drv_gpio_int_dc2+0x34>)
  4049a6:	6e30      	ldr	r0, [r6, #96]	; 0x60
	pio_disable_interrupt(PIOA, PinMask);
  4049a8:	4d0b      	ldr	r5, [pc, #44]	; (4049d8 <drv_gpio_int_dc2+0x38>)
 * @brief Interrupt routine for Jack-2 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
  4049aa:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  4049ac:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4049ae:	4b0b      	ldr	r3, [pc, #44]	; (4049dc <drv_gpio_int_dc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
  4049b0:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4049b2:	4601      	mov	r1, r0
  4049b4:	4628      	mov	r0, r5
  4049b6:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4049b8:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4049ba:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  4049bc:	4806      	ldr	r0, [pc, #24]	; (4049d8 <drv_gpio_int_dc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC2].gpioSetFlag = 1;
  4049be:	bf04      	itt	eq
  4049c0:	2301      	moveq	r3, #1
  4049c2:	f886 306e 	strbeq.w	r3, [r6, #110]	; 0x6e
	}
	pio_enable_interrupt(PIOA, PinMask);
  4049c6:	4621      	mov	r1, r4
  4049c8:	4b05      	ldr	r3, [pc, #20]	; (4049e0 <drv_gpio_int_dc2+0x40>)
  4049ca:	4798      	blx	r3
  4049cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4049ce:	bf00      	nop
  4049d0:	20000178 	.word	0x20000178
  4049d4:	00405471 	.word	0x00405471
  4049d8:	400e0e00 	.word	0x400e0e00
  4049dc:	004052ad 	.word	0x004052ad
  4049e0:	004052a5 	.word	0x004052a5

004049e4 <drv_gpio_int_dc1>:
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4049e4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049e6:	4e0b      	ldr	r6, [pc, #44]	; (404a14 <drv_gpio_int_dc1+0x30>)
  4049e8:	4b0b      	ldr	r3, [pc, #44]	; (404a18 <drv_gpio_int_dc1+0x34>)
  4049ea:	6d30      	ldr	r0, [r6, #80]	; 0x50
	pio_disable_interrupt(PIOA, PinMask);
  4049ec:	4d0b      	ldr	r5, [pc, #44]	; (404a1c <drv_gpio_int_dc1+0x38>)
 * @brief Interrupt routine for Jack-1 Detect
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
  4049ee:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049f0:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  4049f2:	4b0b      	ldr	r3, [pc, #44]	; (404a20 <drv_gpio_int_dc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
  4049f4:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  4049f6:	4601      	mov	r1, r0
  4049f8:	4628      	mov	r0, r5
  4049fa:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  4049fc:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_dc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  4049fe:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a00:	4806      	ldr	r0, [pc, #24]	; (404a1c <drv_gpio_int_dc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_DC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_DC1].gpioSetFlag = 1;
  404a02:	bf04      	itt	eq
  404a04:	2301      	moveq	r3, #1
  404a06:	f886 305e 	strbeq.w	r3, [r6, #94]	; 0x5e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a0a:	4621      	mov	r1, r4
  404a0c:	4b05      	ldr	r3, [pc, #20]	; (404a24 <drv_gpio_int_dc1+0x40>)
  404a0e:	4798      	blx	r3
  404a10:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404a12:	bf00      	nop
  404a14:	20000178 	.word	0x20000178
  404a18:	00405471 	.word	0x00405471
  404a1c:	400e0e00 	.word	0x400e0e00
  404a20:	004052ad 	.word	0x004052ad
  404a24:	004052a5 	.word	0x004052a5

00404a28 <drv_gpio_int_oc2>:
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  404a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404a2a:	4e0b      	ldr	r6, [pc, #44]	; (404a58 <drv_gpio_int_oc2+0x30>)
  404a2c:	4b0b      	ldr	r3, [pc, #44]	; (404a5c <drv_gpio_int_oc2+0x34>)
  404a2e:	6c30      	ldr	r0, [r6, #64]	; 0x40
	pio_disable_interrupt(PIOA, PinMask);
  404a30:	4d0b      	ldr	r5, [pc, #44]	; (404a60 <drv_gpio_int_oc2+0x38>)
 * @brief Interrupt routine for Jack-2 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
  404a32:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404a34:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404a36:	4b0b      	ldr	r3, [pc, #44]	; (404a64 <drv_gpio_int_oc2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
  404a38:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404a3a:	4601      	mov	r1, r0
  404a3c:	4628      	mov	r0, r5
  404a3e:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404a40:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404a42:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a44:	4806      	ldr	r0, [pc, #24]	; (404a60 <drv_gpio_int_oc2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC2].gpioSetFlag = 1;
  404a46:	bf04      	itt	eq
  404a48:	2301      	moveq	r3, #1
  404a4a:	f886 304e 	strbeq.w	r3, [r6, #78]	; 0x4e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a4e:	4621      	mov	r1, r4
  404a50:	4b05      	ldr	r3, [pc, #20]	; (404a68 <drv_gpio_int_oc2+0x40>)
  404a52:	4798      	blx	r3
  404a54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404a56:	bf00      	nop
  404a58:	20000178 	.word	0x20000178
  404a5c:	00405471 	.word	0x00405471
  404a60:	400e0e00 	.word	0x400e0e00
  404a64:	004052ad 	.word	0x004052ad
  404a68:	004052a5 	.word	0x004052a5

00404a6c <drv_gpio_int_oc1>:
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  404a6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a6e:	4e0b      	ldr	r6, [pc, #44]	; (404a9c <drv_gpio_int_oc1+0x30>)
  404a70:	4b0b      	ldr	r3, [pc, #44]	; (404aa0 <drv_gpio_int_oc1+0x34>)
  404a72:	6b30      	ldr	r0, [r6, #48]	; 0x30
	pio_disable_interrupt(PIOA, PinMask);
  404a74:	4d0b      	ldr	r5, [pc, #44]	; (404aa4 <drv_gpio_int_oc1+0x38>)
 * @brief Interrupt routine for Jack-1 Over Current
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
  404a76:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a78:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404a7a:	4b0b      	ldr	r3, [pc, #44]	; (404aa8 <drv_gpio_int_oc1+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
  404a7c:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404a7e:	4601      	mov	r1, r0
  404a80:	4628      	mov	r0, r5
  404a82:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404a84:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_oc1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404a86:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a88:	4806      	ldr	r0, [pc, #24]	; (404aa4 <drv_gpio_int_oc1+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_JC_OC1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_JC_OC1].gpioSetFlag = 1;
  404a8a:	bf04      	itt	eq
  404a8c:	2301      	moveq	r3, #1
  404a8e:	f886 303e 	strbeq.w	r3, [r6, #62]	; 0x3e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404a92:	4621      	mov	r1, r4
  404a94:	4b05      	ldr	r3, [pc, #20]	; (404aac <drv_gpio_int_oc1+0x40>)
  404a96:	4798      	blx	r3
  404a98:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404a9a:	bf00      	nop
  404a9c:	20000178 	.word	0x20000178
  404aa0:	00405471 	.word	0x00405471
  404aa4:	400e0e00 	.word	0x400e0e00
  404aa8:	004052ad 	.word	0x004052ad
  404aac:	004052a5 	.word	0x004052a5

00404ab0 <drv_gpio_int_sw2>:
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  404ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404ab2:	4e0b      	ldr	r6, [pc, #44]	; (404ae0 <drv_gpio_int_sw2+0x30>)
  404ab4:	4b0b      	ldr	r3, [pc, #44]	; (404ae4 <drv_gpio_int_sw2+0x34>)
  404ab6:	6a30      	ldr	r0, [r6, #32]
	pio_disable_interrupt(PIOA, PinMask);
  404ab8:	4d0b      	ldr	r5, [pc, #44]	; (404ae8 <drv_gpio_int_sw2+0x38>)
 * @brief Interrupt routine for Action Switch-2
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
  404aba:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404abc:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404abe:	4b0b      	ldr	r3, [pc, #44]	; (404aec <drv_gpio_int_sw2+0x3c>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
  404ac0:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404ac2:	4601      	mov	r1, r0
  404ac4:	4628      	mov	r0, r5
  404ac6:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404ac8:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw2(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404aca:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404acc:	4806      	ldr	r0, [pc, #24]	; (404ae8 <drv_gpio_int_sw2+0x38>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW2].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW2].gpioSetFlag = 1;
  404ace:	bf04      	itt	eq
  404ad0:	2301      	moveq	r3, #1
  404ad2:	f886 302e 	strbeq.w	r3, [r6, #46]	; 0x2e
	}
	pio_enable_interrupt(PIOA, PinMask);
  404ad6:	4621      	mov	r1, r4
  404ad8:	4b05      	ldr	r3, [pc, #20]	; (404af0 <drv_gpio_int_sw2+0x40>)
  404ada:	4798      	blx	r3
  404adc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404ade:	bf00      	nop
  404ae0:	20000178 	.word	0x20000178
  404ae4:	00405471 	.word	0x00405471
  404ae8:	400e0e00 	.word	0x400e0e00
  404aec:	004052ad 	.word	0x004052ad
  404af0:	004052a5 	.word	0x004052a5

00404af4 <drv_gpio_int_sw1>:
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  404af4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404af6:	4e0a      	ldr	r6, [pc, #40]	; (404b20 <drv_gpio_int_sw1+0x2c>)
  404af8:	4b0a      	ldr	r3, [pc, #40]	; (404b24 <drv_gpio_int_sw1+0x30>)
  404afa:	6930      	ldr	r0, [r6, #16]
	pio_disable_interrupt(PIOA, PinMask);
  404afc:	4d0a      	ldr	r5, [pc, #40]	; (404b28 <drv_gpio_int_sw1+0x34>)
 * @brief Interrupt routine for Action Switch-1
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
  404afe:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404b00:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404b02:	4b0a      	ldr	r3, [pc, #40]	; (404b2c <drv_gpio_int_sw1+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
  404b04:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404b06:	4601      	mov	r1, r0
  404b08:	4628      	mov	r0, r5
  404b0a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404b0c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_sw1(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404b0e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b10:	4805      	ldr	r0, [pc, #20]	; (404b28 <drv_gpio_int_sw1+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_AC_SW1].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_AC_SW1].gpioSetFlag = 1;
  404b12:	bf04      	itt	eq
  404b14:	2301      	moveq	r3, #1
  404b16:	77b3      	strbeq	r3, [r6, #30]
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b18:	4621      	mov	r1, r4
  404b1a:	4b05      	ldr	r3, [pc, #20]	; (404b30 <drv_gpio_int_sw1+0x3c>)
  404b1c:	4798      	blx	r3
  404b1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404b20:	20000178 	.word	0x20000178
  404b24:	00405471 	.word	0x00405471
  404b28:	400e0e00 	.word	0x400e0e00
  404b2c:	004052ad 	.word	0x004052ad
  404b30:	004052a5 	.word	0x004052a5

00404b34 <drv_gpio_int_pw>:
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404b34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b36:	4e0a      	ldr	r6, [pc, #40]	; (404b60 <drv_gpio_int_pw+0x2c>)
  404b38:	4b0a      	ldr	r3, [pc, #40]	; (404b64 <drv_gpio_int_pw+0x30>)
  404b3a:	6830      	ldr	r0, [r6, #0]
	pio_disable_interrupt(PIOA, PinMask);
  404b3c:	4d0a      	ldr	r5, [pc, #40]	; (404b68 <drv_gpio_int_pw+0x34>)
 * @brief Interrupt routine for Power Switch
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
  404b3e:	460f      	mov	r7, r1
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b40:	4798      	blx	r3
	pio_disable_interrupt(PIOA, PinMask);
  404b42:	4b0a      	ldr	r3, [pc, #40]	; (404b6c <drv_gpio_int_pw+0x38>)
 * @param uint32_t ul_id, uint32_t ul_mask
 * @return 
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
  404b44:	4604      	mov	r4, r0
	pio_disable_interrupt(PIOA, PinMask);
  404b46:	4601      	mov	r1, r0
  404b48:	4628      	mov	r0, r5
  404b4a:	4798      	blx	r3
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
  404b4c:	42bc      	cmp	r4, r7
 ***********************************************************************************************/
static void drv_gpio_int_pw(uint32_t ul_id, uint32_t ul_mask)
{
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
  404b4e:	6ceb      	ldr	r3, [r5, #76]	; 0x4c
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b50:	4805      	ldr	r0, [pc, #20]	; (404b68 <drv_gpio_int_pw+0x34>)
	uint32_t PinMask = pio_get_pin_group_mask(gpioConfig[DRV_GPIO_PIN_PW_SW].pinId);
	pio_disable_interrupt(PIOA, PinMask);
	uint32_t ReadIsr = PIOA->PIO_ISR;
	if (PinMask == ul_mask)
	{
		gpioConfig[DRV_GPIO_PIN_PW_SW].gpioSetFlag = 1;
  404b52:	bf04      	itt	eq
  404b54:	2301      	moveq	r3, #1
  404b56:	73b3      	strbeq	r3, [r6, #14]
	}
	pio_enable_interrupt(PIOA, PinMask);
  404b58:	4621      	mov	r1, r4
  404b5a:	4b05      	ldr	r3, [pc, #20]	; (404b70 <drv_gpio_int_pw+0x3c>)
  404b5c:	4798      	blx	r3
  404b5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404b60:	20000178 	.word	0x20000178
  404b64:	00405471 	.word	0x00405471
  404b68:	400e0e00 	.word	0x400e0e00
  404b6c:	004052ad 	.word	0x004052ad
  404b70:	004052a5 	.word	0x004052a5

00404b74 <drv_gpio_config>:
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404b74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  404b78:	7903      	ldrb	r3, [r0, #4]
  404b7a:	2b01      	cmp	r3, #1
 * @brief Set and configure all GPIOs
 * @param drv_gpio_config_t* gpioConfig
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_config(drv_gpio_config_t* gpioConfig)
{
  404b7c:	b082      	sub	sp, #8
  404b7e:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
  404b80:	d011      	beq.n	404ba6 <drv_gpio_config+0x32>
		p_pio->PIO_PPDDR |= PinMask; 
		
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
  404b82:	7942      	ldrb	r2, [r0, #5]
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404b84:	4b36      	ldr	r3, [pc, #216]	; (404c60 <drv_gpio_config+0xec>)
  404b86:	6800      	ldr	r0, [r0, #0]
	}
	else	//The pin is output
	{
		if (gpioConfig->initialPinState == DRV_GPIO_PIN_STATE_HIGH)
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_1;	//set default pin state
  404b88:	2a01      	cmp	r2, #1
  404b8a:	bf14      	ite	ne
  404b8c:	f04f 5540 	movne.w	r5, #805306368	; 0x30000000
  404b90:	f04f 5560 	moveq.w	r5, #939524096	; 0x38000000
		else
		{
			PinFlag |= PIO_TYPE_PIO_OUTPUT_0;	//set default pin state
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);
  404b94:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  404b96:	4629      	mov	r1, r5
  404b98:	6820      	ldr	r0, [r4, #0]
  404b9a:	4b32      	ldr	r3, [pc, #200]	; (404c64 <drv_gpio_config+0xf0>)
  404b9c:	4798      	blx	r3
	}
	
	return status;
}
  404b9e:	2000      	movs	r0, #0
  404ba0:	b002      	add	sp, #8
  404ba2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
		if (gpioConfig->pullUpEnabled == TRUE)
  404ba6:	7b02      	ldrb	r2, [r0, #12]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  404ba8:	4f2f      	ldr	r7, [pc, #188]	; (404c68 <drv_gpio_config+0xf4>)
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  404baa:	7b43      	ldrb	r3, [r0, #13]
{
	status_t status = STATUS_PASS;
	unsigned long PinFlag = 0;	
	if(gpioConfig->pinMode == DRV_GPIO_PIN_MODE_INPUT)	//Check if input or output
	{
		PinFlag |= PIO_TYPE_PIO_INPUT;	//Set as input
  404bac:	2a01      	cmp	r2, #1
  404bae:	bf18      	it	ne
  404bb0:	f04f 5720 	movne.w	r7, #671088640	; 0x28000000
		if (gpioConfig->pullUpEnabled == TRUE)
		{
			PinFlag |= PIO_PULLUP;	//enable the pull up
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
  404bb4:	2b01      	cmp	r3, #1
  404bb6:	d03c      	beq.n	404c32 <drv_gpio_config+0xbe>
  404bb8:	4d2c      	ldr	r5, [pc, #176]	; (404c6c <drv_gpio_config+0xf8>)
  404bba:	4e2d      	ldr	r6, [pc, #180]	; (404c70 <drv_gpio_config+0xfc>)
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
		}
		
		pmc_enable_periph_clk(gpioConfig->pinId);	
  404bbc:	4b28      	ldr	r3, [pc, #160]	; (404c60 <drv_gpio_config+0xec>)
  404bbe:	6820      	ldr	r0, [r4, #0]
  404bc0:	4798      	blx	r3
		pio_configure_pin(gpioConfig->pinId, PinFlag);
  404bc2:	4b28      	ldr	r3, [pc, #160]	; (404c64 <drv_gpio_config+0xf0>)
  404bc4:	6820      	ldr	r0, [r4, #0]
  404bc6:	4639      	mov	r1, r7
  404bc8:	4798      	blx	r3
		 
		PinFlag = 0;	//Reset the PinFlag to use it to configure interrupt
		switch(gpioConfig->interruptType)	//set interrupt configuration flag
  404bca:	79a3      	ldrb	r3, [r4, #6]
  404bcc:	2b03      	cmp	r3, #3
  404bce:	d829      	bhi.n	404c24 <drv_gpio_config+0xb0>
  404bd0:	4a28      	ldr	r2, [pc, #160]	; (404c74 <drv_gpio_config+0x100>)
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  404bd2:	6820      	ldr	r0, [r4, #0]
  404bd4:	f852 7023 	ldr.w	r7, [r2, r3, lsl #2]
  404bd8:	47a8      	blx	r5
  404bda:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404bdc:	6820      	ldr	r0, [r4, #0]
  404bde:	47b0      	blx	r6
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  404be0:	f017 0f70 	tst.w	r7, #112	; 0x70
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404be4:	4606      	mov	r6, r0
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
  404be6:	d014      	beq.n	404c12 <drv_gpio_config+0x9e>
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  404be8:	6820      	ldr	r0, [r4, #0]
  404bea:	4b23      	ldr	r3, [pc, #140]	; (404c78 <drv_gpio_config+0x104>)
  404bec:	4798      	blx	r3
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  404bee:	68a3      	ldr	r3, [r4, #8]
  404bf0:	9300      	str	r3, [sp, #0]
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
		if (PinFlag & (PIO_IT_RISE_EDGE | PIO_IT_FALL_EDGE | PIO_IT_HIGH_LEVEL | PIO_IT_LOW_LEVEL))	//if set as interrupt, enable and configure it
		{			
			uint32_t PinPio = pio_get_pin_group_id(gpioConfig->pinId);	//Pin ID
  404bf2:	4601      	mov	r1, r0
			pio_handler_set(p_pio, PinPio, PinMask, PinFlag, gpioConfig->interruptHandler);
  404bf4:	463b      	mov	r3, r7
  404bf6:	4632      	mov	r2, r6
  404bf8:	4628      	mov	r0, r5
  404bfa:	4c20      	ldr	r4, [pc, #128]	; (404c7c <drv_gpio_config+0x108>)
  404bfc:	47a0      	blx	r4
			pio_enable_interrupt(p_pio, PinMask);
  404bfe:	4b20      	ldr	r3, [pc, #128]	; (404c80 <drv_gpio_config+0x10c>)
  404c00:	4628      	mov	r0, r5
  404c02:	4631      	mov	r1, r6
  404c04:	4798      	blx	r3
			if (p_pio == PIOA)
  404c06:	4b1f      	ldr	r3, [pc, #124]	; (404c84 <drv_gpio_config+0x110>)
  404c08:	429d      	cmp	r5, r3
  404c0a:	d024      	beq.n	404c56 <drv_gpio_config+0xe2>
			{
				NVIC_EnableIRQ(PIOA_IRQn);
			}
			else if (p_pio == PIOB)
  404c0c:	4b1e      	ldr	r3, [pc, #120]	; (404c88 <drv_gpio_config+0x114>)
  404c0e:	429d      	cmp	r5, r3
  404c10:	d01c      	beq.n	404c4c <drv_gpio_config+0xd8>
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  404c12:	f8d5 3090 	ldr.w	r3, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  404c16:	2000      	movs	r0, #0
			{
				NVIC_EnableIRQ(PIOB_IRQn);
			}
		}
		//turn off any pulldown resistors
		p_pio->PIO_PPDDR |= PinMask; 
  404c18:	431e      	orrs	r6, r3
  404c1a:	f8c5 6090 	str.w	r6, [r5, #144]	; 0x90
		pmc_enable_periph_clk(gpioConfig->pinId);
		pio_configure_pin(gpioConfig->pinId, PinFlag);
	}
	
	return status;
}
  404c1e:	b002      	add	sp, #8
  404c20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
				break;
			case DRV_GPIO_INTERRUPT_NONE :
			default:
				break;
		}
		Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);	//peripheral ID
  404c24:	6820      	ldr	r0, [r4, #0]
  404c26:	47a8      	blx	r5
  404c28:	4605      	mov	r5, r0
		uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c2a:	6820      	ldr	r0, [r4, #0]
  404c2c:	47b0      	blx	r6
  404c2e:	4606      	mov	r6, r0
  404c30:	e7ef      	b.n	404c12 <drv_gpio_config+0x9e>
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  404c32:	4d0e      	ldr	r5, [pc, #56]	; (404c6c <drv_gpio_config+0xf8>)
  404c34:	6800      	ldr	r0, [r0, #0]
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c36:	4e0e      	ldr	r6, [pc, #56]	; (404c70 <drv_gpio_config+0xfc>)
		}
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
  404c38:	47a8      	blx	r5
  404c3a:	4680      	mov	r8, r0
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c3c:	6820      	ldr	r0, [r4, #0]
  404c3e:	47b0      	blx	r6
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404c40:	2205      	movs	r2, #5
		
		if (gpioConfig->debounceEnabled == TRUE)
		{
			//PinFlag |= PIO_DEBOUNCE;	//enable debounce filter
			Pio *p_pio = pio_get_pin_group(gpioConfig->pinId);
			uint32_t PinMask = pio_get_pin_group_mask(gpioConfig->pinId);	//PinMask
  404c42:	4601      	mov	r1, r0
			pio_set_debounce_filter(p_pio, PinMask, DEBOUNCE_PERIOD);
  404c44:	4b11      	ldr	r3, [pc, #68]	; (404c8c <drv_gpio_config+0x118>)
  404c46:	4640      	mov	r0, r8
  404c48:	4798      	blx	r3
  404c4a:	e7b7      	b.n	404bbc <drv_gpio_config+0x48>
    \param [in]      IRQn  External interrupt number. Value cannot be negative.
 */
__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
/*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
  NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
  404c4c:	4b10      	ldr	r3, [pc, #64]	; (404c90 <drv_gpio_config+0x11c>)
  404c4e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
  404c52:	601a      	str	r2, [r3, #0]
  404c54:	e7dd      	b.n	404c12 <drv_gpio_config+0x9e>
  404c56:	4b0e      	ldr	r3, [pc, #56]	; (404c90 <drv_gpio_config+0x11c>)
  404c58:	f44f 6200 	mov.w	r2, #2048	; 0x800
  404c5c:	601a      	str	r2, [r3, #0]
  404c5e:	e7d8      	b.n	404c12 <drv_gpio_config+0x9e>
  404c60:	00405649 	.word	0x00405649
  404c64:	00405315 	.word	0x00405315
  404c68:	28000001 	.word	0x28000001
  404c6c:	00405459 	.word	0x00405459
  404c70:	00405471 	.word	0x00405471
  404c74:	004070e8 	.word	0x004070e8
  404c78:	00405469 	.word	0x00405469
  404c7c:	004054f5 	.word	0x004054f5
  404c80:	004052a5 	.word	0x004052a5
  404c84:	400e0e00 	.word	0x400e0e00
  404c88:	400e1000 	.word	0x400e1000
  404c8c:	004051a1 	.word	0x004051a1
  404c90:	e000e100 	.word	0xe000e100

00404c94 <drv_gpio_initializeAll>:
 * @brief initialize all GPIO
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
  404c94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
  404c96:	4b0b      	ldr	r3, [pc, #44]	; (404cc4 <drv_gpio_initializeAll+0x30>)
  404c98:	4c0b      	ldr	r4, [pc, #44]	; (404cc8 <drv_gpio_initializeAll+0x34>)
  404c9a:	f8d3 2114 	ldr.w	r2, [r3, #276]	; 0x114
  404c9e:	4f0b      	ldr	r7, [pc, #44]	; (404ccc <drv_gpio_initializeAll+0x38>)
  404ca0:	f442 6240 	orr.w	r2, r2, #3072	; 0xc00
  404ca4:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
  404ca8:	f504 7698 	add.w	r6, r4, #304	; 0x130
 * @param 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_gpio_initializeAll(void)
{
	status_t status = STATUS_PASS; 
  404cac:	2500      	movs	r5, #0
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
	{
		if(drv_gpio_config(&gpioConfig[i]) != STATUS_PASS)
  404cae:	4620      	mov	r0, r4
  404cb0:	47b8      	blx	r7
  404cb2:	3410      	adds	r4, #16
		{
			//printf("failed to initialize GPIO at index %d", i);
			status |= STATUS_FAIL;
  404cb4:	2800      	cmp	r0, #0
  404cb6:	bf18      	it	ne
  404cb8:	2501      	movne	r5, #1
	status_t status = STATUS_PASS; 
	int numGpio = sizeof(gpioConfig)/sizeof(drv_gpio_config_t); 
	int i = 0; 
	//Change the PB10 and PB11 to be configured as GPIO and not USB DDM and DDP 
	MATRIX->CCFG_SYSIO |= CCFG_SYSIO_SYSIO10 | CCFG_SYSIO_SYSIO11;	
	for(i = 0; i < numGpio ; i++)
  404cba:	42b4      	cmp	r4, r6
  404cbc:	d1f7      	bne.n	404cae <drv_gpio_initializeAll+0x1a>
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST2]);
	//drv_gpio_config(&gpioConfig[DRV_GPIO_PIN_BLE_RST3]);
	
	
	return status; 
}
  404cbe:	4628      	mov	r0, r5
  404cc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  404cc2:	bf00      	nop
  404cc4:	400e0200 	.word	0x400e0200
  404cc8:	20000178 	.word	0x20000178
  404ccc:	00404b75 	.word	0x00404b75

00404cd0 <drv_gpio_setPinState>:
 * @brief Set a GPIO to HIGH or LOW
 * @param drv_gpio_pins_t pin, drv_gpio_pin_state_t state
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_setPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t state)
{
  404cd0:	b538      	push	{r3, r4, r5, lr}
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
  404cd2:	4c18      	ldr	r4, [pc, #96]	; (404d34 <drv_gpio_setPinState+0x64>)
  404cd4:	0105      	lsls	r5, r0, #4
  404cd6:	1963      	adds	r3, r4, r5
  404cd8:	791a      	ldrb	r2, [r3, #4]
  404cda:	b972      	cbnz	r2, 404cfa <drv_gpio_setPinState+0x2a>
	{
		return STATUS_FAIL;
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
  404cdc:	7bdb      	ldrb	r3, [r3, #15]
  404cde:	3b02      	subs	r3, #2
  404ce0:	2b01      	cmp	r3, #1
  404ce2:	d90c      	bls.n	404cfe <drv_gpio_setPinState+0x2e>
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
		}
	}
	//the output should be in the right state. 
	
	switch(state)
  404ce4:	2901      	cmp	r1, #1
  404ce6:	d01f      	beq.n	404d28 <drv_gpio_setPinState+0x58>
  404ce8:	d312      	bcc.n	404d10 <drv_gpio_setPinState+0x40>
  404cea:	2902      	cmp	r1, #2
  404cec:	d115      	bne.n	404d1a <drv_gpio_setPinState+0x4a>
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  404cee:	6820      	ldr	r0, [r4, #0]
  404cf0:	4911      	ldr	r1, [pc, #68]	; (404d38 <drv_gpio_setPinState+0x68>)
  404cf2:	4b12      	ldr	r3, [pc, #72]	; (404d3c <drv_gpio_setPinState+0x6c>)
  404cf4:	4798      	blx	r3
	}
	
	


	return status;
  404cf6:	2000      	movs	r0, #0
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_PULLED_HIGH:
			pinFlag |= PIO_TYPE_PIO_INPUT | PIO_PULLUP;	//Set as input with pull up. 
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		break;
  404cf8:	bd38      	pop	{r3, r4, r5, pc}
{
	status_t status = STATUS_PASS;
	uint32_t pinFlag = 0x00; 
	if(gpioConfig[pin].pinMode != DRV_GPIO_PIN_MODE_OUTPUT)
	{
		return STATUS_FAIL;
  404cfa:	2001      	movs	r0, #1
  404cfc:	bd38      	pop	{r3, r4, r5, pc}
	}
	if(gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_HIGH || gpioConfig[pin].currentPinState == DRV_GPIO_PIN_STATE_PULLED_LOW)
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
  404cfe:	2901      	cmp	r1, #1
  404d00:	d00d      	beq.n	404d1e <drv_gpio_setPinState+0x4e>
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
		}
		else if(state == DRV_GPIO_PIN_STATE_LOW)
  404d02:	2900      	cmp	r1, #0
  404d04:	d1ee      	bne.n	404ce4 <drv_gpio_setPinState+0x14>
		{
			pinFlag |= PIO_TYPE_PIO_OUTPUT_0;
			pio_configure_pin(gpioConfig->pinId, pinFlag);			
  404d06:	6820      	ldr	r0, [r4, #0]
  404d08:	4b0c      	ldr	r3, [pc, #48]	; (404d3c <drv_gpio_setPinState+0x6c>)
  404d0a:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
  404d0e:	4798      	blx	r3
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
  404d10:	5960      	ldr	r0, [r4, r5]
  404d12:	4b0b      	ldr	r3, [pc, #44]	; (404d40 <drv_gpio_setPinState+0x70>)
  404d14:	4798      	blx	r3
	}
	
	


	return status;
  404d16:	2000      	movs	r0, #0
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
		case DRV_GPIO_PIN_STATE_LOW:
			pio_set_pin_low(gpioConfig[pin].pinId);
		break;
  404d18:	bd38      	pop	{r3, r4, r5, pc}
	}
	
	


	return status;
  404d1a:	2000      	movs	r0, #0
}
  404d1c:	bd38      	pop	{r3, r4, r5, pc}
	{
		if(state == DRV_GPIO_PIN_STATE_HIGH )
		{
			//we have to set the pin back to an output
			pinFlag |= PIO_TYPE_PIO_OUTPUT_1;
			pio_configure_pin(gpioConfig->pinId, pinFlag);
  404d1e:	6820      	ldr	r0, [r4, #0]
  404d20:	4b06      	ldr	r3, [pc, #24]	; (404d3c <drv_gpio_setPinState+0x6c>)
  404d22:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
  404d26:	4798      	blx	r3
	//the output should be in the right state. 
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
  404d28:	5960      	ldr	r0, [r4, r5]
  404d2a:	4b06      	ldr	r3, [pc, #24]	; (404d44 <drv_gpio_setPinState+0x74>)
  404d2c:	4798      	blx	r3
	}
	
	


	return status;
  404d2e:	2000      	movs	r0, #0
	
	switch(state)
	{
		case DRV_GPIO_PIN_STATE_HIGH:
			pio_set_pin_high(gpioConfig[pin].pinId);
		break;
  404d30:	bd38      	pop	{r3, r4, r5, pc}
  404d32:	bf00      	nop
  404d34:	20000178 	.word	0x20000178
  404d38:	28000001 	.word	0x28000001
  404d3c:	00405315 	.word	0x00405315
  404d40:	004052d5 	.word	0x004052d5
  404d44:	004052b9 	.word	0x004052b9

00404d48 <drv_gpio_getPinState>:
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_getPinState(drv_gpio_pins_t pin, drv_gpio_pin_state_t* state)
{
	status_t status = STATUS_PASS;
	bool value = ioport_get_pin_level(gpioConfig[pin].pinId);
  404d48:	4b0a      	ldr	r3, [pc, #40]	; (404d74 <drv_gpio_getPinState+0x2c>)
  404d4a:	0100      	lsls	r0, r0, #4
  404d4c:	5818      	ldr	r0, [r3, r0]
typedef uint32_t ioport_port_t;
typedef uint32_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 5;
  404d4e:	0943      	lsrs	r3, r0, #5
	} else {
		return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
		       (IOPORT_PIO_OFFSET * port));
	}
#else
	return (Pio *)((uintptr_t)IOPORT_BASE_ADDRESS +
  404d50:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  404d54:	f203 7307 	addw	r3, r3, #1799	; 0x707
  404d58:	025b      	lsls	r3, r3, #9
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404d5a:	f000 001f 	and.w	r0, r0, #31
	base->PIO_CODR = mask & ~level;
}

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	return arch_ioport_pin_to_base(pin)->PIO_PDSR & arch_ioport_pin_to_mask(pin);
  404d5e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
	return arch_ioport_port_to_base(arch_ioport_pin_to_port_id(pin));
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(ioport_pin_t pin)
{
	return 1U << (pin & 0x1F);
  404d60:	2301      	movs	r3, #1
  404d62:	fa03 f000 	lsl.w	r0, r3, r0
	if (value == false)
  404d66:	4002      	ands	r2, r0
	{
		*state = DRV_GPIO_PIN_STATE_LOW;
  404d68:	bf08      	it	eq
  404d6a:	4613      	moveq	r3, r2
  404d6c:	700b      	strb	r3, [r1, #0]
	else
	{
		*state = DRV_GPIO_PIN_STATE_HIGH;
	}
	return status;
}
  404d6e:	2000      	movs	r0, #0
  404d70:	4770      	bx	lr
  404d72:	bf00      	nop
  404d74:	20000178 	.word	0x20000178

00404d78 <drv_gpio_togglePin>:
 * @brief Toggle a GPIO level
 * @param drv_gpio_pins_t pin
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/
status_t drv_gpio_togglePin(drv_gpio_pins_t pin)
{
  404d78:	b508      	push	{r3, lr}
	status_t status = STATUS_PASS;
	pio_toggle_pin(gpioConfig[pin].pinId);
  404d7a:	4a03      	ldr	r2, [pc, #12]	; (404d88 <drv_gpio_togglePin+0x10>)
  404d7c:	4b03      	ldr	r3, [pc, #12]	; (404d8c <drv_gpio_togglePin+0x14>)
  404d7e:	0100      	lsls	r0, r0, #4
  404d80:	5810      	ldr	r0, [r2, r0]
  404d82:	4798      	blx	r3
	return status;
}
  404d84:	2000      	movs	r0, #0
  404d86:	bd08      	pop	{r3, pc}
  404d88:	20000178 	.word	0x20000178
  404d8c:	004052f1 	.word	0x004052f1

00404d90 <uart_process_byte>:
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d90:	b510      	push	{r4, lr}
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404d92:	f8b1 3204 	ldrh.w	r3, [r1, #516]	; 0x204
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d96:	b082      	sub	sp, #8
	uint32_t val = 0;
  404d98:	2200      	movs	r2, #0
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404d9a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}		
	return status;
}

static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404d9e:	460c      	mov	r4, r1
	uint32_t val = 0;
  404da0:	9201      	str	r2, [sp, #4]
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404da2:	d028      	beq.n	404df6 <uart_process_byte+0x66>
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404da4:	d30c      	bcc.n	404dc0 <uart_process_byte+0x30>
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
	}
	if(memBuf->rx_fifo.i_last == FIFO_BUFFER_SIZE)
  404da6:	f8b4 3202 	ldrh.w	r3, [r4, #514]	; 0x202
  404daa:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->rx_fifo.i_last = 0;                            // roll over the index counter
  404dae:	bf04      	itt	eq
  404db0:	2300      	moveq	r3, #0
  404db2:	f8a4 3202 	strheq.w	r3, [r4, #514]	; 0x202
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
  404db6:	2301      	movs	r3, #1
  404db8:	f884 3207 	strb.w	r3, [r4, #519]	; 0x207
}
  404dbc:	b002      	add	sp, #8
  404dbe:	bd10      	pop	{r4, pc}
		usart_getchar(p_usart,&val);		
	}
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
  404dc0:	a901      	add	r1, sp, #4
  404dc2:	4b14      	ldr	r3, [pc, #80]	; (404e14 <uart_process_byte+0x84>)
  404dc4:	4798      	blx	r3
  404dc6:	b140      	cbz	r0, 404dda <uart_process_byte+0x4a>
  404dc8:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
		//if(p_usart == UART1)
		//{
			//usart_putchar(UART0, val);
		//}
	}
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404dcc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	{      // if sw buffer just filled up
		memBuf->uart_rx_fifo_full_flag = 1;                    // set the RX FIFO full flag
  404dd0:	bf04      	itt	eq
  404dd2:	2301      	moveq	r3, #1
  404dd4:	f884 3208 	strbeq.w	r3, [r4, #520]	; 0x208
  404dd8:	e7e5      	b.n	404da6 <uart_process_byte+0x16>
	else if(memBuf->rx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
  404dda:	f8b4 2202 	ldrh.w	r2, [r4, #514]	; 0x202
  404dde:	9b01      	ldr	r3, [sp, #4]
  404de0:	54a3      	strb	r3, [r4, r2]
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404de2:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404de6:	3301      	adds	r3, #1
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404de8:	3201      	adds	r2, #1
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404dea:	b29b      	uxth	r3, r3
	{		
		//while((UART0->UART_SR & UART_SR_RXRDY) == 0);
		if(usart_getchar(p_usart,&val) == STATUS_PASS)
		{		
			memBuf->rx_fifo.data_buf[memBuf->rx_fifo.i_last] = (uint8_t)val;
			memBuf->rx_fifo.i_last++;                              // increment the index of the most recently added element
  404dec:	f8a4 2202 	strh.w	r2, [r4, #514]	; 0x202
			memBuf->rx_fifo.num_bytes++;                           // increment the bytes counter
  404df0:	f8a4 3204 	strh.w	r3, [r4, #516]	; 0x204
  404df4:	e7ea      	b.n	404dcc <uart_process_byte+0x3c>
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404df6:	f8d1 320c 	ldr.w	r3, [r1, #524]	; 0x20c
		usart_getchar(p_usart,&val);		
  404dfa:	4a06      	ldr	r2, [pc, #24]	; (404e14 <uart_process_byte+0x84>)
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404dfc:	3301      	adds	r3, #1
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404dfe:	2101      	movs	r1, #1
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
  404e00:	f8c4 320c 	str.w	r3, [r4, #524]	; 0x20c
static void uart_process_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	uint32_t val = 0;
	if(memBuf->rx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_rx_fifo_ovf_flag = 1;                     // set the overflow flag
  404e04:	f884 1209 	strb.w	r1, [r4, #521]	; 0x209
		//the buffer is full, but we have to clear the interrupt
		memBuf->uart_rx_fifo_dropped_bytes++; //our data stream will be out of sync now...
		usart_getchar(p_usart,&val);		
  404e08:	a901      	add	r1, sp, #4
  404e0a:	4790      	blx	r2
  404e0c:	f8b4 3204 	ldrh.w	r3, [r4, #516]	; 0x204
  404e10:	e7dc      	b.n	404dcc <uart_process_byte+0x3c>
  404e12:	bf00      	nop
  404e14:	004023b5 	.word	0x004023b5

00404e18 <uart_process_tx_byte>:
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404e18:	b570      	push	{r4, r5, r6, lr}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404e1a:	f8b1 3414 	ldrh.w	r3, [r1, #1044]	; 0x414
  404e1e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
	}
	memBuf->uart_rx_fifo_not_empty_flag = 1;                 // set received-data flag	
}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
  404e22:	460c      	mov	r4, r1
  404e24:	4602      	mov	r2, r0
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404e26:	d00f      	beq.n	404e48 <uart_process_tx_byte+0x30>
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
	}
	if(memBuf->tx_fifo.num_bytes > 0)
  404e28:	b98b      	cbnz	r3, 404e4e <uart_process_tx_byte+0x36>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
	}
	else
	{   // tx sw buffer is empty
		memBuf->uart_tx_fifo_not_empty_flag = 0;          // clear the tx flag
  404e2a:	f881 3416 	strb.w	r3, [r1, #1046]	; 0x416
		uart_disable_interrupt(p_usart,UART_IER_TXEMPTY); //the buffer is empty, stop the interrupt. 
  404e2e:	f44f 7100 	mov.w	r1, #512	; 0x200
  404e32:	4b23      	ldr	r3, [pc, #140]	; (404ec0 <uart_process_tx_byte+0xa8>)
  404e34:	4798      	blx	r3
  404e36:	f8b4 2410 	ldrh.w	r2, [r4, #1040]	; 0x410
	}
	if(memBuf->tx_fifo.i_first == FIFO_BUFFER_SIZE)
  404e3a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{   // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_first = 0;                      // roll over the index counter
  404e3e:	bf04      	itt	eq
  404e40:	2300      	moveq	r3, #0
  404e42:	f8a4 3410 	strheq.w	r3, [r4, #1040]	; 0x410
  404e46:	bd70      	pop	{r4, r5, r6, pc}

static void uart_process_tx_byte(Usart *p_usart, drv_uart_memory_buf_t* memBuf)
{
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{ // if the sw buffer is full
		memBuf->uart_tx_fifo_full_flag = 0;               // clear the buffer full flag because we are about to make room
  404e48:	2100      	movs	r1, #0
  404e4a:	f884 1417 	strb.w	r1, [r4, #1047]	; 0x417
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
  404e4e:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
  404e52:	481c      	ldr	r0, [pc, #112]	; (404ec4 <uart_process_tx_byte+0xac>)
  404e54:	1865      	adds	r5, r4, r1
  404e56:	4282      	cmp	r2, r0
  404e58:	f895 5210 	ldrb.w	r5, [r5, #528]	; 0x210
  404e5c:	d010      	beq.n	404e80 <uart_process_tx_byte+0x68>
		while (uart_write((Uart*)p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
  404e5e:	481a      	ldr	r0, [pc, #104]	; (404ec8 <uart_process_tx_byte+0xb0>)
  404e60:	4282      	cmp	r2, r0
  404e62:	d01f      	beq.n	404ea4 <uart_process_tx_byte+0x8c>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
  404e64:	4819      	ldr	r0, [pc, #100]	; (404ecc <uart_process_tx_byte+0xb4>)
  404e66:	4282      	cmp	r2, r0
  404e68:	d023      	beq.n	404eb2 <uart_process_tx_byte+0x9a>
		while (usart_write(p_usart, c)!=0);
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
  404e6a:	4819      	ldr	r0, [pc, #100]	; (404ed0 <uart_process_tx_byte+0xb8>)
  404e6c:	4282      	cmp	r2, r0
  404e6e:	d012      	beq.n	404e96 <uart_process_tx_byte+0x7e>
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404e70:	1c4a      	adds	r2, r1, #1
  404e72:	b292      	uxth	r2, r2
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404e74:	3b01      	subs	r3, #1
	}
	if(memBuf->tx_fifo.num_bytes > 0)
	{
		// if data exists in the sw buffer
		usart_serial_putchar(p_usart,memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_first]); // send the next value from buffer
		memBuf->tx_fifo.i_first++;                        // increment the index of the oldest element
  404e76:	f8a4 2410 	strh.w	r2, [r4, #1040]	; 0x410
		memBuf->tx_fifo.num_bytes--;                      // decrement the bytes counter
  404e7a:	f8a4 3414 	strh.w	r3, [r4, #1044]	; 0x414
  404e7e:	e7dc      	b.n	404e3a <uart_process_tx_byte+0x22>
  404e80:	4e14      	ldr	r6, [pc, #80]	; (404ed4 <uart_process_tx_byte+0xbc>)
		return 1;
	}
#else
# ifdef UART0
	if (UART0 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404e82:	4810      	ldr	r0, [pc, #64]	; (404ec4 <uart_process_tx_byte+0xac>)
  404e84:	4629      	mov	r1, r5
  404e86:	47b0      	blx	r6
  404e88:	2800      	cmp	r0, #0
  404e8a:	d1fa      	bne.n	404e82 <uart_process_tx_byte+0x6a>
  404e8c:	f8b4 1410 	ldrh.w	r1, [r4, #1040]	; 0x410
  404e90:	f8b4 3414 	ldrh.w	r3, [r4, #1044]	; 0x414
  404e94:	e7ec      	b.n	404e70 <uart_process_tx_byte+0x58>
  404e96:	4e10      	ldr	r6, [pc, #64]	; (404ed8 <uart_process_tx_byte+0xc0>)
		return 1;
	}
# endif
# ifdef USART1
	if (USART1 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404e98:	480d      	ldr	r0, [pc, #52]	; (404ed0 <uart_process_tx_byte+0xb8>)
  404e9a:	4629      	mov	r1, r5
  404e9c:	47b0      	blx	r6
  404e9e:	2800      	cmp	r0, #0
  404ea0:	d1fa      	bne.n	404e98 <uart_process_tx_byte+0x80>
  404ea2:	e7f3      	b.n	404e8c <uart_process_tx_byte+0x74>
  404ea4:	4e0b      	ldr	r6, [pc, #44]	; (404ed4 <uart_process_tx_byte+0xbc>)
		return 1;
	}
# endif
# ifdef UART1
	if (UART1 == (Uart*)p_usart) {
		while (uart_write((Uart*)p_usart, c)!=0);
  404ea6:	4808      	ldr	r0, [pc, #32]	; (404ec8 <uart_process_tx_byte+0xb0>)
  404ea8:	4629      	mov	r1, r5
  404eaa:	47b0      	blx	r6
  404eac:	2800      	cmp	r0, #0
  404eae:	d1fa      	bne.n	404ea6 <uart_process_tx_byte+0x8e>
  404eb0:	e7ec      	b.n	404e8c <uart_process_tx_byte+0x74>
  404eb2:	4e09      	ldr	r6, [pc, #36]	; (404ed8 <uart_process_tx_byte+0xc0>)
		return 1;
	}
#else
# ifdef USART0
	if (USART0 == p_usart) {
		while (usart_write(p_usart, c)!=0);
  404eb4:	4805      	ldr	r0, [pc, #20]	; (404ecc <uart_process_tx_byte+0xb4>)
  404eb6:	4629      	mov	r1, r5
  404eb8:	47b0      	blx	r6
  404eba:	2800      	cmp	r0, #0
  404ebc:	d1fa      	bne.n	404eb4 <uart_process_tx_byte+0x9c>
  404ebe:	e7e5      	b.n	404e8c <uart_process_tx_byte+0x74>
  404ec0:	00402381 	.word	0x00402381
  404ec4:	400e0600 	.word	0x400e0600
  404ec8:	400e0800 	.word	0x400e0800
  404ecc:	40024000 	.word	0x40024000
  404ed0:	40028000 	.word	0x40028000
  404ed4:	00402389 	.word	0x00402389
  404ed8:	004023a1 	.word	0x004023a1

00404edc <drv_uart_putChar>:
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404edc:	b538      	push	{r3, r4, r5, lr}
  404ede:	4604      	mov	r4, r0
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404ee0:	4b1f      	ldr	r3, [pc, #124]	; (404f60 <drv_uart_putChar+0x84>)
  404ee2:	6800      	ldr	r0, [r0, #0]
 * the character
 * @param c, the character that will be sent through the uart. 
 * @return STATUS_PASS if successful, STATUS_FAIL if there is an error
 ***********************************************************************************************/	
status_t drv_uart_putChar(drv_uart_config_t* uartConfig, char c)
{
  404ee4:	460d      	mov	r5, r1
	status_t status = STATUS_PASS;
	//disable the interrupts so we don't fuck up the pointers	
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
  404ee6:	f44f 7100 	mov.w	r1, #512	; 0x200
  404eea:	4798      	blx	r3
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
  404eec:	6962      	ldr	r2, [r4, #20]
  404eee:	481d      	ldr	r0, [pc, #116]	; (404f64 <drv_uart_putChar+0x88>)
  404ef0:	eb02 1242 	add.w	r2, r2, r2, lsl #5
  404ef4:	eb00 1342 	add.w	r3, r0, r2, lsl #5
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
  404ef8:	f8b3 2414 	ldrh.w	r2, [r3, #1044]	; 0x414
  404efc:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
  404f00:	d021      	beq.n	404f46 <drv_uart_putChar+0x6a>
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
  404f02:	d20e      	bcs.n	404f22 <drv_uart_putChar+0x46>
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404f04:	f8b3 1412 	ldrh.w	r1, [r3, #1042]	; 0x412
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404f08:	3201      	adds	r2, #1
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404f0a:	1858      	adds	r0, r3, r1
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404f0c:	b292      	uxth	r2, r2
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404f0e:	3101      	adds	r1, #1
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404f10:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
  404f14:	f880 5210 	strb.w	r5, [r0, #528]	; 0x210
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
		memBuf->tx_fifo.num_bytes++;                           // increment the bytes counter
  404f18:	f8a3 2414 	strh.w	r2, [r3, #1044]	; 0x414
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
	}
	else if(memBuf->tx_fifo.num_bytes < FIFO_BUFFER_SIZE)  // if there's room in the sw buffer
	{
		memBuf->tx_fifo.data_buf[memBuf->tx_fifo.i_last] = c;
		memBuf->tx_fifo.i_last++;                              // increment the index of the most recently added element
  404f1c:	f8a3 1412 	strh.w	r1, [r3, #1042]	; 0x412
		//if(uartConfig->p_usart == UART1)
		//{
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
  404f20:	d019      	beq.n	404f56 <drv_uart_putChar+0x7a>
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
	}
	if(memBuf->tx_fifo.i_last == FIFO_BUFFER_SIZE)
  404f22:	f8b3 2412 	ldrh.w	r2, [r3, #1042]	; 0x412
  404f26:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
	{         // if the index has reached the end of the buffer,
		memBuf->tx_fifo.i_last = 0;                            // roll over the index counter
  404f2a:	bf04      	itt	eq
  404f2c:	2200      	moveq	r2, #0
  404f2e:	f8a3 2412 	strheq.w	r2, [r3, #1042]	; 0x412
	}
	memBuf->uart_tx_fifo_not_empty_flag = 1;                 // set tx-data ready flag	
  404f32:	2201      	movs	r2, #1
  404f34:	f883 2416 	strb.w	r2, [r3, #1046]	; 0x416
	//re-enable the interrupts
	usart_enable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);		
  404f38:	6820      	ldr	r0, [r4, #0]
  404f3a:	4b0b      	ldr	r3, [pc, #44]	; (404f68 <drv_uart_putChar+0x8c>)
  404f3c:	f44f 7100 	mov.w	r1, #512	; 0x200
  404f40:	4798      	blx	r3
	return status;	
}
  404f42:	2000      	movs	r0, #0
  404f44:	bd38      	pop	{r3, r4, r5, pc}
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404f46:	f8d3 241c 	ldr.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404f4a:	2101      	movs	r1, #1
		memBuf->uart_tx_fifo_dropped_bytes++; //our data stream will be out of sync now...	
  404f4c:	440a      	add	r2, r1
  404f4e:	f8c3 241c 	str.w	r2, [r3, #1052]	; 0x41c
	usart_disable_interrupt(uartConfig->p_usart, UART_IER_TXEMPTY);	
	uint32_t val = 0;
	drv_uart_memory_buf_t* memBuf = &uartMemBuf[uartConfig->mem_index]; 
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE) // if the sw buffer is full
	{
		memBuf->uart_tx_fifo_ovf_flag = 1;                     // set the overflow flag
  404f52:	f883 1418 	strb.w	r1, [r3, #1048]	; 0x418
			//usart_putchar(UART0, c);
		//}
	}
	if(memBuf->tx_fifo.num_bytes == FIFO_BUFFER_SIZE)
	{      // if sw buffer just filled up
		memBuf->uart_tx_fifo_full_flag = 1;                    // set the tx FIFO full flag
  404f56:	2201      	movs	r2, #1
  404f58:	f883 2417 	strb.w	r2, [r3, #1047]	; 0x417
  404f5c:	e7e1      	b.n	404f22 <drv_uart_putChar+0x46>
  404f5e:	bf00      	nop
  404f60:	0040239d 	.word	0x0040239d
  404f64:	200013c0 	.word	0x200013c0
  404f68:	00402399 	.word	0x00402399

00404f6c <drv_uart_putData>:
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404f6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	int i=0;
	for (i=0;i<length;)
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f70:	4f09      	ldr	r7, [pc, #36]	; (404f98 <drv_uart_putData+0x2c>)
		}		
	}
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
  404f72:	4606      	mov	r6, r0
  404f74:	4688      	mov	r8, r1
  404f76:	4615      	mov	r5, r2
	int i=0;
	for (i=0;i<length;)
  404f78:	2400      	movs	r4, #0
  404f7a:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f7c:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f7e:	d208      	bcs.n	404f92 <drv_uart_putData+0x26>
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f80:	f818 1004 	ldrb.w	r1, [r8, r4]
  404f84:	47b8      	blx	r7
  404f86:	2800      	cmp	r0, #0
  404f88:	d1f7      	bne.n	404f7a <drv_uart_putData+0xe>
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
  404f8a:	3401      	adds	r4, #1
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f8c:	42ac      	cmp	r4, r5
	{
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
  404f8e:	4630      	mov	r0, r6
}

void drv_uart_putData(drv_uart_config_t* uartConfig, char* str, size_t length)
{
	int i=0;
	for (i=0;i<length;)
  404f90:	d3f6      	bcc.n	404f80 <drv_uart_putData+0x14>
		if(drv_uart_putChar(uartConfig, str[i]) == STATUS_PASS)
		{
			i++; //increment only if PASS is returned (it means the data has been sent)
		}
	}
}
  404f92:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  404f96:	bf00      	nop
  404f98:	00404edd 	.word	0x00404edd

00404f9c <UART0_Handler>:
	}
}

// interrupt handlers
void UART0_Handler()
{	
  404f9c:	b510      	push	{r4, lr}
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404f9e:	480c      	ldr	r0, [pc, #48]	; (404fd0 <UART0_Handler+0x34>)
  404fa0:	4b0c      	ldr	r3, [pc, #48]	; (404fd4 <UART0_Handler+0x38>)
  404fa2:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404fa4:	07c2      	lsls	r2, r0, #31
{	
	//if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized. 
	//{
		//uart_process_byte(UART0, &(uartMemBuf[0]));	
	//}
	uint32_t status = uart_get_status(UART0); 
  404fa6:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404fa8:	d503      	bpl.n	404fb2 <UART0_Handler+0x16>
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404faa:	490b      	ldr	r1, [pc, #44]	; (404fd8 <UART0_Handler+0x3c>)
  404fac:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404fb0:	b953      	cbnz	r3, 404fc8 <UART0_Handler+0x2c>
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404fb2:	05a3      	lsls	r3, r4, #22
  404fb4:	d503      	bpl.n	404fbe <UART0_Handler+0x22>
	{
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
  404fb6:	4908      	ldr	r1, [pc, #32]	; (404fd8 <UART0_Handler+0x3c>)
  404fb8:	f891 3206 	ldrb.w	r3, [r1, #518]	; 0x206
  404fbc:	b903      	cbnz	r3, 404fc0 <UART0_Handler+0x24>
  404fbe:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART0, &(uartMemBuf[0])); 	
  404fc0:	4803      	ldr	r0, [pc, #12]	; (404fd0 <UART0_Handler+0x34>)
  404fc2:	4b06      	ldr	r3, [pc, #24]	; (404fdc <UART0_Handler+0x40>)
  404fc4:	4798      	blx	r3
  404fc6:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[0].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART0, &(uartMemBuf[0]));
  404fc8:	4801      	ldr	r0, [pc, #4]	; (404fd0 <UART0_Handler+0x34>)
  404fca:	4b05      	ldr	r3, [pc, #20]	; (404fe0 <UART0_Handler+0x44>)
  404fcc:	4798      	blx	r3
  404fce:	e7f0      	b.n	404fb2 <UART0_Handler+0x16>
  404fd0:	400e0600 	.word	0x400e0600
  404fd4:	00402385 	.word	0x00402385
  404fd8:	200013c0 	.word	0x200013c0
  404fdc:	00404e19 	.word	0x00404e19
  404fe0:	00404d91 	.word	0x00404d91

00404fe4 <UART1_Handler>:
		}
	}	
}

void UART1_Handler()
{
  404fe4:	b510      	push	{r4, lr}
	uint32_t status = uart_get_status(UART1); 
  404fe6:	480e      	ldr	r0, [pc, #56]	; (405020 <UART1_Handler+0x3c>)
  404fe8:	4b0e      	ldr	r3, [pc, #56]	; (405024 <UART1_Handler+0x40>)
  404fea:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  404fec:	07c2      	lsls	r2, r0, #31
	}	
}

void UART1_Handler()
{
	uint32_t status = uart_get_status(UART1); 
  404fee:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  404ff0:	d503      	bpl.n	404ffa <UART1_Handler+0x16>
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404ff2:	490d      	ldr	r1, [pc, #52]	; (405028 <UART1_Handler+0x44>)
  404ff4:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  404ff8:	b963      	cbnz	r3, 405014 <UART1_Handler+0x30>
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  404ffa:	05a3      	lsls	r3, r4, #22
  404ffc:	d503      	bpl.n	405006 <UART1_Handler+0x22>
	{
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
  404ffe:	490a      	ldr	r1, [pc, #40]	; (405028 <UART1_Handler+0x44>)
  405000:	f891 3626 	ldrb.w	r3, [r1, #1574]	; 0x626
  405004:	b903      	cbnz	r3, 405008 <UART1_Handler+0x24>
  405006:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(UART1, &(uartMemBuf[1])); 	
  405008:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  40500c:	4804      	ldr	r0, [pc, #16]	; (405020 <UART1_Handler+0x3c>)
  40500e:	4b07      	ldr	r3, [pc, #28]	; (40502c <UART1_Handler+0x48>)
  405010:	4798      	blx	r3
  405012:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(UART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[1].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(UART1, &(uartMemBuf[1]));
  405014:	f501 6184 	add.w	r1, r1, #1056	; 0x420
  405018:	4801      	ldr	r0, [pc, #4]	; (405020 <UART1_Handler+0x3c>)
  40501a:	4b05      	ldr	r3, [pc, #20]	; (405030 <UART1_Handler+0x4c>)
  40501c:	4798      	blx	r3
  40501e:	e7ec      	b.n	404ffa <UART1_Handler+0x16>
  405020:	400e0800 	.word	0x400e0800
  405024:	00402385 	.word	0x00402385
  405028:	200013c0 	.word	0x200013c0
  40502c:	00404e19 	.word	0x00404e19
  405030:	00404d91 	.word	0x00404d91

00405034 <USART0_Handler>:
		}
	}
}

void USART0_Handler()
{
  405034:	b510      	push	{r4, lr}
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  405036:	480e      	ldr	r0, [pc, #56]	; (405070 <USART0_Handler+0x3c>)
  405038:	4b0e      	ldr	r3, [pc, #56]	; (405074 <USART0_Handler+0x40>)
  40503a:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  40503c:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART0, &(uartMemBuf[2]));
	//}
	uint32_t status = uart_get_status(USART0); 
  40503e:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  405040:	d503      	bpl.n	40504a <USART0_Handler+0x16>
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  405042:	490d      	ldr	r1, [pc, #52]	; (405078 <USART0_Handler+0x44>)
  405044:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  405048:	b963      	cbnz	r3, 405064 <USART0_Handler+0x30>
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  40504a:	05a3      	lsls	r3, r4, #22
  40504c:	d503      	bpl.n	405056 <USART0_Handler+0x22>
	{
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
  40504e:	490a      	ldr	r1, [pc, #40]	; (405078 <USART0_Handler+0x44>)
  405050:	f891 3a46 	ldrb.w	r3, [r1, #2630]	; 0xa46
  405054:	b903      	cbnz	r3, 405058 <USART0_Handler+0x24>
  405056:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART0, &(uartMemBuf[2])); 	
  405058:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  40505c:	4804      	ldr	r0, [pc, #16]	; (405070 <USART0_Handler+0x3c>)
  40505e:	4b07      	ldr	r3, [pc, #28]	; (40507c <USART0_Handler+0x48>)
  405060:	4798      	blx	r3
  405062:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART0); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[2].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART0, &(uartMemBuf[2]));
  405064:	f501 6104 	add.w	r1, r1, #2112	; 0x840
  405068:	4801      	ldr	r0, [pc, #4]	; (405070 <USART0_Handler+0x3c>)
  40506a:	4b05      	ldr	r3, [pc, #20]	; (405080 <USART0_Handler+0x4c>)
  40506c:	4798      	blx	r3
  40506e:	e7ec      	b.n	40504a <USART0_Handler+0x16>
  405070:	40024000 	.word	0x40024000
  405074:	00402385 	.word	0x00402385
  405078:	200013c0 	.word	0x200013c0
  40507c:	00404e19 	.word	0x00404e19
  405080:	00404d91 	.word	0x00404d91

00405084 <USART1_Handler>:
		}
	}	
}

void USART1_Handler()
{
  405084:	b510      	push	{r4, lr}
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  405086:	480e      	ldr	r0, [pc, #56]	; (4050c0 <USART1_Handler+0x3c>)
  405088:	4b0e      	ldr	r3, [pc, #56]	; (4050c4 <USART1_Handler+0x40>)
  40508a:	4798      	blx	r3
	if(status & UART_SR_RXRDY > 0)
  40508c:	07c2      	lsls	r2, r0, #31
{
	//if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
	//{
		//uart_process_byte(USART1, &(uartMemBuf[3]));
	//}
	uint32_t status = uart_get_status(USART1); 
  40508e:	4604      	mov	r4, r0
	if(status & UART_SR_RXRDY > 0)
  405090:	d503      	bpl.n	40509a <USART1_Handler+0x16>
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  405092:	490d      	ldr	r1, [pc, #52]	; (4050c8 <USART1_Handler+0x44>)
  405094:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  405098:	b963      	cbnz	r3, 4050b4 <USART1_Handler+0x30>
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
		}
	}
	
	if(status & UART_SR_TXEMPTY)
  40509a:	05a3      	lsls	r3, r4, #22
  40509c:	d503      	bpl.n	4050a6 <USART1_Handler+0x22>
	{
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
  40509e:	490a      	ldr	r1, [pc, #40]	; (4050c8 <USART1_Handler+0x44>)
  4050a0:	f891 3e66 	ldrb.w	r3, [r1, #3686]	; 0xe66
  4050a4:	b903      	cbnz	r3, 4050a8 <USART1_Handler+0x24>
  4050a6:	bd10      	pop	{r4, pc}
		{
			uart_process_tx_byte(USART1, &(uartMemBuf[3])); 	
  4050a8:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  4050ac:	4804      	ldr	r0, [pc, #16]	; (4050c0 <USART1_Handler+0x3c>)
  4050ae:	4b07      	ldr	r3, [pc, #28]	; (4050cc <USART1_Handler+0x48>)
  4050b0:	4798      	blx	r3
  4050b2:	bd10      	pop	{r4, pc}
	uint32_t status = uart_get_status(USART1); 
	if(status & UART_SR_RXRDY > 0)
	{	
		if(uartMemBuf[3].isinit) //only handle the interrupt if the driver is initialized.
		{
			uart_process_byte(USART1, &(uartMemBuf[3]));
  4050b4:	f501 6146 	add.w	r1, r1, #3168	; 0xc60
  4050b8:	4801      	ldr	r0, [pc, #4]	; (4050c0 <USART1_Handler+0x3c>)
  4050ba:	4b05      	ldr	r3, [pc, #20]	; (4050d0 <USART1_Handler+0x4c>)
  4050bc:	4798      	blx	r3
  4050be:	e7ec      	b.n	40509a <USART1_Handler+0x16>
  4050c0:	40028000 	.word	0x40028000
  4050c4:	00402385 	.word	0x00402385
  4050c8:	200013c0 	.word	0x200013c0
  4050cc:	00404e19 	.word	0x00404e19
  4050d0:	00404d91 	.word	0x00404d91

004050d4 <sysclk_init>:
	pmc_disable_udpck();
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
  4050d4:	b538      	push	{r3, r4, r5, lr}
	/* Set flash wait state to max in case the below clock switching. */
	system_init_flash(CHIP_FREQ_CPU_MAX);
  4050d6:	480e      	ldr	r0, [pc, #56]	; (405110 <sysclk_init+0x3c>)
  4050d8:	4d0e      	ldr	r5, [pc, #56]	; (405114 <sysclk_init+0x40>)
  4050da:	4c0f      	ldr	r4, [pc, #60]	; (405118 <sysclk_init+0x44>)
  4050dc:	47a8      	blx	r5
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
		break;


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL,
  4050de:	2000      	movs	r0, #0
  4050e0:	213e      	movs	r1, #62	; 0x3e
  4050e2:	4b0e      	ldr	r3, [pc, #56]	; (40511c <sysclk_init+0x48>)
  4050e4:	4798      	blx	r3
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
  4050e6:	47a0      	blx	r4
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
	while (!osc_is_ready(id)) {
  4050e8:	2800      	cmp	r0, #0
  4050ea:	d0fc      	beq.n	4050e6 <sysclk_init+0x12>
static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		pmc_disable_pllack(); // Always stop PLL first!
  4050ec:	4b0c      	ldr	r3, [pc, #48]	; (405120 <sysclk_init+0x4c>)
  4050ee:	4c0d      	ldr	r4, [pc, #52]	; (405124 <sysclk_init+0x50>)
  4050f0:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
  4050f2:	4b0d      	ldr	r3, [pc, #52]	; (405128 <sysclk_init+0x54>)
  4050f4:	4a0d      	ldr	r2, [pc, #52]	; (40512c <sysclk_init+0x58>)
  4050f6:	629a      	str	r2, [r3, #40]	; 0x28
static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
	Assert(ul_pll_id < NR_PLLS);

	if (ul_pll_id == PLLA_ID) {
		return pmc_is_locked_pllack();
  4050f8:	47a0      	blx	r4
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
  4050fa:	2800      	cmp	r0, #0
  4050fc:	d0fc      	beq.n	4050f8 <sysclk_init+0x24>

		pll_enable_source(CONFIG_PLL0_SOURCE);
		pll_config_defaults(&pllcfg, 0);
		pll_enable(&pllcfg, 0);
		pll_wait_for_lock(0);
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
  4050fe:	4b0c      	ldr	r3, [pc, #48]	; (405130 <sysclk_init+0x5c>)
  405100:	2010      	movs	r0, #16
  405102:	4798      	blx	r3
		pmc_switch_mck_to_pllbck(CONFIG_SYSCLK_PRES);
	}
#endif

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
  405104:	4b0b      	ldr	r3, [pc, #44]	; (405134 <sysclk_init+0x60>)
  405106:	4798      	blx	r3

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
  405108:	4801      	ldr	r0, [pc, #4]	; (405110 <sysclk_init+0x3c>)
  40510a:	47a8      	blx	r5
  40510c:	bd38      	pop	{r3, r4, r5, pc}
  40510e:	bf00      	nop
  405110:	07270e00 	.word	0x07270e00
  405114:	0040581d 	.word	0x0040581d
  405118:	00405619 	.word	0x00405619
  40511c:	004055c5 	.word	0x004055c5
  405120:	00405629 	.word	0x00405629
  405124:	00405639 	.word	0x00405639
  405128:	400e0400 	.word	0x400e0400
  40512c:	200e3f01 	.word	0x200e3f01
  405130:	0040556d 	.word	0x0040556d
  405134:	00405735 	.word	0x00405735

00405138 <board_init>:
 * \addtogroup sam4s_xplained_pro_group
 * @{
 */

void board_init(void)
{
  405138:	b538      	push	{r3, r4, r5, lr}
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
	pmc_enable_periph_clk(ul_id);
  40513a:	200b      	movs	r0, #11
  40513c:	4d13      	ldr	r5, [pc, #76]	; (40518c <board_init+0x54>)
// 	ioport_set_pin_level(IO1_LED3_PIN, !IO1_LED3_ACTIVE);
// 	ioport_set_pin_dir(IO1_LED3_PIN, IOPORT_DIR_OUTPUT);
	
	
	/* Configure HSMCI pins */
	gpio_configure_pin(PIN_HSMCI_MCCDA_GPIO, PIN_HSMCI_MCCDA_FLAGS);
  40513e:	4c14      	ldr	r4, [pc, #80]	; (405190 <board_init+0x58>)
  405140:	47a8      	blx	r5
  405142:	200c      	movs	r0, #12
  405144:	47a8      	blx	r5
  405146:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40514a:	201c      	movs	r0, #28
  40514c:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCCK_GPIO, PIN_HSMCI_MCCK_FLAGS);
  40514e:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405152:	201d      	movs	r0, #29
  405154:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA0_GPIO, PIN_HSMCI_MCDA0_FLAGS);
  405156:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40515a:	201e      	movs	r0, #30
  40515c:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA1_GPIO, PIN_HSMCI_MCDA1_FLAGS);
  40515e:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405162:	201f      	movs	r0, #31
  405164:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA2_GPIO, PIN_HSMCI_MCDA2_FLAGS);
  405166:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  40516a:	201a      	movs	r0, #26
  40516c:	47a0      	blx	r4
	gpio_configure_pin(PIN_HSMCI_MCDA3_GPIO, PIN_HSMCI_MCDA3_FLAGS);
  40516e:	f04f 51c0 	mov.w	r1, #402653184	; 0x18000000
  405172:	201b      	movs	r0, #27
  405174:	47a0      	blx	r4

	/* Configure SD/MMC card detect pin */
	gpio_configure_pin(SD_MMC_0_CD_GPIO, SD_MMC_0_CD_FLAGS);
  405176:	4907      	ldr	r1, [pc, #28]	; (405194 <board_init+0x5c>)
  405178:	202b      	movs	r0, #43	; 0x2b
  40517a:	47a0      	blx	r4

//#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART1_PIO, PINS_UART1, PINS_UART1_FLAGS);
  40517c:	4b06      	ldr	r3, [pc, #24]	; (405198 <board_init+0x60>)
  40517e:	4807      	ldr	r0, [pc, #28]	; (40519c <board_init+0x64>)
  405180:	210c      	movs	r1, #12
  405182:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
  405186:	4798      	blx	r3
  405188:	bd38      	pop	{r3, r4, r5, pc}
  40518a:	bf00      	nop
  40518c:	00405649 	.word	0x00405649
  405190:	00405315 	.word	0x00405315
  405194:	28000001 	.word	0x28000001
  405198:	004053cd 	.word	0x004053cd
  40519c:	400e1000 	.word	0x400e1000

004051a0 <pio_set_debounce_filter>:
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  4051a0:	0052      	lsls	r2, r2, #1
  4051a2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  4051a6:	fbb3 f2f2 	udiv	r2, r3, r2
  4051aa:	3a01      	subs	r2, #1
  4051ac:	f3c2 020d 	ubfx	r2, r2, #0, #14
void pio_set_debounce_filter(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_cut_off)
{
#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Set Debouncing, 0 bit field no effect */
	p_pio->PIO_IFSCER = ul_mask;
  4051b0:	f8c0 1084 	str.w	r1, [r0, #132]	; 0x84
	/*
	 * The debouncing filter can filter a pulse of less than 1/2 Period of a
	 * programmable Divided Slow Clock:
	 * Tdiv_slclk = ((DIV+1)*2).Tslow_clock
	 */
	p_pio->PIO_SCDR = PIO_SCDR_DIV((FREQ_SLOW_CLOCK_EXT /
  4051b4:	f8c0 208c 	str.w	r2, [r0, #140]	; 0x8c
  4051b8:	4770      	bx	lr
  4051ba:	bf00      	nop

004051bc <pio_set_peripheral>:

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4051bc:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
  4051c0:	b410      	push	{r4}
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
  4051c2:	6442      	str	r2, [r0, #68]	; 0x44

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4051c4:	d030      	beq.n	405228 <pio_set_peripheral+0x6c>
  4051c6:	d812      	bhi.n	4051ee <pio_set_peripheral+0x32>
  4051c8:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  4051cc:	d020      	beq.n	405210 <pio_set_peripheral+0x54>
  4051ce:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  4051d2:	d11a      	bne.n	40520a <pio_set_peripheral+0x4e>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051d4:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4051d6:	4313      	orrs	r3, r2
  4051d8:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  4051da:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  4051dc:	6f41      	ldr	r1, [r0, #116]	; 0x74
  4051de:	400b      	ands	r3, r1
  4051e0:	ea23 0302 	bic.w	r3, r3, r2
  4051e4:	6743      	str	r3, [r0, #116]	; 0x74
#else
#error "Unsupported device"
#endif

	/* Remove the pins from under the control of PIO */
	p_pio->PIO_PDR = ul_mask;
  4051e6:	6042      	str	r2, [r0, #4]
}
  4051e8:	f85d 4b04 	ldr.w	r4, [sp], #4
  4051ec:	4770      	bx	lr

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  4051ee:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  4051f2:	d0f9      	beq.n	4051e8 <pio_set_peripheral+0x2c>
  4051f4:	d822      	bhi.n	40523c <pio_set_peripheral+0x80>
  4051f6:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
  4051fa:	d1f4      	bne.n	4051e6 <pio_set_peripheral+0x2a>

		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
		break;
	case PIO_PERIPH_D:
		ul_sr = p_pio->PIO_ABCDSR[0];
  4051fc:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] = (ul_mask | ul_sr);
  4051fe:	4313      	orrs	r3, r2
  405200:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  405202:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  405204:	4313      	orrs	r3, r2
  405206:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  405208:	e7ed      	b.n	4051e6 <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40520a:	2900      	cmp	r1, #0
  40520c:	d1eb      	bne.n	4051e6 <pio_set_peripheral+0x2a>
  40520e:	e7eb      	b.n	4051e8 <pio_set_peripheral+0x2c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABCDSR[0];
  405210:	6f01      	ldr	r1, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  405212:	6f04      	ldr	r4, [r0, #112]	; 0x70
  405214:	43d3      	mvns	r3, r2
  405216:	4021      	ands	r1, r4
  405218:	4019      	ands	r1, r3
  40521a:	6701      	str	r1, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  40521c:	6f41      	ldr	r1, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
  40521e:	6f44      	ldr	r4, [r0, #116]	; 0x74
  405220:	4021      	ands	r1, r4
  405222:	400b      	ands	r3, r1
  405224:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  405226:	e7de      	b.n	4051e6 <pio_set_peripheral+0x2a>
		ul_sr = p_pio->PIO_ABCDSR[1];
		p_pio->PIO_ABCDSR[1] &= (~ul_mask & ul_sr);
		break;
#if (!SAMG)
	case PIO_PERIPH_C:
		ul_sr = p_pio->PIO_ABCDSR[0];
  405228:	6f03      	ldr	r3, [r0, #112]	; 0x70
		p_pio->PIO_ABCDSR[0] &= (~ul_mask & ul_sr);
  40522a:	6f01      	ldr	r1, [r0, #112]	; 0x70
  40522c:	400b      	ands	r3, r1
  40522e:	ea23 0302 	bic.w	r3, r3, r2
  405232:	6703      	str	r3, [r0, #112]	; 0x70

		ul_sr = p_pio->PIO_ABCDSR[1];
  405234:	6f43      	ldr	r3, [r0, #116]	; 0x74
		p_pio->PIO_ABCDSR[1] = (ul_mask | ul_sr);
  405236:	4313      	orrs	r3, r2
  405238:	6743      	str	r3, [r0, #116]	; 0x74
		break;
  40523a:	e7d4      	b.n	4051e6 <pio_set_peripheral+0x2a>

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	switch (ul_type) {
  40523c:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  405240:	d0d2      	beq.n	4051e8 <pio_set_peripheral+0x2c>
  405242:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  405246:	d0cf      	beq.n	4051e8 <pio_set_peripheral+0x2c>
  405248:	e7cd      	b.n	4051e6 <pio_set_peripheral+0x2a>
  40524a:	bf00      	nop

0040524c <pio_set_input>:
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40524c:	07d3      	lsls	r3, r2, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40524e:	6441      	str	r1, [r0, #68]	; 0x44
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405250:	bf4c      	ite	mi
  405252:	6641      	strmi	r1, [r0, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405254:	6601      	strpl	r1, [r0, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
  405256:	f012 0f0a 	tst.w	r2, #10
		p_pio->PIO_IFER = ul_mask;
  40525a:	bf14      	ite	ne
  40525c:	6201      	strne	r1, [r0, #32]
	} else {
		p_pio->PIO_IFDR = ul_mask;
  40525e:	6241      	streq	r1, [r0, #36]	; 0x24
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
  405260:	0793      	lsls	r3, r2, #30
  405262:	d406      	bmi.n	405272 <pio_set_input+0x26>
		p_pio->PIO_IFSCDR = ul_mask;
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
  405264:	0713      	lsls	r3, r2, #28
			p_pio->PIO_IFSCER = ul_mask;
  405266:	bf48      	it	mi
  405268:	f8c0 1084 	strmi.w	r1, [r0, #132]	; 0x84
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  40526c:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  40526e:	6001      	str	r1, [r0, #0]
  405270:	4770      	bx	lr
	}

#if (SAM3S || SAM3N || SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM || SAMV71 || SAMV70 || SAME70 || SAMS70)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
		p_pio->PIO_IFSCDR = ul_mask;
  405272:	f8c0 1080 	str.w	r1, [r0, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
  405276:	6141      	str	r1, [r0, #20]
	p_pio->PIO_PER = ul_mask;
  405278:	6001      	str	r1, [r0, #0]
  40527a:	4770      	bx	lr

0040527c <pio_configure_interrupt>:
 */
void pio_configure_interrupt(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
  40527c:	06d3      	lsls	r3, r2, #27
  40527e:	d50e      	bpl.n	40529e <pio_configure_interrupt+0x22>
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
  405280:	0693      	lsls	r3, r2, #26
		const uint32_t ul_attr)
{
	/* Configure additional interrupt mode registers. */
	if (ul_attr & PIO_IT_AIME) {
		/* Enable additional interrupt mode. */
		p_pio->PIO_AIMER = ul_mask;
  405282:	f8c0 10b0 	str.w	r1, [r0, #176]	; 0xb0

		/* If bit field of the selected pin is 1, set as
		   Rising Edge/High level detection event. */
		if (ul_attr & PIO_IT_RE_OR_HL) {
			/* Rising Edge or High Level */
			p_pio->PIO_REHLSR = ul_mask;
  405286:	bf4c      	ite	mi
  405288:	f8c0 10d4 	strmi.w	r1, [r0, #212]	; 0xd4
		} else {
			/* Falling Edge or Low Level */
			p_pio->PIO_FELLSR = ul_mask;
  40528c:	f8c0 10d0 	strpl.w	r1, [r0, #208]	; 0xd0
		}

		/* If bit field of the selected pin is 1, set as
		   edge detection source. */
		if (ul_attr & PIO_IT_EDGE) {
  405290:	0653      	lsls	r3, r2, #25
			/* Edge select */
			p_pio->PIO_ESR = ul_mask;
  405292:	bf4c      	ite	mi
  405294:	f8c0 10c0 	strmi.w	r1, [r0, #192]	; 0xc0
		} else {
			/* Level select */
			p_pio->PIO_LSR = ul_mask;
  405298:	f8c0 10c4 	strpl.w	r1, [r0, #196]	; 0xc4
  40529c:	4770      	bx	lr
		}
	} else {
		/* Disable additional interrupt mode. */
		p_pio->PIO_AIMDR = ul_mask;
  40529e:	f8c0 10b4 	str.w	r1, [r0, #180]	; 0xb4
  4052a2:	4770      	bx	lr

004052a4 <pio_enable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_enable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_ISR;
  4052a4:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
	p_pio->PIO_IER = ul_mask;
  4052a6:	6401      	str	r1, [r0, #64]	; 0x40
  4052a8:	4770      	bx	lr
  4052aa:	bf00      	nop

004052ac <pio_disable_interrupt>:
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  4052ac:	6441      	str	r1, [r0, #68]	; 0x44
  4052ae:	4770      	bx	lr

004052b0 <pio_get_interrupt_status>:
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
	return p_pio->PIO_ISR;
  4052b0:	6cc0      	ldr	r0, [r0, #76]	; 0x4c
}
  4052b2:	4770      	bx	lr

004052b4 <pio_get_interrupt_mask>:
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
	return p_pio->PIO_IMR;
  4052b4:	6c80      	ldr	r0, [r0, #72]	; 0x48
}
  4052b6:	4770      	bx	lr

004052b8 <pio_set_pin_high>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052b8:	0943      	lsrs	r3, r0, #5
  4052ba:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4052be:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4052c2:	025b      	lsls	r3, r3, #9
void pio_set_pin_high(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 1. */
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  4052c4:	f000 001f 	and.w	r0, r0, #31
  4052c8:	2201      	movs	r2, #1
  4052ca:	fa02 f000 	lsl.w	r0, r2, r0
  4052ce:	6318      	str	r0, [r3, #48]	; 0x30
  4052d0:	4770      	bx	lr
  4052d2:	bf00      	nop

004052d4 <pio_set_pin_low>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052d4:	0943      	lsrs	r3, r0, #5
  4052d6:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4052da:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4052de:	025b      	lsls	r3, r3, #9
void pio_set_pin_low(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Value to be driven on the I/O line: 0. */
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  4052e0:	f000 001f 	and.w	r0, r0, #31
  4052e4:	2201      	movs	r2, #1
  4052e6:	fa02 f000 	lsl.w	r0, r2, r0
  4052ea:	6358      	str	r0, [r3, #52]	; 0x34
  4052ec:	4770      	bx	lr
  4052ee:	bf00      	nop

004052f0 <pio_toggle_pin>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  4052f0:	0943      	lsrs	r3, r0, #5
  4052f2:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
  4052f6:	f203 7307 	addw	r3, r3, #1799	; 0x707
  4052fa:	025b      	lsls	r3, r3, #9
 */
void pio_toggle_pin(uint32_t ul_pin)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
  4052fc:	f000 001f 	and.w	r0, r0, #31
  405300:	6b9a      	ldr	r2, [r3, #56]	; 0x38
  405302:	2101      	movs	r1, #1
  405304:	fa01 f000 	lsl.w	r0, r1, r0
  405308:	4210      	tst	r0, r2
		/* Value to be driven on the I/O line: 0. */
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
  40530a:	bf14      	ite	ne
  40530c:	6358      	strne	r0, [r3, #52]	; 0x34
	} else {
		/* Value to be driven on the I/O line: 1. */
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
  40530e:	6318      	streq	r0, [r3, #48]	; 0x30
  405310:	4770      	bx	lr
  405312:	bf00      	nop

00405314 <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  405314:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  405316:	0944      	lsrs	r4, r0, #5
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
  405318:	460d      	mov	r5, r1
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40531a:	f504 1400 	add.w	r4, r4, #2097152	; 0x200000
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40531e:	f001 41f0 	and.w	r1, r1, #2013265920	; 0x78000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  405322:	f204 7407 	addw	r4, r4, #1799	; 0x707
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  405326:	f1b1 5f00 	cmp.w	r1, #536870912	; 0x20000000
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  40532a:	ea4f 2444 	mov.w	r4, r4, lsl #9
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40532e:	d00b      	beq.n	405348 <pio_configure_pin+0x34>
  405330:	d819      	bhi.n	405366 <pio_configure_pin+0x52>
  405332:	f1b1 5f80 	cmp.w	r1, #268435456	; 0x10000000
  405336:	d007      	beq.n	405348 <pio_configure_pin+0x34>
  405338:	f1b1 5fc0 	cmp.w	r1, #402653184	; 0x18000000
  40533c:	d004      	beq.n	405348 <pio_configure_pin+0x34>
  40533e:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
  405342:	d001      	beq.n	405348 <pio_configure_pin+0x34>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  405344:	2000      	movs	r0, #0
	}

	return 1;
}
  405346:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		pio_set_peripheral(p_pio, PIO_PERIPH_C, (1 << (ul_pin & 0x1F)));
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
				(ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, (1 << (ul_pin & 0x1F)));
  405348:	2601      	movs	r6, #1
  40534a:	f000 001f 	and.w	r0, r0, #31
  40534e:	fa06 f700 	lsl.w	r7, r6, r0
  405352:	463a      	mov	r2, r7
  405354:	4620      	mov	r0, r4
  405356:	4b1b      	ldr	r3, [pc, #108]	; (4053c4 <pio_configure_pin+0xb0>)
  405358:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40535a:	07ed      	lsls	r5, r5, #31
		p_pio->PIO_PUER = ul_mask;
  40535c:	bf4c      	ite	mi
  40535e:	6667      	strmi	r7, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405360:	6627      	strpl	r7, [r4, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  405362:	4630      	mov	r0, r6
  405364:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
	Pio *p_pio = pio_get_pin_group(ul_pin);

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  405366:	f1b1 5f40 	cmp.w	r1, #805306368	; 0x30000000
  40536a:	d010      	beq.n	40538e <pio_configure_pin+0x7a>
  40536c:	f1b1 5f60 	cmp.w	r1, #939524096	; 0x38000000
  405370:	d00d      	beq.n	40538e <pio_configure_pin+0x7a>
  405372:	f1b1 5f20 	cmp.w	r1, #671088640	; 0x28000000
  405376:	d1e5      	bne.n	405344 <pio_configure_pin+0x30>
				(ul_flags & PIO_PULLUP));
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
  405378:	2601      	movs	r6, #1
  40537a:	f000 011f 	and.w	r1, r0, #31
  40537e:	462a      	mov	r2, r5
  405380:	4620      	mov	r0, r4
  405382:	fa06 f101 	lsl.w	r1, r6, r1
  405386:	4b10      	ldr	r3, [pc, #64]	; (4053c8 <pio_configure_pin+0xb4>)
  405388:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  40538a:	4630      	mov	r0, r6
		break;
//#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;
  40538c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
  40538e:	f000 001f 	and.w	r0, r0, #31
  405392:	2301      	movs	r3, #1
  405394:	4083      	lsls	r3, r0
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  405396:	f005 0104 	and.w	r1, r5, #4
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  40539a:	07e8      	lsls	r0, r5, #31
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40539c:	6463      	str	r3, [r4, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40539e:	f005 5260 	and.w	r2, r5, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  4053a2:	bf4c      	ite	mi
  4053a4:	6663      	strmi	r3, [r4, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  4053a6:	6623      	strpl	r3, [r4, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  4053a8:	b149      	cbz	r1, 4053be <pio_configure_pin+0xaa>
		p_pio->PIO_MDER = ul_mask;
  4053aa:	6523      	str	r3, [r4, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  4053ac:	f1b2 5f60 	cmp.w	r2, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  4053b0:	bf0c      	ite	eq
  4053b2:	6323      	streq	r3, [r4, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  4053b4:	6363      	strne	r3, [r4, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  4053b6:	6123      	str	r3, [r4, #16]
	p_pio->PIO_PER = ul_mask;
  4053b8:	6023      	str	r3, [r4, #0]

	default:
		return 0;
	}

	return 1;
  4053ba:	2001      	movs	r0, #1
  4053bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  4053be:	6563      	str	r3, [r4, #84]	; 0x54
  4053c0:	e7f4      	b.n	4053ac <pio_configure_pin+0x98>
  4053c2:	bf00      	nop
  4053c4:	004051bd 	.word	0x004051bd
  4053c8:	0040524d 	.word	0x0040524d

004053cc <pio_configure_pin_group>:
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4053cc:	f002 43f0 	and.w	r3, r2, #2013265920	; 0x78000000
  4053d0:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
  4053d4:	b570      	push	{r4, r5, r6, lr}
  4053d6:	4614      	mov	r4, r2
  4053d8:	4606      	mov	r6, r0
  4053da:	460d      	mov	r5, r1
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  4053dc:	d00b      	beq.n	4053f6 <pio_configure_pin_group+0x2a>
  4053de:	d814      	bhi.n	40540a <pio_configure_pin_group+0x3e>
  4053e0:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
  4053e4:	d007      	beq.n	4053f6 <pio_configure_pin_group+0x2a>
  4053e6:	f1b3 5fc0 	cmp.w	r3, #402653184	; 0x18000000
  4053ea:	d004      	beq.n	4053f6 <pio_configure_pin_group+0x2a>
  4053ec:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
  4053f0:	d001      	beq.n	4053f6 <pio_configure_pin_group+0x2a>
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;

	default:
		return 0;
  4053f2:	2000      	movs	r0, #0
	}

	return 1;
}
  4053f4:	bd70      	pop	{r4, r5, r6, pc}
	case PIO_TYPE_PIO_PERIPH_C:
		pio_set_peripheral(p_pio, PIO_PERIPH_C, ul_mask);
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
	case PIO_TYPE_PIO_PERIPH_D:
		pio_set_peripheral(p_pio, PIO_PERIPH_D, ul_mask);
  4053f6:	4619      	mov	r1, r3
  4053f8:	462a      	mov	r2, r5
  4053fa:	4b15      	ldr	r3, [pc, #84]	; (405450 <pio_configure_pin_group+0x84>)
  4053fc:	4798      	blx	r3
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  4053fe:	07e0      	lsls	r0, r4, #31
		p_pio->PIO_PUER = ul_mask;
  405400:	bf4c      	ite	mi
  405402:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405404:	6635      	strpl	r5, [r6, #96]	; 0x60

	default:
		return 0;
	}

	return 1;
  405406:	2001      	movs	r0, #1
  405408:	bd70      	pop	{r4, r5, r6, pc}
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
  40540a:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
  40540e:	d009      	beq.n	405424 <pio_configure_pin_group+0x58>
  405410:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
  405414:	d006      	beq.n	405424 <pio_configure_pin_group+0x58>
  405416:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
  40541a:	d1ea      	bne.n	4053f2 <pio_configure_pin_group+0x26>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
  40541c:	4b0d      	ldr	r3, [pc, #52]	; (405454 <pio_configure_pin_group+0x88>)
  40541e:	4798      	blx	r3

	default:
		return 0;
	}

	return 1;
  405420:	2001      	movs	r0, #1
		break;
#endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;
  405422:	bd70      	pop	{r4, r5, r6, pc}
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
  405424:	07e1      	lsls	r1, r4, #31
	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
  405426:	f004 0204 	and.w	r2, r4, #4
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
	p_pio->PIO_IDR = ul_mask;
  40542a:	6475      	str	r5, [r6, #68]	; 0x44
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
  40542c:	f004 5360 	and.w	r3, r4, #939524096	; 0x38000000
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
		p_pio->PIO_PUER = ul_mask;
  405430:	bf4c      	ite	mi
  405432:	6675      	strmi	r5, [r6, #100]	; 0x64
	} else {
		p_pio->PIO_PUDR = ul_mask;
  405434:	6635      	strpl	r5, [r6, #96]	; 0x60
{
	pio_disable_interrupt(p_pio, ul_mask);
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
  405436:	b14a      	cbz	r2, 40544c <pio_configure_pin_group+0x80>
		p_pio->PIO_MDER = ul_mask;
  405438:	6535      	str	r5, [r6, #80]	; 0x50
	} else {
		p_pio->PIO_MDDR = ul_mask;
	}

	/* Set default value */
	if (ul_default_level) {
  40543a:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
		p_pio->PIO_SODR = ul_mask;
  40543e:	bf0c      	ite	eq
  405440:	6335      	streq	r5, [r6, #48]	; 0x30
	} else {
		p_pio->PIO_CODR = ul_mask;
  405442:	6375      	strne	r5, [r6, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
  405444:	6135      	str	r5, [r6, #16]
	p_pio->PIO_PER = ul_mask;
  405446:	6035      	str	r5, [r6, #0]

	default:
		return 0;
	}

	return 1;
  405448:	2001      	movs	r0, #1
  40544a:	bd70      	pop	{r4, r5, r6, pc}

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
		p_pio->PIO_MDER = ul_mask;
	} else {
		p_pio->PIO_MDDR = ul_mask;
  40544c:	6575      	str	r5, [r6, #84]	; 0x54
  40544e:	e7f4      	b.n	40543a <pio_configure_pin_group+0x6e>
  405450:	004051bd 	.word	0x004051bd
  405454:	0040524d 	.word	0x0040524d

00405458 <pio_get_pin_group>:
		p_pio = PIOC;
	} else {
		p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
	}
#else
	p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
  405458:	0940      	lsrs	r0, r0, #5
  40545a:	f500 1000 	add.w	r0, r0, #2097152	; 0x200000
  40545e:	f200 7007 	addw	r0, r0, #1799	; 0x707
#endif
	return p_pio;
}
  405462:	0240      	lsls	r0, r0, #9
  405464:	4770      	bx	lr
  405466:	bf00      	nop

00405468 <pio_get_pin_group_id>:
		ul_id = ID_PIOC;
	} else {
		ul_id = ID_PIOA + (ul_pin >> 5);
	}
#else
	ul_id = ID_PIOA + (ul_pin >> 5);
  405468:	0940      	lsrs	r0, r0, #5
#endif
	return ul_id;
}
  40546a:	300b      	adds	r0, #11
  40546c:	4770      	bx	lr
  40546e:	bf00      	nop

00405470 <pio_get_pin_group_mask>:
 *
 * \return GPIO port pin mask.
 */
uint32_t pio_get_pin_group_mask(uint32_t ul_pin)
{
	uint32_t ul_mask = 1 << (ul_pin & 0x1F);
  405470:	2301      	movs	r3, #1
  405472:	f000 001f 	and.w	r0, r0, #31
	return ul_mask;
}
  405476:	fa03 f000 	lsl.w	r0, r3, r0
  40547a:	4770      	bx	lr

0040547c <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  40547c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  405480:	4b17      	ldr	r3, [pc, #92]	; (4054e0 <pio_handler_process+0x64>)
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
  405482:	4680      	mov	r8, r0
  405484:	460e      	mov	r6, r1
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  405486:	4798      	blx	r3
	status &= pio_get_interrupt_mask(p_pio);
  405488:	4b16      	ldr	r3, [pc, #88]	; (4054e4 <pio_handler_process+0x68>)
{
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
  40548a:	4605      	mov	r5, r0
	status &= pio_get_interrupt_mask(p_pio);
  40548c:	4640      	mov	r0, r8
  40548e:	4798      	blx	r3

	/* Check pending events */
	if (status != 0) {
  405490:	4005      	ands	r5, r0
  405492:	d018      	beq.n	4054c6 <pio_handler_process+0x4a>
  405494:	4c14      	ldr	r4, [pc, #80]	; (4054e8 <pio_handler_process+0x6c>)
  405496:	f104 07b0 	add.w	r7, r4, #176	; 0xb0
  40549a:	e003      	b.n	4054a4 <pio_handler_process+0x28>
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  40549c:	42bc      	cmp	r4, r7
  40549e:	d012      	beq.n	4054c6 <pio_handler_process+0x4a>
  4054a0:	3410      	adds	r4, #16

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
  4054a2:	b185      	cbz	r5, 4054c6 <pio_handler_process+0x4a>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
  4054a4:	f854 3c0c 	ldr.w	r3, [r4, #-12]
  4054a8:	42b3      	cmp	r3, r6
  4054aa:	d1f7      	bne.n	40549c <pio_handler_process+0x20>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
  4054ac:	f854 1c08 	ldr.w	r1, [r4, #-8]
  4054b0:	4229      	tst	r1, r5
  4054b2:	d0f3      	beq.n	40549c <pio_handler_process+0x20>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
  4054b4:	6823      	ldr	r3, [r4, #0]
  4054b6:	4630      	mov	r0, r6
  4054b8:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  4054ba:	f854 3c08 	ldr.w	r3, [r4, #-8]
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  4054be:	42bc      	cmp	r4, r7
			if (gs_interrupt_sources[i].id == ul_id) {
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
  4054c0:	ea25 0503 	bic.w	r5, r5, r3
				}
			}
			i++;
			if (i >= MAX_INTERRUPT_SOURCES) {
  4054c4:	d1ec      	bne.n	4054a0 <pio_handler_process+0x24>
		}
	}

	/* Check capture events */
#if (SAM3S || SAM4S || SAM4E)
	if (pio_capture_enable_flag) {
  4054c6:	4b09      	ldr	r3, [pc, #36]	; (4054ec <pio_handler_process+0x70>)
  4054c8:	681b      	ldr	r3, [r3, #0]
  4054ca:	b133      	cbz	r3, 4054da <pio_handler_process+0x5e>
		if (pio_capture_handler) {
  4054cc:	4b08      	ldr	r3, [pc, #32]	; (4054f0 <pio_handler_process+0x74>)
  4054ce:	681b      	ldr	r3, [r3, #0]
  4054d0:	b10b      	cbz	r3, 4054d6 <pio_handler_process+0x5a>
			pio_capture_handler(p_pio);
  4054d2:	4640      	mov	r0, r8
  4054d4:	4798      	blx	r3
  4054d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4054da:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4054de:	bf00      	nop
  4054e0:	004052b1 	.word	0x004052b1
  4054e4:	004052b5 	.word	0x004052b5
  4054e8:	200010a0 	.word	0x200010a0
  4054ec:	20002440 	.word	0x20002440
  4054f0:	20001090 	.word	0x20001090

004054f4 <pio_handler_set>:
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4054f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  4054f8:	4d0f      	ldr	r5, [pc, #60]	; (405538 <pio_handler_set+0x44>)
  4054fa:	682c      	ldr	r4, [r5, #0]
  4054fc:	2c0b      	cmp	r4, #11
 *
 * \return 0 if successful, 1 if the maximum number of sources has been defined.
 */
uint32_t pio_handler_set(Pio *p_pio, uint32_t ul_id, uint32_t ul_mask,
		uint32_t ul_attr, void (*p_handler) (uint32_t, uint32_t))
{
  4054fe:	468c      	mov	ip, r1
  405500:	4616      	mov	r6, r2
	struct s_interrupt_source *pSource;

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
  405502:	d902      	bls.n	40550a <pio_handler_set+0x16>
		return 1;
  405504:	2001      	movs	r0, #1

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);

	return 0;
}
  405506:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  40550a:	f8df 8030 	ldr.w	r8, [pc, #48]	; 40553c <pio_handler_set+0x48>
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40550e:	f8df 9030 	ldr.w	r9, [pc, #48]	; 405540 <pio_handler_set+0x4c>

	if (gs_ul_nb_sources >= MAX_INTERRUPT_SOURCES)
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
  405512:	ea4f 1e04 	mov.w	lr, r4, lsl #4
  405516:	eb08 070e 	add.w	r7, r8, lr
	pSource->id = ul_id;
  40551a:	f848 c00e 	str.w	ip, [r8, lr]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40551e:	4611      	mov	r1, r2

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
  405520:	60bb      	str	r3, [r7, #8]
	pSource->handler = p_handler;
	gs_ul_nb_sources++;

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  405522:	461a      	mov	r2, r3
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  405524:	9b08      	ldr	r3, [sp, #32]
		return 1;

	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
  405526:	607e      	str	r6, [r7, #4]
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
	gs_ul_nb_sources++;
  405528:	3401      	adds	r4, #1
	/* Define new source */
	pSource = &(gs_interrupt_sources[gs_ul_nb_sources]);
	pSource->id = ul_id;
	pSource->mask = ul_mask;
	pSource->attr = ul_attr;
	pSource->handler = p_handler;
  40552a:	60fb      	str	r3, [r7, #12]
	gs_ul_nb_sources++;
  40552c:	602c      	str	r4, [r5, #0]

	/* Configure interrupt mode */
	pio_configure_interrupt(p_pio, ul_mask, ul_attr);
  40552e:	47c8      	blx	r9

	return 0;
  405530:	2000      	movs	r0, #0
  405532:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  405536:	bf00      	nop
  405538:	2000108c 	.word	0x2000108c
  40553c:	20001094 	.word	0x20001094
  405540:	0040527d 	.word	0x0040527d

00405544 <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
  405544:	b508      	push	{r3, lr}
	pio_handler_process(PIOA, ID_PIOA);
  405546:	4802      	ldr	r0, [pc, #8]	; (405550 <PIOA_Handler+0xc>)
  405548:	4b02      	ldr	r3, [pc, #8]	; (405554 <PIOA_Handler+0x10>)
  40554a:	210b      	movs	r1, #11
  40554c:	4798      	blx	r3
  40554e:	bd08      	pop	{r3, pc}
  405550:	400e0e00 	.word	0x400e0e00
  405554:	0040547d 	.word	0x0040547d

00405558 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
  405558:	b508      	push	{r3, lr}
    pio_handler_process(PIOB, ID_PIOB);
  40555a:	4802      	ldr	r0, [pc, #8]	; (405564 <PIOB_Handler+0xc>)
  40555c:	4b02      	ldr	r3, [pc, #8]	; (405568 <PIOB_Handler+0x10>)
  40555e:	210c      	movs	r1, #12
  405560:	4798      	blx	r3
  405562:	bd08      	pop	{r3, pc}
  405564:	400e1000 	.word	0x400e1000
  405568:	0040547d 	.word	0x0040547d

0040556c <pmc_switch_mck_to_pllack>:
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
  40556c:	4914      	ldr	r1, [pc, #80]	; (4055c0 <pmc_switch_mck_to_pllack+0x54>)
  40556e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405570:	f023 0370 	bic.w	r3, r3, #112	; 0x70
  405574:	4318      	orrs	r0, r3
  405576:	6308      	str	r0, [r1, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405578:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  40557a:	071b      	lsls	r3, r3, #28
  40557c:	d407      	bmi.n	40558e <pmc_switch_mck_to_pllack+0x22>
  40557e:	f44f 6300 	mov.w	r3, #2048	; 0x800
  405582:	e001      	b.n	405588 <pmc_switch_mck_to_pllack+0x1c>
			--ul_timeout) {
		if (ul_timeout == 0) {
  405584:	3b01      	subs	r3, #1
  405586:	d016      	beq.n	4055b6 <pmc_switch_mck_to_pllack+0x4a>
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  405588:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  40558a:	0710      	lsls	r0, r2, #28
  40558c:	d5fa      	bpl.n	405584 <pmc_switch_mck_to_pllack+0x18>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
  40558e:	490c      	ldr	r1, [pc, #48]	; (4055c0 <pmc_switch_mck_to_pllack+0x54>)
  405590:	6b0b      	ldr	r3, [r1, #48]	; 0x30
  405592:	f023 0303 	bic.w	r3, r3, #3
  405596:	f043 0302 	orr.w	r3, r3, #2
  40559a:	630b      	str	r3, [r1, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  40559c:	6e88      	ldr	r0, [r1, #104]	; 0x68
  40559e:	f010 0008 	ands.w	r0, r0, #8
  4055a2:	d10a      	bne.n	4055ba <pmc_switch_mck_to_pllack+0x4e>
  4055a4:	f44f 6300 	mov.w	r3, #2048	; 0x800
  4055a8:	e001      	b.n	4055ae <pmc_switch_mck_to_pllack+0x42>
			--ul_timeout) {
		if (ul_timeout == 0) {
  4055aa:	3b01      	subs	r3, #1
  4055ac:	d003      	beq.n	4055b6 <pmc_switch_mck_to_pllack+0x4a>
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
  4055ae:	6e8a      	ldr	r2, [r1, #104]	; 0x68
  4055b0:	0712      	lsls	r2, r2, #28
  4055b2:	d5fa      	bpl.n	4055aa <pmc_switch_mck_to_pllack+0x3e>
  4055b4:	4770      	bx	lr

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
		if (ul_timeout == 0) {
			return 1;
  4055b6:	2001      	movs	r0, #1
  4055b8:	4770      	bx	lr
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
  4055ba:	2000      	movs	r0, #0
}
  4055bc:	4770      	bx	lr
  4055be:	bf00      	nop
  4055c0:	400e0400 	.word	0x400e0400

004055c4 <pmc_switch_mainck_to_xtal>:
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
  4055c4:	b9c8      	cbnz	r0, 4055fa <pmc_switch_mainck_to_xtal+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4055c6:	4b11      	ldr	r3, [pc, #68]	; (40560c <pmc_switch_mainck_to_xtal+0x48>)
  4055c8:	6a1a      	ldr	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4055ca:	f422 125c 	bic.w	r2, r2, #3604480	; 0x370000
  4055ce:	f022 0203 	bic.w	r2, r2, #3
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4055d2:	0209      	lsls	r1, r1, #8
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4055d4:	f442 125c 	orr.w	r2, r2, #3604480	; 0x370000
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
  4055d8:	b289      	uxth	r1, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
  4055da:	f042 0201 	orr.w	r2, r2, #1
  4055de:	430a      	orrs	r2, r1
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
  4055e0:	621a      	str	r2, [r3, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(ul_xtal_startup_time);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
  4055e2:	4619      	mov	r1, r3
  4055e4:	6e8b      	ldr	r3, [r1, #104]	; 0x68
  4055e6:	4a09      	ldr	r2, [pc, #36]	; (40560c <pmc_switch_mainck_to_xtal+0x48>)
  4055e8:	07db      	lsls	r3, r3, #31
  4055ea:	d5fb      	bpl.n	4055e4 <pmc_switch_mainck_to_xtal+0x20>

		PMC->CKGR_MOR |= CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCSEL;
  4055ec:	6a13      	ldr	r3, [r2, #32]
  4055ee:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
  4055f2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  4055f6:	6213      	str	r3, [r2, #32]
  4055f8:	4770      	bx	lr
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4055fa:	4904      	ldr	r1, [pc, #16]	; (40560c <pmc_switch_mainck_to_xtal+0x48>)
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  4055fc:	4a04      	ldr	r2, [pc, #16]	; (405610 <pmc_switch_mainck_to_xtal+0x4c>)
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  4055fe:	6a08      	ldr	r0, [r1, #32]
				CKGR_MOR_KEY_PASSWD | CKGR_MOR_MOSCXTBY |
  405600:	4b04      	ldr	r3, [pc, #16]	; (405614 <pmc_switch_mainck_to_xtal+0x50>)
  405602:	4002      	ands	r2, r0
  405604:	4313      	orrs	r3, r2
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass,
		uint32_t ul_xtal_startup_time)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
  405606:	620b      	str	r3, [r1, #32]
  405608:	4770      	bx	lr
  40560a:	bf00      	nop
  40560c:	400e0400 	.word	0x400e0400
  405610:	fec8fffc 	.word	0xfec8fffc
  405614:	01370002 	.word	0x01370002

00405618 <pmc_osc_is_ready_mainck>:
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
  405618:	4b02      	ldr	r3, [pc, #8]	; (405624 <pmc_osc_is_ready_mainck+0xc>)
  40561a:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40561c:	f400 3080 	and.w	r0, r0, #65536	; 0x10000
  405620:	4770      	bx	lr
  405622:	bf00      	nop
  405624:	400e0400 	.word	0x400e0400

00405628 <pmc_disable_pllack>:
void pmc_disable_pllack(void)
{
#if (SAM4C || SAM4CM || SAM4CP || SAMG)
	PMC->CKGR_PLLAR = CKGR_PLLAR_MULA(0);
#else
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
  405628:	4b02      	ldr	r3, [pc, #8]	; (405634 <pmc_disable_pllack+0xc>)
  40562a:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
  40562e:	629a      	str	r2, [r3, #40]	; 0x28
  405630:	4770      	bx	lr
  405632:	bf00      	nop
  405634:	400e0400 	.word	0x400e0400

00405638 <pmc_is_locked_pllack>:
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
	return (PMC->PMC_SR & PMC_SR_LOCKA);
  405638:	4b02      	ldr	r3, [pc, #8]	; (405644 <pmc_is_locked_pllack+0xc>)
  40563a:	6e98      	ldr	r0, [r3, #104]	; 0x68
}
  40563c:	f000 0002 	and.w	r0, r0, #2
  405640:	4770      	bx	lr
  405642:	bf00      	nop
  405644:	400e0400 	.word	0x400e0400

00405648 <pmc_enable_periph_clk>:
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
  405648:	2822      	cmp	r0, #34	; 0x22
  40564a:	d819      	bhi.n	405680 <pmc_enable_periph_clk+0x38>
		return 1;
	}

	if (ul_id < 32) {
  40564c:	281f      	cmp	r0, #31
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  40564e:	4b0e      	ldr	r3, [pc, #56]	; (405688 <pmc_enable_periph_clk+0x40>)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
	}

	if (ul_id < 32) {
  405650:	d809      	bhi.n	405666 <pmc_enable_periph_clk+0x1e>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
  405652:	2101      	movs	r1, #1
  405654:	699a      	ldr	r2, [r3, #24]
  405656:	fa01 f000 	lsl.w	r0, r1, r0
  40565a:	4002      	ands	r2, r0
  40565c:	4290      	cmp	r0, r2
  40565e:	d011      	beq.n	405684 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER0 = 1 << ul_id;
  405660:	6118      	str	r0, [r3, #16]
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405662:	2000      	movs	r0, #0
  405664:	4770      	bx	lr
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
			PMC->PMC_PCER0 = 1 << ul_id;
		}
#if (SAM3S || SAM3XA || SAM4S || SAM4E || SAM4C || SAM4CM || SAM4CP || SAMG55 || SAMV71 || SAMV70 || SAME70 || SAMS70)
	} else {
		ul_id -= 32;
  405666:	3820      	subs	r0, #32
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
  405668:	2101      	movs	r1, #1
  40566a:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
  40566e:	fa01 f000 	lsl.w	r0, r1, r0
  405672:	4002      	ands	r2, r0
  405674:	4290      	cmp	r0, r2
  405676:	d005      	beq.n	405684 <pmc_enable_periph_clk+0x3c>
			PMC->PMC_PCER1 = 1 << ul_id;
  405678:	f8c3 0100 	str.w	r0, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
  40567c:	2000      	movs	r0, #0
  40567e:	4770      	bx	lr
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
	if (ul_id > MAX_PERIPH_ID) {
		return 1;
  405680:	2001      	movs	r0, #1
  405682:	4770      	bx	lr
			PMC->PMC_PCER1 = 1 << ul_id;
		}
#endif
	}

	return 0;
  405684:	2000      	movs	r0, #0
}
  405686:	4770      	bx	lr
  405688:	400e0400 	.word	0x400e0400

0040568c <wdt_disable>:
/**
 * \brief Disable the watchdog timer.
 */
void wdt_disable(Wdt *p_wdt)
{
	p_wdt->WDT_MR = WDT_MR_WDDIS;
  40568c:	f44f 4300 	mov.w	r3, #32768	; 0x8000
  405690:	6043      	str	r3, [r0, #4]
  405692:	4770      	bx	lr

00405694 <wdt_get_status>:
 *
 * \return Bitmask of watchdog timer status.
 */
uint32_t wdt_get_status(Wdt *p_wdt)
{
	return p_wdt->WDT_SR;
  405694:	6880      	ldr	r0, [r0, #8]
}
  405696:	4770      	bx	lr

00405698 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
  405698:	e7fe      	b.n	405698 <Dummy_Handler>
  40569a:	bf00      	nop

0040569c <Reset_Handler>:

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  40569c:	481c      	ldr	r0, [pc, #112]	; (405710 <Reset_Handler+0x74>)
  40569e:	4b1d      	ldr	r3, [pc, #116]	; (405714 <Reset_Handler+0x78>)
  4056a0:	4298      	cmp	r0, r3
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
  4056a2:	b510      	push	{r4, lr}

	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
  4056a4:	d925      	bls.n	4056f2 <Reset_Handler+0x56>
		for (; pDest < &_erelocate;) {
  4056a6:	4a1c      	ldr	r2, [pc, #112]	; (405718 <Reset_Handler+0x7c>)
  4056a8:	4293      	cmp	r3, r2
  4056aa:	d20a      	bcs.n	4056c2 <Reset_Handler+0x26>
  4056ac:	43d9      	mvns	r1, r3
  4056ae:	440a      	add	r2, r1
  4056b0:	f022 0403 	bic.w	r4, r2, #3
  4056b4:	3404      	adds	r4, #4
  4056b6:	2200      	movs	r2, #0
			*pDest++ = *pSrc++;
  4056b8:	5881      	ldr	r1, [r0, r2]
  4056ba:	5099      	str	r1, [r3, r2]
  4056bc:	3204      	adds	r2, #4
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
  4056be:	42a2      	cmp	r2, r4
  4056c0:	d1fa      	bne.n	4056b8 <Reset_Handler+0x1c>

    No Operation does nothing. This instruction can be used for code alignment purposes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
{
  __ASM volatile ("nop");
  4056c2:	bf00      	nop
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4056c4:	4b15      	ldr	r3, [pc, #84]	; (40571c <Reset_Handler+0x80>)
  4056c6:	4a16      	ldr	r2, [pc, #88]	; (405720 <Reset_Handler+0x84>)
  4056c8:	4293      	cmp	r3, r2
  4056ca:	d20a      	bcs.n	4056e2 <Reset_Handler+0x46>
  4056cc:	43d9      	mvns	r1, r3
  4056ce:	440a      	add	r2, r1
  4056d0:	f022 0103 	bic.w	r1, r2, #3
  4056d4:	4419      	add	r1, r3
		*pDest++ = 0;
  4056d6:	2200      	movs	r2, #0
  4056d8:	3b04      	subs	r3, #4
  4056da:	f843 2f04 	str.w	r2, [r3, #4]!
		}
	}
	__NOP();

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
  4056de:	428b      	cmp	r3, r1
  4056e0:	d1fb      	bne.n	4056da <Reset_Handler+0x3e>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
	SCB->VTOR = ((uint32_t) pSrc);
  4056e2:	4b10      	ldr	r3, [pc, #64]	; (405724 <Reset_Handler+0x88>)
  4056e4:	4a10      	ldr	r2, [pc, #64]	; (405728 <Reset_Handler+0x8c>)
  4056e6:	609a      	str	r2, [r3, #8]

	/* Initialize the C library */
	__libc_init_array();
  4056e8:	4b10      	ldr	r3, [pc, #64]	; (40572c <Reset_Handler+0x90>)
  4056ea:	4798      	blx	r3

	/* Branch to main function */
	main();
  4056ec:	4b10      	ldr	r3, [pc, #64]	; (405730 <Reset_Handler+0x94>)
  4056ee:	4798      	blx	r3
  4056f0:	e7fe      	b.n	4056f0 <Reset_Handler+0x54>

	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
  4056f2:	d2e6      	bcs.n	4056c2 <Reset_Handler+0x26>
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4056f4:	4908      	ldr	r1, [pc, #32]	; (405718 <Reset_Handler+0x7c>)
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4056f6:	3804      	subs	r0, #4
	if (pSrc > pDest) {
		for (; pDest < &_erelocate;) {
			*pDest++ = *pSrc++;
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
  4056f8:	1aca      	subs	r2, r1, r3
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
  4056fa:	4410      	add	r0, r2
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  4056fc:	2a00      	cmp	r2, #0
  4056fe:	d0e0      	beq.n	4056c2 <Reset_Handler+0x26>
  405700:	460a      	mov	r2, r1
  405702:	1a54      	subs	r4, r2, r1
			*pDest-- = *pSrc--;
  405704:	5824      	ldr	r4, [r4, r0]
  405706:	f842 4d04 	str.w	r4, [r2, #-4]!
		}
	} else if (pSrc < pDest) {
		uint32_t nb_bytes = (uint32_t)&_erelocate - (uint32_t)&_srelocate;
		pSrc = (uint32_t*)((uint32_t)pSrc + nb_bytes) - 1;
		pDest = (uint32_t*)((uint32_t)pDest + nb_bytes) - 1;
		for (;nb_bytes;nb_bytes -= 4) {
  40570a:	4293      	cmp	r3, r2
  40570c:	d1f9      	bne.n	405702 <Reset_Handler+0x66>
  40570e:	e7d8      	b.n	4056c2 <Reset_Handler+0x26>
  405710:	0040712c 	.word	0x0040712c
  405714:	20000000 	.word	0x20000000
  405718:	20000aec 	.word	0x20000aec
  40571c:	20000aec 	.word	0x20000aec
  405720:	20002448 	.word	0x20002448
  405724:	e000ed00 	.word	0xe000ed00
  405728:	00400000 	.word	0x00400000
  40572c:	00405eb1 	.word	0x00405eb1
  405730:	004058d1 	.word	0x004058d1

00405734 <SystemCoreClockUpdate>:
 * \brief Get Core Clock Frequency.
 */
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
  405734:	4b32      	ldr	r3, [pc, #200]	; (405800 <SystemCoreClockUpdate+0xcc>)
  405736:	6b1a      	ldr	r2, [r3, #48]	; 0x30
  405738:	f002 0203 	and.w	r2, r2, #3
  40573c:	2a01      	cmp	r2, #1
  40573e:	d03a      	beq.n	4057b6 <SystemCoreClockUpdate+0x82>
  405740:	d323      	bcc.n	40578a <SystemCoreClockUpdate+0x56>
		}
		break;
		
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  405742:	6a1a      	ldr	r2, [r3, #32]
  405744:	01d2      	lsls	r2, r2, #7
  405746:	d547      	bpl.n	4057d8 <SystemCoreClockUpdate+0xa4>
				SystemCoreClock = CHIP_FREQ_XTAL;
  405748:	4a2e      	ldr	r2, [pc, #184]	; (405804 <SystemCoreClockUpdate+0xd0>)
  40574a:	482f      	ldr	r0, [pc, #188]	; (405808 <SystemCoreClockUpdate+0xd4>)
  40574c:	6010      	str	r0, [r2, #0]
				default:
					break;
				}
			}
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
  40574e:	4b2c      	ldr	r3, [pc, #176]	; (405800 <SystemCoreClockUpdate+0xcc>)
  405750:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405752:	f001 0103 	and.w	r1, r1, #3
  405756:	2902      	cmp	r1, #2
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
  405758:	bf0b      	itete	eq
  40575a:	6a99      	ldreq	r1, [r3, #40]	; 0x28
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  40575c:	6ad9      	ldrne	r1, [r3, #44]	; 0x2c
			
			if ( (uint32_t)(PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk) ==
					PMC_MCKR_CSS_PLLA_CLK ) {
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
  40575e:	6a9b      	ldreq	r3, [r3, #40]	; 0x28
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405760:	6adb      	ldrne	r3, [r3, #44]	; 0x2c
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
  405762:	f3c1 410a 	ubfx	r1, r1, #16, #11
				SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk)
						>> CKGR_PLLAR_MULA_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
  405766:	fb01 0000 	mla	r0, r1, r0, r0
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
						>> CKGR_PLLBR_DIVB_Pos));
  40576a:	b2db      	uxtb	r3, r3
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  40576c:	fbb0 f0f3 	udiv	r0, r0, r3
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405770:	4b23      	ldr	r3, [pc, #140]	; (405800 <SystemCoreClockUpdate+0xcc>)
				SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk)
						>> CKGR_PLLAR_DIVA_Pos));
			} else {
				SystemCoreClock *= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_MULB_Msk)
						>> CKGR_PLLBR_MULB_Pos) + 1U);
				SystemCoreClock /= ((((PMC->CKGR_PLLBR) & CKGR_PLLBR_DIVB_Msk)
  405772:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  405774:	6b19      	ldr	r1, [r3, #48]	; 0x30
  405776:	f001 0170 	and.w	r1, r1, #112	; 0x70
  40577a:	2970      	cmp	r1, #112	; 0x70
  40577c:	d115      	bne.n	4057aa <SystemCoreClockUpdate+0x76>
		SystemCoreClock /= 3U;
  40577e:	4b23      	ldr	r3, [pc, #140]	; (40580c <SystemCoreClockUpdate+0xd8>)
  405780:	fba3 1000 	umull	r1, r0, r3, r0
  405784:	0840      	lsrs	r0, r0, #1
  405786:	6010      	str	r0, [r2, #0]
  405788:	4770      	bx	lr
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40578a:	4b21      	ldr	r3, [pc, #132]	; (405810 <SystemCoreClockUpdate+0xdc>)
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  40578c:	4a1d      	ldr	r2, [pc, #116]	; (405804 <SystemCoreClockUpdate+0xd0>)
void SystemCoreClockUpdate( void )
{
	/* Determine clock frequency according to clock register values */
	switch ( PMC->PMC_MCKR & (uint32_t) PMC_MCKR_CSS_Msk ) {
	case PMC_MCKR_CSS_SLOW_CLK: /* Slow clock */
			if ( SUPC->SUPC_SR & SUPC_SR_OSCSEL ) {
  40578e:	695b      	ldr	r3, [r3, #20]
  405790:	061b      	lsls	r3, r3, #24
				SystemCoreClock = CHIP_FREQ_XTAL_32K;
  405792:	bf4c      	ite	mi
  405794:	f44f 4000 	movmi.w	r0, #32768	; 0x8000
			} else {
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
  405798:	f44f 40fa 	movpl.w	r0, #32000	; 0x7d00
  40579c:	6010      	str	r0, [r2, #0]
		
	default:
		break;
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
  40579e:	4b18      	ldr	r3, [pc, #96]	; (405800 <SystemCoreClockUpdate+0xcc>)
  4057a0:	6b19      	ldr	r1, [r3, #48]	; 0x30
  4057a2:	f001 0170 	and.w	r1, r1, #112	; 0x70
  4057a6:	2970      	cmp	r1, #112	; 0x70
  4057a8:	d0e9      	beq.n	40577e <SystemCoreClockUpdate+0x4a>
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
			((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> PMC_MCKR_PRES_Pos);
  4057aa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
  4057ac:	f3c3 1302 	ubfx	r3, r3, #4, #3
	}

	if ( (PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3 ) {
		SystemCoreClock /= 3U;
	} else {
		SystemCoreClock >>=
  4057b0:	40d8      	lsrs	r0, r3
  4057b2:	6010      	str	r0, [r2, #0]
  4057b4:	4770      	bx	lr
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4057b6:	6a1a      	ldr	r2, [r3, #32]
  4057b8:	f012 7f80 	tst.w	r2, #16777216	; 0x1000000
			SystemCoreClock = CHIP_FREQ_XTAL;
  4057bc:	4a11      	ldr	r2, [pc, #68]	; (405804 <SystemCoreClockUpdate+0xd0>)
				SystemCoreClock = CHIP_FREQ_SLCK_RC;
			}
		break;
		
	case PMC_MCKR_CSS_MAIN_CLK: /* Main clock */
		if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
  4057be:	d108      	bne.n	4057d2 <SystemCoreClockUpdate+0x9e>
			SystemCoreClock = CHIP_FREQ_XTAL;
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4057c0:	4814      	ldr	r0, [pc, #80]	; (405814 <SystemCoreClockUpdate+0xe0>)
  4057c2:	6010      	str	r0, [r2, #0]
			
			switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4057c4:	6a1b      	ldr	r3, [r3, #32]
  4057c6:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4057ca:	2b10      	cmp	r3, #16
  4057cc:	d014      	beq.n	4057f8 <SystemCoreClockUpdate+0xc4>
  4057ce:	2b20      	cmp	r3, #32
  4057d0:	d1e5      	bne.n	40579e <SystemCoreClockUpdate+0x6a>
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4057d2:	480d      	ldr	r0, [pc, #52]	; (405808 <SystemCoreClockUpdate+0xd4>)
  4057d4:	6010      	str	r0, [r2, #0]
			break;
  4057d6:	e7e2      	b.n	40579e <SystemCoreClockUpdate+0x6a>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_PLLB_CLK:	/* PLLB clock */
			if ( PMC->CKGR_MOR & CKGR_MOR_MOSCSEL ) {
				SystemCoreClock = CHIP_FREQ_XTAL;
			} else {
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
  4057d8:	4a0a      	ldr	r2, [pc, #40]	; (405804 <SystemCoreClockUpdate+0xd0>)
  4057da:	480e      	ldr	r0, [pc, #56]	; (405814 <SystemCoreClockUpdate+0xe0>)
  4057dc:	6010      	str	r0, [r2, #0]
				
				switch ( PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk ) {
  4057de:	6a1b      	ldr	r3, [r3, #32]
  4057e0:	f003 0370 	and.w	r3, r3, #112	; 0x70
  4057e4:	2b10      	cmp	r3, #16
  4057e6:	d004      	beq.n	4057f2 <SystemCoreClockUpdate+0xbe>
  4057e8:	2b20      	cmp	r3, #32
  4057ea:	d1b0      	bne.n	40574e <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_12_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_12MHZ;
  4057ec:	4806      	ldr	r0, [pc, #24]	; (405808 <SystemCoreClockUpdate+0xd4>)
  4057ee:	6010      	str	r0, [r2, #0]
					break;
  4057f0:	e7ad      	b.n	40574e <SystemCoreClockUpdate+0x1a>
				case CKGR_MOR_MOSCRCF_4_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
					break;
				
				case CKGR_MOR_MOSCRCF_8_MHz:
					SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4057f2:	4809      	ldr	r0, [pc, #36]	; (405818 <SystemCoreClockUpdate+0xe4>)
  4057f4:	6010      	str	r0, [r2, #0]
					break;
  4057f6:	e7aa      	b.n	40574e <SystemCoreClockUpdate+0x1a>
			case CKGR_MOR_MOSCRCF_4_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
			break;
			
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock = CHIP_FREQ_MAINCK_RC_8MHZ;
  4057f8:	4807      	ldr	r0, [pc, #28]	; (405818 <SystemCoreClockUpdate+0xe4>)
  4057fa:	6010      	str	r0, [r2, #0]
			break;
  4057fc:	e7cf      	b.n	40579e <SystemCoreClockUpdate+0x6a>
  4057fe:	bf00      	nop
  405800:	400e0400 	.word	0x400e0400
  405804:	200002ac 	.word	0x200002ac
  405808:	00b71b00 	.word	0x00b71b00
  40580c:	aaaaaaab 	.word	0xaaaaaaab
  405810:	400e1410 	.word	0x400e1410
  405814:	003d0900 	.word	0x003d0900
  405818:	007a1200 	.word	0x007a1200

0040581c <system_init_flash>:
 */
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
  40581c:	4b0f      	ldr	r3, [pc, #60]	; (40585c <system_init_flash+0x40>)
  40581e:	4298      	cmp	r0, r3
  405820:	d912      	bls.n	405848 <system_init_flash+0x2c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
  405822:	4b0f      	ldr	r3, [pc, #60]	; (405860 <system_init_flash+0x44>)
  405824:	4298      	cmp	r0, r3
  405826:	d90b      	bls.n	405840 <system_init_flash+0x24>
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
  405828:	4b0e      	ldr	r3, [pc, #56]	; (405864 <system_init_flash+0x48>)
  40582a:	4298      	cmp	r0, r3
  40582c:	d911      	bls.n	405852 <system_init_flash+0x36>
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
  40582e:	4b0e      	ldr	r3, [pc, #56]	; (405868 <system_init_flash+0x4c>)
  405830:	4298      	cmp	r0, r3
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  405832:	4b0e      	ldr	r3, [pc, #56]	; (40586c <system_init_flash+0x50>)
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  405834:	bf8c      	ite	hi
  405836:	4a0e      	ldrhi	r2, [pc, #56]	; (405870 <system_init_flash+0x54>)
			} else {
				if ( ul_clk < CHIP_FREQ_FWS_3 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(3)|EEFC_FMR_CLOE;
				} else {
					if ( ul_clk < CHIP_FREQ_FWS_4 ) {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(4)|EEFC_FMR_CLOE;
  405838:	f04f 2204 	movls.w	r2, #67109888	; 0x4000400
					} else {
					EFC0->EEFC_FMR = EEFC_FMR_FWS(5)|EEFC_FMR_CLOE;
  40583c:	601a      	str	r2, [r3, #0]
  40583e:	4770      	bx	lr
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
  405840:	4b0a      	ldr	r3, [pc, #40]	; (40586c <system_init_flash+0x50>)
  405842:	4a0c      	ldr	r2, [pc, #48]	; (405874 <system_init_flash+0x58>)
  405844:	601a      	str	r2, [r3, #0]
  405846:	4770      	bx	lr
void system_init_flash( uint32_t ul_clk )
{
  /* Set FWS for embedded Flash access according to operating frequency */
#if !defined(ID_EFC1)
	if ( ul_clk < CHIP_FREQ_FWS_0 ) {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0)|EEFC_FMR_CLOE;
  405848:	4b08      	ldr	r3, [pc, #32]	; (40586c <system_init_flash+0x50>)
  40584a:	f04f 6280 	mov.w	r2, #67108864	; 0x4000000
  40584e:	601a      	str	r2, [r3, #0]
  405850:	4770      	bx	lr
	} else {
		if ( ul_clk < CHIP_FREQ_FWS_1 ) {
			EFC0->EEFC_FMR = EEFC_FMR_FWS(1)|EEFC_FMR_CLOE;
		} else {
			if ( ul_clk < CHIP_FREQ_FWS_2 ) {
				EFC0->EEFC_FMR = EEFC_FMR_FWS(2)|EEFC_FMR_CLOE;
  405852:	4b06      	ldr	r3, [pc, #24]	; (40586c <system_init_flash+0x50>)
  405854:	4a08      	ldr	r2, [pc, #32]	; (405878 <system_init_flash+0x5c>)
  405856:	601a      	str	r2, [r3, #0]
  405858:	4770      	bx	lr
  40585a:	bf00      	nop
  40585c:	01ba813f 	.word	0x01ba813f
  405860:	0375027f 	.word	0x0375027f
  405864:	053ec5ff 	.word	0x053ec5ff
  405868:	07270dff 	.word	0x07270dff
  40586c:	400e0a00 	.word	0x400e0a00
  405870:	04000500 	.word	0x04000500
  405874:	04000100 	.word	0x04000100
  405878:	04000200 	.word	0x04000200

0040587c <_sbrk>:
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
  40587c:	4a07      	ldr	r2, [pc, #28]	; (40589c <_sbrk+0x20>)

extern caddr_t _sbrk(int incr)
{
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;
  40587e:	4908      	ldr	r1, [pc, #32]	; (4058a0 <_sbrk+0x24>)

	if (heap == NULL) {
  405880:	6813      	ldr	r3, [r2, #0]
  405882:	b13b      	cbz	r3, 405894 <_sbrk+0x18>
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
  405884:	4418      	add	r0, r3
  405886:	4281      	cmp	r1, r0
		return (caddr_t) -1;	
	}

	heap += incr;
  405888:	bfa6      	itte	ge
  40588a:	6010      	strge	r0, [r2, #0]

	return (caddr_t) prev_heap;
  40588c:	4618      	movge	r0, r3
		heap = (unsigned char *)&_end;
	}
	prev_heap = heap;

	if (((int)prev_heap + incr) > ramend) {
		return (caddr_t) -1;	
  40588e:	f04f 30ff 	movlt.w	r0, #4294967295
	}

	heap += incr;

	return (caddr_t) prev_heap;
}
  405892:	4770      	bx	lr
	static unsigned char *heap = NULL;
	unsigned char *prev_heap;
	int ramend = (int)&__ram_end__;

	if (heap == NULL) {
		heap = (unsigned char *)&_end;
  405894:	4b03      	ldr	r3, [pc, #12]	; (4058a4 <_sbrk+0x28>)
  405896:	6013      	str	r3, [r2, #0]
  405898:	e7f4      	b.n	405884 <_sbrk+0x8>
  40589a:	bf00      	nop
  40589c:	20001154 	.word	0x20001154
  4058a0:	2000fffc 	.word	0x2000fffc
  4058a4:	20005448 	.word	0x20005448

004058a8 <HardFault_Handler>:
extern drv_uart_config_t usart1Config;
extern brainSettings_t brainSettings; 
volatile unsigned long sgSysTickCount = 0;

void HardFault_Handler()
{
  4058a8:	e7fe      	b.n	4058a8 <HardFault_Handler>
  4058aa:	bf00      	nop

004058ac <MemManage_Handler>:
	while(1); 
}
void MemManage_Handler()
{
  4058ac:	e7fe      	b.n	4058ac <MemManage_Handler>
  4058ae:	bf00      	nop

004058b0 <BusFault_Handler>:
	while(1); 
}
void BusFault_Handler()
{
  4058b0:	e7fe      	b.n	4058b0 <BusFault_Handler>
  4058b2:	bf00      	nop

004058b4 <UsageFault_Handler>:
	while(1); 
}
void UsageFault_Handler()
{
  4058b4:	e7fe      	b.n	4058b4 <UsageFault_Handler>
  4058b6:	bf00      	nop

004058b8 <SysTick_Handler>:

/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
  4058b8:	b508      	push	{r3, lr}
	sgSysTickCount++;
  4058ba:	4b03      	ldr	r3, [pc, #12]	; (4058c8 <SysTick_Handler+0x10>)
	xPortSysTickHandler();
  4058bc:	4a03      	ldr	r2, [pc, #12]	; (4058cc <SysTick_Handler+0x14>)
/**
 * \brief Handler for System Tick interrupt.
 */
void SysTick_Handler(void)
{
	sgSysTickCount++;
  4058be:	6819      	ldr	r1, [r3, #0]
  4058c0:	3101      	adds	r1, #1
  4058c2:	6019      	str	r1, [r3, #0]
	xPortSysTickHandler();
  4058c4:	4790      	blx	r2
  4058c6:	bd08      	pop	{r3, pc}
  4058c8:	20001158 	.word	0x20001158
  4058cc:	00403ef5 	.word	0x00403ef5

004058d0 <main>:
}


int main (void)
{
  4058d0:	b508      	push	{r3, lr}
	irq_initialize_vectors();
	cpu_irq_enable();
  4058d2:	4b07      	ldr	r3, [pc, #28]	; (4058f0 <main+0x20>)
  4058d4:	2201      	movs	r2, #1
  4058d6:	701a      	strb	r2, [r3, #0]
    This function ensures the apparent order of the explicit memory operations before
    and after the instruction, without ensuring their completion.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
{
  __ASM volatile ("dmb");
  4058d8:	f3bf 8f5f 	dmb	sy
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
  4058dc:	b662      	cpsie	i
	//Initialize system clock and peripherals
	sysclk_init();
  4058de:	4b05      	ldr	r3, [pc, #20]	; (4058f4 <main+0x24>)
  4058e0:	4c05      	ldr	r4, [pc, #20]	; (4058f8 <main+0x28>)
  4058e2:	4798      	blx	r3
	#ifdef COMPILE_AS_BOOTLOADER
	runBootloader(); 
  4058e4:	4b05      	ldr	r3, [pc, #20]	; (4058fc <main+0x2c>)
  4058e6:	4798      	blx	r3
	#endif
	//we should never get here. 
	/*	Debug code */
	while (1) 
	{		
		delay_ms(1000);
  4058e8:	4805      	ldr	r0, [pc, #20]	; (405900 <main+0x30>)
  4058ea:	47a0      	blx	r4
  4058ec:	e7fc      	b.n	4058e8 <main+0x18>
  4058ee:	bf00      	nop
  4058f0:	200002a8 	.word	0x200002a8
  4058f4:	004050d5 	.word	0x004050d5
  4058f8:	20000085 	.word	0x20000085
  4058fc:	00400c25 	.word	0x00400c25
  405900:	0082ca25 	.word	0x0082ca25

00405904 <__aeabi_uldivmod>:
  405904:	b94b      	cbnz	r3, 40591a <__aeabi_uldivmod+0x16>
  405906:	b942      	cbnz	r2, 40591a <__aeabi_uldivmod+0x16>
  405908:	2900      	cmp	r1, #0
  40590a:	bf08      	it	eq
  40590c:	2800      	cmpeq	r0, #0
  40590e:	d002      	beq.n	405916 <__aeabi_uldivmod+0x12>
  405910:	f04f 31ff 	mov.w	r1, #4294967295
  405914:	4608      	mov	r0, r1
  405916:	f000 b83b 	b.w	405990 <__aeabi_idiv0>
  40591a:	b082      	sub	sp, #8
  40591c:	46ec      	mov	ip, sp
  40591e:	e92d 5000 	stmdb	sp!, {ip, lr}
  405922:	f000 f81d 	bl	405960 <__gnu_uldivmod_helper>
  405926:	f8dd e004 	ldr.w	lr, [sp, #4]
  40592a:	b002      	add	sp, #8
  40592c:	bc0c      	pop	{r2, r3}
  40592e:	4770      	bx	lr

00405930 <__gnu_ldivmod_helper>:
  405930:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405934:	9e06      	ldr	r6, [sp, #24]
  405936:	4614      	mov	r4, r2
  405938:	461d      	mov	r5, r3
  40593a:	4680      	mov	r8, r0
  40593c:	4689      	mov	r9, r1
  40593e:	f000 f829 	bl	405994 <__divdi3>
  405942:	fb04 f301 	mul.w	r3, r4, r1
  405946:	fb00 3305 	mla	r3, r0, r5, r3
  40594a:	fba4 4500 	umull	r4, r5, r4, r0
  40594e:	441d      	add	r5, r3
  405950:	ebb8 0404 	subs.w	r4, r8, r4
  405954:	eb69 0505 	sbc.w	r5, r9, r5
  405958:	e9c6 4500 	strd	r4, r5, [r6]
  40595c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405960 <__gnu_uldivmod_helper>:
  405960:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
  405964:	9e06      	ldr	r6, [sp, #24]
  405966:	4614      	mov	r4, r2
  405968:	4680      	mov	r8, r0
  40596a:	4689      	mov	r9, r1
  40596c:	461d      	mov	r5, r3
  40596e:	f000 f95d 	bl	405c2c <__udivdi3>
  405972:	fb00 f505 	mul.w	r5, r0, r5
  405976:	fb04 5301 	mla	r3, r4, r1, r5
  40597a:	fba0 4504 	umull	r4, r5, r0, r4
  40597e:	441d      	add	r5, r3
  405980:	ebb8 0404 	subs.w	r4, r8, r4
  405984:	eb69 0505 	sbc.w	r5, r9, r5
  405988:	e9c6 4500 	strd	r4, r5, [r6]
  40598c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

00405990 <__aeabi_idiv0>:
  405990:	4770      	bx	lr
  405992:	bf00      	nop

00405994 <__divdi3>:
  405994:	2900      	cmp	r1, #0
  405996:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  40599a:	f2c0 809f 	blt.w	405adc <__divdi3+0x148>
  40599e:	2400      	movs	r4, #0
  4059a0:	2b00      	cmp	r3, #0
  4059a2:	f2c0 8096 	blt.w	405ad2 <__divdi3+0x13e>
  4059a6:	4615      	mov	r5, r2
  4059a8:	4606      	mov	r6, r0
  4059aa:	460f      	mov	r7, r1
  4059ac:	2b00      	cmp	r3, #0
  4059ae:	d13e      	bne.n	405a2e <__divdi3+0x9a>
  4059b0:	428a      	cmp	r2, r1
  4059b2:	d957      	bls.n	405a64 <__divdi3+0xd0>
  4059b4:	fab2 f382 	clz	r3, r2
  4059b8:	b14b      	cbz	r3, 4059ce <__divdi3+0x3a>
  4059ba:	f1c3 0220 	rsb	r2, r3, #32
  4059be:	fa01 f703 	lsl.w	r7, r1, r3
  4059c2:	fa20 f202 	lsr.w	r2, r0, r2
  4059c6:	409d      	lsls	r5, r3
  4059c8:	4317      	orrs	r7, r2
  4059ca:	fa00 f603 	lsl.w	r6, r0, r3
  4059ce:	0c29      	lsrs	r1, r5, #16
  4059d0:	fbb7 f2f1 	udiv	r2, r7, r1
  4059d4:	0c33      	lsrs	r3, r6, #16
  4059d6:	fb01 7c12 	mls	ip, r1, r2, r7
  4059da:	b2a8      	uxth	r0, r5
  4059dc:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
  4059e0:	fb00 f302 	mul.w	r3, r0, r2
  4059e4:	42bb      	cmp	r3, r7
  4059e6:	d909      	bls.n	4059fc <__divdi3+0x68>
  4059e8:	197f      	adds	r7, r7, r5
  4059ea:	f102 3cff 	add.w	ip, r2, #4294967295
  4059ee:	f080 8101 	bcs.w	405bf4 <__divdi3+0x260>
  4059f2:	42bb      	cmp	r3, r7
  4059f4:	f240 80fe 	bls.w	405bf4 <__divdi3+0x260>
  4059f8:	3a02      	subs	r2, #2
  4059fa:	442f      	add	r7, r5
  4059fc:	1aff      	subs	r7, r7, r3
  4059fe:	fbb7 f3f1 	udiv	r3, r7, r1
  405a02:	b2b6      	uxth	r6, r6
  405a04:	fb01 7113 	mls	r1, r1, r3, r7
  405a08:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
  405a0c:	fb00 f003 	mul.w	r0, r0, r3
  405a10:	4288      	cmp	r0, r1
  405a12:	d908      	bls.n	405a26 <__divdi3+0x92>
  405a14:	1949      	adds	r1, r1, r5
  405a16:	f103 37ff 	add.w	r7, r3, #4294967295
  405a1a:	f080 80ed 	bcs.w	405bf8 <__divdi3+0x264>
  405a1e:	4288      	cmp	r0, r1
  405a20:	f240 80ea 	bls.w	405bf8 <__divdi3+0x264>
  405a24:	3b02      	subs	r3, #2
  405a26:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  405a2a:	2300      	movs	r3, #0
  405a2c:	e003      	b.n	405a36 <__divdi3+0xa2>
  405a2e:	428b      	cmp	r3, r1
  405a30:	d90a      	bls.n	405a48 <__divdi3+0xb4>
  405a32:	2300      	movs	r3, #0
  405a34:	461a      	mov	r2, r3
  405a36:	4610      	mov	r0, r2
  405a38:	4619      	mov	r1, r3
  405a3a:	b114      	cbz	r4, 405a42 <__divdi3+0xae>
  405a3c:	4240      	negs	r0, r0
  405a3e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  405a42:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405a46:	4770      	bx	lr
  405a48:	fab3 f883 	clz	r8, r3
  405a4c:	f1b8 0f00 	cmp.w	r8, #0
  405a50:	f040 8084 	bne.w	405b5c <__divdi3+0x1c8>
  405a54:	428b      	cmp	r3, r1
  405a56:	d302      	bcc.n	405a5e <__divdi3+0xca>
  405a58:	4282      	cmp	r2, r0
  405a5a:	f200 80de 	bhi.w	405c1a <__divdi3+0x286>
  405a5e:	2300      	movs	r3, #0
  405a60:	2201      	movs	r2, #1
  405a62:	e7e8      	b.n	405a36 <__divdi3+0xa2>
  405a64:	b912      	cbnz	r2, 405a6c <__divdi3+0xd8>
  405a66:	2301      	movs	r3, #1
  405a68:	fbb3 f5f2 	udiv	r5, r3, r2
  405a6c:	fab5 f285 	clz	r2, r5
  405a70:	2a00      	cmp	r2, #0
  405a72:	d139      	bne.n	405ae8 <__divdi3+0x154>
  405a74:	1b7f      	subs	r7, r7, r5
  405a76:	0c28      	lsrs	r0, r5, #16
  405a78:	fa1f fc85 	uxth.w	ip, r5
  405a7c:	2301      	movs	r3, #1
  405a7e:	fbb7 f1f0 	udiv	r1, r7, r0
  405a82:	0c32      	lsrs	r2, r6, #16
  405a84:	fb00 7711 	mls	r7, r0, r1, r7
  405a88:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
  405a8c:	fb0c f201 	mul.w	r2, ip, r1
  405a90:	42ba      	cmp	r2, r7
  405a92:	d907      	bls.n	405aa4 <__divdi3+0x110>
  405a94:	197f      	adds	r7, r7, r5
  405a96:	f101 38ff 	add.w	r8, r1, #4294967295
  405a9a:	d202      	bcs.n	405aa2 <__divdi3+0x10e>
  405a9c:	42ba      	cmp	r2, r7
  405a9e:	f200 80c1 	bhi.w	405c24 <__divdi3+0x290>
  405aa2:	4641      	mov	r1, r8
  405aa4:	1abf      	subs	r7, r7, r2
  405aa6:	fbb7 f2f0 	udiv	r2, r7, r0
  405aaa:	b2b6      	uxth	r6, r6
  405aac:	fb00 7012 	mls	r0, r0, r2, r7
  405ab0:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
  405ab4:	fb0c fc02 	mul.w	ip, ip, r2
  405ab8:	4584      	cmp	ip, r0
  405aba:	d907      	bls.n	405acc <__divdi3+0x138>
  405abc:	1940      	adds	r0, r0, r5
  405abe:	f102 37ff 	add.w	r7, r2, #4294967295
  405ac2:	d202      	bcs.n	405aca <__divdi3+0x136>
  405ac4:	4584      	cmp	ip, r0
  405ac6:	f200 80ab 	bhi.w	405c20 <__divdi3+0x28c>
  405aca:	463a      	mov	r2, r7
  405acc:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
  405ad0:	e7b1      	b.n	405a36 <__divdi3+0xa2>
  405ad2:	43e4      	mvns	r4, r4
  405ad4:	4252      	negs	r2, r2
  405ad6:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
  405ada:	e764      	b.n	4059a6 <__divdi3+0x12>
  405adc:	4240      	negs	r0, r0
  405ade:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
  405ae2:	f04f 34ff 	mov.w	r4, #4294967295
  405ae6:	e75b      	b.n	4059a0 <__divdi3+0xc>
  405ae8:	4095      	lsls	r5, r2
  405aea:	f1c2 0320 	rsb	r3, r2, #32
  405aee:	fa27 f103 	lsr.w	r1, r7, r3
  405af2:	0c28      	lsrs	r0, r5, #16
  405af4:	fa26 f303 	lsr.w	r3, r6, r3
  405af8:	4097      	lsls	r7, r2
  405afa:	fbb1 f8f0 	udiv	r8, r1, r0
  405afe:	431f      	orrs	r7, r3
  405b00:	0c3b      	lsrs	r3, r7, #16
  405b02:	fb00 1118 	mls	r1, r0, r8, r1
  405b06:	fa1f fc85 	uxth.w	ip, r5
  405b0a:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
  405b0e:	fb0c f308 	mul.w	r3, ip, r8
  405b12:	428b      	cmp	r3, r1
  405b14:	fa06 f602 	lsl.w	r6, r6, r2
  405b18:	d908      	bls.n	405b2c <__divdi3+0x198>
  405b1a:	1949      	adds	r1, r1, r5
  405b1c:	f108 32ff 	add.w	r2, r8, #4294967295
  405b20:	d279      	bcs.n	405c16 <__divdi3+0x282>
  405b22:	428b      	cmp	r3, r1
  405b24:	d977      	bls.n	405c16 <__divdi3+0x282>
  405b26:	f1a8 0802 	sub.w	r8, r8, #2
  405b2a:	4429      	add	r1, r5
  405b2c:	1ac9      	subs	r1, r1, r3
  405b2e:	fbb1 f3f0 	udiv	r3, r1, r0
  405b32:	b2bf      	uxth	r7, r7
  405b34:	fb00 1113 	mls	r1, r0, r3, r1
  405b38:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
  405b3c:	fb0c f203 	mul.w	r2, ip, r3
  405b40:	42ba      	cmp	r2, r7
  405b42:	d907      	bls.n	405b54 <__divdi3+0x1c0>
  405b44:	197f      	adds	r7, r7, r5
  405b46:	f103 31ff 	add.w	r1, r3, #4294967295
  405b4a:	d260      	bcs.n	405c0e <__divdi3+0x27a>
  405b4c:	42ba      	cmp	r2, r7
  405b4e:	d95e      	bls.n	405c0e <__divdi3+0x27a>
  405b50:	3b02      	subs	r3, #2
  405b52:	442f      	add	r7, r5
  405b54:	1abf      	subs	r7, r7, r2
  405b56:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  405b5a:	e790      	b.n	405a7e <__divdi3+0xea>
  405b5c:	f1c8 0220 	rsb	r2, r8, #32
  405b60:	fa03 fc08 	lsl.w	ip, r3, r8
  405b64:	fa25 f302 	lsr.w	r3, r5, r2
  405b68:	ea43 0c0c 	orr.w	ip, r3, ip
  405b6c:	ea4f 491c 	mov.w	r9, ip, lsr #16
  405b70:	fa21 f302 	lsr.w	r3, r1, r2
  405b74:	fa01 f708 	lsl.w	r7, r1, r8
  405b78:	fa20 f202 	lsr.w	r2, r0, r2
  405b7c:	fbb3 f1f9 	udiv	r1, r3, r9
  405b80:	4317      	orrs	r7, r2
  405b82:	fb09 3311 	mls	r3, r9, r1, r3
  405b86:	0c3a      	lsrs	r2, r7, #16
  405b88:	fa1f fb8c 	uxth.w	fp, ip
  405b8c:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
  405b90:	fb0b fa01 	mul.w	sl, fp, r1
  405b94:	459a      	cmp	sl, r3
  405b96:	fa05 f008 	lsl.w	r0, r5, r8
  405b9a:	d908      	bls.n	405bae <__divdi3+0x21a>
  405b9c:	eb13 030c 	adds.w	r3, r3, ip
  405ba0:	f101 32ff 	add.w	r2, r1, #4294967295
  405ba4:	d235      	bcs.n	405c12 <__divdi3+0x27e>
  405ba6:	459a      	cmp	sl, r3
  405ba8:	d933      	bls.n	405c12 <__divdi3+0x27e>
  405baa:	3902      	subs	r1, #2
  405bac:	4463      	add	r3, ip
  405bae:	ebca 0303 	rsb	r3, sl, r3
  405bb2:	fbb3 f2f9 	udiv	r2, r3, r9
  405bb6:	fb09 3312 	mls	r3, r9, r2, r3
  405bba:	b2bf      	uxth	r7, r7
  405bbc:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405bc0:	fb0b f902 	mul.w	r9, fp, r2
  405bc4:	45b9      	cmp	r9, r7
  405bc6:	d908      	bls.n	405bda <__divdi3+0x246>
  405bc8:	eb17 070c 	adds.w	r7, r7, ip
  405bcc:	f102 33ff 	add.w	r3, r2, #4294967295
  405bd0:	d21b      	bcs.n	405c0a <__divdi3+0x276>
  405bd2:	45b9      	cmp	r9, r7
  405bd4:	d919      	bls.n	405c0a <__divdi3+0x276>
  405bd6:	3a02      	subs	r2, #2
  405bd8:	4467      	add	r7, ip
  405bda:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
  405bde:	fba5 0100 	umull	r0, r1, r5, r0
  405be2:	ebc9 0707 	rsb	r7, r9, r7
  405be6:	428f      	cmp	r7, r1
  405be8:	f04f 0300 	mov.w	r3, #0
  405bec:	d30a      	bcc.n	405c04 <__divdi3+0x270>
  405bee:	d005      	beq.n	405bfc <__divdi3+0x268>
  405bf0:	462a      	mov	r2, r5
  405bf2:	e720      	b.n	405a36 <__divdi3+0xa2>
  405bf4:	4662      	mov	r2, ip
  405bf6:	e701      	b.n	4059fc <__divdi3+0x68>
  405bf8:	463b      	mov	r3, r7
  405bfa:	e714      	b.n	405a26 <__divdi3+0x92>
  405bfc:	fa06 f608 	lsl.w	r6, r6, r8
  405c00:	4286      	cmp	r6, r0
  405c02:	d2f5      	bcs.n	405bf0 <__divdi3+0x25c>
  405c04:	1e6a      	subs	r2, r5, #1
  405c06:	2300      	movs	r3, #0
  405c08:	e715      	b.n	405a36 <__divdi3+0xa2>
  405c0a:	461a      	mov	r2, r3
  405c0c:	e7e5      	b.n	405bda <__divdi3+0x246>
  405c0e:	460b      	mov	r3, r1
  405c10:	e7a0      	b.n	405b54 <__divdi3+0x1c0>
  405c12:	4611      	mov	r1, r2
  405c14:	e7cb      	b.n	405bae <__divdi3+0x21a>
  405c16:	4690      	mov	r8, r2
  405c18:	e788      	b.n	405b2c <__divdi3+0x198>
  405c1a:	4643      	mov	r3, r8
  405c1c:	4642      	mov	r2, r8
  405c1e:	e70a      	b.n	405a36 <__divdi3+0xa2>
  405c20:	3a02      	subs	r2, #2
  405c22:	e753      	b.n	405acc <__divdi3+0x138>
  405c24:	3902      	subs	r1, #2
  405c26:	442f      	add	r7, r5
  405c28:	e73c      	b.n	405aa4 <__divdi3+0x110>
  405c2a:	bf00      	nop

00405c2c <__udivdi3>:
  405c2c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405c30:	4614      	mov	r4, r2
  405c32:	4605      	mov	r5, r0
  405c34:	460e      	mov	r6, r1
  405c36:	2b00      	cmp	r3, #0
  405c38:	d143      	bne.n	405cc2 <__udivdi3+0x96>
  405c3a:	428a      	cmp	r2, r1
  405c3c:	d953      	bls.n	405ce6 <__udivdi3+0xba>
  405c3e:	fab2 f782 	clz	r7, r2
  405c42:	b157      	cbz	r7, 405c5a <__udivdi3+0x2e>
  405c44:	f1c7 0620 	rsb	r6, r7, #32
  405c48:	fa20 f606 	lsr.w	r6, r0, r6
  405c4c:	fa01 f307 	lsl.w	r3, r1, r7
  405c50:	fa02 f407 	lsl.w	r4, r2, r7
  405c54:	431e      	orrs	r6, r3
  405c56:	fa00 f507 	lsl.w	r5, r0, r7
  405c5a:	0c21      	lsrs	r1, r4, #16
  405c5c:	fbb6 f2f1 	udiv	r2, r6, r1
  405c60:	0c2b      	lsrs	r3, r5, #16
  405c62:	fb01 6712 	mls	r7, r1, r2, r6
  405c66:	b2a0      	uxth	r0, r4
  405c68:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
  405c6c:	fb00 f302 	mul.w	r3, r0, r2
  405c70:	42b3      	cmp	r3, r6
  405c72:	d909      	bls.n	405c88 <__udivdi3+0x5c>
  405c74:	1936      	adds	r6, r6, r4
  405c76:	f102 37ff 	add.w	r7, r2, #4294967295
  405c7a:	f080 80f6 	bcs.w	405e6a <__udivdi3+0x23e>
  405c7e:	42b3      	cmp	r3, r6
  405c80:	f240 80f3 	bls.w	405e6a <__udivdi3+0x23e>
  405c84:	3a02      	subs	r2, #2
  405c86:	4426      	add	r6, r4
  405c88:	1af6      	subs	r6, r6, r3
  405c8a:	fbb6 f3f1 	udiv	r3, r6, r1
  405c8e:	b2ad      	uxth	r5, r5
  405c90:	fb01 6113 	mls	r1, r1, r3, r6
  405c94:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
  405c98:	fb00 f003 	mul.w	r0, r0, r3
  405c9c:	4288      	cmp	r0, r1
  405c9e:	d908      	bls.n	405cb2 <__udivdi3+0x86>
  405ca0:	1909      	adds	r1, r1, r4
  405ca2:	f103 36ff 	add.w	r6, r3, #4294967295
  405ca6:	f080 80e2 	bcs.w	405e6e <__udivdi3+0x242>
  405caa:	4288      	cmp	r0, r1
  405cac:	f240 80df 	bls.w	405e6e <__udivdi3+0x242>
  405cb0:	3b02      	subs	r3, #2
  405cb2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
  405cb6:	2300      	movs	r3, #0
  405cb8:	4610      	mov	r0, r2
  405cba:	4619      	mov	r1, r3
  405cbc:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405cc0:	4770      	bx	lr
  405cc2:	428b      	cmp	r3, r1
  405cc4:	d84a      	bhi.n	405d5c <__udivdi3+0x130>
  405cc6:	fab3 f683 	clz	r6, r3
  405cca:	2e00      	cmp	r6, #0
  405ccc:	d14d      	bne.n	405d6a <__udivdi3+0x13e>
  405cce:	428b      	cmp	r3, r1
  405cd0:	d302      	bcc.n	405cd8 <__udivdi3+0xac>
  405cd2:	4282      	cmp	r2, r0
  405cd4:	f200 80d6 	bhi.w	405e84 <__udivdi3+0x258>
  405cd8:	2300      	movs	r3, #0
  405cda:	2201      	movs	r2, #1
  405cdc:	4610      	mov	r0, r2
  405cde:	4619      	mov	r1, r3
  405ce0:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405ce4:	4770      	bx	lr
  405ce6:	b912      	cbnz	r2, 405cee <__udivdi3+0xc2>
  405ce8:	2401      	movs	r4, #1
  405cea:	fbb4 f4f2 	udiv	r4, r4, r2
  405cee:	fab4 f284 	clz	r2, r4
  405cf2:	2a00      	cmp	r2, #0
  405cf4:	d17c      	bne.n	405df0 <__udivdi3+0x1c4>
  405cf6:	1b09      	subs	r1, r1, r4
  405cf8:	0c26      	lsrs	r6, r4, #16
  405cfa:	b2a7      	uxth	r7, r4
  405cfc:	2301      	movs	r3, #1
  405cfe:	fbb1 f0f6 	udiv	r0, r1, r6
  405d02:	0c2a      	lsrs	r2, r5, #16
  405d04:	fb06 1110 	mls	r1, r6, r0, r1
  405d08:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
  405d0c:	fb07 f200 	mul.w	r2, r7, r0
  405d10:	428a      	cmp	r2, r1
  405d12:	d907      	bls.n	405d24 <__udivdi3+0xf8>
  405d14:	1909      	adds	r1, r1, r4
  405d16:	f100 3cff 	add.w	ip, r0, #4294967295
  405d1a:	d202      	bcs.n	405d22 <__udivdi3+0xf6>
  405d1c:	428a      	cmp	r2, r1
  405d1e:	f200 80c3 	bhi.w	405ea8 <__udivdi3+0x27c>
  405d22:	4660      	mov	r0, ip
  405d24:	1a89      	subs	r1, r1, r2
  405d26:	fbb1 f2f6 	udiv	r2, r1, r6
  405d2a:	b2ad      	uxth	r5, r5
  405d2c:	fb06 1112 	mls	r1, r6, r2, r1
  405d30:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
  405d34:	fb07 f702 	mul.w	r7, r7, r2
  405d38:	42af      	cmp	r7, r5
  405d3a:	d908      	bls.n	405d4e <__udivdi3+0x122>
  405d3c:	192c      	adds	r4, r5, r4
  405d3e:	f102 31ff 	add.w	r1, r2, #4294967295
  405d42:	f080 8096 	bcs.w	405e72 <__udivdi3+0x246>
  405d46:	42a7      	cmp	r7, r4
  405d48:	f240 8093 	bls.w	405e72 <__udivdi3+0x246>
  405d4c:	3a02      	subs	r2, #2
  405d4e:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
  405d52:	4610      	mov	r0, r2
  405d54:	4619      	mov	r1, r3
  405d56:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405d5a:	4770      	bx	lr
  405d5c:	2300      	movs	r3, #0
  405d5e:	461a      	mov	r2, r3
  405d60:	4610      	mov	r0, r2
  405d62:	4619      	mov	r1, r3
  405d64:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  405d68:	4770      	bx	lr
  405d6a:	f1c6 0520 	rsb	r5, r6, #32
  405d6e:	fa22 f405 	lsr.w	r4, r2, r5
  405d72:	40b3      	lsls	r3, r6
  405d74:	431c      	orrs	r4, r3
  405d76:	ea4f 4814 	mov.w	r8, r4, lsr #16
  405d7a:	fa21 f305 	lsr.w	r3, r1, r5
  405d7e:	fa01 f706 	lsl.w	r7, r1, r6
  405d82:	fa20 f505 	lsr.w	r5, r0, r5
  405d86:	fbb3 fcf8 	udiv	ip, r3, r8
  405d8a:	432f      	orrs	r7, r5
  405d8c:	fb08 331c 	mls	r3, r8, ip, r3
  405d90:	0c3d      	lsrs	r5, r7, #16
  405d92:	fa1f fa84 	uxth.w	sl, r4
  405d96:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
  405d9a:	fb0a f90c 	mul.w	r9, sl, ip
  405d9e:	4599      	cmp	r9, r3
  405da0:	fa02 fb06 	lsl.w	fp, r2, r6
  405da4:	d904      	bls.n	405db0 <__udivdi3+0x184>
  405da6:	191b      	adds	r3, r3, r4
  405da8:	f10c 32ff 	add.w	r2, ip, #4294967295
  405dac:	d36d      	bcc.n	405e8a <__udivdi3+0x25e>
  405dae:	4694      	mov	ip, r2
  405db0:	ebc9 0303 	rsb	r3, r9, r3
  405db4:	fbb3 f5f8 	udiv	r5, r3, r8
  405db8:	fb08 3315 	mls	r3, r8, r5, r3
  405dbc:	b2bf      	uxth	r7, r7
  405dbe:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
  405dc2:	fb0a f805 	mul.w	r8, sl, r5
  405dc6:	45b8      	cmp	r8, r7
  405dc8:	d904      	bls.n	405dd4 <__udivdi3+0x1a8>
  405dca:	193f      	adds	r7, r7, r4
  405dcc:	f105 33ff 	add.w	r3, r5, #4294967295
  405dd0:	d361      	bcc.n	405e96 <__udivdi3+0x26a>
  405dd2:	461d      	mov	r5, r3
  405dd4:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
  405dd8:	fbac 230b 	umull	r2, r3, ip, fp
  405ddc:	ebc8 0707 	rsb	r7, r8, r7
  405de0:	429f      	cmp	r7, r3
  405de2:	f04f 0500 	mov.w	r5, #0
  405de6:	d349      	bcc.n	405e7c <__udivdi3+0x250>
  405de8:	d045      	beq.n	405e76 <__udivdi3+0x24a>
  405dea:	4662      	mov	r2, ip
  405dec:	462b      	mov	r3, r5
  405dee:	e763      	b.n	405cb8 <__udivdi3+0x8c>
  405df0:	4094      	lsls	r4, r2
  405df2:	f1c2 0320 	rsb	r3, r2, #32
  405df6:	fa21 fc03 	lsr.w	ip, r1, r3
  405dfa:	0c26      	lsrs	r6, r4, #16
  405dfc:	fa20 f303 	lsr.w	r3, r0, r3
  405e00:	fa01 f502 	lsl.w	r5, r1, r2
  405e04:	fbbc f8f6 	udiv	r8, ip, r6
  405e08:	ea43 0105 	orr.w	r1, r3, r5
  405e0c:	0c0b      	lsrs	r3, r1, #16
  405e0e:	fb06 cc18 	mls	ip, r6, r8, ip
  405e12:	b2a7      	uxth	r7, r4
  405e14:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
  405e18:	fb07 f308 	mul.w	r3, r7, r8
  405e1c:	4563      	cmp	r3, ip
  405e1e:	fa00 f502 	lsl.w	r5, r0, r2
  405e22:	d909      	bls.n	405e38 <__udivdi3+0x20c>
  405e24:	eb1c 0c04 	adds.w	ip, ip, r4
  405e28:	f108 32ff 	add.w	r2, r8, #4294967295
  405e2c:	d23a      	bcs.n	405ea4 <__udivdi3+0x278>
  405e2e:	4563      	cmp	r3, ip
  405e30:	d938      	bls.n	405ea4 <__udivdi3+0x278>
  405e32:	f1a8 0802 	sub.w	r8, r8, #2
  405e36:	44a4      	add	ip, r4
  405e38:	ebc3 0c0c 	rsb	ip, r3, ip
  405e3c:	fbbc f3f6 	udiv	r3, ip, r6
  405e40:	b289      	uxth	r1, r1
  405e42:	fb06 cc13 	mls	ip, r6, r3, ip
  405e46:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
  405e4a:	fb07 f203 	mul.w	r2, r7, r3
  405e4e:	428a      	cmp	r2, r1
  405e50:	d907      	bls.n	405e62 <__udivdi3+0x236>
  405e52:	1909      	adds	r1, r1, r4
  405e54:	f103 30ff 	add.w	r0, r3, #4294967295
  405e58:	d222      	bcs.n	405ea0 <__udivdi3+0x274>
  405e5a:	428a      	cmp	r2, r1
  405e5c:	d920      	bls.n	405ea0 <__udivdi3+0x274>
  405e5e:	3b02      	subs	r3, #2
  405e60:	4421      	add	r1, r4
  405e62:	1a89      	subs	r1, r1, r2
  405e64:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
  405e68:	e749      	b.n	405cfe <__udivdi3+0xd2>
  405e6a:	463a      	mov	r2, r7
  405e6c:	e70c      	b.n	405c88 <__udivdi3+0x5c>
  405e6e:	4633      	mov	r3, r6
  405e70:	e71f      	b.n	405cb2 <__udivdi3+0x86>
  405e72:	460a      	mov	r2, r1
  405e74:	e76b      	b.n	405d4e <__udivdi3+0x122>
  405e76:	40b0      	lsls	r0, r6
  405e78:	4290      	cmp	r0, r2
  405e7a:	d2b6      	bcs.n	405dea <__udivdi3+0x1be>
  405e7c:	f10c 32ff 	add.w	r2, ip, #4294967295
  405e80:	2300      	movs	r3, #0
  405e82:	e719      	b.n	405cb8 <__udivdi3+0x8c>
  405e84:	4633      	mov	r3, r6
  405e86:	4632      	mov	r2, r6
  405e88:	e716      	b.n	405cb8 <__udivdi3+0x8c>
  405e8a:	4599      	cmp	r9, r3
  405e8c:	d98f      	bls.n	405dae <__udivdi3+0x182>
  405e8e:	f1ac 0c02 	sub.w	ip, ip, #2
  405e92:	4423      	add	r3, r4
  405e94:	e78c      	b.n	405db0 <__udivdi3+0x184>
  405e96:	45b8      	cmp	r8, r7
  405e98:	d99b      	bls.n	405dd2 <__udivdi3+0x1a6>
  405e9a:	3d02      	subs	r5, #2
  405e9c:	4427      	add	r7, r4
  405e9e:	e799      	b.n	405dd4 <__udivdi3+0x1a8>
  405ea0:	4603      	mov	r3, r0
  405ea2:	e7de      	b.n	405e62 <__udivdi3+0x236>
  405ea4:	4690      	mov	r8, r2
  405ea6:	e7c7      	b.n	405e38 <__udivdi3+0x20c>
  405ea8:	3802      	subs	r0, #2
  405eaa:	4421      	add	r1, r4
  405eac:	e73a      	b.n	405d24 <__udivdi3+0xf8>
  405eae:	bf00      	nop

00405eb0 <__libc_init_array>:
  405eb0:	b570      	push	{r4, r5, r6, lr}
  405eb2:	4e0f      	ldr	r6, [pc, #60]	; (405ef0 <__libc_init_array+0x40>)
  405eb4:	4d0f      	ldr	r5, [pc, #60]	; (405ef4 <__libc_init_array+0x44>)
  405eb6:	1b76      	subs	r6, r6, r5
  405eb8:	10b6      	asrs	r6, r6, #2
  405eba:	d007      	beq.n	405ecc <__libc_init_array+0x1c>
  405ebc:	3d04      	subs	r5, #4
  405ebe:	2400      	movs	r4, #0
  405ec0:	3401      	adds	r4, #1
  405ec2:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405ec6:	4798      	blx	r3
  405ec8:	42a6      	cmp	r6, r4
  405eca:	d1f9      	bne.n	405ec0 <__libc_init_array+0x10>
  405ecc:	4e0a      	ldr	r6, [pc, #40]	; (405ef8 <__libc_init_array+0x48>)
  405ece:	4d0b      	ldr	r5, [pc, #44]	; (405efc <__libc_init_array+0x4c>)
  405ed0:	1b76      	subs	r6, r6, r5
  405ed2:	f001 f915 	bl	407100 <_init>
  405ed6:	10b6      	asrs	r6, r6, #2
  405ed8:	d008      	beq.n	405eec <__libc_init_array+0x3c>
  405eda:	3d04      	subs	r5, #4
  405edc:	2400      	movs	r4, #0
  405ede:	3401      	adds	r4, #1
  405ee0:	f855 3f04 	ldr.w	r3, [r5, #4]!
  405ee4:	4798      	blx	r3
  405ee6:	42a6      	cmp	r6, r4
  405ee8:	d1f9      	bne.n	405ede <__libc_init_array+0x2e>
  405eea:	bd70      	pop	{r4, r5, r6, pc}
  405eec:	bd70      	pop	{r4, r5, r6, pc}
  405eee:	bf00      	nop
  405ef0:	0040710c 	.word	0x0040710c
  405ef4:	0040710c 	.word	0x0040710c
  405ef8:	00407114 	.word	0x00407114
  405efc:	0040710c 	.word	0x0040710c

00405f00 <malloc>:
  405f00:	4b02      	ldr	r3, [pc, #8]	; (405f0c <malloc+0xc>)
  405f02:	4601      	mov	r1, r0
  405f04:	6818      	ldr	r0, [r3, #0]
  405f06:	f000 b803 	b.w	405f10 <_malloc_r>
  405f0a:	bf00      	nop
  405f0c:	200006d8 	.word	0x200006d8

00405f10 <_malloc_r>:
  405f10:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  405f14:	f101 050b 	add.w	r5, r1, #11
  405f18:	2d16      	cmp	r5, #22
  405f1a:	b083      	sub	sp, #12
  405f1c:	4606      	mov	r6, r0
  405f1e:	d927      	bls.n	405f70 <_malloc_r+0x60>
  405f20:	f035 0507 	bics.w	r5, r5, #7
  405f24:	d427      	bmi.n	405f76 <_malloc_r+0x66>
  405f26:	42a9      	cmp	r1, r5
  405f28:	d825      	bhi.n	405f76 <_malloc_r+0x66>
  405f2a:	4630      	mov	r0, r6
  405f2c:	f000 fb70 	bl	406610 <__malloc_lock>
  405f30:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
  405f34:	d226      	bcs.n	405f84 <_malloc_r+0x74>
  405f36:	4fc1      	ldr	r7, [pc, #772]	; (40623c <_malloc_r+0x32c>)
  405f38:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
  405f3c:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
  405f40:	68dc      	ldr	r4, [r3, #12]
  405f42:	429c      	cmp	r4, r3
  405f44:	f000 81d2 	beq.w	4062ec <_malloc_r+0x3dc>
  405f48:	6863      	ldr	r3, [r4, #4]
  405f4a:	68e2      	ldr	r2, [r4, #12]
  405f4c:	68a1      	ldr	r1, [r4, #8]
  405f4e:	f023 0303 	bic.w	r3, r3, #3
  405f52:	4423      	add	r3, r4
  405f54:	4630      	mov	r0, r6
  405f56:	685d      	ldr	r5, [r3, #4]
  405f58:	60ca      	str	r2, [r1, #12]
  405f5a:	f045 0501 	orr.w	r5, r5, #1
  405f5e:	6091      	str	r1, [r2, #8]
  405f60:	605d      	str	r5, [r3, #4]
  405f62:	f000 fb57 	bl	406614 <__malloc_unlock>
  405f66:	3408      	adds	r4, #8
  405f68:	4620      	mov	r0, r4
  405f6a:	b003      	add	sp, #12
  405f6c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405f70:	2510      	movs	r5, #16
  405f72:	42a9      	cmp	r1, r5
  405f74:	d9d9      	bls.n	405f2a <_malloc_r+0x1a>
  405f76:	2400      	movs	r4, #0
  405f78:	230c      	movs	r3, #12
  405f7a:	4620      	mov	r0, r4
  405f7c:	6033      	str	r3, [r6, #0]
  405f7e:	b003      	add	sp, #12
  405f80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  405f84:	ea5f 2c55 	movs.w	ip, r5, lsr #9
  405f88:	f000 808a 	beq.w	4060a0 <_malloc_r+0x190>
  405f8c:	f1bc 0f04 	cmp.w	ip, #4
  405f90:	f200 8160 	bhi.w	406254 <_malloc_r+0x344>
  405f94:	ea4f 1c95 	mov.w	ip, r5, lsr #6
  405f98:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
  405f9c:	ea4f 014c 	mov.w	r1, ip, lsl #1
  405fa0:	4fa6      	ldr	r7, [pc, #664]	; (40623c <_malloc_r+0x32c>)
  405fa2:	eb07 0181 	add.w	r1, r7, r1, lsl #2
  405fa6:	68cc      	ldr	r4, [r1, #12]
  405fa8:	42a1      	cmp	r1, r4
  405faa:	d105      	bne.n	405fb8 <_malloc_r+0xa8>
  405fac:	e00c      	b.n	405fc8 <_malloc_r+0xb8>
  405fae:	2b00      	cmp	r3, #0
  405fb0:	da7a      	bge.n	4060a8 <_malloc_r+0x198>
  405fb2:	68e4      	ldr	r4, [r4, #12]
  405fb4:	42a1      	cmp	r1, r4
  405fb6:	d007      	beq.n	405fc8 <_malloc_r+0xb8>
  405fb8:	6862      	ldr	r2, [r4, #4]
  405fba:	f022 0203 	bic.w	r2, r2, #3
  405fbe:	1b53      	subs	r3, r2, r5
  405fc0:	2b0f      	cmp	r3, #15
  405fc2:	ddf4      	ble.n	405fae <_malloc_r+0x9e>
  405fc4:	f10c 3cff 	add.w	ip, ip, #4294967295
  405fc8:	f10c 0c01 	add.w	ip, ip, #1
  405fcc:	4b9b      	ldr	r3, [pc, #620]	; (40623c <_malloc_r+0x32c>)
  405fce:	693c      	ldr	r4, [r7, #16]
  405fd0:	f103 0e08 	add.w	lr, r3, #8
  405fd4:	4574      	cmp	r4, lr
  405fd6:	f000 817e 	beq.w	4062d6 <_malloc_r+0x3c6>
  405fda:	6861      	ldr	r1, [r4, #4]
  405fdc:	f021 0103 	bic.w	r1, r1, #3
  405fe0:	1b4a      	subs	r2, r1, r5
  405fe2:	2a0f      	cmp	r2, #15
  405fe4:	f300 8164 	bgt.w	4062b0 <_malloc_r+0x3a0>
  405fe8:	2a00      	cmp	r2, #0
  405fea:	f8c3 e014 	str.w	lr, [r3, #20]
  405fee:	f8c3 e010 	str.w	lr, [r3, #16]
  405ff2:	da6a      	bge.n	4060ca <_malloc_r+0x1ba>
  405ff4:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
  405ff8:	f080 813a 	bcs.w	406270 <_malloc_r+0x360>
  405ffc:	08c9      	lsrs	r1, r1, #3
  405ffe:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
  406002:	ea4f 08a1 	mov.w	r8, r1, asr #2
  406006:	685a      	ldr	r2, [r3, #4]
  406008:	6881      	ldr	r1, [r0, #8]
  40600a:	60a1      	str	r1, [r4, #8]
  40600c:	f04f 0901 	mov.w	r9, #1
  406010:	fa09 f808 	lsl.w	r8, r9, r8
  406014:	ea48 0202 	orr.w	r2, r8, r2
  406018:	60e0      	str	r0, [r4, #12]
  40601a:	605a      	str	r2, [r3, #4]
  40601c:	6084      	str	r4, [r0, #8]
  40601e:	60cc      	str	r4, [r1, #12]
  406020:	ea4f 03ac 	mov.w	r3, ip, asr #2
  406024:	2001      	movs	r0, #1
  406026:	4098      	lsls	r0, r3
  406028:	4290      	cmp	r0, r2
  40602a:	d85b      	bhi.n	4060e4 <_malloc_r+0x1d4>
  40602c:	4202      	tst	r2, r0
  40602e:	d106      	bne.n	40603e <_malloc_r+0x12e>
  406030:	f02c 0c03 	bic.w	ip, ip, #3
  406034:	0040      	lsls	r0, r0, #1
  406036:	4202      	tst	r2, r0
  406038:	f10c 0c04 	add.w	ip, ip, #4
  40603c:	d0fa      	beq.n	406034 <_malloc_r+0x124>
  40603e:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
  406042:	4644      	mov	r4, r8
  406044:	46e1      	mov	r9, ip
  406046:	68e3      	ldr	r3, [r4, #12]
  406048:	429c      	cmp	r4, r3
  40604a:	d107      	bne.n	40605c <_malloc_r+0x14c>
  40604c:	e145      	b.n	4062da <_malloc_r+0x3ca>
  40604e:	2a00      	cmp	r2, #0
  406050:	f280 8156 	bge.w	406300 <_malloc_r+0x3f0>
  406054:	68db      	ldr	r3, [r3, #12]
  406056:	429c      	cmp	r4, r3
  406058:	f000 813f 	beq.w	4062da <_malloc_r+0x3ca>
  40605c:	6859      	ldr	r1, [r3, #4]
  40605e:	f021 0103 	bic.w	r1, r1, #3
  406062:	1b4a      	subs	r2, r1, r5
  406064:	2a0f      	cmp	r2, #15
  406066:	ddf2      	ble.n	40604e <_malloc_r+0x13e>
  406068:	461c      	mov	r4, r3
  40606a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  40606e:	f854 8f08 	ldr.w	r8, [r4, #8]!
  406072:	1959      	adds	r1, r3, r5
  406074:	f045 0901 	orr.w	r9, r5, #1
  406078:	f042 0501 	orr.w	r5, r2, #1
  40607c:	f8c3 9004 	str.w	r9, [r3, #4]
  406080:	4630      	mov	r0, r6
  406082:	f8c8 c00c 	str.w	ip, [r8, #12]
  406086:	f8cc 8008 	str.w	r8, [ip, #8]
  40608a:	6179      	str	r1, [r7, #20]
  40608c:	6139      	str	r1, [r7, #16]
  40608e:	f8c1 e00c 	str.w	lr, [r1, #12]
  406092:	f8c1 e008 	str.w	lr, [r1, #8]
  406096:	604d      	str	r5, [r1, #4]
  406098:	508a      	str	r2, [r1, r2]
  40609a:	f000 fabb 	bl	406614 <__malloc_unlock>
  40609e:	e763      	b.n	405f68 <_malloc_r+0x58>
  4060a0:	217e      	movs	r1, #126	; 0x7e
  4060a2:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  4060a6:	e77b      	b.n	405fa0 <_malloc_r+0x90>
  4060a8:	4422      	add	r2, r4
  4060aa:	68e3      	ldr	r3, [r4, #12]
  4060ac:	6850      	ldr	r0, [r2, #4]
  4060ae:	68a1      	ldr	r1, [r4, #8]
  4060b0:	f040 0501 	orr.w	r5, r0, #1
  4060b4:	60cb      	str	r3, [r1, #12]
  4060b6:	4630      	mov	r0, r6
  4060b8:	6099      	str	r1, [r3, #8]
  4060ba:	6055      	str	r5, [r2, #4]
  4060bc:	f000 faaa 	bl	406614 <__malloc_unlock>
  4060c0:	3408      	adds	r4, #8
  4060c2:	4620      	mov	r0, r4
  4060c4:	b003      	add	sp, #12
  4060c6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4060ca:	4421      	add	r1, r4
  4060cc:	4630      	mov	r0, r6
  4060ce:	684b      	ldr	r3, [r1, #4]
  4060d0:	f043 0301 	orr.w	r3, r3, #1
  4060d4:	604b      	str	r3, [r1, #4]
  4060d6:	f000 fa9d 	bl	406614 <__malloc_unlock>
  4060da:	3408      	adds	r4, #8
  4060dc:	4620      	mov	r0, r4
  4060de:	b003      	add	sp, #12
  4060e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  4060e4:	68bc      	ldr	r4, [r7, #8]
  4060e6:	6863      	ldr	r3, [r4, #4]
  4060e8:	f023 0903 	bic.w	r9, r3, #3
  4060ec:	45a9      	cmp	r9, r5
  4060ee:	d304      	bcc.n	4060fa <_malloc_r+0x1ea>
  4060f0:	ebc5 0309 	rsb	r3, r5, r9
  4060f4:	2b0f      	cmp	r3, #15
  4060f6:	f300 8091 	bgt.w	40621c <_malloc_r+0x30c>
  4060fa:	4b51      	ldr	r3, [pc, #324]	; (406240 <_malloc_r+0x330>)
  4060fc:	4a51      	ldr	r2, [pc, #324]	; (406244 <_malloc_r+0x334>)
  4060fe:	6819      	ldr	r1, [r3, #0]
  406100:	6813      	ldr	r3, [r2, #0]
  406102:	3301      	adds	r3, #1
  406104:	eb05 0a01 	add.w	sl, r5, r1
  406108:	eb04 0b09 	add.w	fp, r4, r9
  40610c:	f000 8161 	beq.w	4063d2 <_malloc_r+0x4c2>
  406110:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
  406114:	f10a 0a0f 	add.w	sl, sl, #15
  406118:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
  40611c:	f02a 0a0f 	bic.w	sl, sl, #15
  406120:	4630      	mov	r0, r6
  406122:	4651      	mov	r1, sl
  406124:	9201      	str	r2, [sp, #4]
  406126:	f000 fa77 	bl	406618 <_sbrk_r>
  40612a:	f1b0 3fff 	cmp.w	r0, #4294967295
  40612e:	4680      	mov	r8, r0
  406130:	9a01      	ldr	r2, [sp, #4]
  406132:	f000 8100 	beq.w	406336 <_malloc_r+0x426>
  406136:	4583      	cmp	fp, r0
  406138:	f200 80fa 	bhi.w	406330 <_malloc_r+0x420>
  40613c:	f8df c110 	ldr.w	ip, [pc, #272]	; 406250 <_malloc_r+0x340>
  406140:	f8dc 3000 	ldr.w	r3, [ip]
  406144:	45c3      	cmp	fp, r8
  406146:	4453      	add	r3, sl
  406148:	f8cc 3000 	str.w	r3, [ip]
  40614c:	f000 814a 	beq.w	4063e4 <_malloc_r+0x4d4>
  406150:	6812      	ldr	r2, [r2, #0]
  406152:	493c      	ldr	r1, [pc, #240]	; (406244 <_malloc_r+0x334>)
  406154:	3201      	adds	r2, #1
  406156:	bf1b      	ittet	ne
  406158:	ebcb 0b08 	rsbne	fp, fp, r8
  40615c:	445b      	addne	r3, fp
  40615e:	f8c1 8000 	streq.w	r8, [r1]
  406162:	f8cc 3000 	strne.w	r3, [ip]
  406166:	f018 0307 	ands.w	r3, r8, #7
  40616a:	f000 8113 	beq.w	406394 <_malloc_r+0x484>
  40616e:	f1c3 0208 	rsb	r2, r3, #8
  406172:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
  406176:	4490      	add	r8, r2
  406178:	3308      	adds	r3, #8
  40617a:	44c2      	add	sl, r8
  40617c:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
  406180:	ebca 0a03 	rsb	sl, sl, r3
  406184:	4651      	mov	r1, sl
  406186:	4630      	mov	r0, r6
  406188:	f8cd c004 	str.w	ip, [sp, #4]
  40618c:	f000 fa44 	bl	406618 <_sbrk_r>
  406190:	1c43      	adds	r3, r0, #1
  406192:	f8dd c004 	ldr.w	ip, [sp, #4]
  406196:	f000 8135 	beq.w	406404 <_malloc_r+0x4f4>
  40619a:	ebc8 0200 	rsb	r2, r8, r0
  40619e:	4452      	add	r2, sl
  4061a0:	f042 0201 	orr.w	r2, r2, #1
  4061a4:	f8dc 3000 	ldr.w	r3, [ip]
  4061a8:	f8c7 8008 	str.w	r8, [r7, #8]
  4061ac:	4453      	add	r3, sl
  4061ae:	42bc      	cmp	r4, r7
  4061b0:	f8c8 2004 	str.w	r2, [r8, #4]
  4061b4:	f8cc 3000 	str.w	r3, [ip]
  4061b8:	f8df a094 	ldr.w	sl, [pc, #148]	; 406250 <_malloc_r+0x340>
  4061bc:	d015      	beq.n	4061ea <_malloc_r+0x2da>
  4061be:	f1b9 0f0f 	cmp.w	r9, #15
  4061c2:	f240 80ea 	bls.w	40639a <_malloc_r+0x48a>
  4061c6:	6861      	ldr	r1, [r4, #4]
  4061c8:	f1a9 020c 	sub.w	r2, r9, #12
  4061cc:	f022 0207 	bic.w	r2, r2, #7
  4061d0:	f001 0e01 	and.w	lr, r1, #1
  4061d4:	18a1      	adds	r1, r4, r2
  4061d6:	2005      	movs	r0, #5
  4061d8:	ea42 0e0e 	orr.w	lr, r2, lr
  4061dc:	2a0f      	cmp	r2, #15
  4061de:	f8c4 e004 	str.w	lr, [r4, #4]
  4061e2:	6048      	str	r0, [r1, #4]
  4061e4:	6088      	str	r0, [r1, #8]
  4061e6:	f200 8111 	bhi.w	40640c <_malloc_r+0x4fc>
  4061ea:	4a17      	ldr	r2, [pc, #92]	; (406248 <_malloc_r+0x338>)
  4061ec:	68bc      	ldr	r4, [r7, #8]
  4061ee:	6811      	ldr	r1, [r2, #0]
  4061f0:	428b      	cmp	r3, r1
  4061f2:	bf88      	it	hi
  4061f4:	6013      	strhi	r3, [r2, #0]
  4061f6:	4a15      	ldr	r2, [pc, #84]	; (40624c <_malloc_r+0x33c>)
  4061f8:	6811      	ldr	r1, [r2, #0]
  4061fa:	428b      	cmp	r3, r1
  4061fc:	bf88      	it	hi
  4061fe:	6013      	strhi	r3, [r2, #0]
  406200:	6862      	ldr	r2, [r4, #4]
  406202:	f022 0203 	bic.w	r2, r2, #3
  406206:	4295      	cmp	r5, r2
  406208:	ebc5 0302 	rsb	r3, r5, r2
  40620c:	d801      	bhi.n	406212 <_malloc_r+0x302>
  40620e:	2b0f      	cmp	r3, #15
  406210:	dc04      	bgt.n	40621c <_malloc_r+0x30c>
  406212:	4630      	mov	r0, r6
  406214:	f000 f9fe 	bl	406614 <__malloc_unlock>
  406218:	2400      	movs	r4, #0
  40621a:	e6a5      	b.n	405f68 <_malloc_r+0x58>
  40621c:	1962      	adds	r2, r4, r5
  40621e:	f043 0301 	orr.w	r3, r3, #1
  406222:	f045 0501 	orr.w	r5, r5, #1
  406226:	6065      	str	r5, [r4, #4]
  406228:	4630      	mov	r0, r6
  40622a:	60ba      	str	r2, [r7, #8]
  40622c:	6053      	str	r3, [r2, #4]
  40622e:	f000 f9f1 	bl	406614 <__malloc_unlock>
  406232:	3408      	adds	r4, #8
  406234:	4620      	mov	r0, r4
  406236:	b003      	add	sp, #12
  406238:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  40623c:	200006dc 	.word	0x200006dc
  406240:	20001164 	.word	0x20001164
  406244:	20000ae8 	.word	0x20000ae8
  406248:	20001160 	.word	0x20001160
  40624c:	2000115c 	.word	0x2000115c
  406250:	20001168 	.word	0x20001168
  406254:	f1bc 0f14 	cmp.w	ip, #20
  406258:	d961      	bls.n	40631e <_malloc_r+0x40e>
  40625a:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
  40625e:	f200 808f 	bhi.w	406380 <_malloc_r+0x470>
  406262:	ea4f 3c15 	mov.w	ip, r5, lsr #12
  406266:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
  40626a:	ea4f 014c 	mov.w	r1, ip, lsl #1
  40626e:	e697      	b.n	405fa0 <_malloc_r+0x90>
  406270:	0a4b      	lsrs	r3, r1, #9
  406272:	2b04      	cmp	r3, #4
  406274:	d958      	bls.n	406328 <_malloc_r+0x418>
  406276:	2b14      	cmp	r3, #20
  406278:	f200 80ae 	bhi.w	4063d8 <_malloc_r+0x4c8>
  40627c:	f103 025b 	add.w	r2, r3, #91	; 0x5b
  406280:	0050      	lsls	r0, r2, #1
  406282:	eb07 0080 	add.w	r0, r7, r0, lsl #2
  406286:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 406444 <_malloc_r+0x534>
  40628a:	6883      	ldr	r3, [r0, #8]
  40628c:	4283      	cmp	r3, r0
  40628e:	f000 808a 	beq.w	4063a6 <_malloc_r+0x496>
  406292:	685a      	ldr	r2, [r3, #4]
  406294:	f022 0203 	bic.w	r2, r2, #3
  406298:	4291      	cmp	r1, r2
  40629a:	d202      	bcs.n	4062a2 <_malloc_r+0x392>
  40629c:	689b      	ldr	r3, [r3, #8]
  40629e:	4298      	cmp	r0, r3
  4062a0:	d1f7      	bne.n	406292 <_malloc_r+0x382>
  4062a2:	68d9      	ldr	r1, [r3, #12]
  4062a4:	687a      	ldr	r2, [r7, #4]
  4062a6:	60e1      	str	r1, [r4, #12]
  4062a8:	60a3      	str	r3, [r4, #8]
  4062aa:	608c      	str	r4, [r1, #8]
  4062ac:	60dc      	str	r4, [r3, #12]
  4062ae:	e6b7      	b.n	406020 <_malloc_r+0x110>
  4062b0:	1961      	adds	r1, r4, r5
  4062b2:	f042 0701 	orr.w	r7, r2, #1
  4062b6:	f045 0501 	orr.w	r5, r5, #1
  4062ba:	6065      	str	r5, [r4, #4]
  4062bc:	4630      	mov	r0, r6
  4062be:	6159      	str	r1, [r3, #20]
  4062c0:	6119      	str	r1, [r3, #16]
  4062c2:	f8c1 e00c 	str.w	lr, [r1, #12]
  4062c6:	f8c1 e008 	str.w	lr, [r1, #8]
  4062ca:	604f      	str	r7, [r1, #4]
  4062cc:	508a      	str	r2, [r1, r2]
  4062ce:	3408      	adds	r4, #8
  4062d0:	f000 f9a0 	bl	406614 <__malloc_unlock>
  4062d4:	e648      	b.n	405f68 <_malloc_r+0x58>
  4062d6:	685a      	ldr	r2, [r3, #4]
  4062d8:	e6a2      	b.n	406020 <_malloc_r+0x110>
  4062da:	f109 0901 	add.w	r9, r9, #1
  4062de:	f019 0f03 	tst.w	r9, #3
  4062e2:	f104 0408 	add.w	r4, r4, #8
  4062e6:	f47f aeae 	bne.w	406046 <_malloc_r+0x136>
  4062ea:	e02d      	b.n	406348 <_malloc_r+0x438>
  4062ec:	f104 0308 	add.w	r3, r4, #8
  4062f0:	6964      	ldr	r4, [r4, #20]
  4062f2:	42a3      	cmp	r3, r4
  4062f4:	bf08      	it	eq
  4062f6:	f10c 0c02 	addeq.w	ip, ip, #2
  4062fa:	f43f ae67 	beq.w	405fcc <_malloc_r+0xbc>
  4062fe:	e623      	b.n	405f48 <_malloc_r+0x38>
  406300:	4419      	add	r1, r3
  406302:	461c      	mov	r4, r3
  406304:	6848      	ldr	r0, [r1, #4]
  406306:	68db      	ldr	r3, [r3, #12]
  406308:	f854 2f08 	ldr.w	r2, [r4, #8]!
  40630c:	f040 0501 	orr.w	r5, r0, #1
  406310:	604d      	str	r5, [r1, #4]
  406312:	4630      	mov	r0, r6
  406314:	60d3      	str	r3, [r2, #12]
  406316:	609a      	str	r2, [r3, #8]
  406318:	f000 f97c 	bl	406614 <__malloc_unlock>
  40631c:	e624      	b.n	405f68 <_malloc_r+0x58>
  40631e:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
  406322:	ea4f 014c 	mov.w	r1, ip, lsl #1
  406326:	e63b      	b.n	405fa0 <_malloc_r+0x90>
  406328:	098a      	lsrs	r2, r1, #6
  40632a:	3238      	adds	r2, #56	; 0x38
  40632c:	0050      	lsls	r0, r2, #1
  40632e:	e7a8      	b.n	406282 <_malloc_r+0x372>
  406330:	42bc      	cmp	r4, r7
  406332:	f43f af03 	beq.w	40613c <_malloc_r+0x22c>
  406336:	68bc      	ldr	r4, [r7, #8]
  406338:	6862      	ldr	r2, [r4, #4]
  40633a:	f022 0203 	bic.w	r2, r2, #3
  40633e:	e762      	b.n	406206 <_malloc_r+0x2f6>
  406340:	f8d8 8000 	ldr.w	r8, [r8]
  406344:	4598      	cmp	r8, r3
  406346:	d17b      	bne.n	406440 <_malloc_r+0x530>
  406348:	f01c 0f03 	tst.w	ip, #3
  40634c:	f1a8 0308 	sub.w	r3, r8, #8
  406350:	f10c 3cff 	add.w	ip, ip, #4294967295
  406354:	d1f4      	bne.n	406340 <_malloc_r+0x430>
  406356:	687b      	ldr	r3, [r7, #4]
  406358:	ea23 0300 	bic.w	r3, r3, r0
  40635c:	607b      	str	r3, [r7, #4]
  40635e:	0040      	lsls	r0, r0, #1
  406360:	4298      	cmp	r0, r3
  406362:	f63f aebf 	bhi.w	4060e4 <_malloc_r+0x1d4>
  406366:	2800      	cmp	r0, #0
  406368:	f43f aebc 	beq.w	4060e4 <_malloc_r+0x1d4>
  40636c:	4203      	tst	r3, r0
  40636e:	46cc      	mov	ip, r9
  406370:	f47f ae65 	bne.w	40603e <_malloc_r+0x12e>
  406374:	0040      	lsls	r0, r0, #1
  406376:	4203      	tst	r3, r0
  406378:	f10c 0c04 	add.w	ip, ip, #4
  40637c:	d0fa      	beq.n	406374 <_malloc_r+0x464>
  40637e:	e65e      	b.n	40603e <_malloc_r+0x12e>
  406380:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
  406384:	d81a      	bhi.n	4063bc <_malloc_r+0x4ac>
  406386:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
  40638a:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
  40638e:	ea4f 014c 	mov.w	r1, ip, lsl #1
  406392:	e605      	b.n	405fa0 <_malloc_r+0x90>
  406394:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  406398:	e6ef      	b.n	40617a <_malloc_r+0x26a>
  40639a:	2301      	movs	r3, #1
  40639c:	f8c8 3004 	str.w	r3, [r8, #4]
  4063a0:	4644      	mov	r4, r8
  4063a2:	2200      	movs	r2, #0
  4063a4:	e72f      	b.n	406206 <_malloc_r+0x2f6>
  4063a6:	1091      	asrs	r1, r2, #2
  4063a8:	2001      	movs	r0, #1
  4063aa:	f8d8 2004 	ldr.w	r2, [r8, #4]
  4063ae:	fa00 f101 	lsl.w	r1, r0, r1
  4063b2:	430a      	orrs	r2, r1
  4063b4:	f8c8 2004 	str.w	r2, [r8, #4]
  4063b8:	4619      	mov	r1, r3
  4063ba:	e774      	b.n	4062a6 <_malloc_r+0x396>
  4063bc:	f240 5354 	movw	r3, #1364	; 0x554
  4063c0:	459c      	cmp	ip, r3
  4063c2:	d81b      	bhi.n	4063fc <_malloc_r+0x4ec>
  4063c4:	ea4f 4c95 	mov.w	ip, r5, lsr #18
  4063c8:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
  4063cc:	ea4f 014c 	mov.w	r1, ip, lsl #1
  4063d0:	e5e6      	b.n	405fa0 <_malloc_r+0x90>
  4063d2:	f10a 0a10 	add.w	sl, sl, #16
  4063d6:	e6a3      	b.n	406120 <_malloc_r+0x210>
  4063d8:	2b54      	cmp	r3, #84	; 0x54
  4063da:	d81f      	bhi.n	40641c <_malloc_r+0x50c>
  4063dc:	0b0a      	lsrs	r2, r1, #12
  4063de:	326e      	adds	r2, #110	; 0x6e
  4063e0:	0050      	lsls	r0, r2, #1
  4063e2:	e74e      	b.n	406282 <_malloc_r+0x372>
  4063e4:	f3cb 010b 	ubfx	r1, fp, #0, #12
  4063e8:	2900      	cmp	r1, #0
  4063ea:	f47f aeb1 	bne.w	406150 <_malloc_r+0x240>
  4063ee:	eb0a 0109 	add.w	r1, sl, r9
  4063f2:	68ba      	ldr	r2, [r7, #8]
  4063f4:	f041 0101 	orr.w	r1, r1, #1
  4063f8:	6051      	str	r1, [r2, #4]
  4063fa:	e6f6      	b.n	4061ea <_malloc_r+0x2da>
  4063fc:	21fc      	movs	r1, #252	; 0xfc
  4063fe:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
  406402:	e5cd      	b.n	405fa0 <_malloc_r+0x90>
  406404:	2201      	movs	r2, #1
  406406:	f04f 0a00 	mov.w	sl, #0
  40640a:	e6cb      	b.n	4061a4 <_malloc_r+0x294>
  40640c:	f104 0108 	add.w	r1, r4, #8
  406410:	4630      	mov	r0, r6
  406412:	f000 f9eb 	bl	4067ec <_free_r>
  406416:	f8da 3000 	ldr.w	r3, [sl]
  40641a:	e6e6      	b.n	4061ea <_malloc_r+0x2da>
  40641c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
  406420:	d803      	bhi.n	40642a <_malloc_r+0x51a>
  406422:	0bca      	lsrs	r2, r1, #15
  406424:	3277      	adds	r2, #119	; 0x77
  406426:	0050      	lsls	r0, r2, #1
  406428:	e72b      	b.n	406282 <_malloc_r+0x372>
  40642a:	f240 5254 	movw	r2, #1364	; 0x554
  40642e:	4293      	cmp	r3, r2
  406430:	d803      	bhi.n	40643a <_malloc_r+0x52a>
  406432:	0c8a      	lsrs	r2, r1, #18
  406434:	327c      	adds	r2, #124	; 0x7c
  406436:	0050      	lsls	r0, r2, #1
  406438:	e723      	b.n	406282 <_malloc_r+0x372>
  40643a:	20fc      	movs	r0, #252	; 0xfc
  40643c:	227e      	movs	r2, #126	; 0x7e
  40643e:	e720      	b.n	406282 <_malloc_r+0x372>
  406440:	687b      	ldr	r3, [r7, #4]
  406442:	e78c      	b.n	40635e <_malloc_r+0x44e>
  406444:	200006dc 	.word	0x200006dc

00406448 <memcpy>:
  406448:	4684      	mov	ip, r0
  40644a:	ea41 0300 	orr.w	r3, r1, r0
  40644e:	f013 0303 	ands.w	r3, r3, #3
  406452:	d16d      	bne.n	406530 <memcpy+0xe8>
  406454:	3a40      	subs	r2, #64	; 0x40
  406456:	d341      	bcc.n	4064dc <memcpy+0x94>
  406458:	f851 3b04 	ldr.w	r3, [r1], #4
  40645c:	f840 3b04 	str.w	r3, [r0], #4
  406460:	f851 3b04 	ldr.w	r3, [r1], #4
  406464:	f840 3b04 	str.w	r3, [r0], #4
  406468:	f851 3b04 	ldr.w	r3, [r1], #4
  40646c:	f840 3b04 	str.w	r3, [r0], #4
  406470:	f851 3b04 	ldr.w	r3, [r1], #4
  406474:	f840 3b04 	str.w	r3, [r0], #4
  406478:	f851 3b04 	ldr.w	r3, [r1], #4
  40647c:	f840 3b04 	str.w	r3, [r0], #4
  406480:	f851 3b04 	ldr.w	r3, [r1], #4
  406484:	f840 3b04 	str.w	r3, [r0], #4
  406488:	f851 3b04 	ldr.w	r3, [r1], #4
  40648c:	f840 3b04 	str.w	r3, [r0], #4
  406490:	f851 3b04 	ldr.w	r3, [r1], #4
  406494:	f840 3b04 	str.w	r3, [r0], #4
  406498:	f851 3b04 	ldr.w	r3, [r1], #4
  40649c:	f840 3b04 	str.w	r3, [r0], #4
  4064a0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064a4:	f840 3b04 	str.w	r3, [r0], #4
  4064a8:	f851 3b04 	ldr.w	r3, [r1], #4
  4064ac:	f840 3b04 	str.w	r3, [r0], #4
  4064b0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064b4:	f840 3b04 	str.w	r3, [r0], #4
  4064b8:	f851 3b04 	ldr.w	r3, [r1], #4
  4064bc:	f840 3b04 	str.w	r3, [r0], #4
  4064c0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064c4:	f840 3b04 	str.w	r3, [r0], #4
  4064c8:	f851 3b04 	ldr.w	r3, [r1], #4
  4064cc:	f840 3b04 	str.w	r3, [r0], #4
  4064d0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064d4:	f840 3b04 	str.w	r3, [r0], #4
  4064d8:	3a40      	subs	r2, #64	; 0x40
  4064da:	d2bd      	bcs.n	406458 <memcpy+0x10>
  4064dc:	3230      	adds	r2, #48	; 0x30
  4064de:	d311      	bcc.n	406504 <memcpy+0xbc>
  4064e0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064e4:	f840 3b04 	str.w	r3, [r0], #4
  4064e8:	f851 3b04 	ldr.w	r3, [r1], #4
  4064ec:	f840 3b04 	str.w	r3, [r0], #4
  4064f0:	f851 3b04 	ldr.w	r3, [r1], #4
  4064f4:	f840 3b04 	str.w	r3, [r0], #4
  4064f8:	f851 3b04 	ldr.w	r3, [r1], #4
  4064fc:	f840 3b04 	str.w	r3, [r0], #4
  406500:	3a10      	subs	r2, #16
  406502:	d2ed      	bcs.n	4064e0 <memcpy+0x98>
  406504:	320c      	adds	r2, #12
  406506:	d305      	bcc.n	406514 <memcpy+0xcc>
  406508:	f851 3b04 	ldr.w	r3, [r1], #4
  40650c:	f840 3b04 	str.w	r3, [r0], #4
  406510:	3a04      	subs	r2, #4
  406512:	d2f9      	bcs.n	406508 <memcpy+0xc0>
  406514:	3204      	adds	r2, #4
  406516:	d008      	beq.n	40652a <memcpy+0xe2>
  406518:	07d2      	lsls	r2, r2, #31
  40651a:	bf1c      	itt	ne
  40651c:	f811 3b01 	ldrbne.w	r3, [r1], #1
  406520:	f800 3b01 	strbne.w	r3, [r0], #1
  406524:	d301      	bcc.n	40652a <memcpy+0xe2>
  406526:	880b      	ldrh	r3, [r1, #0]
  406528:	8003      	strh	r3, [r0, #0]
  40652a:	4660      	mov	r0, ip
  40652c:	4770      	bx	lr
  40652e:	bf00      	nop
  406530:	2a08      	cmp	r2, #8
  406532:	d313      	bcc.n	40655c <memcpy+0x114>
  406534:	078b      	lsls	r3, r1, #30
  406536:	d08d      	beq.n	406454 <memcpy+0xc>
  406538:	f010 0303 	ands.w	r3, r0, #3
  40653c:	d08a      	beq.n	406454 <memcpy+0xc>
  40653e:	f1c3 0304 	rsb	r3, r3, #4
  406542:	1ad2      	subs	r2, r2, r3
  406544:	07db      	lsls	r3, r3, #31
  406546:	bf1c      	itt	ne
  406548:	f811 3b01 	ldrbne.w	r3, [r1], #1
  40654c:	f800 3b01 	strbne.w	r3, [r0], #1
  406550:	d380      	bcc.n	406454 <memcpy+0xc>
  406552:	f831 3b02 	ldrh.w	r3, [r1], #2
  406556:	f820 3b02 	strh.w	r3, [r0], #2
  40655a:	e77b      	b.n	406454 <memcpy+0xc>
  40655c:	3a04      	subs	r2, #4
  40655e:	d3d9      	bcc.n	406514 <memcpy+0xcc>
  406560:	3a01      	subs	r2, #1
  406562:	f811 3b01 	ldrb.w	r3, [r1], #1
  406566:	f800 3b01 	strb.w	r3, [r0], #1
  40656a:	d2f9      	bcs.n	406560 <memcpy+0x118>
  40656c:	780b      	ldrb	r3, [r1, #0]
  40656e:	7003      	strb	r3, [r0, #0]
  406570:	784b      	ldrb	r3, [r1, #1]
  406572:	7043      	strb	r3, [r0, #1]
  406574:	788b      	ldrb	r3, [r1, #2]
  406576:	7083      	strb	r3, [r0, #2]
  406578:	4660      	mov	r0, ip
  40657a:	4770      	bx	lr

0040657c <memset>:
  40657c:	b4f0      	push	{r4, r5, r6, r7}
  40657e:	0784      	lsls	r4, r0, #30
  406580:	d043      	beq.n	40660a <memset+0x8e>
  406582:	1e54      	subs	r4, r2, #1
  406584:	2a00      	cmp	r2, #0
  406586:	d03e      	beq.n	406606 <memset+0x8a>
  406588:	b2cd      	uxtb	r5, r1
  40658a:	4603      	mov	r3, r0
  40658c:	e003      	b.n	406596 <memset+0x1a>
  40658e:	1e62      	subs	r2, r4, #1
  406590:	2c00      	cmp	r4, #0
  406592:	d038      	beq.n	406606 <memset+0x8a>
  406594:	4614      	mov	r4, r2
  406596:	f803 5b01 	strb.w	r5, [r3], #1
  40659a:	079a      	lsls	r2, r3, #30
  40659c:	d1f7      	bne.n	40658e <memset+0x12>
  40659e:	2c03      	cmp	r4, #3
  4065a0:	d92a      	bls.n	4065f8 <memset+0x7c>
  4065a2:	b2cd      	uxtb	r5, r1
  4065a4:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
  4065a8:	2c0f      	cmp	r4, #15
  4065aa:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
  4065ae:	d915      	bls.n	4065dc <memset+0x60>
  4065b0:	f1a4 0710 	sub.w	r7, r4, #16
  4065b4:	093f      	lsrs	r7, r7, #4
  4065b6:	f103 0610 	add.w	r6, r3, #16
  4065ba:	eb06 1607 	add.w	r6, r6, r7, lsl #4
  4065be:	461a      	mov	r2, r3
  4065c0:	6015      	str	r5, [r2, #0]
  4065c2:	6055      	str	r5, [r2, #4]
  4065c4:	6095      	str	r5, [r2, #8]
  4065c6:	60d5      	str	r5, [r2, #12]
  4065c8:	3210      	adds	r2, #16
  4065ca:	42b2      	cmp	r2, r6
  4065cc:	d1f8      	bne.n	4065c0 <memset+0x44>
  4065ce:	f004 040f 	and.w	r4, r4, #15
  4065d2:	3701      	adds	r7, #1
  4065d4:	2c03      	cmp	r4, #3
  4065d6:	eb03 1307 	add.w	r3, r3, r7, lsl #4
  4065da:	d90d      	bls.n	4065f8 <memset+0x7c>
  4065dc:	461e      	mov	r6, r3
  4065de:	4622      	mov	r2, r4
  4065e0:	3a04      	subs	r2, #4
  4065e2:	2a03      	cmp	r2, #3
  4065e4:	f846 5b04 	str.w	r5, [r6], #4
  4065e8:	d8fa      	bhi.n	4065e0 <memset+0x64>
  4065ea:	1f22      	subs	r2, r4, #4
  4065ec:	f022 0203 	bic.w	r2, r2, #3
  4065f0:	3204      	adds	r2, #4
  4065f2:	4413      	add	r3, r2
  4065f4:	f004 0403 	and.w	r4, r4, #3
  4065f8:	b12c      	cbz	r4, 406606 <memset+0x8a>
  4065fa:	b2c9      	uxtb	r1, r1
  4065fc:	441c      	add	r4, r3
  4065fe:	f803 1b01 	strb.w	r1, [r3], #1
  406602:	42a3      	cmp	r3, r4
  406604:	d1fb      	bne.n	4065fe <memset+0x82>
  406606:	bcf0      	pop	{r4, r5, r6, r7}
  406608:	4770      	bx	lr
  40660a:	4614      	mov	r4, r2
  40660c:	4603      	mov	r3, r0
  40660e:	e7c6      	b.n	40659e <memset+0x22>

00406610 <__malloc_lock>:
  406610:	4770      	bx	lr
  406612:	bf00      	nop

00406614 <__malloc_unlock>:
  406614:	4770      	bx	lr
  406616:	bf00      	nop

00406618 <_sbrk_r>:
  406618:	b538      	push	{r3, r4, r5, lr}
  40661a:	4c07      	ldr	r4, [pc, #28]	; (406638 <_sbrk_r+0x20>)
  40661c:	2300      	movs	r3, #0
  40661e:	4605      	mov	r5, r0
  406620:	4608      	mov	r0, r1
  406622:	6023      	str	r3, [r4, #0]
  406624:	f7ff f92a 	bl	40587c <_sbrk>
  406628:	1c43      	adds	r3, r0, #1
  40662a:	d000      	beq.n	40662e <_sbrk_r+0x16>
  40662c:	bd38      	pop	{r3, r4, r5, pc}
  40662e:	6823      	ldr	r3, [r4, #0]
  406630:	2b00      	cmp	r3, #0
  406632:	d0fb      	beq.n	40662c <_sbrk_r+0x14>
  406634:	602b      	str	r3, [r5, #0]
  406636:	bd38      	pop	{r3, r4, r5, pc}
  406638:	20002444 	.word	0x20002444

0040663c <strlen>:
  40663c:	f020 0103 	bic.w	r1, r0, #3
  406640:	f010 0003 	ands.w	r0, r0, #3
  406644:	f1c0 0000 	rsb	r0, r0, #0
  406648:	f851 3b04 	ldr.w	r3, [r1], #4
  40664c:	f100 0c04 	add.w	ip, r0, #4
  406650:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
  406654:	f06f 0200 	mvn.w	r2, #0
  406658:	bf1c      	itt	ne
  40665a:	fa22 f20c 	lsrne.w	r2, r2, ip
  40665e:	4313      	orrne	r3, r2
  406660:	f04f 0c01 	mov.w	ip, #1
  406664:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
  406668:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
  40666c:	eba3 020c 	sub.w	r2, r3, ip
  406670:	ea22 0203 	bic.w	r2, r2, r3
  406674:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
  406678:	bf04      	itt	eq
  40667a:	f851 3b04 	ldreq.w	r3, [r1], #4
  40667e:	3004      	addeq	r0, #4
  406680:	d0f4      	beq.n	40666c <strlen+0x30>
  406682:	f013 0fff 	tst.w	r3, #255	; 0xff
  406686:	bf1f      	itttt	ne
  406688:	3001      	addne	r0, #1
  40668a:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
  40668e:	3001      	addne	r0, #1
  406690:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
  406694:	bf18      	it	ne
  406696:	3001      	addne	r0, #1
  406698:	4770      	bx	lr
  40669a:	bf00      	nop

0040669c <strncpy>:
  40669c:	ea40 0301 	orr.w	r3, r0, r1
  4066a0:	079b      	lsls	r3, r3, #30
  4066a2:	b470      	push	{r4, r5, r6}
  4066a4:	d12a      	bne.n	4066fc <strncpy+0x60>
  4066a6:	2a03      	cmp	r2, #3
  4066a8:	d928      	bls.n	4066fc <strncpy+0x60>
  4066aa:	460c      	mov	r4, r1
  4066ac:	4603      	mov	r3, r0
  4066ae:	4621      	mov	r1, r4
  4066b0:	f854 5b04 	ldr.w	r5, [r4], #4
  4066b4:	f1a5 3601 	sub.w	r6, r5, #16843009	; 0x1010101
  4066b8:	ea26 0605 	bic.w	r6, r6, r5
  4066bc:	f016 3f80 	tst.w	r6, #2155905152	; 0x80808080
  4066c0:	d105      	bne.n	4066ce <strncpy+0x32>
  4066c2:	3a04      	subs	r2, #4
  4066c4:	2a03      	cmp	r2, #3
  4066c6:	f843 5b04 	str.w	r5, [r3], #4
  4066ca:	4621      	mov	r1, r4
  4066cc:	d8ef      	bhi.n	4066ae <strncpy+0x12>
  4066ce:	b19a      	cbz	r2, 4066f8 <strncpy+0x5c>
  4066d0:	780c      	ldrb	r4, [r1, #0]
  4066d2:	701c      	strb	r4, [r3, #0]
  4066d4:	3a01      	subs	r2, #1
  4066d6:	3301      	adds	r3, #1
  4066d8:	b13c      	cbz	r4, 4066ea <strncpy+0x4e>
  4066da:	b16a      	cbz	r2, 4066f8 <strncpy+0x5c>
  4066dc:	f811 4f01 	ldrb.w	r4, [r1, #1]!
  4066e0:	f803 4b01 	strb.w	r4, [r3], #1
  4066e4:	3a01      	subs	r2, #1
  4066e6:	2c00      	cmp	r4, #0
  4066e8:	d1f7      	bne.n	4066da <strncpy+0x3e>
  4066ea:	b12a      	cbz	r2, 4066f8 <strncpy+0x5c>
  4066ec:	441a      	add	r2, r3
  4066ee:	2100      	movs	r1, #0
  4066f0:	f803 1b01 	strb.w	r1, [r3], #1
  4066f4:	4293      	cmp	r3, r2
  4066f6:	d1fb      	bne.n	4066f0 <strncpy+0x54>
  4066f8:	bc70      	pop	{r4, r5, r6}
  4066fa:	4770      	bx	lr
  4066fc:	4603      	mov	r3, r0
  4066fe:	e7e6      	b.n	4066ce <strncpy+0x32>

00406700 <register_fini>:
  406700:	4b02      	ldr	r3, [pc, #8]	; (40670c <register_fini+0xc>)
  406702:	b113      	cbz	r3, 40670a <register_fini+0xa>
  406704:	4802      	ldr	r0, [pc, #8]	; (406710 <register_fini+0x10>)
  406706:	f000 b805 	b.w	406714 <atexit>
  40670a:	4770      	bx	lr
  40670c:	00000000 	.word	0x00000000
  406710:	00406721 	.word	0x00406721

00406714 <atexit>:
  406714:	4601      	mov	r1, r0
  406716:	2000      	movs	r0, #0
  406718:	4602      	mov	r2, r0
  40671a:	4603      	mov	r3, r0
  40671c:	f000 b934 	b.w	406988 <__register_exitproc>

00406720 <__libc_fini_array>:
  406720:	b538      	push	{r3, r4, r5, lr}
  406722:	4d09      	ldr	r5, [pc, #36]	; (406748 <__libc_fini_array+0x28>)
  406724:	4c09      	ldr	r4, [pc, #36]	; (40674c <__libc_fini_array+0x2c>)
  406726:	1b64      	subs	r4, r4, r5
  406728:	10a4      	asrs	r4, r4, #2
  40672a:	bf18      	it	ne
  40672c:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
  406730:	d005      	beq.n	40673e <__libc_fini_array+0x1e>
  406732:	3c01      	subs	r4, #1
  406734:	f855 3d04 	ldr.w	r3, [r5, #-4]!
  406738:	4798      	blx	r3
  40673a:	2c00      	cmp	r4, #0
  40673c:	d1f9      	bne.n	406732 <__libc_fini_array+0x12>
  40673e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  406742:	f000 bce7 	b.w	407114 <_fini>
  406746:	bf00      	nop
  406748:	00407120 	.word	0x00407120
  40674c:	00407124 	.word	0x00407124

00406750 <_malloc_trim_r>:
  406750:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  406752:	4d23      	ldr	r5, [pc, #140]	; (4067e0 <_malloc_trim_r+0x90>)
  406754:	460f      	mov	r7, r1
  406756:	4604      	mov	r4, r0
  406758:	f7ff ff5a 	bl	406610 <__malloc_lock>
  40675c:	68ab      	ldr	r3, [r5, #8]
  40675e:	685e      	ldr	r6, [r3, #4]
  406760:	f026 0603 	bic.w	r6, r6, #3
  406764:	1bf1      	subs	r1, r6, r7
  406766:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
  40676a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
  40676e:	f021 010f 	bic.w	r1, r1, #15
  406772:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
  406776:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
  40677a:	db07      	blt.n	40678c <_malloc_trim_r+0x3c>
  40677c:	4620      	mov	r0, r4
  40677e:	2100      	movs	r1, #0
  406780:	f7ff ff4a 	bl	406618 <_sbrk_r>
  406784:	68ab      	ldr	r3, [r5, #8]
  406786:	4433      	add	r3, r6
  406788:	4298      	cmp	r0, r3
  40678a:	d004      	beq.n	406796 <_malloc_trim_r+0x46>
  40678c:	4620      	mov	r0, r4
  40678e:	f7ff ff41 	bl	406614 <__malloc_unlock>
  406792:	2000      	movs	r0, #0
  406794:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  406796:	4620      	mov	r0, r4
  406798:	4279      	negs	r1, r7
  40679a:	f7ff ff3d 	bl	406618 <_sbrk_r>
  40679e:	3001      	adds	r0, #1
  4067a0:	d00d      	beq.n	4067be <_malloc_trim_r+0x6e>
  4067a2:	4b10      	ldr	r3, [pc, #64]	; (4067e4 <_malloc_trim_r+0x94>)
  4067a4:	68aa      	ldr	r2, [r5, #8]
  4067a6:	6819      	ldr	r1, [r3, #0]
  4067a8:	1bf6      	subs	r6, r6, r7
  4067aa:	f046 0601 	orr.w	r6, r6, #1
  4067ae:	4620      	mov	r0, r4
  4067b0:	1bc9      	subs	r1, r1, r7
  4067b2:	6056      	str	r6, [r2, #4]
  4067b4:	6019      	str	r1, [r3, #0]
  4067b6:	f7ff ff2d 	bl	406614 <__malloc_unlock>
  4067ba:	2001      	movs	r0, #1
  4067bc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  4067be:	4620      	mov	r0, r4
  4067c0:	2100      	movs	r1, #0
  4067c2:	f7ff ff29 	bl	406618 <_sbrk_r>
  4067c6:	68ab      	ldr	r3, [r5, #8]
  4067c8:	1ac2      	subs	r2, r0, r3
  4067ca:	2a0f      	cmp	r2, #15
  4067cc:	ddde      	ble.n	40678c <_malloc_trim_r+0x3c>
  4067ce:	4d06      	ldr	r5, [pc, #24]	; (4067e8 <_malloc_trim_r+0x98>)
  4067d0:	4904      	ldr	r1, [pc, #16]	; (4067e4 <_malloc_trim_r+0x94>)
  4067d2:	682d      	ldr	r5, [r5, #0]
  4067d4:	f042 0201 	orr.w	r2, r2, #1
  4067d8:	1b40      	subs	r0, r0, r5
  4067da:	605a      	str	r2, [r3, #4]
  4067dc:	6008      	str	r0, [r1, #0]
  4067de:	e7d5      	b.n	40678c <_malloc_trim_r+0x3c>
  4067e0:	200006dc 	.word	0x200006dc
  4067e4:	20001168 	.word	0x20001168
  4067e8:	20000ae8 	.word	0x20000ae8

004067ec <_free_r>:
  4067ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  4067f0:	460d      	mov	r5, r1
  4067f2:	4606      	mov	r6, r0
  4067f4:	2900      	cmp	r1, #0
  4067f6:	d055      	beq.n	4068a4 <_free_r+0xb8>
  4067f8:	f7ff ff0a 	bl	406610 <__malloc_lock>
  4067fc:	f855 1c04 	ldr.w	r1, [r5, #-4]
  406800:	f8df c174 	ldr.w	ip, [pc, #372]	; 406978 <_free_r+0x18c>
  406804:	f021 0301 	bic.w	r3, r1, #1
  406808:	f1a5 0408 	sub.w	r4, r5, #8
  40680c:	18e2      	adds	r2, r4, r3
  40680e:	f8dc 0008 	ldr.w	r0, [ip, #8]
  406812:	6857      	ldr	r7, [r2, #4]
  406814:	4290      	cmp	r0, r2
  406816:	f027 0703 	bic.w	r7, r7, #3
  40681a:	d069      	beq.n	4068f0 <_free_r+0x104>
  40681c:	f011 0101 	ands.w	r1, r1, #1
  406820:	6057      	str	r7, [r2, #4]
  406822:	d032      	beq.n	40688a <_free_r+0x9e>
  406824:	2100      	movs	r1, #0
  406826:	19d0      	adds	r0, r2, r7
  406828:	6840      	ldr	r0, [r0, #4]
  40682a:	07c0      	lsls	r0, r0, #31
  40682c:	d406      	bmi.n	40683c <_free_r+0x50>
  40682e:	443b      	add	r3, r7
  406830:	6890      	ldr	r0, [r2, #8]
  406832:	2900      	cmp	r1, #0
  406834:	d04e      	beq.n	4068d4 <_free_r+0xe8>
  406836:	68d2      	ldr	r2, [r2, #12]
  406838:	60c2      	str	r2, [r0, #12]
  40683a:	6090      	str	r0, [r2, #8]
  40683c:	f043 0201 	orr.w	r2, r3, #1
  406840:	6062      	str	r2, [r4, #4]
  406842:	50e3      	str	r3, [r4, r3]
  406844:	b9e1      	cbnz	r1, 406880 <_free_r+0x94>
  406846:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
  40684a:	d32d      	bcc.n	4068a8 <_free_r+0xbc>
  40684c:	0a5a      	lsrs	r2, r3, #9
  40684e:	2a04      	cmp	r2, #4
  406850:	d86a      	bhi.n	406928 <_free_r+0x13c>
  406852:	0998      	lsrs	r0, r3, #6
  406854:	3038      	adds	r0, #56	; 0x38
  406856:	0041      	lsls	r1, r0, #1
  406858:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
  40685c:	4946      	ldr	r1, [pc, #280]	; (406978 <_free_r+0x18c>)
  40685e:	f8dc 2008 	ldr.w	r2, [ip, #8]
  406862:	4562      	cmp	r2, ip
  406864:	d066      	beq.n	406934 <_free_r+0x148>
  406866:	6851      	ldr	r1, [r2, #4]
  406868:	f021 0103 	bic.w	r1, r1, #3
  40686c:	428b      	cmp	r3, r1
  40686e:	d202      	bcs.n	406876 <_free_r+0x8a>
  406870:	6892      	ldr	r2, [r2, #8]
  406872:	4594      	cmp	ip, r2
  406874:	d1f7      	bne.n	406866 <_free_r+0x7a>
  406876:	68d3      	ldr	r3, [r2, #12]
  406878:	60e3      	str	r3, [r4, #12]
  40687a:	60a2      	str	r2, [r4, #8]
  40687c:	609c      	str	r4, [r3, #8]
  40687e:	60d4      	str	r4, [r2, #12]
  406880:	4630      	mov	r0, r6
  406882:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  406886:	f7ff bec5 	b.w	406614 <__malloc_unlock>
  40688a:	f855 5c08 	ldr.w	r5, [r5, #-8]
  40688e:	1b64      	subs	r4, r4, r5
  406890:	f10c 0808 	add.w	r8, ip, #8
  406894:	68a0      	ldr	r0, [r4, #8]
  406896:	4540      	cmp	r0, r8
  406898:	442b      	add	r3, r5
  40689a:	d043      	beq.n	406924 <_free_r+0x138>
  40689c:	68e5      	ldr	r5, [r4, #12]
  40689e:	60c5      	str	r5, [r0, #12]
  4068a0:	60a8      	str	r0, [r5, #8]
  4068a2:	e7c0      	b.n	406826 <_free_r+0x3a>
  4068a4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  4068a8:	08db      	lsrs	r3, r3, #3
  4068aa:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
  4068ae:	2501      	movs	r5, #1
  4068b0:	f8dc 0004 	ldr.w	r0, [ip, #4]
  4068b4:	6891      	ldr	r1, [r2, #8]
  4068b6:	60a1      	str	r1, [r4, #8]
  4068b8:	109b      	asrs	r3, r3, #2
  4068ba:	fa05 f303 	lsl.w	r3, r5, r3
  4068be:	4318      	orrs	r0, r3
  4068c0:	60e2      	str	r2, [r4, #12]
  4068c2:	f8cc 0004 	str.w	r0, [ip, #4]
  4068c6:	6094      	str	r4, [r2, #8]
  4068c8:	4630      	mov	r0, r6
  4068ca:	60cc      	str	r4, [r1, #12]
  4068cc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  4068d0:	f7ff bea0 	b.w	406614 <__malloc_unlock>
  4068d4:	4d29      	ldr	r5, [pc, #164]	; (40697c <_free_r+0x190>)
  4068d6:	42a8      	cmp	r0, r5
  4068d8:	d1ad      	bne.n	406836 <_free_r+0x4a>
  4068da:	f043 0201 	orr.w	r2, r3, #1
  4068de:	f8cc 4014 	str.w	r4, [ip, #20]
  4068e2:	f8cc 4010 	str.w	r4, [ip, #16]
  4068e6:	60e0      	str	r0, [r4, #12]
  4068e8:	60a0      	str	r0, [r4, #8]
  4068ea:	6062      	str	r2, [r4, #4]
  4068ec:	50e3      	str	r3, [r4, r3]
  4068ee:	e7c7      	b.n	406880 <_free_r+0x94>
  4068f0:	441f      	add	r7, r3
  4068f2:	07cb      	lsls	r3, r1, #31
  4068f4:	d407      	bmi.n	406906 <_free_r+0x11a>
  4068f6:	f855 3c08 	ldr.w	r3, [r5, #-8]
  4068fa:	1ae4      	subs	r4, r4, r3
  4068fc:	441f      	add	r7, r3
  4068fe:	68a2      	ldr	r2, [r4, #8]
  406900:	68e3      	ldr	r3, [r4, #12]
  406902:	60d3      	str	r3, [r2, #12]
  406904:	609a      	str	r2, [r3, #8]
  406906:	4b1e      	ldr	r3, [pc, #120]	; (406980 <_free_r+0x194>)
  406908:	681b      	ldr	r3, [r3, #0]
  40690a:	f047 0201 	orr.w	r2, r7, #1
  40690e:	429f      	cmp	r7, r3
  406910:	6062      	str	r2, [r4, #4]
  406912:	f8cc 4008 	str.w	r4, [ip, #8]
  406916:	d3b3      	bcc.n	406880 <_free_r+0x94>
  406918:	4b1a      	ldr	r3, [pc, #104]	; (406984 <_free_r+0x198>)
  40691a:	4630      	mov	r0, r6
  40691c:	6819      	ldr	r1, [r3, #0]
  40691e:	f7ff ff17 	bl	406750 <_malloc_trim_r>
  406922:	e7ad      	b.n	406880 <_free_r+0x94>
  406924:	2101      	movs	r1, #1
  406926:	e77e      	b.n	406826 <_free_r+0x3a>
  406928:	2a14      	cmp	r2, #20
  40692a:	d80c      	bhi.n	406946 <_free_r+0x15a>
  40692c:	f102 005b 	add.w	r0, r2, #91	; 0x5b
  406930:	0041      	lsls	r1, r0, #1
  406932:	e791      	b.n	406858 <_free_r+0x6c>
  406934:	684b      	ldr	r3, [r1, #4]
  406936:	1080      	asrs	r0, r0, #2
  406938:	2501      	movs	r5, #1
  40693a:	fa05 f000 	lsl.w	r0, r5, r0
  40693e:	4303      	orrs	r3, r0
  406940:	604b      	str	r3, [r1, #4]
  406942:	4613      	mov	r3, r2
  406944:	e798      	b.n	406878 <_free_r+0x8c>
  406946:	2a54      	cmp	r2, #84	; 0x54
  406948:	d803      	bhi.n	406952 <_free_r+0x166>
  40694a:	0b18      	lsrs	r0, r3, #12
  40694c:	306e      	adds	r0, #110	; 0x6e
  40694e:	0041      	lsls	r1, r0, #1
  406950:	e782      	b.n	406858 <_free_r+0x6c>
  406952:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
  406956:	d803      	bhi.n	406960 <_free_r+0x174>
  406958:	0bd8      	lsrs	r0, r3, #15
  40695a:	3077      	adds	r0, #119	; 0x77
  40695c:	0041      	lsls	r1, r0, #1
  40695e:	e77b      	b.n	406858 <_free_r+0x6c>
  406960:	f240 5154 	movw	r1, #1364	; 0x554
  406964:	428a      	cmp	r2, r1
  406966:	d803      	bhi.n	406970 <_free_r+0x184>
  406968:	0c98      	lsrs	r0, r3, #18
  40696a:	307c      	adds	r0, #124	; 0x7c
  40696c:	0041      	lsls	r1, r0, #1
  40696e:	e773      	b.n	406858 <_free_r+0x6c>
  406970:	21fc      	movs	r1, #252	; 0xfc
  406972:	207e      	movs	r0, #126	; 0x7e
  406974:	e770      	b.n	406858 <_free_r+0x6c>
  406976:	bf00      	nop
  406978:	200006dc 	.word	0x200006dc
  40697c:	200006e4 	.word	0x200006e4
  406980:	20000ae4 	.word	0x20000ae4
  406984:	20001164 	.word	0x20001164

00406988 <__register_exitproc>:
  406988:	b5f0      	push	{r4, r5, r6, r7, lr}
  40698a:	4c27      	ldr	r4, [pc, #156]	; (406a28 <__register_exitproc+0xa0>)
  40698c:	6826      	ldr	r6, [r4, #0]
  40698e:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
  406992:	b085      	sub	sp, #20
  406994:	4607      	mov	r7, r0
  406996:	2c00      	cmp	r4, #0
  406998:	d041      	beq.n	406a1e <__register_exitproc+0x96>
  40699a:	6865      	ldr	r5, [r4, #4]
  40699c:	2d1f      	cmp	r5, #31
  40699e:	dd1e      	ble.n	4069de <__register_exitproc+0x56>
  4069a0:	4822      	ldr	r0, [pc, #136]	; (406a2c <__register_exitproc+0xa4>)
  4069a2:	b918      	cbnz	r0, 4069ac <__register_exitproc+0x24>
  4069a4:	f04f 30ff 	mov.w	r0, #4294967295
  4069a8:	b005      	add	sp, #20
  4069aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4069ac:	f44f 70c8 	mov.w	r0, #400	; 0x190
  4069b0:	9103      	str	r1, [sp, #12]
  4069b2:	9202      	str	r2, [sp, #8]
  4069b4:	9301      	str	r3, [sp, #4]
  4069b6:	f7ff faa3 	bl	405f00 <malloc>
  4069ba:	9903      	ldr	r1, [sp, #12]
  4069bc:	9a02      	ldr	r2, [sp, #8]
  4069be:	9b01      	ldr	r3, [sp, #4]
  4069c0:	4604      	mov	r4, r0
  4069c2:	2800      	cmp	r0, #0
  4069c4:	d0ee      	beq.n	4069a4 <__register_exitproc+0x1c>
  4069c6:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
  4069ca:	6025      	str	r5, [r4, #0]
  4069cc:	2000      	movs	r0, #0
  4069ce:	6060      	str	r0, [r4, #4]
  4069d0:	4605      	mov	r5, r0
  4069d2:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  4069d6:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
  4069da:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
  4069de:	b93f      	cbnz	r7, 4069f0 <__register_exitproc+0x68>
  4069e0:	1cab      	adds	r3, r5, #2
  4069e2:	2000      	movs	r0, #0
  4069e4:	3501      	adds	r5, #1
  4069e6:	6065      	str	r5, [r4, #4]
  4069e8:	f844 1023 	str.w	r1, [r4, r3, lsl #2]
  4069ec:	b005      	add	sp, #20
  4069ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
  4069f0:	eb04 0085 	add.w	r0, r4, r5, lsl #2
  4069f4:	f04f 0c01 	mov.w	ip, #1
  4069f8:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
  4069fc:	f8d4 6188 	ldr.w	r6, [r4, #392]	; 0x188
  406a00:	fa0c f205 	lsl.w	r2, ip, r5
  406a04:	4316      	orrs	r6, r2
  406a06:	2f02      	cmp	r7, #2
  406a08:	f8c4 6188 	str.w	r6, [r4, #392]	; 0x188
  406a0c:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
  406a10:	d1e6      	bne.n	4069e0 <__register_exitproc+0x58>
  406a12:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
  406a16:	431a      	orrs	r2, r3
  406a18:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
  406a1c:	e7e0      	b.n	4069e0 <__register_exitproc+0x58>
  406a1e:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
  406a22:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
  406a26:	e7b8      	b.n	40699a <__register_exitproc+0x12>
  406a28:	004070fc 	.word	0x004070fc
  406a2c:	00405f01 	.word	0x00405f01

00406a30 <all_twi_definitions>:
  406a30:	40018000 40018100 00000013 00000013     ...@...@........
  406a40:	4001c000 4001c100 00000014 00000014     ...@...@........
  406a50:	69663a30 61776d72 622e6572 00006e69     0:firmware.bin..

00406a60 <sd_trans_multipliers>:
  406a60:	00000000 0000000a 0000000c 0000000d     ................
  406a70:	0000000f 00000014 00000019 0000001e     ................
  406a80:	00000023 00000028 0000002d 00000032     #...(...-...2...
  406a90:	00000037 0000003c 00000046 00000050     7...<...F...P...

00406aa0 <sd_mmc_trans_units>:
  406aa0:	0000000a 00000064 000003e8 00002710     ....d........'..
	...

00406abc <mmc_trans_multipliers>:
  406abc:	00000000 0000000a 0000000c 0000000d     ................
  406acc:	0000000f 00000014 0000001a 0000001e     ................
  406adc:	00000023 00000028 0000002d 00000034     #...(...-...4...
  406aec:	00000037 0000003c 00000046 00000050     7...<...F...P...

00406afc <lun_desc>:
  406afc:	00401af9 00401b39 00401b59 00401b71     ..@.9.@.Y.@.q.@.
  406b0c:	00401b91 00401bd5 00401c39 00406b3c     ..@...@.9.@.<k@.
  406b1c:	00401b09 00401b49 00401b65 00401b81     ..@.I.@.e.@...@.
  406b2c:	00401b95 00401be9 00401c4d 00406b54     ..@...@.M.@.Tk@.
  406b3c:	2f445322 20434d4d 64726143 6f6c5320     "SD/MMC Card Slo
  406b4c:	22302074 00000000 2f445322 20434d4d     t 0"...."SD/MMC 
  406b5c:	64726143 6f6c5320 22312074 00000000     Card Slot 1"....

00406b6c <excvt.4554>:
  406b6c:	b6909a80 808fb78e d8d4d3d2 8f8eded7     ................
  406b7c:	e2929290 ebeae399 9d9a9959 9f9e9d9c     ........Y.......
  406b8c:	e9e0d6b5 a7a6a5a5 abaaa9a8 afae21ac     .............!..
  406b9c:	b3b2b1b0 b7b6b5b4 bbbab9b8 bfbebdbc     ................
  406bac:	c3c2c1c0 c7c7c5c4 cbcac9c8 cfcecdcc     ................
  406bbc:	d3d2d1d0 d7d6d5d4 dbdad9d8 dfdedddc     ................
  406bcc:	e3e2e1e0 e7e6e5e5 ebeae9e7 efeeeded     ................
  406bdc:	f3f2f1f0 f7f6f5f4 fbfaf9f8 fffefdfc     ................
  406bec:	3c3a2a22 7f7c3f3e 00000000 3d3b2c2b     "*:<>?|.....+,;=
  406bfc:	00005d5b                                []..

00406c00 <LfnOfs>:
  406c00:	07050301 12100e09 1c181614 0000001e     ................

00406c10 <tbl_lower.4258>:
  406c10:	00620061 00640063 00660065 00680067     a.b.c.d.e.f.g.h.
  406c20:	006a0069 006c006b 006e006d 0070006f     i.j.k.l.m.n.o.p.
  406c30:	00720071 00740073 00760075 00780077     q.r.s.t.u.v.w.x.
  406c40:	007a0079 00a200a1 00a500a3 00af00ac     y.z.............
  406c50:	00e100e0 00e300e2 00e500e4 00e700e6     ................
  406c60:	00e900e8 00eb00ea 00ed00ec 00ef00ee     ................
  406c70:	00f100f0 00f300f2 00f500f4 00f800f6     ................
  406c80:	00fa00f9 00fc00fb 00fe00fd 010100ff     ................
  406c90:	01050103 01090107 010d010b 0111010f     ................
  406ca0:	01150113 01190117 011d011b 0121011f     ..............!.
  406cb0:	01250123 01290127 012d012b 0131012f     #.%.'.).+.-./.1.
  406cc0:	01350133 013a0137 013e013c 01420140     3.5.7.:.<.>.@.B.
  406cd0:	01460144 014b0148 014f014d 01530151     D.F.H.K.M.O.Q.S.
  406ce0:	01570155 015b0159 015f015d 01630161     U.W.Y.[.]._.a.c.
  406cf0:	01670165 016b0169 016f016d 01730171     e.g.i.k.m.o.q.s.
  406d00:	01770175 017c017a 0192017e 03b203b1     u.w.z.|.~.......
  406d10:	03b403b3 03b603b5 03b803b7 03ba03b9     ................
  406d20:	03bc03bb 03be03bd 03c003bf 03c303c1     ................
  406d30:	03c503c4 03c703c6 03c903c8 043003ca     ..............0.
  406d40:	04320431 04340433 04360435 04380437     1.2.3.4.5.6.7.8.
  406d50:	043a0439 043c043b 043e043d 0440043f     9.:.;.<.=.>.?.@.
  406d60:	04420441 04440443 04460445 04480447     A.B.C.D.E.F.G.H.
  406d70:	044a0449 044c044b 044e044d 0451044f     I.J.K.L.M.N.O.Q.
  406d80:	04530452 04550454 04570456 04590458     R.S.T.U.V.W.X.Y.
  406d90:	045b045a 045e045c 2170045f 21722171     Z.[.\.^._.p!q!r!
  406da0:	21742173 21762175 21782177 217a2179     s!t!u!v!w!x!y!z!
  406db0:	217c217b 217e217d ff41217f ff43ff42     {!|!}!~!.!A.B.C.
  406dc0:	ff45ff44 ff47ff46 ff49ff48 ff4bff4a     D.E.F.G.H.I.J.K.
  406dd0:	ff4dff4c ff4fff4e ff51ff50 ff53ff52     L.M.N.O.P.Q.R.S.
  406de0:	ff55ff54 ff57ff56 ff59ff58 0000ff5a     T.U.V.W.X.Y.Z...

00406df0 <Tbl>:
  406df0:	00fc00c7 00e200e9 00e000e4 00e700e5     ................
  406e00:	00eb00ea 00ef00e8 00ec00ee 00c500c4     ................
  406e10:	00e600c9 00f400c6 00f200f6 00f900fb     ................
  406e20:	00d600ff 00f800dc 00d800a3 019200d7     ................
  406e30:	00ed00e1 00fa00f3 00d100f1 00ba00aa     ................
  406e40:	00ae00bf 00bd00ac 00a100bc 00bb00ab     ................
  406e50:	25922591 25022593 00c12524 00c000c2     .%.%.%.%$%......
  406e60:	256300a9 25572551 00a2255d 251000a5     ..c%Q%W%]%.....%
  406e70:	25342514 251c252c 253c2500 00c300e3     .%4%,%.%.%<%....
  406e80:	2554255a 25662569 25502560 00a4256c     Z%T%i%f%`%P%l%..
  406e90:	00d000f0 00cb00ca 013100c8 00ce00cd     ..........1.....
  406ea0:	251800cf 2588250c 00a62584 258000cc     ...%.%.%.%.....%
  406eb0:	00df00d3 00d200d4 00d500f5 00fe00b5     ................
  406ec0:	00da00de 00d900db 00dd00fd 00b400af     ................
  406ed0:	00b100ad 00be2017 00a700b6 00b800f7     ..... ..........
  406ee0:	00a800b0 00b900b7 00b200b3 00a025a0     .............%..

00406ef0 <tbl_upper.4259>:
  406ef0:	00420041 00440043 00460045 00480047     A.B.C.D.E.F.G.H.
  406f00:	004a0049 004c004b 004e004d 0050004f     I.J.K.L.M.N.O.P.
  406f10:	00520051 00540053 00560055 00580057     Q.R.S.T.U.V.W.X.
  406f20:	005a0059 ffe00021 ffe5ffe1 ffe3ffe2     Y.Z.!...........
  406f30:	00c100c0 00c300c2 00c500c4 00c700c6     ................
  406f40:	00c900c8 00cb00ca 00cd00cc 00cf00ce     ................
  406f50:	00d100d0 00d300d2 00d500d4 00d800d6     ................
  406f60:	00da00d9 00dc00db 00de00dd 01000178     ............x...
  406f70:	01040102 01080106 010c010a 0110010e     ................
  406f80:	01140112 01180116 011c011a 0120011e     .............. .
  406f90:	01240122 01280126 012c012a 0130012e     ".$.&.(.*.,...0.
  406fa0:	01340132 01390136 013d013b 0141013f     2.4.6.9.;.=.?.A.
  406fb0:	01450143 014a0147 014e014c 01520150     C.E.G.J.L.N.P.R.
  406fc0:	01560154 015a0158 015e015c 01620160     T.V.X.Z.\.^.`.b.
  406fd0:	01660164 016a0168 016e016c 01720170     d.f.h.j.l.n.p.r.
  406fe0:	01760174 017b0179 0191017d 03920391     t.v.y.{.}.......
  406ff0:	03940393 03960395 03980397 039a0399     ................
  407000:	039c039b 039e039d 03a0039f 03a303a1     ................
  407010:	03a503a4 03a703a6 03a903a8 041003aa     ................
  407020:	04120411 04140413 04160415 04180417     ................
  407030:	041a0419 041c041b 041e041d 0420041f     .............. .
  407040:	04220421 04240423 04260425 04280427     !.".#.$.%.&.'.(.
  407050:	042a0429 042c042b 042e042d 0401042f     ).*.+.,.-.../...
  407060:	04030402 04050404 04070406 04090408     ................
  407070:	040b040a 040e040c 2160040f 21622161     ..........`!a!b!
  407080:	21642163 21662165 21682167 216a2169     c!d!e!f!g!h!i!j!
  407090:	216c216b 216e216d ff21216f ff23ff22     k!l!m!n!o!!.".#.
  4070a0:	ff25ff24 ff27ff26 ff29ff28 ff2bff2a     $.%.&.'.(.).*.+.
  4070b0:	ff2dff2c ff2fff2e ff31ff30 ff33ff32     ,.-.../.0.1.2.3.
  4070c0:	ff35ff34 ff37ff36 ff39ff38 0000ff3a     4.5.6.7.8.9.:...
  4070d0:	74736552 69747261 7320676e 65747379     Restarting syste
  4070e0:	2121216d 0000000d                       m!!!....

004070e8 <CSWTCH.21>:
  4070e8:	00000070 00000050 00000030 00000010     p...P...0.......
  4070f8:	00000043                                C...

004070fc <_global_impure_ptr>:
  4070fc:	200002b0                                ... 

00407100 <_init>:
  407100:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  407102:	bf00      	nop
  407104:	bcf8      	pop	{r3, r4, r5, r6, r7}
  407106:	bc08      	pop	{r3}
  407108:	469e      	mov	lr, r3
  40710a:	4770      	bx	lr

0040710c <__init_array_start>:
  40710c:	00406701 	.word	0x00406701

00407110 <__frame_dummy_init_array_entry>:
  407110:	004000f1                                ..@.

00407114 <_fini>:
  407114:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  407116:	bf00      	nop
  407118:	bcf8      	pop	{r3, r4, r5, r6, r7}
  40711a:	bc08      	pop	{r3}
  40711c:	469e      	mov	lr, r3
  40711e:	4770      	bx	lr

00407120 <__fini_array_start>:
  407120:	004000cd 	.word	0x004000cd

Disassembly of section .relocate:

20000000 <efc_perform_read_sequence>:
__no_inline
RAMFUNC
uint32_t efc_perform_read_sequence(Efc *p_efc,
		uint32_t ul_cmd_st, uint32_t ul_cmd_sp,
		uint32_t *p_ul_buf, uint32_t ul_size)
{
20000000:	b470      	push	{r4, r5, r6}
20000002:	b083      	sub	sp, #12
20000004:	9e06      	ldr	r6, [sp, #24]
	uint32_t *p_ul_data = (uint32_t *) READ_BUFF_ADDR;
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
20000006:	b343      	cbz	r3, 2000005a <efc_perform_read_sequence+0x5a>
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000008:	6804      	ldr	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
			| EEFC_FCR_FCMD(ul_cmd_st);
2000000a:	b2c9      	uxtb	r1, r1
2000000c:	f041 41b4 	orr.w	r1, r1, #1509949440	; 0x5a000000

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
	}

	p_efc->EEFC_FMR |= (0x1u << 16);
20000010:	f444 3480 	orr.w	r4, r4, #65536	; 0x10000
20000014:	6004      	str	r4, [r0, #0]

	/* Send the Start Read command */
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
	p_efc->EEFC_FCR = EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0)
20000016:	6041      	str	r1, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register
	 * (EEFC_FSR) falls.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000018:	6881      	ldr	r1, [r0, #8]
2000001a:	9101      	str	r1, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);
2000001c:	9901      	ldr	r1, [sp, #4]
2000001e:	f011 0101 	ands.w	r1, r1, #1
20000022:	d1f9      	bne.n	20000018 <efc_perform_read_sequence+0x18>

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000024:	b146      	cbz	r6, 20000038 <efc_perform_read_sequence+0x38>
20000026:	4c0f      	ldr	r4, [pc, #60]	; (20000064 <efc_perform_read_sequence+0x64>)
20000028:	eb03 0686 	add.w	r6, r3, r6, lsl #2
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
2000002c:	f854 5f04 	ldr.w	r5, [r4, #4]!
20000030:	f843 5b04 	str.w	r5, [r3], #4
	} while ((ul_status & EEFC_FSR_FRDY) == EEFC_FSR_FRDY);

	/* The data is located in the first address of the Flash
	 * memory mapping.
	 */
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
20000034:	42b3      	cmp	r3, r6
20000036:	d1f9      	bne.n	2000002c <efc_perform_read_sequence+0x2c>

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
			EEFC_FCR_FCMD(ul_cmd_sp);
20000038:	b2d2      	uxtb	r2, r2
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
#if (SAM4S || SAM4E || SAM4N || SAM4C || SAMG || SAM4CP || SAM4CM)
			EEFC_FCR_FKEY_PASSWD | EEFC_FCR_FARG(0) |
2000003a:	f042 42b4 	orr.w	r2, r2, #1509949440	; 0x5a000000
	for (ul_cnt = 0; ul_cnt < ul_size; ul_cnt++) {
		p_ul_buf[ul_cnt] = p_ul_data[ul_cnt];
	}

	/* To stop the read mode */
	p_efc->EEFC_FCR =
2000003e:	6042      	str	r2, [r0, #4]
#endif
	/* Wait for the FRDY bit in the Flash Programming Status Register (EEFC_FSR)
	 * rises.
	 */
	do {
		ul_status = p_efc->EEFC_FSR;
20000040:	6883      	ldr	r3, [r0, #8]
20000042:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000044:	9b01      	ldr	r3, [sp, #4]
20000046:	07db      	lsls	r3, r3, #31
20000048:	d5fa      	bpl.n	20000040 <efc_perform_read_sequence+0x40>

	p_efc->EEFC_FMR &= ~(0x1u << 16);
2000004a:	6803      	ldr	r3, [r0, #0]
2000004c:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
20000050:	6003      	str	r3, [r0, #0]

	return EFC_RC_OK;
}
20000052:	4608      	mov	r0, r1
20000054:	b003      	add	sp, #12
20000056:	bc70      	pop	{r4, r5, r6}
20000058:	4770      	bx	lr
#else
	return EFC_RC_NOT_SUPPORT;
#endif

	if (p_ul_buf == NULL) {
		return EFC_RC_INVALID;
2000005a:	2102      	movs	r1, #2
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);

	p_efc->EEFC_FMR &= ~(0x1u << 16);

	return EFC_RC_OK;
}
2000005c:	4608      	mov	r0, r1
2000005e:	b003      	add	sp, #12
20000060:	bc70      	pop	{r4, r5, r6}
20000062:	4770      	bx	lr
20000064:	003ffffc 	.word	0x003ffffc

20000068 <efc_write_fmr>:
 */
__no_inline
RAMFUNC
void efc_write_fmr(Efc *p_efc, uint32_t ul_fmr)
{
	p_efc->EEFC_FMR = ul_fmr;
20000068:	6001      	str	r1, [r0, #0]
2000006a:	4770      	bx	lr

2000006c <efc_perform_fcr>:
 * \return The current status.
 */
__no_inline
RAMFUNC
uint32_t efc_perform_fcr(Efc *p_efc, uint32_t ul_fcr)
{
2000006c:	b082      	sub	sp, #8
	volatile uint32_t ul_status;

	p_efc->EEFC_FCR = ul_fcr;
2000006e:	6041      	str	r1, [r0, #4]
	do {
		ul_status = p_efc->EEFC_FSR;
20000070:	6883      	ldr	r3, [r0, #8]
20000072:	9301      	str	r3, [sp, #4]
	} while ((ul_status & EEFC_FSR_FRDY) != EEFC_FSR_FRDY);
20000074:	9b01      	ldr	r3, [sp, #4]
20000076:	07db      	lsls	r3, r3, #31
20000078:	d5fa      	bpl.n	20000070 <efc_perform_fcr+0x4>

	return (ul_status & EEFC_ERROR_FLAGS);
2000007a:	9801      	ldr	r0, [sp, #4]
}
2000007c:	f000 000e 	and.w	r0, r0, #14
20000080:	b002      	add	sp, #8
20000082:	4770      	bx	lr

20000084 <portable_delay_cycles>:
RAMFUNC
void portable_delay_cycles(unsigned long n)
{
	UNUSED(n);

	__asm (
20000084:	f3bf 8f5f 	dmb	sy
20000088:	3801      	subs	r0, #1
2000008a:	d1fb      	bne.n	20000084 <portable_delay_cycles>
2000008c:	4770      	bx	lr
2000008e:	bf00      	nop

20000090 <sd_mmc_cards>:
	...
20000098:	002b 0000 0000 0000 0000 0000 0000 0000     +...............
	...

200000b4 <uxCriticalNesting>:
200000b4:	aaaa aaaa                                   ....

200000b8 <uxPreviousTask>:
200000b8:	00ff 0000                                   ....

200000bc <xNextTaskUnblockTime>:
200000bc:	ffff ffff                                   ....

200000c0 <brainSettings>:
	...
2000015c:	0000 0001 0000 0000 0000 0000 0000 0000     ................
	...

20000178 <gpioConfig>:
20000178:	0000 0000 0001 0001 4b35 0040 0101 0000     ........5K@.....
20000188:	0001 0000 0001 0001 4af5 0040 0101 0000     .........J@.....
20000198:	0014 0000 0001 0001 4ab1 0040 0101 0000     .........J@.....
200001a8:	0010 0000 0001 0001 4a6d 0040 0101 0000     ........mJ@.....
200001b8:	000f 0000 0001 0001 4a29 0040 0101 0000     ........)J@.....
200001c8:	0018 0000 0001 0001 49e5 0040 0100 0000     .........I@.....
200001d8:	0019 0000 0001 0001 49a1 0040 0100 0000     .........I@.....
200001e8:	0013 0000 0100 0004 0000 0000 0000 0100     ................
200001f8:	0017 0000 0100 0004 0000 0000 0000 0100     ................
20000208:	002a 0000 0100 0004 0000 0000 0100 0100     *...............
20000218:	0011 0000 0100 0004 0000 0000 0100 0100     ................
20000228:	0012 0000 0100 0004 0000 0000 0100 0100     ................
20000238:	002d 0000 0100 0004 0000 0000 0000 0100     -...............
20000248:	0020 0000 0100 0004 0000 0000 0000 0100      ...............
20000258:	0021 0000 0100 0004 0000 0000 0000 0100     !...............
20000268:	000b 0000 0001 0001 495d 0040 0101 0000     ........]I@.....
20000278:	002b 0000 0001 0001 4919 0040 0101 0000     +........I@.....
20000288:	000c 0000 0000 0004 0000 0000 0000 0000     ................
20000298:	0002 0000 0000 0004 0000 0000 0000 0100     ................

200002a8 <g_interrupt_enabled>:
200002a8:	0001 0000                                   ....

200002ac <SystemCoreClock>:
200002ac:	0900 003d                                   ..=.

200002b0 <impure_data>:
200002b0:	0000 0000 059c 2000 0604 2000 066c 2000     ....... ... l.. 
	...
200002e4:	70f8 0040 0000 0000 0000 0000 0000 0000     .p@.............
	...
20000358:	0001 0000 0000 0000 330e abcd 1234 e66d     .........3..4.m.
20000368:	deec 0005 000b 0000 0000 0000 0000 0000     ................
	...

200006d8 <_impure_ptr>:
200006d8:	02b0 2000                                   ... 

200006dc <__malloc_av_>:
	...
200006e4:	06dc 2000 06dc 2000 06e4 2000 06e4 2000     ... ... ... ... 
200006f4:	06ec 2000 06ec 2000 06f4 2000 06f4 2000     ... ... ... ... 
20000704:	06fc 2000 06fc 2000 0704 2000 0704 2000     ... ... ... ... 
20000714:	070c 2000 070c 2000 0714 2000 0714 2000     ... ... ... ... 
20000724:	071c 2000 071c 2000 0724 2000 0724 2000     ... ... $.. $.. 
20000734:	072c 2000 072c 2000 0734 2000 0734 2000     ,.. ,.. 4.. 4.. 
20000744:	073c 2000 073c 2000 0744 2000 0744 2000     <.. <.. D.. D.. 
20000754:	074c 2000 074c 2000 0754 2000 0754 2000     L.. L.. T.. T.. 
20000764:	075c 2000 075c 2000 0764 2000 0764 2000     \.. \.. d.. d.. 
20000774:	076c 2000 076c 2000 0774 2000 0774 2000     l.. l.. t.. t.. 
20000784:	077c 2000 077c 2000 0784 2000 0784 2000     |.. |.. ... ... 
20000794:	078c 2000 078c 2000 0794 2000 0794 2000     ... ... ... ... 
200007a4:	079c 2000 079c 2000 07a4 2000 07a4 2000     ... ... ... ... 
200007b4:	07ac 2000 07ac 2000 07b4 2000 07b4 2000     ... ... ... ... 
200007c4:	07bc 2000 07bc 2000 07c4 2000 07c4 2000     ... ... ... ... 
200007d4:	07cc 2000 07cc 2000 07d4 2000 07d4 2000     ... ... ... ... 
200007e4:	07dc 2000 07dc 2000 07e4 2000 07e4 2000     ... ... ... ... 
200007f4:	07ec 2000 07ec 2000 07f4 2000 07f4 2000     ... ... ... ... 
20000804:	07fc 2000 07fc 2000 0804 2000 0804 2000     ... ... ... ... 
20000814:	080c 2000 080c 2000 0814 2000 0814 2000     ... ... ... ... 
20000824:	081c 2000 081c 2000 0824 2000 0824 2000     ... ... $.. $.. 
20000834:	082c 2000 082c 2000 0834 2000 0834 2000     ,.. ,.. 4.. 4.. 
20000844:	083c 2000 083c 2000 0844 2000 0844 2000     <.. <.. D.. D.. 
20000854:	084c 2000 084c 2000 0854 2000 0854 2000     L.. L.. T.. T.. 
20000864:	085c 2000 085c 2000 0864 2000 0864 2000     \.. \.. d.. d.. 
20000874:	086c 2000 086c 2000 0874 2000 0874 2000     l.. l.. t.. t.. 
20000884:	087c 2000 087c 2000 0884 2000 0884 2000     |.. |.. ... ... 
20000894:	088c 2000 088c 2000 0894 2000 0894 2000     ... ... ... ... 
200008a4:	089c 2000 089c 2000 08a4 2000 08a4 2000     ... ... ... ... 
200008b4:	08ac 2000 08ac 2000 08b4 2000 08b4 2000     ... ... ... ... 
200008c4:	08bc 2000 08bc 2000 08c4 2000 08c4 2000     ... ... ... ... 
200008d4:	08cc 2000 08cc 2000 08d4 2000 08d4 2000     ... ... ... ... 
200008e4:	08dc 2000 08dc 2000 08e4 2000 08e4 2000     ... ... ... ... 
200008f4:	08ec 2000 08ec 2000 08f4 2000 08f4 2000     ... ... ... ... 
20000904:	08fc 2000 08fc 2000 0904 2000 0904 2000     ... ... ... ... 
20000914:	090c 2000 090c 2000 0914 2000 0914 2000     ... ... ... ... 
20000924:	091c 2000 091c 2000 0924 2000 0924 2000     ... ... $.. $.. 
20000934:	092c 2000 092c 2000 0934 2000 0934 2000     ,.. ,.. 4.. 4.. 
20000944:	093c 2000 093c 2000 0944 2000 0944 2000     <.. <.. D.. D.. 
20000954:	094c 2000 094c 2000 0954 2000 0954 2000     L.. L.. T.. T.. 
20000964:	095c 2000 095c 2000 0964 2000 0964 2000     \.. \.. d.. d.. 
20000974:	096c 2000 096c 2000 0974 2000 0974 2000     l.. l.. t.. t.. 
20000984:	097c 2000 097c 2000 0984 2000 0984 2000     |.. |.. ... ... 
20000994:	098c 2000 098c 2000 0994 2000 0994 2000     ... ... ... ... 
200009a4:	099c 2000 099c 2000 09a4 2000 09a4 2000     ... ... ... ... 
200009b4:	09ac 2000 09ac 2000 09b4 2000 09b4 2000     ... ... ... ... 
200009c4:	09bc 2000 09bc 2000 09c4 2000 09c4 2000     ... ... ... ... 
200009d4:	09cc 2000 09cc 2000 09d4 2000 09d4 2000     ... ... ... ... 
200009e4:	09dc 2000 09dc 2000 09e4 2000 09e4 2000     ... ... ... ... 
200009f4:	09ec 2000 09ec 2000 09f4 2000 09f4 2000     ... ... ... ... 
20000a04:	09fc 2000 09fc 2000 0a04 2000 0a04 2000     ... ... ... ... 
20000a14:	0a0c 2000 0a0c 2000 0a14 2000 0a14 2000     ... ... ... ... 
20000a24:	0a1c 2000 0a1c 2000 0a24 2000 0a24 2000     ... ... $.. $.. 
20000a34:	0a2c 2000 0a2c 2000 0a34 2000 0a34 2000     ,.. ,.. 4.. 4.. 
20000a44:	0a3c 2000 0a3c 2000 0a44 2000 0a44 2000     <.. <.. D.. D.. 
20000a54:	0a4c 2000 0a4c 2000 0a54 2000 0a54 2000     L.. L.. T.. T.. 
20000a64:	0a5c 2000 0a5c 2000 0a64 2000 0a64 2000     \.. \.. d.. d.. 
20000a74:	0a6c 2000 0a6c 2000 0a74 2000 0a74 2000     l.. l.. t.. t.. 
20000a84:	0a7c 2000 0a7c 2000 0a84 2000 0a84 2000     |.. |.. ... ... 
20000a94:	0a8c 2000 0a8c 2000 0a94 2000 0a94 2000     ... ... ... ... 
20000aa4:	0a9c 2000 0a9c 2000 0aa4 2000 0aa4 2000     ... ... ... ... 
20000ab4:	0aac 2000 0aac 2000 0ab4 2000 0ab4 2000     ... ... ... ... 
20000ac4:	0abc 2000 0abc 2000 0ac4 2000 0ac4 2000     ... ... ... ... 
20000ad4:	0acc 2000 0acc 2000 0ad4 2000 0ad4 2000     ... ... ... ... 

20000ae4 <__malloc_trim_threshold>:
20000ae4:	0000 0002                                   ....

20000ae8 <__malloc_sbrk_base>:
20000ae8:	ffff ffff                                   ....
